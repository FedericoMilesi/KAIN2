#include "CORE.H"
#include "MEMCARD.H"
#include "GAMELOOP.H"
#include "MEMPACK.H"
#include "STRMLOAD.H"
#include "RELMOD.H"

#if defined(PSXPC_VERSION)
#include "OVERLAYS/MCARDX.H"
#endif

struct memcard_t gMemcard;
int the_header_size;
struct SavedInfoTracker savedInfoTracker;
struct mcmenu gMcmenu;

int MEMCARD_IsWrongVersion(struct memcard_t *memcard)
{
	int result = 1;
	if (memcard != NULL)
	{
		result = memcard->wrongVerison;
	}

	return result;
}

void load(struct memcard_t *memcard)
{
	struct Object *object;
	
	if ((gameTrackerX.gameFlags & 0x8000000))
	{
		object = (Object*)&gameTrackerX.primPool->prim[0];
	}
	else
	{
		object = (Object*)MEMPACK_Malloc(40000, 0x2B);
	}

	LOAD_LoadToAddress("\\kain2\\object\\mcardx\\mcardx.drm", object, 1);

	memcard->table = (mcmenu_table_t*)object->relocModule;
	RELMOD_InitModulePointers((int)object->relocModule, (int*)object->relocList);
	memcard->object = object;

#if !defined(PSXPC_VERSION)
	if (memcard->table->versionID != "Jun 30 1999")
	{
		if (!(gameTrackerX.gameFlags & 0x8000000))
		{
			MEMPACK_Free((char*)object);
		}

		memcard->table = NULL;
	}
#elif defined(PSXPC_VERSION)
	//PSXPC version we have to override this stuff now.
	memcard->table->data_size = NULL;
	memcard->table->initialize = MCARDX_initialize;
	memcard->table->terminate = NULL;
	memcard->table->begin = MCARDX_begin;
	memcard->table->end = NULL;
	memcard->table->set_buffer = MCARDX_set_buffer;
	memcard->table->main = MCARDX_main;
	memcard->table->pause = NULL;
#endif
}


// autogenerated function stub: 
// void /*$ra*/ unload(struct memcard_t *memcard /*$s0*/)
void unload(struct memcard_t *memcard)
{ // line 117, offset 0x800b9a04
	/* begin block 1 */
		// Start line: 253
	/* end block 1 */
	// End Line: 254

}


// autogenerated function stub: 
// int /*$ra*/ memcard_data_size()
int memcard_data_size()
{ // line 133, offset 0x800b9a58
	/* begin block 1 */
		// Start line: 285
	/* end block 1 */
	// End Line: 286

	/* begin block 2 */
		// Start line: 286
	/* end block 2 */
	// End Line: 287

	return 0;
}

int memcard_initialize(struct memcard_t *memcard, void *gt, int nblocks, void *buffer, int nbytes)
{
	int header_size;
	
	memset(memcard, 0, sizeof(memcard_t));

	load(memcard);
	
	header_size = 0;
	memcard->wrongVerison = 0;

	if (memcard->table != NULL)
	{
		memcard->mcmenu = &gMcmenu.dummy1;
		memcard->table->initialize(memcard->mcmenu, memcard, nblocks);
		header_size = memcard->table->set_buffer(memcard->mcmenu, buffer, nbytes);
		unload(memcard);
	}
	else
	{
		memcard->wrongVerison = 1;
	}

	return header_size;
}


// autogenerated function stub: 
// void /*$ra*/ memcard_end(struct memcard_t *memcard /*$s0*/)
void memcard_end(struct memcard_t *memcard)
{ // line 182, offset 0x800b9b20
	/* begin block 1 */
		// Start line: 400
	/* end block 1 */
	// End Line: 401

}

int maybe_start(struct memcard_t *memcard)
{
	if (memcard->running == 0)
	{
		if (memcard->object == NULL)
		{
			load(memcard);
		}
		memcard->running = 1;
		memcard->table->begin();
	}
	
	return 1;
}

int memcard_main_menu(void *gt, int index)
{
	struct memcard_t *memcard;
	
	memcard = ((GameTracker*)gt)->memcard;
	
	if (maybe_start(memcard) != 0)
	{
		memcard->table->main(memcard->mcmenu, index);
	}
	
	return -1;
}

int memcard_pause_menu(void *gt, int index)
{ 
	struct memcard_t *memcard;

	memcard = ((struct GameTracker*)gt)->memcard;

	if (maybe_start(memcard))
	{
		return memcard->table->pause(memcard->mcmenu, index);
	}

	return -1;
}


// autogenerated function stub: 
// void * /*$ra*/ gt2mcmenu(void *gt /*$a0*/)
void * gt2mcmenu(void *gt)
{ // line 229, offset 0x800b9c78
	/* begin block 1 */
		// Start line: 231
		// Start offset: 0x800B9C78
		// Variables:
			struct memcard_t *memcard; // $v0
	/* end block 1 */
	// End offset: 0x800B9C78
	// End Line: 231

	/* begin block 2 */
		// Start line: 497
	/* end block 2 */
	// End Line: 498

	/* begin block 3 */
		// Start line: 498
	/* end block 3 */
	// End Line: 499

	return null;
}


// autogenerated function stub: 
// void /*$ra*/ memcard_pop(void *opaque /*$a0*/)
void memcard_pop(void *opaque)
{ // line 235, offset 0x800b9c8c
	/* begin block 1 */
		// Start line: 509
	/* end block 1 */
	// End Line: 510

}


// autogenerated function stub: 
// void /*$ra*/ memcard_start(void *opaque /*$a0*/)
void memcard_start(void *opaque)
{ // line 243, offset 0x800b9cc8
	/* begin block 1 */
		// Start line: 528
	/* end block 1 */
	// End Line: 529

}


// autogenerated function stub: 
// void /*$ra*/ memcard_load(void *opaque /*$a0*/)
void memcard_load(void *opaque)
{ // line 252, offset 0x800b9d0c
	/* begin block 1 */
		// Start line: 549
	/* end block 1 */
	// End Line: 550

}


// autogenerated function stub: 
// void /*$ra*/ memcard_save(void *opaque /*$a0*/)
void memcard_save(void *opaque)
{ // line 261, offset 0x800b9d58
	/* begin block 1 */
		// Start line: 569
	/* end block 1 */
	// End Line: 570

}


// autogenerated function stub: 
// void /*$ra*/ memcard_item(void *opaque /*$a0*/, TDRFuncPtr_memcard_item1fn fn /*$a1*/, long parameter /*$a2*/, long flags /*$a3*/, char *text /*stack 16*/)
void memcard_item(void *opaque, TDRFuncPtr_memcard_item1fn fn, long parameter, long flags, char *text)
{ // line 266, offset 0x800b9d78
	/* begin block 1 */
		// Start line: 579
	/* end block 1 */
	// End Line: 580

}




