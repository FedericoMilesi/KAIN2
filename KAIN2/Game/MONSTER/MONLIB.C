#include "Game/CORE.H"
#include "MONLIB.H"
#include "Game/PHYSICS.H"
#include "Game/G2/ANIMG2.H"

// autogenerated function stub: 
// void /*$ra*/ MON_TurnOffWeaponSpheres(struct _Instance *instance /*$s1*/)
void MON_TurnOffWeaponSpheres(struct _Instance *instance)
{ // line 148, offset 0x8007f3e4
#if defined(PSX_VERSION)
	UNIMPLEMENTED();
#elif defined(PC_VERSION)
	struct _Instance* LinkChild; // esi
	struct _MonsterVars* mv; // ebp
	struct _HModel* hmodel; // eax
	int numprim; // ecx
	struct _HPrim* hprim; // eax

	LinkChild = instance->LinkChild;
	for (mv = (struct _MonsterVars*)instance->extraData; LinkChild; LinkChild = LinkChild->LinkSibling)
		TurnOffCollisionPhysOb(LinkChild, 3);
	if ((mv->mvFlags & 0x4000) != 0)
	{
		hmodel = &instance->hModelList[instance->currentModel];
		numprim = hmodel->numHPrims;
		for (hprim = hmodel->hPrimList; numprim; --numprim)
		{
			if (hprim->type == 1 && hprim->data.hsphere->id == 9)
				hprim->hpFlags &= ~1u;
			++hprim;
		}
		mv->mvFlags &= ~0x4000;
	}
#endif
}


// autogenerated function stub: 
// void /*$ra*/ MON_TurnOnWeaponSpheres(struct _Instance *instance /*$a0*/)
void MON_TurnOnWeaponSpheres(struct _Instance *instance)
{ // line 174, offset 0x8007f4dc
	/* begin block 1 */
		// Start line: 176
		// Start offset: 0x8007F4DC
		// Variables:
			struct _MonsterVars *mv; // $a2

		/* begin block 1.1 */
			// Start line: 179
			// Start offset: 0x8007F508
			// Variables:
				int i; // $a1
				struct _HPrim *hprim; // $a0
				struct _HModel *hmodel; // $v0
		/* end block 1.1 */
		// End offset: 0x8007F58C
		// End Line: 191
	/* end block 1 */
	// End offset: 0x8007F58C
	// End Line: 192

	/* begin block 2 */
		// Start line: 352
	/* end block 2 */
	// End Line: 353

	/* begin block 3 */
		// Start line: 353
	/* end block 3 */
	// End Line: 354
				UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MON_TurnOnWeaponSphere(struct _Instance *instance /*$a0*/, int segment /*$a1*/)
void MON_TurnOnWeaponSphere(struct _Instance *instance, int segment)
{ // line 198, offset 0x8007f594
	/* begin block 1 */
		// Start line: 199
		// Start offset: 0x8007F594
		// Variables:
			struct _MonsterVars *mv; // $s0

		/* begin block 1.1 */
			// Start line: 204
			// Start offset: 0x8007F5B0
			// Variables:
				struct _Instance *weapon; // $v0
		/* end block 1.1 */
		// End offset: 0x8007F5C0
		// End Line: 208

		/* begin block 1.2 */
			// Start line: 214
			// Start offset: 0x8007F5F8
			// Variables:
				int i; // $a2
				struct _HPrim *hprim; // $a0
				struct _HModel *hmodel; // $v0
		/* end block 1.2 */
		// End offset: 0x8007F68C
		// End Line: 223
	/* end block 1 */
	// End offset: 0x8007F68C
	// End Line: 224

	/* begin block 2 */
		// Start line: 404
	/* end block 2 */
	// End Line: 405
				UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MON_TurnOffBodySpheres(struct _Instance *instance /*$a0*/)
void MON_TurnOffBodySpheres(struct _Instance *instance)
{ // line 229, offset 0x8007f69c
	/* begin block 1 */
		// Start line: 231
		// Start offset: 0x8007F69C
		// Variables:
			struct _MonsterVars *mv; // $a2

		/* begin block 1.1 */
			// Start line: 234
			// Start offset: 0x8007F6B8
			// Variables:
				int i; // $a1
				struct _HPrim *hprim; // $v1
				struct _HModel *hmodel; // $v1
		/* end block 1.1 */
		// End offset: 0x8007F73C
		// End Line: 242
	/* end block 1 */
	// End offset: 0x8007F73C
	// End Line: 243

	/* begin block 2 */
		// Start line: 470
	/* end block 2 */
	// End Line: 471

	/* begin block 3 */
		// Start line: 471
	/* end block 3 */
	// End Line: 472
				UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MON_TurnOnBodySpheres(struct _Instance *instance /*$a0*/)
void MON_TurnOnBodySpheres(struct _Instance *instance)
{ // line 248, offset 0x8007f744
	/* begin block 1 */
		// Start line: 250
		// Start offset: 0x8007F744
		// Variables:
			struct _MonsterVars *mv; // $a2

		/* begin block 1.1 */
			// Start line: 253
			// Start offset: 0x8007F770
			// Variables:
				int i; // $a1
				struct _HPrim *hprim; // $a0
				struct _HModel *hmodel; // $v0
		/* end block 1.1 */
		// End offset: 0x8007F7F0
		// End Line: 261
	/* end block 1 */
	// End offset: 0x8007F7F0
	// End Line: 262

	/* begin block 2 */
		// Start line: 510
	/* end block 2 */
	// End Line: 511

	/* begin block 3 */
		// Start line: 511
	/* end block 3 */
	// End Line: 512
				UNIMPLEMENTED();
}

void MON_TurnOffAllSpheres(struct _Instance* instance)
{
	MON_TurnOffWeaponSpheres(instance);

	MON_TurnOffBodySpheres(instance);
}

void MON_TurnOnAllSpheres(struct _Instance* instance)
{
	MON_TurnOnWeaponSpheres(instance);

	MON_TurnOnBodySpheres(instance);
}


// autogenerated function stub: 
// void /*$ra*/ MON_SwitchState(struct _Instance *instance /*$s2*/, enum MonsterState state /*$s1*/)
void MON_SwitchState(struct _Instance *instance, enum MonsterState state)
{ // line 318, offset 0x8007f850
#if defined(PC_VERSION)
	struct _MonsterVars* mv; // edi
	struct _Instance* i; // esi
	struct _HModel* v4; // eax
	int numHPrims; // ecx
	struct _HPrim* prim; // eax
	unsigned int mvFlags; // eax
	char pathSlotID; // al

	mv = (struct _MonsterVars*)instance->extraData;
	if ((mv->mvFlags & 0x4000) != 0)
	{
		for (i = instance->LinkChild; i; i = i->LinkSibling)
			TurnOffCollisionPhysOb(i, 3);
		if ((mv->mvFlags & 0x4000) != 0)
		{
			v4 = &instance->hModelList[instance->currentModel];
			numHPrims = v4->numHPrims;
			for (prim = v4->hPrimList; numHPrims; --numHPrims)
			{
				if (prim->type == 1 && prim->data.hsphere->id == 9)
					prim->hpFlags &= ~1u;
				++prim;
			}
			mv->mvFlags &= ~0x4000;
		}
	}
	if ((mv->mvFlags & 1) != 0)
	{
		if ((gameTrackerX.debugFlags2 & 1) != 0)
			MON_Say();
	}
	else
	{
		mv->previousMainState = instance->currentMainState;
	}
	if (state == MONSTER_STATE_GENERALDEATH
		|| state == MONSTER_STATE_DEAD
		|| state == MONSTER_STATE_IMPALEDEATH
		|| state == MONSTER_STATE_GRABBED
		|| state == MONSTER_STATE_MISSILEHIT)
	{
		PurgeMessageQueue(&mv->messageQueue);
	}
	instance->currentMainState = state;
	pathSlotID = mv->pathSlotID;
	mv->mvFlags = mv->mvFlags & ~0x44021001 | 1;
	if (pathSlotID != -1)
	{
		ENMYPLAN_ReleasePlanningWorkspace(pathSlotID);
		mv->pathSlotID = -1;
	}
#else
	UNIMPLEMENTED();
#endif
}


// autogenerated function stub: 
// void /*$ra*/ MON_SwitchStateDoEntry(struct _Instance *instance /*$s1*/, enum MonsterState state /*$a1*/)
void MON_SwitchStateDoEntry(struct _Instance *instance, enum MonsterState state)
{ // line 360, offset 0x8007f94c
#if defined(PC_VERSION)
	struct _MonsterVars* mv; // edi
	struct _MonsterState* StateFuncs; // eax
	unsigned int mvFlags; // eax

	mv = (struct _MonsterVars*)instance->extraData;
	MON_SwitchState(instance, state);
	if (mv)
	{
		StateFuncs = MONTABLE_GetStateFuncs(instance, instance->currentMainState);
		((void(__cdecl*)(struct _Instance*))StateFuncs->entryFunction)(instance);
		mv->mvFlags &= ~1;
	}
#else
	UNIMPLEMENTED();
#endif
}

int MON_TransNodeAnimation(struct _Instance* instance)
{
#if defined(PSX_VERSION)
	return G2Anim_SegmentHasActiveChannels(&instance->anim, 0, 0x700);
#elif defined(PC_VERSION)
	return G2Anim_SegmentHasActiveChannels(&instance->anim, 0, 0x700);
#endif
}

struct _MonsterAnim* MON_GetAnim(struct _Instance* instance, char* animList, int index)
{
#if defined(PSX_VERSION)
	int whichAnim;

	whichAnim = animList[index];

	if (whichAnim != -1)
	{
		return ((struct _MonsterAttributes*)instance->data)->animList + whichAnim;
	}

	return 0;
#elif defined(PC_VERSION)
	int whichAnim; // ecx

	whichAnim = animList[index];
	if (whichAnim == -1)
		return 0;
	else
		return (struct _MonsterAnim*)(16 * whichAnim + *((DWORD*)instance->data + 16));
#endif
}


// autogenerated function stub: 
// void /*$ra*/ MON_PlayAnimID(struct _Instance *instance /*$s3*/, int index /*$a1*/, int mode /*$fp*/)
void MON_PlayAnimID(struct _Instance *instance, int index, int mode)
{ // line 409, offset 0x8007fa10
#if defined(PC_VERSION)
	struct _MonsterVars* mv; // ebp
	struct _MonsterAnim* manim; // edi
	int anims; // eax
	struct _MonsterAnim* v7; // ecx
	int v8; // esi
	int v9; // eax
	int v10; // edx
	int v11; // [esp+10h] [ebp-4h]
	struct _MonsterAttributes* ma; // [esp+18h] [ebp+4h]
	struct _Instance* instanceb; // [esp+18h] [ebp+4h]
	int indexa; // [esp+1Ch] [ebp+8h]

	mv = (struct _MonsterVars*)instance->extraData;
	ma = (struct _MonsterAttributes*)instance->data;
	if (index < 0)
	{
		MON_Say();
		MON_Say();
	}
	manim = &ma->animList[index];
	anims = manim->index[0];
	instanceb = (struct _Instance*)anims;
	if (anims < 0 || anims >= instance->object->numAnims)
	{
		MON_Say();
		MON_Say();
		instanceb = 0;
	}
	G2Anim_SetCallback(&instance->anim, INSTANCE_DefaultAnimCallback, (int)instance);
	v7 = mv->anim;
	if (v7 && v7->interpOut)
	{
		v11 = v7->interpOut;
		indexa = v7->alphaTableOut;
	}
	else
	{
		v11 = manim->interpFrames;
		indexa = manim->alphaTable;
	}
	v8 = 0;
	if (mv->subAttr->numSections)
	{
		do
		{
			v9 = manim->index[v8];
			if (v9 == -1)
				v9 = (int)instanceb;
			G2EmulationInstanceSwitchAnimationAlpha(instance, v8, v9, manim->startFrame, v11, mode, indexa);
			G2EmulationInstanceSetAnimSpeed(instance, v8++, manim->playSpeed);
		} while (v8 < mv->subAttr->numSections);
	}
	v10 = mv->mvFlags | 0x4000000;
	mv->anim = manim;
	mv->mvFlags = v10;
	instance->anim.section[manim->controllingSection].callback = (int(__stdcall*)())MON_AnimCallback;
	instance->anim.section[manim->controllingSection].callbackData = instance;
#else
	UNIMPLEMENTED();
#endif
}

void MON_PlayAnimFromList(struct _Instance* instance, char* animList, int animtype, int mode)
{
#if defined(PSX_VERSION)
	MON_PlayAnimID(instance, animList[animtype], mode);
#elif defined(PC_VERSION)
	MON_PlayAnimID(instance, animList[animtype], mode);
#endif
}

int MON_AnimIDPlaying(struct _Instance* instance, int index)
{
#if defined(PSX_VERSION)

	//index <<= 4
	//v0 = instance->data
	//a0 = instance->extraData
	//v1 = ((struct _MonsterAttributes*)instance->data)[index].

	return 0;
	UNIMPLEMENTED();//structs need detecting for this!
#elif defined(PC_VERSION)
	struct _MonsterAttributes *ma; // $v0
	return *((DWORD*)instance->extraData + 47) == 16 * index + *((DWORD*)instance->data + 16);
#endif
}


// autogenerated function stub: 
// void /*$ra*/ MON_PlayAnimIDIfNotPlaying(struct _Instance *instance /*$s0*/, int index /*$s1*/, int mode /*$s2*/)
void MON_PlayAnimIDIfNotPlaying(struct _Instance *instance, int index, int mode)
{ // line 482, offset 0x8007fc14
#if defined(PC_VERSION)
	if (*((DWORD*)instance->extraData + 47) != 16 * index + *((DWORD*)instance->data + 16))
		MON_PlayAnimID(instance, index, mode);
#else
	UNIMPLEMENTED();
#endif
}

int MON_AnimPlayingFromList(struct _Instance* instance, char* animList, int animtype)
{
#if defined(PSX_VERSION)
	return MON_AnimIDPlaying(instance, animList[animtype]);
#elif defined(PC_VERSION)
	return *((DWORD*)instance->extraData + 47) == *((DWORD*)instance->data + 16) + 16 * animList[animtype];
#endif
}


// autogenerated function stub: 
// void /*$ra*/ MON_PlayAnimFromListIfNotPlaying(struct _Instance *instance /*$s1*/, char *animList /*$a1*/, int animtype /*$a2*/, int mode /*$s2*/)
void MON_PlayAnimFromListIfNotPlaying(struct _Instance *instance, char *animList, int animtype, int mode)
{ // line 496, offset 0x8007fc8c
	/* begin block 1 */
		// Start line: 497
		// Start offset: 0x8007FC8C
		// Variables:
			int index; // $s0
	/* end block 1 */
	// End offset: 0x8007FCCC
	// End Line: 502

	/* begin block 2 */
		// Start line: 1033
	/* end block 2 */
	// End Line: 1034
			UNIMPLEMENTED();
}

void MON_PlayAnim(struct _Instance* instance, enum MonsterAnim animtype, int mode)
{
	MON_PlayAnimFromList(instance, ((struct _MonsterVars*)instance->extraData)->subAttr->animList, animtype, mode);
}


// autogenerated function stub: 
// int /*$ra*/ MON_AnimPlaying(struct _Instance *instance /*$a0*/, enum MonsterAnim animtype /*$a2*/)
int MON_AnimPlaying(struct _Instance *instance, enum MonsterAnim animtype)
{ // line 516, offset 0x8007fd18
	/* begin block 1 */
		// Start line: 1076
	/* end block 1 */
	// End Line: 1077
	UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// void /*$ra*/ MON_PlayAnimIfNotPlaying(struct _Instance *instance /*$a0*/, enum MonsterAnim animtype /*$a1*/, int mode /*$a3*/)
void MON_PlayAnimIfNotPlaying(struct _Instance *instance, enum MonsterAnim animtype, int mode)
{ // line 524, offset 0x8007fd4c
	/* begin block 1 */
		// Start line: 1093
	/* end block 1 */
	// End Line: 1094
	UNIMPLEMENTED();
}


// autogenerated function stub: 
// long /*$ra*/ MON_AnimCallback(struct _G2Anim_Type *anim /*$a0*/, int sectionID /*$a1*/, enum _G2AnimCallbackMsg_Enum message /*$a2*/, long messageDataA /*$s0*/, long messageDataB /*stack 16*/, void *data /*stack 20*/)
long MON_AnimCallback(struct _G2Anim_Type *anim, int sectionID, enum _G2AnimCallbackMsg_Enum message, long messageDataA, long messageDataB, void *data)
{ // line 566, offset 0x8007fd80
	/* begin block 1 */
		// Start line: 567
		// Start offset: 0x8007FD80
		// Variables:
			struct _Instance *instance; // $a3
			struct _MonsterVars *mv; // $t0
	/* end block 1 */
	// End offset: 0x8007FE1C
	// End Line: 591

	/* begin block 2 */
		// Start line: 1132
	/* end block 2 */
	// End Line: 1133
			UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// void /*$ra*/ MON_AnimInit(struct _Instance *instance /*$s1*/)
void MON_AnimInit(struct _Instance *instance)
{ // line 597, offset 0x8007fe30
	/* begin block 1 */
		// Start line: 598
		// Start offset: 0x8007FE30
		// Variables:
			struct _MonsterVars *mv; // $s2
			struct _G2AnimSection_Type *animSection; // $s3
			int i; // $s0
			int startSection; // $s6
			int numSections; // $s7

		/* begin block 1.1 */
			// Start line: 611
			// Start offset: 0x8007FE8C
			// Variables:
				int sectionEnd; // $a3
		/* end block 1.1 */
		// End offset: 0x8007FF10
		// End Line: 621
	/* end block 1 */
	// End offset: 0x8007FF58
	// End Line: 626

	/* begin block 2 */
		// Start line: 1203
	/* end block 2 */
	// End Line: 1204
				UNIMPLEMENTED();
}


// autogenerated function stub: 
// short /*$ra*/ MON_FacingOffset(struct _Instance *instance /*$a0*/, struct _Instance *target /*$s0*/)
short MON_FacingOffset(struct _Instance *instance, struct _Instance *target)
{ // line 638, offset 0x8007ffa8
	/* begin block 1 */
		// Start line: 639
		// Start offset: 0x8007FFA8
	/* end block 1 */
	// End offset: 0x8007FFA8
	// End Line: 639

	/* begin block 2 */
		// Start line: 1309
	/* end block 2 */
	// End Line: 1310
	UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ MON_CheckConditions(struct _Instance *instance /*$a0*/, struct _MonsterIR *mir /*$a1*/, char *probArray /*$a2*/)
int MON_CheckConditions(struct _Instance *instance, struct _MonsterIR *mir, char *probArray)
{ // line 651, offset 0x8007ffe4
	/* begin block 1 */
		// Start line: 653
		// Start offset: 0x8007FFE4
		// Variables:
			struct _MonsterVars *mv; // $v0
			char *probability; // $a2
			int chance; // $a1
			int i; // $t1
			int prob; // $a3
			int nprob; // $t0

		/* begin block 1.1 */
			// Start line: 663
			// Start offset: 0x80080014
			// Variables:
				int conditionProb; // $v0
		/* end block 1.1 */
		// End offset: 0x80080078
		// End Line: 674
	/* end block 1 */
	// End offset: 0x80080088
	// End Line: 677

	/* begin block 2 */
		// Start line: 1341
	/* end block 2 */
	// End Line: 1342

	/* begin block 3 */
		// Start line: 1342
	/* end block 3 */
	// End Line: 1343

	/* begin block 4 */
		// Start line: 1346
	/* end block 4 */
	// End Line: 1347
				UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ MON_ShouldIAttackInstance(struct _Instance *instance /*$s2*/, struct _Instance *ei /*$s0*/)
int MON_ShouldIAttackInstance(struct _Instance *instance, struct _Instance *ei)
{ // line 695, offset 0x800800bc
	/* begin block 1 */
		// Start line: 696
		// Start offset: 0x800800BC

		/* begin block 1.1 */
			// Start line: 699
			// Start offset: 0x800800E4
			// Variables:
				struct _Instance *enemyAttackee; // $s1
				long mode; // $v1
				struct _MonsterVars *mv; // $s3

			/* begin block 1.1.1 */
				// Start line: 713
				// Start offset: 0x80080180
			/* end block 1.1.1 */
			// End offset: 0x800801C0
			// End Line: 719
		/* end block 1.1 */
		// End offset: 0x800801C0
		// End Line: 720
	/* end block 1 */
	// End offset: 0x800801C4
	// End Line: 723

	/* begin block 2 */
		// Start line: 1454
	/* end block 2 */
	// End Line: 1455

	/* begin block 3 */
		// Start line: 1455
	/* end block 3 */
	// End Line: 1456
				UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ MON_ShouldIAttack(struct _Instance *instance /*$s3*/, struct _MonsterIR *enemy /*$s1*/, struct _MonsterAttackAttributes *attack /*$s0*/)
int MON_ShouldIAttack(struct _Instance *instance, struct _MonsterIR *enemy, struct _MonsterAttackAttributes *attack)
{ // line 731, offset 0x800801e0
	/* begin block 1 */
		// Start line: 732
		// Start offset: 0x800801E0
		// Variables:
			struct _MonsterVars *mv; // $s4
			int rv; // $a0
			struct _Instance *ei; // $s2

		/* begin block 1.1 */
			// Start line: 751
			// Start offset: 0x8008024C
			// Variables:
				long distance; // $v1
		/* end block 1.1 */
		// End offset: 0x80080364
		// End Line: 803
	/* end block 1 */
	// End offset: 0x80080368
	// End Line: 809

	/* begin block 2 */
		// Start line: 1527
	/* end block 2 */
	// End Line: 1528
				UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// struct _MonsterAttackAttributes * /*$ra*/ MON_ChooseAttack(struct _Instance *instance /*$a0*/, struct _MonsterIR *enemy /*$a1*/)
struct _MonsterAttackAttributes * MON_ChooseAttack(struct _Instance *instance, struct _MonsterIR *enemy)
{ // line 818, offset 0x80080388
	/* begin block 1 */
		// Start line: 820
		// Start offset: 0x80080388
		// Variables:
			struct _MonsterVars *mv; // $t1
			struct _MonsterAttackAttributes *bestAttack; // $t5
			struct _MonsterAttributes *ma; // $t6
			struct _MonsterCombatAttributes *combat; // $t0
			long distance; // $t3
			long zdiff; // $t2
			long smallest; // $t4
			int i; // $a3
			char *attackIndex; // $t0

		/* begin block 1.1 */
			// Start line: 850
			// Start offset: 0x8008042C
			// Variables:
				struct _MonsterAttackAttributes *attack; // $a2
				long delta; // $a0
		/* end block 1.1 */
		// End offset: 0x800804CC
		// End Line: 864
	/* end block 1 */
	// End offset: 0x800804D8
	// End Line: 869

	/* begin block 2 */
		// Start line: 1705
	/* end block 2 */
	// End Line: 1706

	/* begin block 3 */
		// Start line: 1706
	/* end block 3 */
	// End Line: 1707

	/* begin block 4 */
		// Start line: 1707
	/* end block 4 */
	// End Line: 1708
				UNIMPLEMENTED();
	return null;
}


// autogenerated function stub: 
// int /*$ra*/ MON_ShouldIEvade(struct _Instance *instance /*$s1*/)
int MON_ShouldIEvade(struct _Instance *instance)
{ // line 878, offset 0x800804e8
	/* begin block 1 */
		// Start line: 879
		// Start offset: 0x800804E8
		// Variables:
			struct _MonsterVars *mv; // $s0
			int rv; // $s3

		/* begin block 1.1 */
			// Start line: 886
			// Start offset: 0x80080520
			// Variables:
				struct _MonsterIR *enemy; // $s2
		/* end block 1.1 */
		// End offset: 0x80080574
		// End Line: 899
	/* end block 1 */
	// End offset: 0x80080574
	// End Line: 903

	/* begin block 2 */
		// Start line: 1869
	/* end block 2 */
	// End Line: 1870
				UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ MON_ChooseLeftOrRight(struct _Instance *instance /*$s0*/, struct _MonsterIR *enemy /*$a1*/)
int MON_ChooseLeftOrRight(struct _Instance *instance, struct _MonsterIR *enemy)
{ // line 913, offset 0x80080594
	/* begin block 1 */
		// Start line: 914
		// Start offset: 0x80080594

		/* begin block 1.1 */
			// Start line: 923
			// Start offset: 0x800805D4
			// Variables:
				int leftDist; // $s0
				int rightDist; // $v1
		/* end block 1.1 */
		// End offset: 0x80080628
		// End Line: 932
	/* end block 1 */
	// End offset: 0x80080628
	// End Line: 933

	/* begin block 2 */
		// Start line: 1940
	/* end block 2 */
	// End Line: 1941
				UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ MON_ChooseEvadeMove(struct _Instance *instance /*$a0*/)
int MON_ChooseEvadeMove(struct _Instance *instance)
{ // line 935, offset 0x80080638
	/* begin block 1 */
		// Start line: 936
		// Start offset: 0x80080638
		// Variables:
			int anim; // $v0
			struct _MonsterVars *mv; // $v0
			int leftOrRight; // $v1
	/* end block 1 */
	// End offset: 0x80080684
	// End Line: 964

	/* begin block 2 */
		// Start line: 1989
	/* end block 2 */
	// End Line: 1990
			UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ MON_ChooseCombatMove(struct _Instance *instance /*$s2*/, int reason /*$a1*/)
int MON_ChooseCombatMove(struct _Instance *instance, int reason)
{ // line 969, offset 0x80080694
	/* begin block 1 */
		// Start line: 970
		// Start offset: 0x80080694
		// Variables:
			struct _MonsterVars *mv; // $s3
			struct _MonsterSubAttributes *subAttr; // $s4
			int anim; // $s1
			int data; // $v0
			struct _MonsterIR *enemy; // $s0
			int infront; // $a0
			struct _MonsterAnim *manim; // $s0

		/* begin block 1.1 */
			// Start line: 1032
			// Start offset: 0x80080748

			/* begin block 1.1.1 */
				// Start line: 1036
				// Start offset: 0x80080768
				// Variables:
					int dir; // $v0
			/* end block 1.1.1 */
			// End offset: 0x800807B0
			// End Line: 1045
		/* end block 1.1 */
		// End offset: 0x800807C8
		// End Line: 1068

		/* begin block 1.2 */
			// Start line: 1072
			// Start offset: 0x800807D0
			// Variables:
				short zrot; // $s0

			/* begin block 1.2.1 */
				// Start line: 1108
				// Start offset: 0x800808C0
				// Variables:
					_Position temp; // stack offset -56
					SVECTOR New; // stack offset -48
					VECTOR OutTrans; // stack offset -40
			/* end block 1.2.1 */
			// End offset: 0x800809E0
			// End Line: 1148
		/* end block 1.2 */
		// End offset: 0x80080AB8
		// End Line: 1173
	/* end block 1 */
	// End offset: 0x80080AB8
	// End Line: 1177

	/* begin block 2 */
		// Start line: 2057
	/* end block 2 */
	// End Line: 2058
					UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// void /*$ra*/ MON_PlayRandomIdle(struct _Instance *instance /*$s4*/, int mode /*$s5*/)
void MON_PlayRandomIdle(struct _Instance *instance, int mode)
{ // line 1185, offset 0x80080adc
	/* begin block 1 */
		// Start line: 1186
		// Start offset: 0x80080ADC
		// Variables:
			struct _MonsterVars *mv; // $s3
			struct _MonsterAttributes *ma; // $s2
			struct _MonsterBehavior *behavior; // $s0
			struct _MonsterIdle *idle; // $s1
			int chance; // $a2
			int i; // $a0
			char *idleIndex; // $a1
	/* end block 1 */
	// End offset: 0x80080C5C
	// End Line: 1244

	/* begin block 2 */
		// Start line: 2527
	/* end block 2 */
	// End Line: 2528
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MON_PlayCombatIdle(struct _Instance *instance /*$a0*/, int mode /*$a2*/)
void MON_PlayCombatIdle(struct _Instance *instance, int mode)
{ // line 1249, offset 0x80080c80
	/* begin block 1 */
		// Start line: 1250
		// Start offset: 0x80080C80
		// Variables:
			int anim; // $a1
	/* end block 1 */
	// End offset: 0x80080CA8
	// End Line: 1258

	/* begin block 2 */
		// Start line: 2664
	/* end block 2 */
	// End Line: 2665
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MON_GetRandomPoint(_Position *out /*$s2*/, _Position *in /*$s1*/, short r /*$a2*/)
void MON_GetRandomPoint(_Position *out, _Position *in, short r)
{ // line 1290, offset 0x80080cc0
	/* begin block 1 */
		// Start line: 1291
		// Start offset: 0x80080CC0
		// Variables:
			int ang; // $s0
	/* end block 1 */
	// End offset: 0x80080CC0
	// End Line: 1291

	/* begin block 2 */
		// Start line: 2580
	/* end block 2 */
	// End Line: 2581
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// int /*$ra*/ MON_GetRandomDestinationInWorld(struct _Instance *instance /*$s2*/, _Position *in /*$s0*/, short r /*$s4*/)
int MON_GetRandomDestinationInWorld(struct _Instance *instance, _Position *in, short r)
{ // line 1307, offset 0x80080d6c
	/* begin block 1 */
		// Start line: 1308
		// Start offset: 0x80080D6C

		/* begin block 1.1 */
			// Start line: 1311
			// Start offset: 0x80080DA0
			// Variables:
				struct _MonsterVars *mv; // $s1
				//struct evPhysicsLOSData data; // stack offset -48
				int result; // $s0
				int avoidEnemy; // $s3

			/* begin block 1.1.1 */
				// Start line: 1322
				// Start offset: 0x80080DDC
			/* end block 1.1.1 */
			// End offset: 0x80080E2C
			// End Line: 1328

			/* begin block 1.1.2 */
				// Start line: 1342
				// Start offset: 0x80080EA8
			/* end block 1.1.2 */
			// End offset: 0x80080EF8
			// End Line: 1348
		/* end block 1.1 */
		// End offset: 0x80080F30
		// End Line: 1357
	/* end block 1 */
	// End offset: 0x80080F34
	// End Line: 1360

	/* begin block 2 */
		// Start line: 2752
	/* end block 2 */
	// End Line: 2753
				UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// void /*$ra*/ MON_MoveForward(struct _Instance *instance /*$s0*/)
void MON_MoveForward(struct _Instance *instance)
{ // line 1453, offset 0x80080f54
	/* begin block 1 */
		// Start line: 1454
		// Start offset: 0x80080F54
		// Variables:
			struct _MonsterVars *mv; // $v0
	/* end block 1 */
	// End offset: 0x80080F54
	// End Line: 1454

	/* begin block 2 */
		// Start line: 2906
	/* end block 2 */
	// End Line: 2907
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// int /*$ra*/ MON_TurnToPosition(struct _Instance *instance /*$s1*/, _Position *position /*$a1*/, short turnspeed /*$a2*/)
int MON_TurnToPosition(struct _Instance *instance, _Position *position, short turnspeed)
{ // line 1468, offset 0x80080fa4
	/* begin block 1 */
		// Start line: 1469
		// Start offset: 0x80080FA4
	/* end block 1 */
	// End offset: 0x80080FA4
	// End Line: 1469

	/* begin block 2 */
		// Start line: 2989
	/* end block 2 */
	// End Line: 2990
	UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// void /*$ra*/ MON_MoveToPosition(struct _Instance *instance /*$s0*/, _Position *position /*$a1*/, short turnSpeed /*$a2*/)
void MON_MoveToPosition(struct _Instance *instance, _Position *position, short turnSpeed)
{ // line 1485, offset 0x80081014
	/* begin block 1 */
		// Start line: 3029
	/* end block 1 */
	// End Line: 3030
	UNIMPLEMENTED();
}


// autogenerated function stub: 
// int /*$ra*/ MON_OnGround(struct _Instance *instance /*$s0*/)
int MON_OnGround(struct _Instance *instance)
{ // line 1504, offset 0x80081058
	/* begin block 1 */
		// Start line: 1505
		// Start offset: 0x80081058
		// Variables:
			struct _MonsterVars *mv; // $s1
			//struct evPhysicsGravityData data; // stack offset -32
			int minUpper; // $v1
			long xyDist; // $a1
	/* end block 1 */
	// End offset: 0x800810E8
	// End Line: 1532

	/* begin block 2 */
		// Start line: 3069
	/* end block 2 */
	// End Line: 3070
			UNIMPLEMENTED();
	return 0;
}

void MON_ApplyPhysics(struct _Instance* instance)
{
	PhysicsMove(instance, &instance->position, gameTrackerX.timeMult);
}


// autogenerated function stub: 
// void /*$ra*/ MON_ChangeBehavior(struct _Instance *instance /*$a0*/, int behavior /*$s0*/)
void MON_ChangeBehavior(struct _Instance *instance, int behavior)
{ // line 1559, offset 0x8008116c
#if defined(PC_VERSION)
	struct _MonsterVars* extraData; // ebp
	enum MonsterState v3; // esi

	if (behavior != -1)
	{
		extraData = (struct _MonsterVars*)instance->extraData;
		if ((gameTrackerX.debugFlags2 & 1) != 0)
			MON_Say();
		switch (behavior)
		{
		case 2:
			v3 = MONSTER_STATE_WANDER;
			break;
		case 4:
		case 8:
			v3 = MONSTER_STATE_HIDE;
			break;
		case 9:
			v3 = MONSTER_STATE_FLEE;
			if ((gameTrackerX.debugFlags2 & 1) != 0)
				MON_Say();
			break;
		default:
			v3 = MONSTER_STATE_PURSUE;
			break;
		}
		MON_SwitchState(instance, v3);
		extraData->behaviorState = behavior;
	}
#else
	UNIMPLEMENTED();
#endif
}


// autogenerated function stub: 
// void /*$ra*/ MON_CheckEnvironment(struct _Instance *instance /*$s1*/)
void MON_CheckEnvironment(struct _Instance *instance)
{ // line 1596, offset 0x800811f4
	/* begin block 1 */
		// Start line: 1597
		// Start offset: 0x800811F4
		// Variables:
			struct _MonsterVars *mv; // $s0
			struct _MonsterAttributes *ma; // $s4
			int inwater; // $v0
			struct _SVector Hack; // stack offset -40

		/* begin block 1.1 */
			// Start line: 1637
			// Start offset: 0x80081328
			// Variables:
				int moveback; // $s2
				int onground; // $s3

			/* begin block 1.1.1 */
				// Start line: 1664
				// Start offset: 0x800813D4
				// Variables:
					int offset; // $a1
					//int result; // $v0
					_Position pos; // stack offset -32
			/* end block 1.1.1 */
			// End offset: 0x8008147C
			// End Line: 1684

			/* begin block 1.1.2 */
				// Start line: 1696
				// Start offset: 0x800814B8
				// Variables:
					//int result; // $v0
					//int offset; // $a1
			/* end block 1.1.2 */
			// End offset: 0x80081518
			// End Line: 1712

			/* begin block 1.1.3 */
				// Start line: 1719
				// Start offset: 0x80081520
				// Variables:
					//int result; // $v1
			/* end block 1.1.3 */
			// End offset: 0x8008157C
			// End Line: 1749
		/* end block 1.1 */
		// End offset: 0x800815E4
		// End Line: 1762
	/* end block 1 */
	// End offset: 0x80081608
	// End Line: 1767

	/* begin block 2 */
		// Start line: 3284
	/* end block 2 */
	// End Line: 3285
					UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MON_CheckTerrainAndRespond(struct _Instance *instance /*$s1*/, struct BSPTree *bsp /*$a1*/, struct _TFace *tface /*$a2*/)
void MON_CheckTerrainAndRespond(struct _Instance *instance, struct BSPTree *bsp, struct _TFace *tface)
{ // line 1769, offset 0x80081628
	/* begin block 1 */
		// Start line: 1770
		// Start offset: 0x80081628
		// Variables:
			unsigned long results; // $s0
	/* end block 1 */
	// End offset: 0x80081698
	// End Line: 1781

	/* begin block 2 */
		// Start line: 3645
	/* end block 2 */
	// End Line: 3646
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// unsigned long /*$ra*/ MON_CheckTerrain(struct _Instance *instance /*$s2*/, struct BSPTree *bsp /*$s1*/, struct _TFace *tface /*$a2*/)
unsigned long MON_CheckTerrain(struct _Instance *instance, struct BSPTree *bsp, struct _TFace *tface)
{ // line 1786, offset 0x800816ac
	/* begin block 1 */
		// Start line: 1787
		// Start offset: 0x800816AC
		// Variables:
			unsigned long rv; // $s0

		/* begin block 1.1 */
			// Start line: 1793
			// Start offset: 0x800816D0
			// Variables:
				struct Level *level; // $v1
		/* end block 1.1 */
		// End offset: 0x80081750
		// End Line: 1813
	/* end block 1 */
	// End offset: 0x80081750
	// End Line: 1815

	/* begin block 2 */
		// Start line: 3679
	/* end block 2 */
	// End Line: 3680
				UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ MON_CheckPointSuitability(struct _Instance *instance /*$s2*/, _Position *origin /*$a1*/, _Position *destination /*$s4*/)
int MON_CheckPointSuitability(struct _Instance *instance, _Position *origin, _Position *destination)
{ // line 1824, offset 0x8008176c
	/* begin block 1 */
		// Start line: 1825
		// Start offset: 0x8008176C
		// Variables:
			struct _MonsterVars *mv; // $s1
			int rc; // $s3
			int result; // $a0
			struct evPhysicsDropHeightData *data; // $s0
	/* end block 1 */
	// End offset: 0x80081820
	// End Line: 1851

	/* begin block 2 */
		// Start line: 3761
	/* end block 2 */
	// End Line: 3762
			UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// unsigned long /*$ra*/ MON_GetTime(struct _Instance *instance /*$a0*/)
unsigned long MON_GetTime(struct _Instance *instance)
{ // line 1926, offset 0x80081844
	/* begin block 1 */
		// Start line: 3852
	/* end block 1 */
	// End Line: 3853

	/* begin block 2 */
		// Start line: 3896
	/* end block 2 */
	// End Line: 3897
	UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// void /*$ra*/ MON_BirthSoul(struct _Instance *instance /*$s1*/, int link /*$s3*/)
void MON_BirthSoul(struct _Instance *instance, int link)
{ // line 1944, offset 0x80081898
	/* begin block 1 */
		// Start line: 1945
		// Start offset: 0x80081898
		// Variables:
			struct _MonsterVars *mv; // $s2

		/* begin block 1.1 */
			// Start line: 1952
			// Start offset: 0x800818E4
			// Variables:
				struct Object *soulob; // $a1

			/* begin block 1.1.1 */
				// Start line: 1959
				// Start offset: 0x800818F8
				// Variables:
					struct _Instance *isoul; // $s0

				/* begin block 1.1.1.1 */
					// Start line: 1980
					// Start offset: 0x8008195C
					// Variables:
						MATRIX *matrix; // $v1
				/* end block 1.1.1.1 */
				// End offset: 0x80081980
				// End Line: 1984
			/* end block 1.1.1 */
			// End offset: 0x80081988
			// End Line: 1990
		/* end block 1.1 */
		// End offset: 0x80081988
		// End Line: 1993

		/* begin block 1.2 */
			// Start line: 1996
			// Start offset: 0x80081990
			// Variables:
				//struct _Instance *isoul; // $a0
		/* end block 1.2 */
		// End offset: 0x800819E0
		// End Line: 2010
	/* end block 1 */
	// End offset: 0x800819E0
	// End Line: 2012

	/* begin block 2 */
		// Start line: 3923
	/* end block 2 */
	// End Line: 3924

	/* begin block 3 */
		// Start line: 3931
	/* end block 3 */
	// End Line: 3932
						UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MON_ProcessIntro(struct _Instance *instance /*$s2*/)
void MON_ProcessIntro(struct _Instance *instance)
{ // line 2018, offset 0x800819fc
	/* begin block 1 */
		// Start line: 2019
		// Start offset: 0x800819FC
		// Variables:
			struct _MonsterVars *mv; // $s0
			long initialBehavior; // $s3
			long triggeredBehavior; // $s5
			long activeBehavior; // $s6
			long guardRange; // $s7
			long wanderRange; // $fp
			long ambushRange; // $t1
			long hitPoints; // $s4
			int spectral; // stack offset -56
			long flags; // $s1
			struct _MonsterAttributes *ma; // $v0

		/* begin block 1.1 */
			// Start line: 2039
			// Start offset: 0x80081AA0
			// Variables:
				struct INICommand *command; // $a2

			/* begin block 1.1.1 */
				// Start line: 2093
				// Start offset: 0x80081D14
				// Variables:
					short *pmarker; // $a0
					int i; // $a1
					long *param; // $v1
			/* end block 1.1.1 */
			// End offset: 0x80081D3C
			// End Line: 2108

			/* begin block 1.1.2 */
				// Start line: 2117
				// Start offset: 0x80081D64
				// Variables:
					//int i; // $a0
					short *unit; // $a1
			/* end block 1.1.2 */
			// End offset: 0x80081D9C
			// End Line: 2127
		/* end block 1.1 */
		// End offset: 0x80081E14
		// End Line: 2157
	/* end block 1 */
	// End offset: 0x80081EF8
	// End Line: 2198

	/* begin block 2 */
		// Start line: 4082
	/* end block 2 */
	// End Line: 4083
					UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MON_SetDefaults(struct _Instance *instance /*$a0*/)
void MON_SetDefaults(struct _Instance *instance)
{ // line 2203, offset 0x80081f28
	/* begin block 1 */
		// Start line: 2205
		// Start offset: 0x80081F28
		// Variables:
			struct _MonsterVars *mv; // $a1
			struct _MonsterAttributes *ma; // $a3
			struct _MonsterSubAttributes *subAttr; // $a2
	/* end block 1 */
	// End offset: 0x80082120
	// End Line: 2261

	/* begin block 2 */
		// Start line: 4620
	/* end block 2 */
	// End Line: 4621

	/* begin block 3 */
		// Start line: 4621
	/* end block 3 */
	// End Line: 4622
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MON_GetPlanSlot(struct _MonsterVars *mv /*$s0*/)
void MON_GetPlanSlot(struct _MonsterVars *mv)
{ // line 2266, offset 0x80082128
	/* begin block 1 */
		// Start line: 4749
	/* end block 1 */
	// End Line: 4750
	UNIMPLEMENTED();
}


// autogenerated function stub: 
// int /*$ra*/ MON_DefaultPlanMovement(struct _Instance *instance /*$s2*/, int anim /*$s4*/, long distance /*$s5*/)
int MON_DefaultPlanMovement(struct _Instance *instance, int anim, long distance)
{ // line 2277, offset 0x8008216c
	/* begin block 1 */
		// Start line: 2278
		// Start offset: 0x8008216C
		// Variables:
			struct _MonsterVars *mv; // $s0
			int rc; // $s1
			int felloff; // $v1
			long length; // $s3
			struct _MonsterAnim *manim; // $s6

		/* begin block 1.1 */
			// Start line: 2307
			// Start offset: 0x80082260
			// Variables:
				_Position pos; // stack offset -40
				int planresult; // $v1

			/* begin block 1.1.1 */
				// Start line: 2348
				// Start offset: 0x80082318
				// Variables:
					short turnSpeed; // $a2
			/* end block 1.1.1 */
			// End offset: 0x80082394
			// End Line: 2365
		/* end block 1.1 */
		// End offset: 0x80082394
		// End Line: 2365
	/* end block 1 */
	// End offset: 0x800823E4
	// End Line: 2389

	/* begin block 2 */
		// Start line: 4771
	/* end block 2 */
	// End Line: 4772
					UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// void /*$ra*/ MON_DropAllObjects(struct _Instance *instance /*$a0*/)
void MON_DropAllObjects(struct _Instance *instance)
{ // line 2391, offset 0x8008240c
	/* begin block 1 */
		// Start line: 2392
		// Start offset: 0x8008240C
		// Variables:
			struct _Instance *child; // $a0

		/* begin block 1.1 */
			// Start line: 2397
			// Start offset: 0x8008242C
			// Variables:
				struct _Instance *next; // $s0
		/* end block 1.1 */
		// End offset: 0x8008245C
		// End Line: 2403
	/* end block 1 */
	// End offset: 0x80082468
	// End Line: 2405

	/* begin block 2 */
		// Start line: 5002
	/* end block 2 */
	// End Line: 5003
				UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MON_EnableHeadMove(struct _Instance *instance /*$a0*/)
void MON_EnableHeadMove(struct _Instance *instance)
{ // line 2407, offset 0x8008247c
	/* begin block 1 */
		// Start line: 2408
		// Start offset: 0x8008247C
		// Variables:
			struct _MonsterAttributes *ma; // $s0
	/* end block 1 */
	// End offset: 0x80082510
	// End Line: 2427

	/* begin block 2 */
		// Start line: 5042
	/* end block 2 */
	// End Line: 5043
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MON_DisableHeadMove(struct _Instance *instance /*$a0*/)
void MON_DisableHeadMove(struct _Instance *instance)
{ // line 2429, offset 0x80082524
	/* begin block 1 */
		// Start line: 2430
		// Start offset: 0x80082524
		// Variables:
			struct _MonsterAttributes *ma; // $s0
	/* end block 1 */
	// End offset: 0x8008259C
	// End Line: 2442

	/* begin block 2 */
		// Start line: 5086
	/* end block 2 */
	// End Line: 5087
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MON_LookInDirection(struct _Instance *instance /*$a0*/, short tx /*$a1*/, short tz /*$a2*/)
void MON_LookInDirection(struct _Instance *instance, short tx, short tz)
{ // line 2447, offset 0x800825b0
#if defined(PC_VERSION)
	struct _MonsterAttributes* ma; // ebp
	uchar v4; // al
	struct _G2SVector3_Type rot; // [esp+10h] [ebp-8h] BYREF

	ma = (struct _MonsterAttributes*)instance->data;
	v4 = ma->neckSegment;
	if (v4)
	{
		if (ma->spineSegment == v4)
		{
			rot.x = tx;
			rot.y = 0;
			rot.z = tz;
			G2Anim_SetController_Vector(&instance->anim, ma->neckSegment, 14, &rot);
		}
		else
		{
			rot.y = 0;
			rot.x = (__int16)(70 * tx) / 100;
			rot.z = (__int16)(70 * tz) / 100;
			G2Anim_SetController_Vector(&instance->anim, ma->neckSegment, 14, &rot);
			if (ma->spineSegment)
			{
				rot.y = 0;
				rot.x = (__int16)(30 * tx) / 100;
				rot.z = (__int16)(30 * tz) / 100;
				G2Anim_SetController_Vector(&instance->anim, ma->spineSegment, 14, &rot);
			}
		}
	}
#else
	UNIMPLEMENTED();
#endif
}


// autogenerated function stub: 
// void /*$ra*/ MON_LookAtPos(struct _Instance *instance /*$s1*/, _Position *position /*$a1*/)
void MON_LookAtPos(struct _Instance *instance, _Position *position)
{ // line 2478, offset 0x80082724
#if defined(PC_VERSION)
	struct _MonsterVars* mv; // esi
	__int16 v3; // ax
	__int16 v4; // ax
	__int16 lookAngleZ; // cx
	__int16 v6; // cx
	__int16 v7; // cx
	__int16 z; // ax

	mv = (struct _MonsterVars*)instance->extraData;
	v3 = MATH3D_AngleFromPosToPos(&instance->position, position);
	v4 = AngleDiff(instance->rotation.z, v3);
	if (v4 <= 796)
	{
		if (v4 < -796)
			v4 = -796;
	}
	else
	{
		v4 = 796;
	}
	lookAngleZ = mv->lookAngleZ;
	if (lookAngleZ <= v4)
	{
		if (lookAngleZ < v4)
		{
			v7 = lookAngleZ + 273;
			mv->lookAngleZ = v7;
			if (v7 > v4)
				goto LABEL_10;
		}
	}
	else
	{
		v6 = lookAngleZ - 273;
		mv->lookAngleZ = v6;
		if (v6 < v4)
			LABEL_10:
		mv->lookAngleZ = v4;
	}
	z = mv->lookAngleZ;
	mv->lookAngleX = 0;
	MON_LookInDirection(instance, 0, z);
#else
	UNIMPLEMENTED();
#endif
}


// autogenerated function stub: 
// void /*$ra*/ MON_ProcessLookAt(struct _Instance *instance /*$s1*/)
void MON_ProcessLookAt(struct _Instance *instance)
{ // line 2511, offset 0x80082800
#if defined(PC_VERSION)
	struct _MonsterVars* mv; // ebp
	struct _MonsterAttributes* v2; // edi
	struct _MonsterAttributes* ma; // edi
	struct _MonsterAttributes* v4; // edi
	uchar v5; // al

	mv = (struct _MonsterVars*)instance->extraData;
	if (mv->mode != 0x80000)
	{
		if ((mv->mvFlags & 0x80000000) == 0)
		{
			if (mv->lookAtPos)
			{
				ma = (struct _MonsterAttributes*)instance->data;
				if (ma->neckSegment)
				{
					if (!G2Anim_IsControllerActive(&instance->anim, ma->neckSegment, 14))
					{
						G2Anim_SetControllerAngleOrder(&instance->anim, ma->neckSegment, 14, 1);
						G2Anim_EnableController(&instance->anim, ma->neckSegment, 14);
						if (ma->spineSegment != ma->neckSegment)
						{
							G2Anim_SetControllerAngleOrder(&instance->anim, ma->spineSegment, 14, 1);
							G2Anim_EnableController(&instance->anim, ma->spineSegment, 14);
						}
					}
				}
				MON_LookAtPos(instance, mv->lookAtPos);
				mv->lookAtPos = 0;
			}
			else if (mv->lookAngleX || mv->lookAngleZ)
			{
				AngleMoveToward(&mv->lookAngleX, 0, 100);
				AngleMoveToward(&mv->lookAngleZ, 0, 100);
				MON_LookInDirection(instance, mv->lookAngleX, mv->lookAngleZ);
			}
			else
			{
				v4 = (struct _MonsterAttributes*)instance->data;
				if (v4->neckSegment)
				{
					if (G2Anim_IsControllerActive(&instance->anim, v4->neckSegment, 14))
					{
						G2Anim_DisableController(&instance->anim, v4->neckSegment, 14);
						v5 = v4->spineSegment;
						if (v5)
						{
							if (v5 != v4->neckSegment)
								G2Anim_DisableController(&instance->anim, v4->spineSegment, 14);
						}
					}
				}
			}
		}
		else
		{
			v2 = (struct _MonsterAttributes*)instance->data;
			if (v2->neckSegment && !G2Anim_IsControllerActive(&instance->anim, v2->neckSegment, 14))
			{
				G2Anim_SetControllerAngleOrder(&instance->anim, v2->neckSegment, 14, 1);
				G2Anim_EnableController(&instance->anim, v2->neckSegment, 14);
				if (v2->spineSegment != v2->neckSegment)
				{
					G2Anim_SetControllerAngleOrder(&instance->anim, v2->spineSegment, 14, 1);
					G2Anim_EnableController(&instance->anim, v2->spineSegment, 14);
				}
			}
			MON_LookAtPos(instance, &mv->lookAtPosData);
		}
	}
#else
	UNIMPLEMENTED();
#endif
}


// autogenerated function stub: 
// int /*$ra*/ MON_TakeDamage(struct _Instance *instance /*$a0*/, int damage /*$s2*/, int type /*$s1*/)
int MON_TakeDamage(struct _Instance *instance, int damage, int type)
{ // line 2545, offset 0x800828f4
#if defined(PC_VERSION)
	struct _MonsterVars* mv; // esi
	struct _MonsterCombatAttributes* combatAttributes; // eax
	char v5; // al
	unsigned int mvFlags; // eax

	mv = (struct _MonsterVars*)instance->extraData;
	combatAttributes = mv->subAttr->combatAttributes;
	if (!combatAttributes)
		return 0;
	if (!combatAttributes->hitPoints)
		return 0;
	v5 = INSTANCE_Query(instance, 1);
	if (type == 0x40000 && (v5 & 8) == 0)
		return 0;
	mv->damageType = type;
	mv->hitPoints -= damage;
	if (mv->hitPoints > 0)
		return 0;
	mvFlags = mv->mvFlags;
	mv->hitPoints = 0;
	if ((mvFlags & 0x2000) != 0)
	{
		if ((gameTrackerX.debugFlags2 & 1) != 0)
		{
			MON_Say();
			return 1;
		}
	}
	else if ((gameTrackerX.debugFlags2 & 1) != 0)
	{
		MON_Say();
	}
	return 1;
#else
	UNIMPLEMENTED();
	return 0;
#endif
}


// autogenerated function stub: 
// void /*$ra*/ MON_SetUpSaveInfo(struct _Instance *instance /*$t0*/, struct _MonsterSaveInfo *saveData /*$a3*/)
void MON_SetUpSaveInfo(struct _Instance *instance, struct _MonsterSaveInfo *saveData)
{ // line 2582, offset 0x800829a0
#if defined(PC_VERSION)
	struct _MonsterVars* mv; // ecx
	struct _MonsterAttributes* ma; // ebp
	unsigned int v4; // esi
	int v5; // edx
	int v6; // ebx
	unsigned int v7; // esi
	__int16 soulJuice; // dx
	unsigned int v9; // edx

	mv = (struct _MonsterVars*)instance->extraData;
	ma = (struct _MonsterAttributes*)instance->data;
	v4 = saveData->age & ~7u;
	saveData->mvFlags = mv->mvFlags & ~0x440004u;
	saveData->auxFlags = mv->auxFlags & ~0x8000000u;
	v5 = v4 | (mv->age & 7);
	saveData->age = v5;
	v6 = 8 * (instance->currentMainState & 0x3F);
	saveData->age = v6 | v5 & ~0x1F8u;
	v7 = ((mv->behaviorState & 0x1F) << 9) | v6 & ~0x3E00 | v5 & ~0x3FF8;
	saveData->age = v7;
	saveData->age = v7 & 0xFF1FFFFF | ((mv->causeOfDeath & 7) << 21);
	if (instance->currentMainState != 23 || mv->causeOfDeath)
		soulJuice = mv->soulJuice;
	else
		soulJuice = mv->heldID;
	saveData->soulJuice = soulJuice;
	saveData->soulID = mv->soulID;
	if (mv->anim)
	{
		v9 = saveData->age & ~0x100000u | ((instance->anim.section[0].flags & 2) << 19);
		saveData->age = v9;
		saveData->age = v9 & ~0xFC000u | (((mv->anim - ma->animList) & 0x3F) << 14);
	}
	else
	{
		saveData->age = ((ma->numAnims & 0x3F) << 14) | saveData->age & 0xFFF03FFF;
	}
	if ((gameTrackerX.debugFlags2 & 1) != 0)
		MON_Say();
#else
	UNIMPLEMENTED();
#endif
}


// autogenerated function stub: 
// void /*$ra*/ MON_GetSaveInfo(struct _Instance *instance /*$s1*/, struct _MonsterSaveInfo *saveData /*$s2*/)
void MON_GetSaveInfo(struct _Instance *instance, struct _MonsterSaveInfo *saveData)
{ // line 2616, offset 0x80082b0c
#if defined(PC_VERSION)
	struct _MonsterAttributes* ma; // ebx
	struct _MonsterVars* mv; // esi
	unsigned __int8 v4; // al
	struct _MonsterSubAttributes* v5; // eax
	struct _MonsterVars* extraData; // edx
	__int16 modelNum; // ax
	struct _HModel* v8; // eax
	int numHPrims; // ecx
	struct _HPrim* i; // eax
	unsigned int mvFlags; // eax
	struct _HModel* hModelList; // ecx
	struct _HModel* v13; // eax
	int v14; // ecx
	struct _HPrim* j; // eax
	unsigned int v16; // edx
	int v17; // eax
	unsigned int v18; // eax
	int flags2; // eax
	unsigned int age; // edi
	int v21; // eax
	int v22; // edi

	ma = (struct _MonsterAttributes*)instance->data;
	mv = (struct _MonsterVars*)instance->extraData;
	if ((gameTrackerX.debugFlags2 & 1) != 0)
		MON_Say();
	v4 = saveData->age & 7;
	mv->age = v4;
	v5 = ma->subAttributesList[v4];
	mv->subAttr = v5;
	extraData = (struct _MonsterVars*)instance->extraData;
	modelNum = v5->modelNum;
	instance->currentModel = modelNum;
	if ((saveData->mvFlags & 0x8000) == 0)
	{
		if ((BYTE1(extraData->mvFlags) & 0x80u) == 0)
			goto LABEL_20;
		v8 = &instance->hModelList[modelNum];
		numHPrims = v8->numHPrims;
		for (i = v8->hPrimList; numHPrims; --numHPrims)
		{
			if (i->type == 1 && i->data.hsphere->id == 8)
				i->hpFlags &= ~1u;
			++i;
		}
		mvFlags = extraData->mvFlags;
		mvFlags = extraData->mvFlags & ~0x8000;
		goto LABEL_19;
	}
	if ((BYTE1(extraData->mvFlags) & 0x80u) == 0)
	{
		hModelList = instance->hModelList;
		if (hModelList)
		{
			v13 = &hModelList[modelNum];
			v14 = v13->numHPrims;
			for (j = v13->hPrimList; v14; --v14)
			{
				if (j->type == 1 && j->data.hsphere->id == 8)
					j->hpFlags |= 1u;
				++j;
			}
			mvFlags = extraData->mvFlags;
			mvFlags = extraData->mvFlags | 0x8000;
		LABEL_19:
			extraData->mvFlags = mvFlags;
		}
	}
LABEL_20:
	v16 = mv->auxFlags & 0x8000000;
	mv->mvFlags = saveData->mvFlags | mv->mvFlags & 0xC000;
	mv->auxFlags = v16 | saveData->auxFlags;
	mv->behaviorState = (saveData->age >> 9) & 0x1F;
	mv->causeOfDeath = (saveData->age >> 21) & 7;
	mv->soulID = saveData->soulID;
	mv->soulJuice = saveData->soulJuice;
	v17 = (saveData->age >> 3) & 0x3F;
	switch (v17)
	{
	case 6:
	case 8:
	case 9:
	case 21:
	case 28:
		instance->currentMainState = 13;
		break;
	case 10:
	case 11:
	case 12:
	case 14:
		instance->currentMainState = 2;
		break;
	case 16:
		instance->flags2 &= ~0x40u;
		v18 = mv->mvFlags;
		v18 = mv->mvFlags | 0x200;
		mv->soulID = 0x7FFFFFFF;
		mv->mvFlags = v18;
		goto LABEL_22;
	case 23:
	LABEL_22:
		if (!mv->causeOfDeath)
		{
			mv->heldID = mv->soulJuice;
			mv->soulJuice = 4096;
			flags2 = instance->flags2;
			flags2 = flags2 | 0x80;
			instance->flags2 = flags2;
		}
		instance->currentMainState = 23;
		break;
	default:
		instance->currentMainState = v17;
		break;
	}
	instance->position = instance->oldPos;
	age = saveData->age;
	v21 = (age >> 14) & 0x3F;
	if (v21 < ma->numAnims)
	{
		v22 = ((age & 0x100000) != 0) + 1;
		if (instance->currentMainState == 23)
			MON_PlayAnimID(instance, *(char*)(**((DWORD**)instance->extraData + 85) + 24), 1);
		else
			MON_PlayAnimID(instance, v21, v22);
	}
#else
UNIMPLEMENTED();
#endif
}


// autogenerated function stub: 
// void /*$ra*/ MON_KillMonster(struct _Instance *instance /*$s5*/)
void MON_KillMonster(struct _Instance *instance)
{ // line 2694, offset 0x80082d50
#if defined(PC_VERSION)
	struct _Instance* LinkChild; // esi
	struct _Instance* LinkSibling; // ebp
	struct Intro* intro; // eax
	struct Object* object; // edx
	int oflags2; // ecx
	int flags2; // eax
	int flags; // eax
	struct _MonsterVars* mv; // [esp-2Ch] [ebp-3Ch]

	LinkChild = instance->LinkChild;
	mv = (struct _MonsterVars*)instance->extraData;
	if (LinkChild)
	{
		do
		{
			LinkSibling = LinkChild->LinkSibling;
			if ((gameTrackerX.debugFlags2 & 1) != 0)
				MON_Say();
			if (LinkChild->ParentLinkNode == 3)
				INSTANCE_Post(LinkChild, 0x800008, 2);
			else
				INSTANCE_Post(LinkChild, 0x800008, 1);
			LinkChild = LinkSibling;
		} while (LinkSibling);
	}
	if (mv->causeOfDeath == 6)
	{
		FX_BuildSplinters(instance, 0, 0, 0, *((struct FXSplinter**)instance->data + 19), gFXT, 0, 0, 8);
		if ((instance->flags2 & 0x1000) == 0)
			SOUND_Play3dSound(&instance->position, 48, 0, 95, 16000);
	}
	if ((mv->mvFlags & 0x1000000) == 0 || (intro = instance->intro) != 0 && (intro->flags & 0x400) != 0)
	{
		if ((gameTrackerX.debugFlags2 & 1) != 0)
			MON_Say();
		SAVE_MarkDeadDead(instance);
	}
	else
	{
		if ((gameTrackerX.debugFlags2 & 1) != 0)
			MON_Say();
		if (mv->regenTime)
			MONAPI_AddToGenerator(instance);
		SAVE_DeleteInstance(instance);
	}
	object = instance->object;
	oflags2 = object->oflags2;
	if ((oflags2 & 4) != 0)
	{
		flags2 = instance->flags2;
		if ((flags2 & 0x1000) != 0)
		{
			SOUND_ProcessInstanceSounds(
				object->soundData,
				instance->soundInstanceTbl,
				&instance->position,
				oflags2 & 0x2000000,
				flags2 & 0x8000000,
				0,
				0,
				&instance->flags2);
			SOUND_ProcessInstanceSounds(
				instance->object->soundData,
				instance->soundInstanceTbl,
				&instance->position,
				instance->object->oflags2 & 0x2000000,
				instance->flags2 & 0x8000000,
				0,
				0,
				&instance->flags2);
		}
	}
	flags = instance->flags;
	flags = flags | 0x20;
	instance->flags = flags;
#else
	UNIMPLEMENTED();
#endif
}


// autogenerated function stub: 
// int /*$ra*/ MON_ShouldIAmbushEnemy(struct _Instance *instance /*$s3*/)
int MON_ShouldIAmbushEnemy(struct _Instance *instance)
{ // line 2755, offset 0x80082f28
#if defined(PC_VERSION)
	struct _MonsterVars* mv; // esi
	int birthStreamUnitID; // eax
	struct _MonsterIR* enemy; // ebx
	char ambushMarker; // cl
	struct _Instance* ppos; // ebp
	struct _StreamUnit* unit; // eax
	__int16 arc; // ax
	int v9; // [esp-8h] [ebp-20h]
	_Position pos; // [esp+10h] [ebp-8h] BYREF

	mv = (struct _MonsterVars*)instance->extraData;
	birthStreamUnitID = instance->birthStreamUnitID;
	enemy = mv->enemy;
	if (instance->currentStreamUnitID == birthStreamUnitID)
	{
		ambushMarker = mv->ambushMarker;
		if (ambushMarker)
		{
			if (mv->ambushArc == 2048 && mv->ambushElevation == 1024)
			{
				ppos = enemy ? enemy->instance : gameTrackerX.playerInstance;
				v9 = ambushMarker;
				unit = STREAM_GetStreamUnitWithID(birthStreamUnitID);
				if (PLANAPI_FindNodePositionInUnit(unit, &pos, v9, 4))
				{
					if (MATH3D_LengthXYZ(ppos->position.x - pos.x, ppos->position.y - pos.y, ppos->position.z - pos.z) < mv->ambushRange)
						return 1;
				}
			}
		}
	}
	if (!enemy || instance->currentMainState == 26 && (enemy->mirFlags & 0x40) == 0)
		return 0;
	arc = mv->ambushArc;
	if (arc == 2048 && mv->ambushElevation == 1024)
		return enemy->distance < mv->ambushRange;
	if (enemy->distance < mv->ambushRange)
		return MATH3D_ConeDetect(&enemy->relativePosition, arc, mv->ambushElevation);
	else
		return 0;
#else
	UNIMPLEMENTED();
	return 0;
#endif
}


// autogenerated function stub: 
// int /*$ra*/ MON_ShouldIFireAtTarget(struct _Instance *instance /*$a0*/, struct _MonsterIR *target /*$a1*/)
int MON_ShouldIFireAtTarget(struct _Instance *instance, struct _MonsterIR *target)
{ // line 2802, offset 0x80083094
	/* begin block 1 */
		// Start line: 2804
		// Start offset: 0x80083094
		// Variables:
			struct _MonsterVars *mv; // $a2

		/* begin block 1.1 */
			// Start line: 2810
			// Start offset: 0x800830C4
			// Variables:
				struct _MonsterAttributes *ma; // $v1
				struct _MonsterMissile *missileAttack; // $a0

			/* begin block 1.1.1 */
				// Start line: 2815
				// Start offset: 0x800830FC
				// Variables:
					long distance; // $a1

				/* begin block 1.1.1.1 */
					// Start line: 2819
					// Start offset: 0x80083114
					// Variables:
						struct _MonsterIR *known; // $v1
				/* end block 1.1.1.1 */
				// End offset: 0x8008317C
				// End Line: 2836
			/* end block 1.1.1 */
			// End offset: 0x8008317C
			// End Line: 2837
		/* end block 1.1 */
		// End offset: 0x8008317C
		// End Line: 2838
	/* end block 1 */
	// End offset: 0x8008317C
	// End Line: 2842

	/* begin block 2 */
		// Start line: 5881
	/* end block 2 */
	// End Line: 5882

	/* begin block 3 */
		// Start line: 5882
	/* end block 3 */
	// End Line: 5883
						UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ MON_ShouldIFlee(struct _Instance *instance /*$a0*/)
int MON_ShouldIFlee(struct _Instance *instance)
{ // line 2847, offset 0x80083184
#if defined(PC_VERSION)
	struct _MonsterVars* mv; // edx
	struct _MonsterIR* enemy; // eax
	__int16 v3; // ax
	__int16* validUnits; // ecx
	struct _MonsterIR* ally; // eax

	mv = (struct _MonsterVars*)instance->extraData;
	enemy = mv->enemy;
	if (!enemy || (enemy->mirFlags & 8) != 0 || enemy->distance >= mv->subAttr->fleeRange)
		return 0;
	v3 = mv->validUnits[0];
	validUnits = mv->validUnits;
	if (v3)
	{
		while (LOWORD(instance->currentStreamUnitID) != v3)
		{
			v3 = validUnits[1];
			++validUnits;
			if (!v3)
				return 0;
		}
	}
	mv->lastValidPos = instance->position;
	if (mv->behaviorState == 9)
		return 1;
	if ((mv->mvFlags & 0x2000000) != 0)
	{
		ally = mv->ally;
		if ((!ally || (ally->mirFlags & 0x200) == 0) && mv->hitPoints < 0x2000)
			return 1;
	}
	return (mv->mvFlags & 0x2000) != 0 && !mv->hitPoints;
#else
	UNIMPLEMENTED();
	return 0;
#endif
}


// autogenerated function stub: 
// void /*$ra*/ MON_RelocateCoords(struct _Instance *instance /*$a0*/, struct _SVector *offset /*$t0*/)
void MON_RelocateCoords(struct _Instance *instance, struct _SVector *offset)
{ // line 2877, offset 0x80083284
#if defined(PC_VERSION)
	__int16 x; // dx
	__int16 y; // si
	__int16 z; // di
	struct _MonsterVars* mv; // eax
	char v6; // al

	x = offset->x;
	y = offset->y;
	z = offset->z;
	mv = (struct _MonsterVars*)instance->extraData;
	mv->destination.x += offset->x;
	mv->destination.y += y;
	mv->destination.z += z;
	mv->lastValidPos.x += x;
	mv->lastValidPos.y += y;
	mv->lastValidPos.z += z;
	v6 = mv->pathSlotID;
	if (v6 != -1)
		ENMYPLAN_RelocatePlanPositions(v6, offset);
#else
	UNIMPLEMENTED();
#endif
}


// autogenerated function stub: 
// int /*$ra*/ MON_ValidUnit(struct _Instance *instance /*$a0*/, unsigned long unitId /*$a1*/)
int MON_ValidUnit(struct _Instance *instance, unsigned long unitId)
{ // line 2901, offset 0x80083310
#if defined(PC_VERSION)
	struct _MonsterVars* extraData; // ecx
	__int16 v3; // ax
	__int16* validUnits; // ecx

	extraData = (struct _MonsterVars*)instance->extraData;
	v3 = extraData->validUnits[0];
	validUnits = extraData->validUnits;
	if (!v3)
		return 1;
	while ((WORD)unitId != v3)
	{
		v3 = validUnits[1];
		++validUnits;
		if (!v3)
			return 0;
	}
	return 1;
#else
	UNIMPLEMENTED();
	return 0;
#endif
}


// autogenerated function stub: 
// int /*$ra*/ MON_ValidPosition(struct _Instance *instance /*$s0*/)
int MON_ValidPosition(struct _Instance *instance)
{ // line 2923, offset 0x8008335c
#if defined(PC_VERSION)
	struct _MonsterVars* mv; // esi
	__int16 v2; // ax
	__int16* validUnits; // ecx

	mv = (struct _MonsterVars*)instance->extraData;
	v2 = mv->validUnits[0];
	validUnits = mv->validUnits;
	if (v2)
	{
		while (instance->currentStreamUnitID != v2)
		{
			v2 = validUnits[1];
			++validUnits;
			if (!v2)
				return 0;
		}
	}
	mv->lastValidPos = instance->position;
	return 1;
#else
	UNIMPLEMENTED();
	return 0;
#endif
}


// autogenerated function stub: 
// void /*$ra*/ MON_SphereWorldPos(MATRIX *mat /*$s1*/, struct _HSphere *sphere /*$a1*/, _Position *ret /*$s0*/)
void MON_SphereWorldPos(MATRIX *mat, struct _HSphere *sphere, _Position *ret)
{ // line 2936, offset 0x800833b4
#if defined(PC_VERSION)
	ApplyMatrixSV(mat, (SVECTOR*)&sphere->position, (SVECTOR*)ret);
	ret->x += mat->t[0];
	ret->y += mat->t[1];
	ret->z += mat->t[2];
#else
	UNIMPLEMENTED();
#endif
}


// autogenerated function stub: 
// struct _HPrim * /*$ra*/ MON_FindSphereForTerrain(struct _Instance *instance /*$a0*/)
struct _HPrim * MON_FindSphereForTerrain(struct _Instance *instance)
{ // line 2945, offset 0x80083424
#if defined(PC_VERSION)
	struct _HPrim* usePrim; // eax
	struct _HModel* hmodel; // ecx
	int radius; // edi
	int currentModel; // edx
	int numHPrims; // esi
	struct _HPrim* curPrim; // edx
	int i; // ebp

	usePrim = 0;
	hmodel = instance->hModelList;
	radius = 0;
	if (hmodel)
	{
		currentModel = instance->currentModel;
		numHPrims = hmodel[currentModel].numHPrims;
		curPrim = hmodel[currentModel].hPrimList;
		if (numHPrims)
		{
			i = numHPrims;
			do
			{
				if ((curPrim->withFlags & 2) != 0 && curPrim->type == 1 && curPrim->data.hsphere->radius > radius)
				{
					usePrim = curPrim;
					radius = curPrim->data.hsphere->radius;
				}
				++curPrim;
				--i;
			} while (i);
		}
	}
	return usePrim;
#else
	UNIMPLEMENTED();
	return NULL;
#endif
}


// autogenerated function stub: 
// struct Intro * /*$ra*/ MON_FindNearestImpalingIntro(int unitID /*$a0*/, _Position *position /*$s4*/)
struct Intro * MON_FindNearestImpalingIntro(int unitID, _Position *position)
{ // line 2979, offset 0x800834b0
	/* begin block 1 */
		// Start line: 2980
		// Start offset: 0x800834B0
		// Variables:
			struct Intro *current; // $v1
			struct Intro *res; // $s2
			struct Level *level; // $v0
			int min_dist; // $s3
			int dist; // $v1
			int i; // $s1
	/* end block 1 */
	// End offset: 0x800835BC
	// End Line: 3023

	/* begin block 2 */
		// Start line: 6271
	/* end block 2 */
	// End Line: 6272
			UNIMPLEMENTED();
	return null;
}


// autogenerated function stub: 
// struct Intro * /*$ra*/ MON_TestForTerrainImpale(struct _Instance *instance /*$s0*/, struct _Terrain *terrain /*$s1*/)
struct Intro * MON_TestForTerrainImpale(struct _Instance *instance, struct _Terrain *terrain)
{ // line 3027, offset 0x800835e0
	/* begin block 1 */
		// Start line: 3028
		// Start offset: 0x800835E0
		// Variables:
			struct _MonsterVars *mv; // $v0
			struct Intro *current; // $s1
			struct _HPrim *prim; // $v1
			struct _HSphere *sphere; // $a1
			int i; // $s2
			int radius; // $s3
			_Position spherePos; // stack offset -32
	/* end block 1 */
	// End offset: 0x800836C0
	// End Line: 3070

	/* begin block 2 */
		// Start line: 6385
	/* end block 2 */
	// End Line: 6386
			UNIMPLEMENTED();
	return null;
}


// autogenerated function stub: 
// void /*$ra*/ MON_MoveInstanceToImpalePoint(struct _Instance *instance /*$s0*/)
void MON_MoveInstanceToImpalePoint(struct _Instance *instance)
{ // line 3072, offset 0x800836dc
	/* begin block 1 */
		// Start line: 3073
		// Start offset: 0x800836DC
		// Variables:
			struct _MonsterVars *mv; // $v1
			struct Intro *impaler; // $t3
			_Position offset; // stack offset -16

		/* begin block 1.1 */
			// Start line: 3097
			// Start offset: 0x80083718
			// Variables:
				short _x0; // $v0
				short _y0; // $v1
				short _z0; // $a2
				short _y1; // $t0
				//short _z1; // $t2
				_Position *_v; // $a3
				//_Position *_v1; // $a1
		/* end block 1.1 */
		// End offset: 0x80083718
		// End Line: 3097

		/* begin block 1.2 */
			// Start line: 3097
			// Start offset: 0x80083718
			// Variables:
				short _x1; // $v1
				//short _y1; // $a2
				//short _z1; // $a3
				struct _Rotation *_v0; // $v0
				//struct _Rotation *_v1; // $v0
		/* end block 1.2 */
		// End offset: 0x80083718
		// End Line: 3097
	/* end block 1 */
	// End offset: 0x800837B0
	// End Line: 3107

	/* begin block 2 */
		// Start line: 6491
	/* end block 2 */
	// End Line: 6492
				UNIMPLEMENTED();
}


// autogenerated function stub: 
// int /*$ra*/ MON_ReachableIntro(struct _Instance *instance /*stack 0*/, _Position *pos /*$fp*/, _Position *introPos /*$s7*/, struct _Rotation *introRot /*stack 12*/, int checkOrientation /*stack 16*/)
int MON_ReachableIntro(struct _Instance *instance, _Position *pos, _Position *introPos, struct _Rotation *introRot, int checkOrientation)
{ // line 3121, offset 0x800837c0
	/* begin block 1 */
		// Start line: 3122
		// Start offset: 0x800837C0
		// Variables:
			struct _MonsterVars *mv; // $s2
			int angle; // $s5
			int angle2; // $s6
			int angle3; // $v1
			int flightAngle; // $v0
			int length; // $v0
			int length2; // $s4
			int newFVel; // $s0
			int newZVel; // $s1
			int zDiff; // $s1
			int zAccl; // $s3
			int tempFVel; // $v1
			int maxForwardVel; // $s1
			int res; // $s3
	/* end block 1 */
	// End offset: 0x80083B7C
	// End Line: 3241

	/* begin block 2 */
		// Start line: 6605
	/* end block 2 */
	// End Line: 6606

			UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ MON_SetVelocityTowardsImpalingObject(struct _Instance *instance /*$s3*/, int checkOrientation /*$s4*/)
int MON_SetVelocityTowardsImpalingObject(struct _Instance *instance, int checkOrientation)
{ // line 3244, offset 0x80083bac
	/* begin block 1 */
		// Start line: 3245
		// Start offset: 0x80083BAC
		// Variables:
			struct Level *level; // $s0
			struct Intro *currentI; // $s1
			struct _HPrim *usePrim; // $v0
			int i; // $s2
			_Position spherePos; // stack offset -32

		/* begin block 1.1 */
			// Start line: 3259
			// Start offset: 0x80083C04
			// Variables:
				struct _Instance *target; // $s0

			/* begin block 1.1.1 */
				// Start line: 3284
				// Start offset: 0x80083CA4
				// Variables:
					struct PhysObProperties *prop; // $v1

				/* begin block 1.1.1.1 */
					// Start line: 3287
					// Start offset: 0x80083CBC
				/* end block 1.1.1.1 */
				// End offset: 0x80083CEC
				// End Line: 3296
			/* end block 1.1.1 */
			// End offset: 0x80083CEC
			// End Line: 3297
		/* end block 1.1 */
		// End offset: 0x80083CFC
		// End Line: 3299
	/* end block 1 */
	// End offset: 0x80083D00
	// End Line: 3303

	/* begin block 2 */
		// Start line: 6905
	/* end block 2 */
	// End Line: 6906
					UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// void /*$ra*/ MON_TurnOffSphereCollisions(struct _Instance *instance /*$a0*/)
void MON_TurnOffSphereCollisions(struct _Instance *instance)
{ // line 3312, offset 0x80083d20
	/* begin block 1 */
		// Start line: 3314
		// Start offset: 0x80083D20
		// Variables:
			int i; // $a0
			struct _HPrim *hprim; // $v1
			struct _HModel *hmodel; // $v1
	/* end block 1 */
	// End offset: 0x80083D74
	// End Line: 3330

	/* begin block 2 */
		// Start line: 7064
	/* end block 2 */
	// End Line: 7065

	/* begin block 3 */
		// Start line: 7065
	/* end block 3 */
	// End Line: 7066

	/* begin block 4 */
		// Start line: 7067
	/* end block 4 */
	// End Line: 7068
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MON_TurnOnSphereCollisions(struct _Instance *instance /*$a0*/)
void MON_TurnOnSphereCollisions(struct _Instance *instance)
{ // line 3332, offset 0x80083d7c
	/* begin block 1 */
		// Start line: 3334
		// Start offset: 0x80083D7C
		// Variables:
			int i; // $a0
			struct _HPrim *hprim; // $v1
			struct _HModel *hmodel; // $v1
	/* end block 1 */
	// End offset: 0x80083DD0
	// End Line: 3350

	/* begin block 2 */
		// Start line: 7106
	/* end block 2 */
	// End Line: 7107

	/* begin block 3 */
		// Start line: 7107
	/* end block 3 */
	// End Line: 7108

	/* begin block 4 */
		// Start line: 7109
	/* end block 4 */
	// End Line: 7110
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MON_ProcessSpecialFade(struct _Instance *instance /*$s0*/)
void MON_ProcessSpecialFade(struct _Instance *instance)
{ // line 3352, offset 0x80083dd8
	/* begin block 1 */
		// Start line: 3353
		// Start offset: 0x80083DD8
		// Variables:
			struct _MonsterVars *mv; // $a0
			int currentFadeValue; // $a1
			int targetFadeValue; // $v1
			int fadeRate; // $a3
			struct _Instance *child; // $v1
	/* end block 1 */
	// End offset: 0x80084004
	// End Line: 3447

	/* begin block 2 */
		// Start line: 7148
	/* end block 2 */
	// End Line: 7149
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MON_StartSpecialFade(struct _Instance *instance /*$a0*/, int fadeLevel /*$a1*/, int fadeTime /*$a2*/)
void MON_StartSpecialFade(struct _Instance *instance, int fadeLevel, int fadeTime)
{ // line 3449, offset 0x80084014
	/* begin block 1 */
		// Start line: 3451
		// Start offset: 0x80084014
		// Variables:
			struct _MonsterVars *mv; // $a3
			int diff; // $a1
	/* end block 1 */
	// End offset: 0x80084074
	// End Line: 3464

	/* begin block 2 */
		// Start line: 7351
	/* end block 2 */
	// End Line: 7352

	/* begin block 3 */
		// Start line: 7352
	/* end block 3 */
	// End Line: 7353
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MON_UnlinkFromRaziel(struct _Instance *instance /*$s0*/)
void MON_UnlinkFromRaziel(struct _Instance *instance)
{ // line 3466, offset 0x8008407c
	/* begin block 1 */
		// Start line: 3467
		// Start offset: 0x8008407C
		// Variables:
			struct _MonsterVars *mv; // $v0
			struct evPositionData *data; // $v1
			struct _Instance *enemy; // $s1
	/* end block 1 */
	// End offset: 0x800840F8
	// End Line: 3485

	/* begin block 2 */
		// Start line: 7386
	/* end block 2 */
	// End Line: 7387
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MON_BurnInAir(struct _Instance *instance /*$s1*/, int currentState /*$s2*/)
void MON_BurnInAir(struct _Instance *instance, int currentState)
{ // line 3491, offset 0x8008411c
	/* begin block 1 */
		// Start line: 3492
		// Start offset: 0x8008411C
		// Variables:
			struct _MonsterVars *mv; // $s0
	/* end block 1 */
	// End offset: 0x8008419C
	// End Line: 3502

	/* begin block 2 */
		// Start line: 7436
	/* end block 2 */
	// End Line: 7437
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MON_BirthMana(struct _Instance *instance /*$s0*/)
void MON_BirthMana(struct _Instance *instance)
{ // line 3508, offset 0x800841d8
	/* begin block 1 */
		// Start line: 3509
		// Start offset: 0x800841D8

		/* begin block 1.1 */
			// Start line: 3512
			// Start offset: 0x800841F8
			// Variables:
				struct _MonsterVars *mv; // $v0

			/* begin block 1.1.1 */
				// Start line: 3516
				// Start offset: 0x80084214
				// Variables:
					int type; // $a0
					MATRIX *mat; // $a3
			/* end block 1.1.1 */
			// End offset: 0x80084280
			// End Line: 3519
		/* end block 1.1 */
		// End offset: 0x80084280
		// End Line: 3520
	/* end block 1 */
	// End offset: 0x80084280
	// End Line: 3521

	/* begin block 2 */
		// Start line: 7472
	/* end block 2 */
	// End Line: 7473
					UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MON_SoulSucked(struct _Instance *instance /*$s1*/)
void MON_SoulSucked(struct _Instance *instance)
{ // line 3523, offset 0x80084290
	/* begin block 1 */
		// Start line: 3524
		// Start offset: 0x80084290
		// Variables:
			struct _MonsterVars *mv; // $s0
	/* end block 1 */
	// End offset: 0x800842F4
	// End Line: 3535

	/* begin block 2 */
		// Start line: 7505
	/* end block 2 */
	// End Line: 7506
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// int /*$ra*/ MON_SetUpKnockBack(struct _Instance *instance /*$s2*/, struct _Instance *enemy /*$s1*/, struct evMonsterHitData *data /*$a2*/)
int MON_SetUpKnockBack(struct _Instance *instance, struct _Instance *enemy, struct evMonsterHitData *data)
{ // line 3540, offset 0x80084308
	/* begin block 1 */
		// Start line: 3541
		// Start offset: 0x80084308
		// Variables:
			struct _MonsterVars *mv; // $s5
			long d; // $s0
			long t; // $s4
			long a; // $s3
			long v; // $s0
			int front; // $s0
	/* end block 1 */
	// End offset: 0x800843CC
	// End Line: 3570

	/* begin block 2 */
		// Start line: 7539
	/* end block 2 */
	// End Line: 7540
			UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// void /*$ra*/ MON_DoDrainEffects(struct _Instance *instance /*$s1*/, struct _Instance *ei /*$s0*/)
void MON_DoDrainEffects(struct _Instance *instance, struct _Instance *ei)
{ // line 3575, offset 0x8008440c
	/* begin block 1 */
		// Start line: 3576
		// Start offset: 0x8008440C
		// Variables:
			struct _MonsterAttributes *ma; // $s3
			struct _MonsterVars *mv; // $s2
			MATRIX *mat; // $t2
			struct _SVector location; // stack offset -56
			struct _SVector position; // stack offset -48
			struct _SVector vel; // stack offset -40
			struct _SVector accel; // stack offset -32
	/* end block 1 */
	// End offset: 0x8008467C
	// End Line: 3621

	/* begin block 2 */
		// Start line: 7610
	/* end block 2 */
	// End Line: 7611
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MON_SetFXHitData(struct _Instance *instance /*$a0*/, struct evFXHitData *data /*$a1*/, int type /*$a2*/, int amount /*$a3*/)
void MON_SetFXHitData(struct _Instance *instance, struct evFXHitData *data, int type, int amount)
{ // line 3623, offset 0x80084698
	/* begin block 1 */
		// Start line: 3625
		// Start offset: 0x80084698

		/* begin block 1.1 */
			// Start line: 3629
			// Start offset: 0x800846B0
			// Variables:
				MATRIX *mat; // $v0
		/* end block 1.1 */
		// End offset: 0x800846B0
		// End Line: 3629
	/* end block 1 */
	// End offset: 0x80084714
	// End Line: 3640

	/* begin block 2 */
		// Start line: 7778
	/* end block 2 */
	// End Line: 7779

	/* begin block 3 */
		// Start line: 7779
	/* end block 3 */
	// End Line: 7780
				UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MON_LaunchMonster(struct _Instance *instance /*$s0*/, int zDirection /*$s1*/, int power /*$s2*/, int loft /*$s3*/)
void MON_LaunchMonster(struct _Instance *instance, int zDirection, int power, int loft)
{ // line 3645, offset 0x80084724
	/* begin block 1 */
		// Start line: 7822
	/* end block 1 */
	// End Line: 7823
	UNIMPLEMENTED();
}




