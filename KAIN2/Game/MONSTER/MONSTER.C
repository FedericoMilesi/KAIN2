#include "Game/CORE.H"
#include "MONSTER.H"
#include <Game/SOUND.H>
#include <Game/PLAN/ENMYPLAN.H>
#include <Game/G2/ANMCTRLR.H>
#include <Game/SAVEINFO.H>
#include <Game/STREAM.H>
#include <Game/MATH3D.H>
#include <Game/CAMERA.H>
#include <Game/STATE.H>
#include <Game/G2/ANMG2ILF.H>
#include <Game/FX.H>

void MON_DoCombatTimers(struct _Instance* instance) // Matching - 99.14%
{
	struct _MonsterVars* mv;
	unsigned long curtime;

	mv = (struct _MonsterVars*)instance->extraData;

	curtime = MON_GetTime(instance);

	if ((mv->mvFlags & 0x10))
	{
		if (mv->damageTimer < curtime)
		{
			mv->mvFlags &= ~0x10;
			mv->mvFlags &= ~0x800000;
		}
	}
	else if ((!(mv->mvFlags & 0x2000)) && (mv->hitPoints < mv->maxHitPoints))
	{
		struct _MonsterCombatAttributes* combat;

		combat = mv->subAttr->combatAttributes;

		mv->hitPoints += (short)((combat->recovery * gameTrackerX.timeMult) / 4096);

		if (mv->maxHitPoints < mv->hitPoints)
		{
			mv->hitPoints = mv->maxHitPoints;
		}

		MONSTER_VertexBlood(instance, mv->mainColorVertex, MONSTER_CalcDamageIntensity(mv->hitPoints, mv->maxHitPoints));
	}

	if (((mv->mvFlags & 0x100)) && (mv->stunTimer < curtime))
	{
		mv->mvFlags &= ~0x100;
	}

	if ((curtime % 1000) < ((curtime - gameTrackerX.lastLoopTime) % 1000))
	{
		mv->chance = (rand() % 100);
	}
}


// autogenerated function stub: 
// void /*$ra*/ MON_ChangeHumanOpinion(struct _Instance *instance /*$a0*/)
void MON_ChangeHumanOpinion(struct _Instance *instance)
{ // line 147, offset 0x800873e4
	/* begin block 1 */
		// Start line: 148
		// Start offset: 0x800873E4
		// Variables:
			int good; // $v0

		/* begin block 1.1 */
			// Start line: 172
			// Start offset: 0x80087404
			// Variables:
				int opinion; // $s0
		/* end block 1.1 */
		// End offset: 0x8008747C
		// End Line: 188
	/* end block 1 */
	// End offset: 0x8008747C
	// End Line: 189

	/* begin block 2 */
		// Start line: 298
	/* end block 2 */
	// End Line: 299
				UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MON_CutOut_Monster(struct _Instance *instance /*$s2*/, int fade_amount /*$t4*/, int startseg /*$a2*/, int endseg /*$a3*/)
void MON_CutOut_Monster(struct _Instance *instance, int fade_amount, int startseg, int endseg)
{ // line 192, offset 0x8008748c
	UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MON_DeadEntry(struct _Instance *instance /*$s1*/)
void MON_DeadEntry(struct _Instance *instance)
{ // line 249, offset 0x800876e0
	UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MON_Dead(struct _Instance *instance /*$s2*/)
void MON_Dead(struct _Instance *instance)
{ // line 280, offset 0x800877d0
	/* begin block 1 */
		// Start line: 281
		// Start offset: 0x800877D0
		// Variables:
			struct _MonsterVars *mv; // $s1
			struct _Instance *soul; // $s5
			struct __Event *message; // $v0
			int reanimate; // $s6

		/* begin block 1.1 */
			// Start line: 304
			// Start offset: 0x8008787C
			// Variables:
				struct _MonsterAttributes *ma; // $s0
				int fade_amount; // $a1
		/* end block 1.1 */
		// End offset: 0x800878B0
		// End Line: 316

		/* begin block 1.2 */
			// Start line: 336
			// Start offset: 0x80087930
			// Variables:
				struct _Model *model; // $s0
				int i; // $s0
				CVECTOR *ptr; // $v0
		/* end block 1.2 */
		// End offset: 0x80087980
		// End Line: 344

		/* begin block 1.3 */
			// Start line: 347
			// Start offset: 0x800879A8
			// Variables:
				struct _Instance *imp; // $s0
				struct _Instance *closest; // $s3

			/* begin block 1.3.1 */
				// Start line: 351
				// Start offset: 0x800879C8
				// Variables:
					long closestdist; // $s4

				/* begin block 1.3.1.1 */
					// Start line: 360
					// Start offset: 0x80087A3C
					// Variables:
						long dist; // $v1
				/* end block 1.3.1.1 */
				// End offset: 0x80087A7C
				// End Line: 367
			/* end block 1.3.1 */
			// End offset: 0x80087A8C
			// End Line: 370
		/* end block 1.3 */
		// End offset: 0x80087B18
		// End Line: 383

		/* begin block 1.4 */
			// Start line: 402
			// Start offset: 0x80087B98
			// Variables:
				SVECTOR New; // stack offset -96
				SVECTOR Old; // stack offset -88
				//struct _PCollideInfo pcinfo; // stack offset -80
		/* end block 1.4 */
		// End offset: 0x80087C20
		// End Line: 421

		/* begin block 1.5 */
			// Start line: 448
			// Start offset: 0x80087D20
			// Variables:
				//struct _MonsterAttributes *ma; // $a0
		/* end block 1.5 */
		// End offset: 0x80087E30
		// End Line: 482
	/* end block 1 */
	// End offset: 0x80087EDC
	// End Line: 522

	/* begin block 2 */
		// Start line: 587
	/* end block 2 */
	// End Line: 588
				UNIMPLEMENTED();
}


void MON_MissileHitEntry(struct _Instance *instance) // Matching - 100%
{
	struct _MonsterVars* mv;

    mv = (struct _MonsterVars*) instance->extraData;
    instance->xAccl = 0;
    instance->yAccl = 0;
    instance->xVel = 0;
    instance->yVel = 0;
    MON_PlayAnim(instance, MONSTER_ANIM_MISSILEIMPALEDEATH, 1);
    mv->mvFlags |= 0x200000;
    mv->mvFlags &= ~0x10;
    MON_TurnOffAllSpheres(instance);
    mv->causeOfDeath = 0;
    MON_DropAllObjects(instance);
    mv->heldID = mv->held->introUniqueID;
    INSTANCE_Post(mv->held, 0x800002, SetObjectData(0, 0, 0, instance, 3));
    SOUND_Play3dSound(&instance->position, 39, -100, 100, 16000);
}


// autogenerated function stub: 
// void /*$ra*/ MON_MissileHit(struct _Instance *instance /*$s1*/)
void MON_MissileHit(struct _Instance *instance)
{ // line 551, offset 0x80087fd0
	UNIMPLEMENTED();
}

void MON_BirthEntry(struct _Instance* instance)
{
}

void MON_Birth(struct _Instance* instance)  // Matching - 100%
{
	MON_SwitchState(instance, MONSTER_STATE_IDLE);
}

void MON_ParryEntry(struct _Instance* instance)  // Matching - 100%
{
	struct _MonsterVars* mv;

	mv = (struct _MonsterVars*)instance->extraData;

	MON_PlayAnim(instance, MONSTER_ANIM_JUMPRIGHT, 1);

	do
	{

	} while (FALSE);  // garbage code for reordering

	MON_TurnToPosition(instance, &mv->enemy->instance->position, 4096);
}

void MON_Parry(struct _Instance* instance)  // Matching - 100%
{
	if ((instance->flags2 & 0x10))
	{
		MON_SwitchState(instance, MONSTER_STATE_COMBAT);
	}

	MON_DefaultQueueHandler(instance);
}


// autogenerated function stub: 
// void /*$ra*/ MON_LandOnFeetEntry(struct _Instance *instance /*$s0*/)
void MON_LandOnFeetEntry(struct _Instance *instance)
{ // line 628, offset 0x8008816c
	/* begin block 1 */
		// Start line: 629
		// Start offset: 0x8008816C
		// Variables:
			struct _MonsterVars *mv; // $v0

		/* begin block 1.1 */
			// Start line: 646
			// Start offset: 0x800881E0
			// Variables:
				int damage; // $a1
		/* end block 1.1 */
		// End offset: 0x80088204
		// End Line: 656
	/* end block 1 */
	// End offset: 0x80088204
	// End Line: 657

	/* begin block 2 */
		// Start line: 1380
	/* end block 2 */
	// End Line: 1381
				UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MON_LandOnFeet(struct _Instance *instance /*$s1*/)
void MON_LandOnFeet(struct _Instance *instance)
{ // line 661, offset 0x80088230
	/* begin block 1 */
		// Start line: 662
		// Start offset: 0x80088230
		// Variables:
			struct _MonsterVars *mv; // $s0

		/* begin block 1.1 */
			// Start line: 680
			// Start offset: 0x80088298
			// Variables:
				int state; // $a1
		/* end block 1.1 */
		// End offset: 0x80088348
		// End Line: 711
	/* end block 1 */
	// End offset: 0x800883A8
	// End Line: 725

	/* begin block 2 */
		// Start line: 1447
	/* end block 2 */
	// End Line: 1448
				UNIMPLEMENTED();
}

void MON_LandInWaterEntry(struct _Instance *instance)  // Matching - 100%
{
	instance->checkMask &= 0xFFFFFFDF;
}

void MON_LandInWater(struct _Instance* instance)  // Matching - 100%
{
	MON_SwitchState(instance, MONSTER_STATE_FALL);
}


// autogenerated function stub: 
// void /*$ra*/ MON_BreakHoldEntry(struct _Instance *instance /*$s1*/)
void MON_BreakHoldEntry(struct _Instance *instance)
{ // line 743, offset 0x800883f0
	/* begin block 1 */
		// Start line: 744
		// Start offset: 0x800883F0
		// Variables:
			struct _MonsterVars *mv; // $s0
	/* end block 1 */
	// End offset: 0x80088448
	// End Line: 753

	/* begin block 2 */
		// Start line: 1611
	/* end block 2 */
	// End Line: 1612
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MON_BreakHold(struct _Instance *instance /*$s1*/)
void MON_BreakHold(struct _Instance *instance)
{ // line 755, offset 0x8008845c
	/* begin block 1 */
		// Start line: 756
		// Start offset: 0x8008845C

		/* begin block 1.1 */
			// Start line: 763
			// Start offset: 0x8008849C
			// Variables:
				struct _MonsterVars *mv; // $s3
				struct __Event *message; // $a1

			/* begin block 1.1.1 */
				// Start line: 773
				// Start offset: 0x80088524
				// Variables:
					struct evMonsterThrownData *data; // $s0
			/* end block 1.1.1 */
			// End offset: 0x80088524
			// End Line: 773

			/* begin block 1.1.2 */
				// Start line: 780
				// Start offset: 0x8008854C
				// Variables:
					//struct evMonsterHitTerrainData *data; // $v0
			/* end block 1.1.2 */
			// End offset: 0x80088568
			// End Line: 782
		/* end block 1.1 */
		// End offset: 0x800885F4
		// End Line: 808
	/* end block 1 */
	// End offset: 0x8008861C
	// End Line: 814

	/* begin block 2 */
		// Start line: 1638
	/* end block 2 */
	// End Line: 1639
					UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MON_ImpactEntry(struct _Instance *instance /*$s0*/)
void MON_ImpactEntry(struct _Instance *instance)
{ // line 819, offset 0x80088638
	/* begin block 1 */
		// Start line: 820
		// Start offset: 0x80088638
		// Variables:
			struct _MonsterVars *mv; // $s1
			struct _MonsterCombatAttributes *combat; // $s2
			//struct evFXHitData data; // stack offset -40
	/* end block 1 */
	// End offset: 0x800886F4
	// End Line: 842

	/* begin block 2 */
		// Start line: 1768
	/* end block 2 */
	// End Line: 1769
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MON_Impact(struct _Instance *instance /*$s0*/)
void MON_Impact(struct _Instance *instance)
{ // line 845, offset 0x8008871c
	/* begin block 1 */
		// Start line: 846
		// Start offset: 0x8008871C
		// Variables:
			struct _MonsterVars *mv; // $s1
	/* end block 1 */
	// End offset: 0x80088788
	// End Line: 866

	/* begin block 2 */
		// Start line: 1830
	/* end block 2 */
	// End Line: 1831
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MON_FallEntry(struct _Instance *instance /*$s0*/)
void MON_FallEntry(struct _Instance *instance)
{ // line 871, offset 0x8008879c
	/* begin block 1 */
		// Start line: 872
		// Start offset: 0x8008879C
		// Variables:
			struct _MonsterVars *mv; // $s1
	/* end block 1 */
	// End offset: 0x80088820
	// End Line: 893

	/* begin block 2 */
		// Start line: 1884
	/* end block 2 */
	// End Line: 1885
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MON_Fall(struct _Instance *instance /*$s1*/)
void MON_Fall(struct _Instance *instance)
{ // line 901, offset 0x8008885c
	/* begin block 1 */
		// Start line: 902
		// Start offset: 0x8008885C
		// Variables:
			struct _MonsterVars *mv; // $s3
			struct __Event *message; // $a1
			int state; // $s2

		/* begin block 1.1 */
			// Start line: 929
			// Start offset: 0x80088910
			// Variables:
				int x; // $s0
				int y; // $v0
		/* end block 1.1 */
		// End offset: 0x80088944
		// End Line: 934
	/* end block 1 */
	// End offset: 0x800889BC
	// End Line: 963

	/* begin block 2 */
		// Start line: 1944
	/* end block 2 */
	// End Line: 1945
				UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MON_ThrownEntry(struct _Instance *instance /*$s0*/)
void MON_ThrownEntry(struct _Instance *instance)
{ // line 968, offset 0x800889d8
	/* begin block 1 */
		// Start line: 969
		// Start offset: 0x800889D8
		// Variables:
			struct _MonsterVars *mv; // $s1
	/* end block 1 */
	// End offset: 0x80088A40
	// End Line: 985

	/* begin block 2 */
		// Start line: 2081
	/* end block 2 */
	// End Line: 2082
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MON_Thrown(struct _Instance *instance /*$s0*/)
void MON_Thrown(struct _Instance *instance)
{ // line 989, offset 0x80088a74
	/* begin block 1 */
		// Start line: 990
		// Start offset: 0x80088A74
		// Variables:
			struct _MonsterVars *mv; // $s1
			struct Intro *impaler; // $v0

		/* begin block 1.1 */
			// Start line: 996
			// Start offset: 0x80088AA4
		/* end block 1.1 */
		// End offset: 0x80088AE4
		// End Line: 1006

		/* begin block 1.2 */
			// Start line: 1012
			// Start offset: 0x80088B00
			// Variables:
				struct __Event *message; // $a1

			/* begin block 1.2.1 */
				// Start line: 1024
				// Start offset: 0x80088B40
				// Variables:
					struct evMonsterHitTerrainData *data; // $v0
			/* end block 1.2.1 */
			// End offset: 0x80088B40
			// End Line: 1024
		/* end block 1.2 */
		// End offset: 0x80088BB8
		// End Line: 1049
	/* end block 1 */
	// End offset: 0x80088BB8
	// End Line: 1050

	/* begin block 2 */
		// Start line: 2126
	/* end block 2 */
	// End Line: 2127
					UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MON_ImpaleDeathEntry(struct _Instance *instance /*$s0*/)
void MON_ImpaleDeathEntry(struct _Instance *instance)
{ // line 1055, offset 0x80088bcc
	/* begin block 1 */
		// Start line: 1056
		// Start offset: 0x80088BCC
		// Variables:
			struct _MonsterVars *mv; // $s1
	/* end block 1 */
	// End offset: 0x80088BCC
	// End Line: 1056

	/* begin block 2 */
		// Start line: 2262
	/* end block 2 */
	// End Line: 2263
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MON_ImpaleDeath(struct _Instance *instance /*$s1*/)
void MON_ImpaleDeath(struct _Instance *instance)
{ // line 1073, offset 0x80088c4c
	/* begin block 1 */
		// Start line: 1074
		// Start offset: 0x80088C4C
		// Variables:
			struct _MonsterVars *mv; // $s0
			struct _MonsterAttributes *ma; // $s2
			struct __Event *message; // $v0

		/* begin block 1.1 */
			// Start line: 1081
			// Start offset: 0x80088C80
			// Variables:
				int thisFrame; // $s3
				int lastFrame; // $a0
		/* end block 1.1 */
		// End offset: 0x80088CF4
		// End Line: 1092
	/* end block 1 */
	// End offset: 0x80088E38
	// End Line: 1127

	/* begin block 2 */
		// Start line: 2310
	/* end block 2 */
	// End Line: 2311
				UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MON_TerrainImpaleDeathEntry(struct _Instance *instance /*$s1*/)
void MON_TerrainImpaleDeathEntry(struct _Instance *instance)
{ // line 1132, offset 0x80088e54
	/* begin block 1 */
		// Start line: 1133
		// Start offset: 0x80088E54
		// Variables:
			struct _MonsterVars *mv; // $s2
			struct _MonsterAttributes *ma; // $s0
			struct Intro *impaler; // $s0
	/* end block 1 */
	// End offset: 0x80088F8C
	// End Line: 1173

	/* begin block 2 */
		// Start line: 2434
	/* end block 2 */
	// End Line: 2435
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MON_TerrainImpaleDeath(struct _Instance *instance /*$s3*/)
void MON_TerrainImpaleDeath(struct _Instance *instance)
{ // line 1176, offset 0x80088fa8
	/* begin block 1 */
		// Start line: 1177
		// Start offset: 0x80088FA8
		// Variables:
			struct _MonsterVars *mv; // $s2
			struct Intro *impaler; // $v1

		/* begin block 1.1 */
			// Start line: 1201
			// Start offset: 0x80089090
		/* end block 1.1 */
		// End offset: 0x800890A0
		// End Line: 1205

		/* begin block 1.2 */
			// Start line: 1212
			// Start offset: 0x800890B0
			// Variables:
				struct _MonsterAttributes *ma; // $s1
				int fade_amount; // $s0
		/* end block 1.2 */
		// End offset: 0x80089118
		// End Line: 1230
	/* end block 1 */
	// End offset: 0x80089174
	// End Line: 1242

	/* begin block 2 */
		// Start line: 2525
	/* end block 2 */
	// End Line: 2526
				UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MON_SurprisedEntry(struct _Instance *instance /*$s0*/)
void MON_SurprisedEntry(struct _Instance *instance)
{ // line 1247, offset 0x80089190
	/* begin block 1 */
		// Start line: 1248
		// Start offset: 0x80089190
		// Variables:
			struct _MonsterVars *mv; // $s1
	/* end block 1 */
	// End offset: 0x80089190
	// End Line: 1248

	/* begin block 2 */
		// Start line: 2671
	/* end block 2 */
	// End Line: 2672
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MON_Surprised(struct _Instance *instance /*$s1*/)
void MON_Surprised(struct _Instance *instance)
{ // line 1258, offset 0x800891f0
	/* begin block 1 */
		// Start line: 1259
		// Start offset: 0x800891F0
		// Variables:
			struct _MonsterVars *mv; // $s0
	/* end block 1 */
	// End offset: 0x80089298
	// End Line: 1279

	/* begin block 2 */
		// Start line: 2693
	/* end block 2 */
	// End Line: 2694
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MON_StunnedEntry(struct _Instance *instance /*$s1*/)
void MON_StunnedEntry(struct _Instance *instance)
{ // line 1285, offset 0x800892b4
	/* begin block 1 */
		// Start line: 1286
		// Start offset: 0x800892B4
		// Variables:
			struct _MonsterVars *mv; // $s0
			struct _MonsterCombatAttributes *combat; // $s2
	/* end block 1 */
	// End offset: 0x80089434
	// End Line: 1328

	/* begin block 2 */
		// Start line: 2749
	/* end block 2 */
	// End Line: 2750
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MON_Stunned(struct _Instance *instance /*$s0*/)
void MON_Stunned(struct _Instance *instance)
{ // line 1332, offset 0x80089464
	/* begin block 1 */
		// Start line: 1333
		// Start offset: 0x80089464
		// Variables:
			struct _MonsterVars *mv; // $s1
	/* end block 1 */
	// End offset: 0x80089560
	// End Line: 1363

	/* begin block 2 */
		// Start line: 2862
	/* end block 2 */
	// End Line: 2863
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MON_GrabbedEntry(struct _Instance *instance /*$s0*/)
void MON_GrabbedEntry(struct _Instance *instance)
{ // line 1368, offset 0x80089574
	/* begin block 1 */
		// Start line: 1369
		// Start offset: 0x80089574
		// Variables:
			struct _MonsterVars *mv; // $s1
	/* end block 1 */
	// End offset: 0x800895CC
	// End Line: 1385

	/* begin block 2 */
		// Start line: 2935
	/* end block 2 */
	// End Line: 2936
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MON_Grabbed(struct _Instance *instance /*$s1*/)
void MON_Grabbed(struct _Instance *instance)
{ // line 1398, offset 0x80089658
	/* begin block 1 */
		// Start line: 1399
		// Start offset: 0x80089658
		// Variables:
			struct _MonsterVars *mv; // $s2
			struct __Event *message; // $a1
			int time; // $v1

		/* begin block 1.1 */
			// Start line: 1424
			// Start offset: 0x80089754
			// Variables:
				struct evMonsterThrownData *data; // $s0
		/* end block 1.1 */
		// End offset: 0x80089754
		// End Line: 1424

		/* begin block 1.2 */
			// Start line: 1431
			// Start offset: 0x8008977C
			// Variables:
				//struct evMonsterHitTerrainData *data; // $v0
		/* end block 1.2 */
		// End offset: 0x80089798
		// End Line: 1433
	/* end block 1 */
	// End offset: 0x80089854
	// End Line: 1466

	/* begin block 2 */
		// Start line: 3000
	/* end block 2 */
	// End Line: 3001
				UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MON_HitEntry(struct _Instance *instance /*$s1*/)
void MON_HitEntry(struct _Instance *instance)
{ // line 1471, offset 0x80089870
	/* begin block 1 */
		// Start line: 1472
		// Start offset: 0x80089870
		// Variables:
			struct _MonsterVars *mv; // $s0
			struct _MonsterIR *enemy; // $a0
	/* end block 1 */
	// End offset: 0x800898DC
	// End Line: 1486

	/* begin block 2 */
		// Start line: 3154
	/* end block 2 */
	// End Line: 3155
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MON_Hit(struct _Instance *instance /*$s0*/)
void MON_Hit(struct _Instance *instance)
{ // line 1494, offset 0x80089914
	/* begin block 1 */
		// Start line: 1495
		// Start offset: 0x80089914
		// Variables:
			struct _MonsterVars *mv; // $s1
	/* end block 1 */
	// End offset: 0x800899E8
	// End Line: 1519

	/* begin block 2 */
		// Start line: 3207
	/* end block 2 */
	// End Line: 3208
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MON_AttackEntry(struct _Instance *instance /*$s0*/)
void MON_AttackEntry(struct _Instance *instance)
{ // line 1524, offset 0x800899fc
	/* begin block 1 */
		// Start line: 1525
		// Start offset: 0x800899FC
		// Variables:
			struct _MonsterVars *mv; // $s1
			struct _MonsterAttackAttributes *attack; // $s2
	/* end block 1 */
	// End offset: 0x800899FC
	// End Line: 1525

	/* begin block 2 */
		// Start line: 3267
	/* end block 2 */
	// End Line: 3268
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MON_Attack(struct _Instance *instance /*$s2*/)
void MON_Attack(struct _Instance *instance)
{ // line 1540, offset 0x80089a70
	/* begin block 1 */
		// Start line: 1541
		// Start offset: 0x80089A70
		// Variables:
			struct _MonsterVars *mv; // $s3
			struct _MonsterIR *enemy; // $s4
			struct _MonsterAttackAttributes *attack; // $s0
			struct _MonsterAnim *anim; // $s1
	/* end block 1 */
	// End offset: 0x80089C28
	// End Line: 1584

	/* begin block 2 */
		// Start line: 3299
	/* end block 2 */
	// End Line: 3300
			UNIMPLEMENTED();
}

void MON_CombatEntry(struct _Instance* instance)  // Matching - 100%
{
	struct _MonsterVars* mv;

	mv = (struct _MonsterVars*)instance->extraData;

	mv->mode = 0x2000000;
	mv->mvFlags &= 0xFFFBFFFF;
	mv->mvFlags |= 0x10000;
}


// autogenerated function stub: 
// void /*$ra*/ MON_Combat(struct _Instance *instance /*$s1*/)
void MON_Combat(struct _Instance *instance)
{ // line 1603, offset 0x80089c7c
	/* begin block 1 */
		// Start line: 1604
		// Start offset: 0x80089C7C
		// Variables:
			struct _MonsterVars *mv; // $s0
			struct _MonsterIR *enemy; // $s3

		/* begin block 1.1 */
			// Start line: 1622
			// Start offset: 0x80089D2C
			// Variables:
				struct _MonsterCombatAttributes *combat; // $s2

			/* begin block 1.1.1 */
				// Start line: 1632
				// Start offset: 0x80089D7C
				// Variables:
					int reason; // $a1

				/* begin block 1.1.1.1 */
					// Start line: 1647
					// Start offset: 0x80089DCC
					// Variables:
						int anim; // $v0
				/* end block 1.1.1.1 */
				// End offset: 0x80089DDC
				// End Line: 1651

				/* begin block 1.1.1.2 */
					// Start line: 1662
					// Start offset: 0x80089E38
				/* end block 1.1.1.2 */
				// End offset: 0x80089E54
				// End Line: 1665

				/* begin block 1.1.1.3 */
					// Start line: 1676
					// Start offset: 0x80089EA4
					// Variables:
						//int anim; // $v0
				/* end block 1.1.1.3 */
				// End offset: 0x80089EDC
				// End Line: 1687
			/* end block 1.1.1 */
			// End offset: 0x80089EDC
			// End Line: 1691

			/* begin block 1.1.2 */
				// Start line: 1695
				// Start offset: 0x80089EFC
				// Variables:
					int state; // $a1
			/* end block 1.1.2 */
			// End offset: 0x80089F40
			// End Line: 1706
		/* end block 1.1 */
		// End offset: 0x80089F40
		// End Line: 1707
	/* end block 1 */
	// End offset: 0x80089F40
	// End Line: 1709

	/* begin block 2 */
		// Start line: 3434
	/* end block 2 */
	// End Line: 3435
					UNIMPLEMENTED();
}

void MON_ProjectileEntry(struct _Instance* instance)  // Matching - 100%
{
	struct _MonsterVars* mv;
	struct _MonsterAttributes* ma;
	struct _MonsterMissile* missileDef;

	mv = (struct _MonsterVars*)instance->extraData;

	ma = (struct _MonsterAttributes*)instance->data;

	missileDef = &ma->missileList[mv->subAttr->combatAttributes->missileAttack];

	do
	{

	} while (FALSE);  // garbage code for reordering

	MON_PlayAnimFromList(instance, missileDef->animList, 0, 1);

	mv->attackState = 0;
}


// autogenerated function stub: 
// void /*$ra*/ MON_Projectile(struct _Instance *instance /*$s2*/)
void MON_Projectile(struct _Instance *instance)
{ // line 1727, offset 0x80089fbc
	/* begin block 1 */
		// Start line: 1728
		// Start offset: 0x80089FBC
		// Variables:
			struct _MonsterVars *mv; // $s1
			struct _MonsterAttributes *ma; // $v1
			struct _MonsterMissile *missileDef; // $s0
	/* end block 1 */
	// End offset: 0x8008A0E0
	// End Line: 1757

	/* begin block 2 */
		// Start line: 3686
	/* end block 2 */
	// End Line: 3687
			UNIMPLEMENTED();
}


void MON_IdleEntry(struct _Instance* instance)  // Matching - 100%
{
	struct _MonsterVars* mv;

	mv = (struct _MonsterVars*)instance->extraData;

	mv->mvFlags &= ~0x1000;
	mv->mvFlags &= 0xFFFBFFFF;
	mv->mode = 1;

	if (mv->mvFlags & 4)
	{
		struct _MonsterAttributes* ma;

		ma = (struct _MonsterAttributes*)instance->data;

		if (mv->enemy != NULL)
		{
			MON_PlayCombatIdle(instance, 2);
		}
		else
		{
			MON_PlayAnimID(instance, ma->idleList->anim, 2);
		}
	}
	else if (!(instance->anim.section[0].flags & 1))
	{
		G2Anim_SetLooping(&instance->anim);
		mv->mvFlags |= 0x4000000;
	}
}


void MON_Idle(struct _Instance* instance) // Matching - 100%
{
	struct _MonsterVars* mv;
	int combatIdle;

	mv = (struct _MonsterVars*)instance->extraData;

	combatIdle = 0;

	if (!(mv->mvFlags & 0x4))
	{
		int state;
		struct _MonsterIR* enemy;

		enemy = mv->enemy;

		state = -1;

		if (MON_ValidPosition(instance) == 0)
		{
			state = 1;
		}

		else if (enemy != NULL)
		{
			combatIdle = 1;

			if (MON_ShouldIFlee(instance) != 0)
			{
				state = 19;
			}
			else if ((enemy->mirFlags & 0x100))
			{
				state = 25;
			}
			else if (((mv->behaviorState == 7) && (enemy->distance > mv->guardRange)) || (MON_ValidUnit(instance, enemy->instance->currentStreamUnitID) == 0))
			{
				MON_TurnToPosition(instance, (struct _Position*)&enemy->instance->position.x, mv->subAttr->speedPivotTurn);
			}
			else
			{
				state = 13;
			}

			mv->lookAtPos = &enemy->instance->position;
		}
		else if (((mv->behaviorState == 2) || (mv->behaviorState == 3)) && (instance->flags2 & 2))
		{
			state = 5;
		}

		if (state != -1)
		{
			MON_SwitchState(instance, (enum MonsterState)state);
		}
	}
	else if ((mv->auxFlags & 0x10000000))
	{
		AngleMoveToward(&instance->rotation.z, mv->destination.z, (short)(mv->subAttr->speedPivotTurn * gameTrackerX.timeMult / 4096));

		if (instance->rotation.z == mv->destination.z)
		{
			mv->auxFlags &= ~0x10000000;
		}
	}

	if ((!(mv->mvFlags & 0x4)) && ((!(mv->mvFlags & 0x4000000)) || ((instance->flags2 & 0x2))))
	{
		if (combatIdle != 0)
		{
			MON_PlayCombatIdle(instance, 2);
		}
		else
		{
			MON_PlayRandomIdle(instance, 2);
		}
	}

	MON_IdleQueueHandler(instance);
}

void MON_FleeEntry(struct _Instance* instance)  // Matching - 100%
{
	struct _MonsterVars* mv;

	mv = (struct _MonsterVars*)instance->extraData;
	
	mv->mode = 4;
	
	mv->mvFlags |= 0x1000;
	mv->mvFlags &= 0xFFFEFFFF;
	mv->mvFlags &= 0xFFFDFFFF;

	MON_PlayAnim(instance, MONSTER_ANIM_RUN, 2);
}

// autogenerated function stub: 
// void /*$ra*/ MON_Flee(struct _Instance *instance /*$s1*/)
void MON_Flee(struct _Instance *instance)
{ // line 1869, offset 0x8008a448
	/* begin block 1 */
		// Start line: 1870
		// Start offset: 0x8008A448
		// Variables:
			struct _MonsterVars *mv; // $s0

		/* begin block 1.1 */
			// Start line: 1896
			// Start offset: 0x8008A530
		/* end block 1.1 */
		// End offset: 0x8008A578
		// End Line: 1903
	/* end block 1 */
	// End offset: 0x8008A578
	// End Line: 1904

	/* begin block 2 */
		// Start line: 3993
	/* end block 2 */
	// End Line: 3994
			UNIMPLEMENTED();
}


void MON_PursueEntry(struct _Instance* instance)  // Matching - 100%
{
	struct _MonsterVars* mv;

	mv = (struct _MonsterVars*)instance->extraData;

	mv->mvFlags |= 0x1000;
	mv->mvFlags &= 0xFFFEFFFF;

	if (mv->mvFlags & 4)
	{
		MON_PlayAnim(instance, MONSTER_ANIM_RUN, 2);
	}
	else
	{
		MON_GetPlanSlot(mv);
		MON_PlayCombatIdle(instance, 2);
	}

	mv->mode = 4;
	mv->mvFlags &= 0xFFFDFFFF;
}


// autogenerated function stub: 
// void /*$ra*/ MON_Pursue(struct _Instance *instance /*$s3*/)
void MON_Pursue(struct _Instance *instance)
{ // line 1930, offset 0x8008a61c
	/* begin block 1 */
		// Start line: 1931
		// Start offset: 0x8008A61C
		// Variables:
			struct _MonsterVars *mv; // $s1
			int anim; // $a1
			int planresult; // $v1
			long range; // $s6
			struct _MonsterIR *target; // $s4
			int pursueType; // $s2

		/* begin block 1.1 */
			// Start line: 1954
			// Start offset: 0x8008A674

			/* begin block 1.1.1 */
				// Start line: 1960
				// Start offset: 0x8008A6A4
			/* end block 1.1.1 */
			// End offset: 0x8008A6E0
			// End Line: 1966

			/* begin block 1.1.2 */
				// Start line: 1998
				// Start offset: 0x8008A794
				// Variables:
					struct _MonsterCombatAttributes *combat; // $a2

				/* begin block 1.1.2.1 */
					// Start line: 2002
					// Start offset: 0x8008A7B0
					// Variables:
						struct _MonsterIR *ally; // $a1
				/* end block 1.1.2.1 */
				// End offset: 0x8008A7E0
				// End Line: 2023

				/* begin block 1.1.2.2 */
					// Start line: 2060
					// Start offset: 0x8008A888
				/* end block 1.1.2.2 */
				// End offset: 0x8008A8E0
				// End Line: 2068
			/* end block 1.1.2 */
			// End offset: 0x8008A8E0
			// End Line: 2070

			/* begin block 1.1.3 */
				// Start line: 2082
				// Start offset: 0x8008A90C
				// Variables:
					int state; // $s5
			/* end block 1.1.3 */
			// End offset: 0x8008A9F8
			// End Line: 2153
		/* end block 1.1 */
		// End offset: 0x8008AA2C
		// End Line: 2170
	/* end block 1 */
	// End offset: 0x8008AA2C
	// End Line: 2171

	/* begin block 2 */
		// Start line: 4119
	/* end block 2 */
	// End Line: 4120
					UNIMPLEMENTED();
}


void MON_WanderEntry(struct _Instance* instance)  // Matching - 98.81%
{
	struct _MonsterVars* mv;

	mv = (struct _MonsterVars*)instance->extraData;

	mv->mvFlags |= 0x11000;

	if (mv->mvFlags & 4)
	{
		MON_PlayAnim(instance, MONSTER_ANIM_WALK, 2);

		mv->mvFlags &= ~0x20000;
	}
	else
	{
		MON_GetPlanSlot(mv);

		if (MON_AnimPlaying(instance, MONSTER_ANIM_WALK) == 0)
		{
			MON_PlayRandomIdle(instance, 2);
		}

		mv->mvFlags &= ~0x20000;
	}

	mv->generalTimer = MON_GetTime(instance) + 1000;
}

void MON_Wander(struct _Instance* instance) // Matching - 100%
{
	struct _MonsterVars* mv;
	int markerID;
	struct _Position* target;
	short range;
	int planresult;
	int state;

	mv = (struct _MonsterVars*)instance->extraData;
	if (mv->mvFlags & 4)
	{
		MON_TurnToPosition(instance, (struct _Position*)(&mv->destination), mv->subAttr->speedWalkTurn);
		if (MATH3D_LengthXYZ(instance->position.x - mv->destination.x, instance->position.y - mv->destination.y, instance->position.z - mv->destination.z) < 300)
		{
			MON_SwitchState(instance, MONSTER_STATE_IDLE);
		}
		MON_GroundMoveQueueHandler(instance);
	}
	else if (!(mv->mvFlags & 0x40000))
	{
		if (mv->generalTimer < MON_GetTime(instance))
		{
			MON_SwitchState(instance, MONSTER_STATE_IDLE);
		}
		else
		{
			if (mv->behaviorState == 3)
			{
				if (mv->currentMarker)
				{
					markerID = mv->currentMarker[0];
					mv->currentMarker++;
					PLANAPI_FindNodePositionInUnit(STREAM_GetStreamUnitWithID(instance->currentStreamUnitID), &mv->destination, markerID, 0);
					if (mv->currentMarker[0] == 0)
					{
						mv->currentMarker = mv->patrolMarkers;
					}
					mv->mvFlags |= 0x40000;
				}
			}
			else
			{
				range = mv->wanderRange;
				target = 0;
				if (mv->leader)
				{
					range = 800;
					target = &mv->leader->instance->position;
				}
				else
				{
					if (instance->intro)
					{
						target = &instance->intro->position;
					}
				}
				MON_GetRandomDestinationInWorld(instance, target, range);
			}
		}
		MON_GroundMoveQueueHandler(instance);
	}
	else
	{
		planresult = MON_DefaultPlanMovement(instance, 2, 100);
		state = -1;
		switch (planresult)
		{
		case 0:
		case 1:
		case 5:
		case 6:
			break;
		case 4:
			if (mv->behaviorState != 4)
			{
				if (!(rand() & 3))
				{
					mv->generalTimer = MON_GetTime(instance) + 1000;
					state = MONSTER_STATE_WANDER;
				}
				else {
					state = MONSTER_STATE_IDLE;
				}
			}
			else {
				state = MONSTER_STATE_HIDE;
			}
			break;
		case 2:
		case 3:
			state = MONSTER_STATE_IDLE;
			break;
		}
		if (state != -1)
		{
			MON_SwitchState(instance, (enum MonsterState)state);
		}
	}
	if (mv->enemy)
	{
		if (MON_ShouldIFlee(instance))
		{
			MON_SwitchState(instance, MONSTER_STATE_FLEE);
		}
		mv->lookAtPos = &mv->enemy->instance->position;
	}
}

void MON_HideEntry(struct _Instance* instance)  // Matching - 100%
{
	MON_PlayRandomIdle(instance, 1);
}

void MON_Hide(struct _Instance* instance) // Matching - 100%
{
	struct _MonsterVars* mv;
	struct _MonsterIR* enemy;

	mv = (struct _MonsterVars*)instance->extraData;
	enemy = mv->enemy;
	if (!(mv->mvFlags & 4) && enemy)
	{
		switch (mv->behaviorState)
		{
		case 4:
			MON_ChangeBehavior(instance, mv->triggeredBehavior);
			break;
		case 9:
			MON_SwitchState(instance, MONSTER_STATE_FLEE);
			break;
		case 8:
			if (!(mv->mvFlags & 0x40000000) && MON_ShouldIAmbushEnemy(instance))
			{
				if (mv->ambushJumpType == 0)
				{
					MON_TurnToPosition(instance, &enemy->instance->position, 4096);
					MON_SwitchState(instance, MONSTER_STATE_SURPRISEATTACK);
				}
				else
				{
					if (mv->ambushJumpType == 1)
					{
						MON_PlayAnim(instance, MONSTER_ANIM_EVADELEFT, 1);
					}
					else
					{
						MON_PlayAnim(instance, MONSTER_ANIM_EVADERIGHT, 1);
					}
					mv->mvFlags |= 0x40000000;
				}
			}
			break;
		default:
			MON_SwitchState(instance, MONSTER_STATE_PURSUE);
			break;
		}
	}
	if (instance->flags2 & 0x10)
	{
		if (mv->mvFlags & 0x40000000)
		{
			MON_SwitchState(instance, MONSTER_STATE_COMBAT);
		}
		else
		{
			MON_PlayRandomIdle(instance, 1);
		}
	}
	MON_DefaultQueueHandler(instance);
}

void MON_SurpriseAttackEntry(struct _Instance* instance)  // Matching - 100%
{
	struct _MonsterVars* mv;
	struct _MonsterCombatAttributes* combatAttr;
	struct _MonsterAttributes* ma;

	mv = (struct _MonsterVars*)instance->extraData;
	combatAttr = (struct _MonsterCombatAttributes*)mv->subAttr->combatAttributes;
	ma = (struct _MonsterAttributes*)instance->data;

	do
	{

	} while (FALSE);  // garbage code for reordering

	mv->attackType = &ma->attackAttributesList[combatAttr->ambushAttack];
	mv->attackState = 0;

	MON_PlayAnimFromList(instance, mv->attackType->animList, 0, 1);

	if (mv->behaviorState == 8)
	{
		if (mv->activeBehavior != -1)
		{
			mv->behaviorState = mv->activeBehavior;
		}
		else
		{
			mv->behaviorState = mv->initialBehavior;
		}
	}
}

void MON_SurpriseAttack(struct _Instance* instance)  // Matching - 100%
{
	MON_Attack(instance);
}

void MON_EnvironmentDamageEntry(struct _Instance* instance)
{
}

void MON_EnvironmentDamage(struct _Instance* instance)
{
}


void MON_MonsterGlow(struct _Instance* instance, long color, int glowtime, int glowin, int glowfade) // Matching - 100%
{
	struct _FXGlowEffect* glow;
	struct _MonsterAttributes* ma;

	ma = (struct _MonsterAttributes*)instance->data;
	if (glowtime > 0)
	{
		glowtime *= 33;
	}
	if (glowfade > 0)
	{
		glowfade *= 33;
	}
	if (glowin > 0)
	{
		glowin *= 33;
	}

	glow = FX_DoInstanceTwoSegmentGlow(instance, ma->waistSegment, ma->leftFootSegment, &color, 1, 1024, 160);
	glow->lifeTime = glowtime;
	glow->fadein_time = glowin;
	glow->fadeout_time = glowfade;

	glow = FX_DoInstanceTwoSegmentGlow(instance, ma->waistSegment, ma->rightFootSegment, &color, 1, 1024, 160);
	glow->lifeTime = glowtime;
	glow->fadein_time = glowin;
	glow->fadeout_time = glowfade;

	glow = FX_DoInstanceTwoSegmentGlow(instance, ma->leftShoulderSegment, ma->leftWeaponSegment, &color, 1, 1024, 128);
	glow->lifeTime = glowtime;
	glow->fadein_time = glowin;
	glow->fadeout_time = glowfade;

	glow = FX_DoInstanceTwoSegmentGlow(instance, ma->rightShoulderSegment, ma->rightWeaponSegment, &color, 1, 1024, 128);
	glow->lifeTime = glowtime;
	glow->fadein_time = glowin;
	glow->fadeout_time = glowfade;

	glow = FX_DoInstanceTwoSegmentGlow(instance, ma->headSegment, ma->waistSegment, &color, 1, 1024, 192);
	glow->lifeTime = glowtime;
	glow->fadein_time = glowin;
	glow->fadeout_time = glowfade;
}

void MON_GeneralDeathEntry(struct _Instance* instance) // Matching - 100%
{
	struct _MonsterVars* mv;
	struct _MonsterAttributes* ma;
	char unk = 0;

	mv = (struct _MonsterVars*)instance->extraData;
	ma = (struct _MonsterAttributes*)instance->data;
	if (instance->LinkParent)
	{
		MON_UnlinkFromRaziel(instance);

		instance->xAccl = 0;
		instance->yAccl = 0;
		instance->zAccl = -0x10;
	}
	instance->flags2 |= 0x80;
	mv->mvFlags |= 0x202000;
	mv->mvFlags &= ~0x10;
	switch (mv->damageType)
	{
	case 16:
		mv->effect = (void*)SOUND_Play3dSound(&instance->position, 35, 600, 80, 10000);
		MON_PlayAnim(instance, MONSTER_ANIM_AGONY, 2);
		mv->causeOfDeath = 3;
		mv->generalTimer = MON_GetTime(instance) + 3000;
		mv->effectTimer = MON_GetTime(instance) + 12000;
		instance->xAccl = 0;
		instance->yAccl = 0;
		instance->xVel = 0;
		instance->yVel = 0;
		break;
	case 32:
		mv->causeOfDeath = 1;
	case 64:
		if (mv && mv->mvFlags)
		{
			unk = -unk;
		}
		if (ma->whatAmI & 8)
		{
			MON_PlayAnim(instance, MONSTER_ANIM_FALLOVER, 1);
		}
		else
		{
			MON_PlayAnim(instance, MONSTER_ANIM_AGONY, 2);
		}
		if (mv->damageType == 64)
		{
			mv->causeOfDeath = 2;
		}
		mv->generalTimer = MON_GetTime(instance) + 2000;
		mv->mvFlags = mv->mvFlags | 0x400000;
		mv->effectTimer = MON_GetTime(instance) + 10000;
		MON_MonsterGlow(instance, 18784, -1, 0, 0);
		instance->xAccl = 0;
		instance->yAccl = 0;
		instance->xVel = 0;
		instance->yVel = 0;
		break;
	case 1024:
		MON_PlayAnim(instance, MONSTER_ANIM_FALLOVER, 1);
		mv->causeOfDeath = 6;
		mv->generalTimer = 0;
		instance->xAccl = 0;
		instance->yAccl = 0;
		instance->xVel = 0;
		instance->yVel = 0;
		break;
	default:
		if (mv->enemy != NULL)
		{
			if (MON_SetUpKnockBack(instance, mv->enemy->instance, (struct evMonsterHitData*)mv->messageData))
			{
				MON_PlayAnim(instance, MONSTER_ANIM_HIT1, 1);
			}
			else
			{
				MON_PlayAnim(instance, MONSTER_ANIM_HIT2, 1);
			}
		}
		else
		{
			MON_PlayAnim(instance, MONSTER_ANIM_FALLOVER, 1);
		}
		mv->generalTimer = 0;
		mv->causeOfDeath = 7;
		MON_TurnOffAllSpheres(instance);
		instance->xAccl = 0;
		instance->yAccl = 0;
		instance->xVel = 0;
		instance->yVel = 0;
		break;
	}
	MON_DropAllObjects(instance);
}

void MON_GeneralDeath(struct _Instance* instance) // Matching - 100%
{
	struct _MonsterVars* mv;
	struct __Event* message;
	int dead;

	mv = (struct _MonsterVars*)instance->extraData;
	dead = 0;
	if (instance->flags2 & 0x10 && MON_AnimPlaying(instance, MONSTER_ANIM_FALLOVER) || mv->causeOfDeath == 6)
	{
		dead = 1;
	}
	else if (instance->flags2 & 0x12 && mv->generalTimer < MON_GetTime(instance))
	{
		MON_PlayAnim(instance, MONSTER_ANIM_FALLOVER, 1);
		MON_TurnOffAllSpheres(instance);
	}
	if (dead)
	{
		mv->mvFlags &= ~0x10;
		G2Anim_SetNoLooping(&instance->anim);
		MON_SwitchState(instance, MONSTER_STATE_DEAD);
	}
	if (mv->mvFlags & 0x400)
	{
		if (MON_OnGround(instance))
		{
			mv->mvFlags |= 2;
		}
		else
		{
			mv->mvFlags &= ~2;
		}
	}
	if (!(mv->mvFlags & 2))
	{
		MON_ApplyPhysics(instance);
	}
	while (message = DeMessageQueue(&mv->messageQueue))
	{
		if (message->ID == 0x0100000B)
		{
			instance->xAccl = 0;
			instance->yAccl = 0;
			instance->zAccl = -16;
		}
	}
}

void MON_NoticeEntry(struct _Instance* instance) // Matching - 100%
{
	struct _MonsterVars* mv;

	mv = (struct _MonsterVars*)instance->extraData;
	if ((long)mv->auxFlags < 0 && mv->subAttr->allegiances->allies)
	{
		MON_PlayAnim(instance, MONSTER_ANIM_ALARM, 1);
		INSTANCE_Broadcast(instance, mv->subAttr->allegiances->allies, 0x01000011, SetMonsterAlarmData(mv->enemy->instance, &mv->enemy->instance->position, 2));
	}
	else
	{
		MON_PlayAnim(instance, MONSTER_ANIM_NOTICE, 1);
	}
}

void MON_Notice(struct _Instance* instance) // Matching - 100%
{
	struct _MonsterVars* mv;

	mv = (struct _MonsterVars*)instance->extraData;
	if (instance->flags2 & 0x10)
	{
		if (mv->behaviorState == 8)
		{
			MON_SwitchState(instance, MONSTER_STATE_HIDE);
		}
		else
		{
			MON_SwitchState(instance, MONSTER_STATE_COMBAT);
		}
	}
	if (mv->enemy)
	{
		mv->lookAtPos = &mv->enemy->instance->position;
		MON_TurnToPosition(instance, &mv->enemy->instance->position, mv->subAttr->speedPivotTurn);
	}
	MON_DefaultQueueHandler(instance);
}

void MON_PupateEntry(struct _Instance* instance) // Matching - 100%
{
	struct _MonsterVars* mv; // $s1

	mv = (struct _MonsterVars*)instance->extraData;
	instance->flags |= 0x800;
	instance->flags2 |= 0x20000000;
	mv->effectTimer = MON_GetTime(instance) + 2000 + (rand() & 4095);
}

// autogenerated function stub: 
// void /*$ra*/ MON_Pupate(struct _Instance *instance /*$s2*/)
void MON_Pupate(struct _Instance *instance)
{ // line 2632, offset 0x8008b6dc
	/* begin block 1 */
		// Start line: 2633
		// Start offset: 0x8008B6DC
		// Variables:
			struct _MonsterVars *mv; // $s3

		/* begin block 1.1 */
			// Start line: 2639
			// Start offset: 0x8008B71C
			// Variables:
				struct _MonsterAttributes *ma; // $s0
				static unsigned char pupateObjects[4]; // offset 0x0
				struct Object *cocoonOb; // $s6
				struct _Instance *cocoon; // $s1
				struct _Instance *closest; // $s4
				long closestDist; // $s5
				int burst; // $s7

			/* begin block 1.1.1 */
				// Start line: 2657
				// Start offset: 0x8008B79C
				// Variables:
					long dist; // $v1
			/* end block 1.1.1 */
			// End offset: 0x8008B89C
			// End Line: 2675
		/* end block 1.1 */
		// End offset: 0x8008B988
		// End Line: 2712
	/* end block 1 */
	// End offset: 0x8008B9F0
	// End Line: 2728

	/* begin block 2 */
		// Start line: 5586
	/* end block 2 */
	// End Line: 5587
					UNIMPLEMENTED();
}


void MON_EmbraceEntry(struct _Instance* instance) // Matching - 100%
{
	struct _MonsterVars* mv;

	mv = (struct _MonsterVars*)instance->extraData;
	MON_PlayAnim(instance, MONSTER_ANIM_SOULSUCK, 2);
	mv->generalTimer = MON_GetTime(instance) + mv->subAttr->combatAttributes->suckTime;
}

void MON_Embrace(struct _Instance* instance)  // Matching - 100%
{
	struct _MonsterVars* mv;
	struct _MonsterIR* enemy;
	struct _Instance* ei;

	mv = (struct _MonsterVars*)instance->extraData;
	enemy = mv->enemy;

	if (enemy != NULL)
	{
		if (((mv->subAttr->combatAttributes->suckRange < enemy->distance) || !(enemy->mirFlags & 0x20) || !(enemy->mirFlags & 0x1000)
			|| (mv->mvFlags & 4) || (mv->generalTimer < MON_GetTime(instance))))
		{
			MON_SwitchState(instance, MONSTER_STATE_COMBAT);
		}
		else
		{
			ei = enemy->instance;

			MON_DoDrainEffects(instance, ei);

			INSTANCE_Post(ei, 0x40006, mv->subAttr->combatAttributes->suckPower << 8);

			INSTANCE_Post(instance, 0x1000016, mv->subAttr->combatAttributes->suckPower / 8);

			MON_TurnToPosition(instance, &ei->position, mv->subAttr->speedPivotTurn);
		}
	}
	else
	{
		MON_SwitchState(instance, MONSTER_STATE_IDLE);
	}

	MON_DefaultQueueHandler(instance);

	if ((enemy != NULL) && (instance->currentMainState != 27))
	{
		enemy->mirFlags &= 0xEFFF;
	}
}

void MON_PetrifiedEntry(struct _Instance* instance)  // Matching - 100%
{
	struct _MonsterVars* mv;

	mv = (struct _MonsterVars*)instance->extraData;

	mv->generalTimer = MON_GetTime(instance) + 7000;

	mv->mvFlags |= 0x80;
}

void MON_Petrified(struct _Instance* instance) // Matching - 100%
{
	struct _MonsterVars* mv;
	struct __Event* message;
	int time;

	mv = (struct _MonsterVars*)instance->extraData;
	time = MON_GetTime(instance);
	if (mv->generalTimer < (unsigned long)time)
	{
		mv->mvFlags &= 0xffffff7f;
		instance->petrifyValue = 0;
		MON_SwitchState(instance, MONSTER_STATE_IDLE);
	}
	else if (mv->generalTimer - 1000 < (unsigned long)time)
	{
		instance->petrifyValue = (short)(4 * (mv->generalTimer - (unsigned long)time));
	}
	while (message = DeMessageQueue(&mv->messageQueue))
	{
		if (message->ID == 0x100001f || message->ID == 0x1000023 && message->Data == 0x1000)
		{
			mv->damageType = 0x400;
			MON_SwitchState(instance, MONSTER_STATE_GENERALDEATH);
		}
	}
}

int MONSTER_CalcDamageIntensity(int hp, int maxHp)  // Matching - 100%
{
	return ((maxHp - hp) * 256) / maxHp;
}


// autogenerated function stub: 
// void /*$ra*/ MONSTER_ProcessClosestVerts(struct _Instance *instance /*$fp*/, struct _SVector *location /*stack 4*/, TDRFuncPtr_MONSTER_ProcessClosestVerts2processVert_cb processVert_cb /*stack 8*/, void *cb_data /*stack 12*/)
void MONSTER_ProcessClosestVerts(struct _Instance *instance, struct _SVector *location, TDRFuncPtr_MONSTER_ProcessClosestVerts2processVert_cb processVert_cb, void *cb_data)
{ // line 2907, offset 0x8008bd5c
	UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ ProcessBloodyMess(struct _Instance *instance /*$a0*/, int vertidx /*$a1*/, int segidx /*$a2*/, int dist /*$a3*/, void *cb_data /*stack 16*/)
void ProcessBloodyMess(struct _Instance *instance, int vertidx, int segidx, int dist, void *cb_data)
{ // line 2967, offset 0x8008bf24
	UNIMPLEMENTED();
}


void MONSTER_InitVertexColors(struct _Instance* instance, struct _Model* model) // Matching - 100%
{
	int i;
	CVECTOR* ptr;

	instance->perVertexColor = (CVECTOR*)MEMPACK_Malloc(model->numVertices * 4, 33);
	ptr = instance->perVertexColor;
	for (i = model->numVertices; i != 0; i--)
	{
		*(long*)ptr = 0xFFFFFF;
		ptr++;
	}
}

int MONSTER_StartVertexBlood(struct _Instance* instance, struct _SVector* location, int amount) // Matching - 100%
{
	struct _Model* model;
	struct bloodyMessType bmt;
	struct _SVector localloc;
	struct _MVertex* vertexList;
	struct _Vector locVec;
	long flag;
	MATRIX* segMatrix;

	model = instance->object->modelList[instance->currentModel];
	if (instance->perVertexColor != NULL || (MONSTER_InitVertexColors(instance, model), instance->perVertexColor != NULL))
	{
		localloc = *location;
		bmt.closestvert = -1;
		bmt.closestdist = 0x10000;
		bmt.closestseg = -1;
		bmt.bloodiedAVert = 0;
		bmt.bloodIntensity = amount;
		MONSTER_ProcessClosestVerts(instance, (struct _SVector*)&localloc, ProcessBloodyMess, &bmt.closestvert);
		if (bmt.closestdist >= 0x33)
		{
			vertexList = model->vertexList;
			segMatrix = &instance->matrix[bmt.closestseg];
			SetRotMatrix(segMatrix);
			SetTransMatrix(segMatrix);
			RotTrans((SVECTOR*)&vertexList[bmt.closestvert].vertex, (VECTOR*)&locVec, &flag);
			bmt.bloodiedAVert = 1;
			bmt.closestdist = 0;
			localloc.x = (short)locVec.x;
			localloc.y = (short)locVec.y;
			localloc.z = (short)locVec.z;
			FX_MakeHitFX(&localloc);
			MONSTER_ProcessClosestVerts(instance, (struct _SVector*)&localloc, ProcessBloodyMess, &bmt);
		}
		else
		{
			FX_MakeHitFX(&localloc);
		}
		return bmt.closestvert;
	}
	return -1;
}

// autogenerated function stub: 
// void /*$ra*/ MONSTER_VertexBlood(struct _Instance *instance /*$s0*/, int vert /*$a1*/, int amount /*$a2*/)
void MONSTER_VertexBlood(struct _Instance *instance, int vert, int amount)
{ // line 3081, offset 0x8008c220
	/* begin block 1 */
		// Start line: 3082
		// Start offset: 0x8008C220
		// Variables:
			int i; // $v1
			struct _Model *model; // $t0

		/* begin block 1.1 */
			// Start line: 3088
			// Start offset: 0x8008C254
			// Variables:
				CVECTOR *c; // $a3

			/* begin block 1.1.1 */
				// Start line: 3097
				// Start offset: 0x8008C26C
				// Variables:
					struct _MonsterVars *mv; // $v1
					int current; // $a1
					int wanted; // $a0
					int col; // $a0
			/* end block 1.1.1 */
			// End offset: 0x8008C3DC
			// End Line: 3155
		/* end block 1.1 */
		// End offset: 0x8008C3DC
		// End Line: 3156
	/* end block 1 */
	// End offset: 0x8008C3DC
	// End Line: 3157

	/* begin block 2 */
		// Start line: 6563
	/* end block 2 */
	// End Line: 6564
					UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ ProcessBurntMess(struct _Instance *instance /*$a0*/, int vertidx /*$a1*/, int segidx /*$a2*/, int dist /*$a3*/, void *cb_data /*stack 16*/)
void ProcessBurntMess(struct _Instance *instance, int vertidx, int segidx, int dist, void *cb_data)
{ // line 3164, offset 0x8008c3ec
	/* begin block 1 */
		// Start line: 3165
		// Start offset: 0x8008C3EC
		// Variables:
			short scl; // $a2
			struct burntTuneType *burntTune; // $t0
	/* end block 1 */
	// End offset: 0x8008C450
	// End Line: 3185

	/* begin block 2 */
		// Start line: 6758
	/* end block 2 */
	// End Line: 6759
			UNIMPLEMENTED();
}


int MONSTER_StartVertexBurnt(struct _Instance* instance, struct _SVector* location, struct burntTuneType* burntTune) // Matching - 100%
{
	struct _Model* model;
	struct burntMessType bmt;
	struct _SVector localloc;
	struct _MVertex* vertexList;
	struct _Vector locVec;
	long flag;
	MATRIX* segMatrix;

	model = (struct _Model*)instance->object->modelList[instance->currentModel];
	if ((instance->perVertexColor != NULL) || (MONSTER_InitVertexColors(instance, model), instance->perVertexColor != NULL))
	{
		localloc = *location;
		bmt.closestvert = -1;
		bmt.closestdist = 0x10000;
		bmt.closestseg = -1;
		bmt.burntTune = burntTune;
		MONSTER_ProcessClosestVerts(instance, &localloc, ProcessBurntMess, &bmt);
		if ((burntTune->burntDist >> 1) < bmt.closestdist)
		{
			vertexList = model->vertexList;
			segMatrix = &instance->matrix[bmt.closestseg];
			SetRotMatrix(segMatrix);
			SetTransMatrix(segMatrix);
			RotTrans((SVECTOR*)&vertexList[bmt.closestvert].vertex, (VECTOR*)&locVec, &flag);
			localloc.x = (short)locVec.x;
			localloc.y = (short)locVec.y;
			localloc.z = (short)locVec.z;
			bmt.closestdist = 0;
			FX_MakeHitFX(&localloc);
			MONSTER_ProcessClosestVerts(instance, &localloc, ProcessBurntMess, &bmt);
		}
		else
		{
			FX_MakeHitFX(&localloc);
		}
		return bmt.closestvert;
	}
	return -1;
}

// autogenerated function stub: 
// void /*$ra*/ MONSTER_VertexBurnt(struct _Instance *instance /*$a0*/, struct burntTuneType *burntTune /*$a1*/)
void MONSTER_VertexBurnt(struct _Instance *instance, struct burntTuneType *burntTune)
{ // line 3242, offset 0x8008c618
	/* begin block 1 */
		// Start line: 3244
		// Start offset: 0x8008C618
		// Variables:
			int i; // $a3
			int fade; // $a2
			struct _Model *model; // $t0

		/* begin block 1.1 */
			// Start line: 3253
			// Start offset: 0x8008C650
			// Variables:
				CVECTOR *c; // $v1
		/* end block 1.1 */
		// End offset: 0x8008C6A4
		// End Line: 3262
	/* end block 1 */
	// End offset: 0x8008C6BC
	// End Line: 3265

	/* begin block 2 */
		// Start line: 6940
	/* end block 2 */
	// End Line: 6941

	/* begin block 3 */
		// Start line: 6941
	/* end block 3 */
	// End Line: 6942

	/* begin block 4 */
		// Start line: 6942
	/* end block 4 */
	// End Line: 6943
				UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MON_DamageEffect(struct _Instance *instance /*$s2*/, struct evFXHitData *data /*$s0*/)
void MON_DamageEffect(struct _Instance *instance, struct evFXHitData *data)
{ // line 3272, offset 0x8008c6c4
	/* begin block 1 */
		// Start line: 3273
		// Start offset: 0x8008C6C4
		// Variables:
			//struct _SVector accel; // stack offset -104
			struct _MonsterVars *mv; // $s4

		/* begin block 1.1 */
			// Start line: 3289
			// Start offset: 0x8008C720
			// Variables:
				struct _MonsterAttributes *ma; // $s3

			/* begin block 1.1.1 */
				// Start line: 3293
				// Start offset: 0x8008C740
				// Variables:
					//MATRIX *mat; // $s1
					//struct _SVector location; // stack offset -96
					//struct _SVector vel; // stack offset -88
					//struct _SVector accel; // stack offset -80
			/* end block 1.1.1 */
			// End offset: 0x8008C81C
			// End Line: 3308

			/* begin block 1.1.2 */
				// Start line: 3312
				// Start offset: 0x8008C834
				// Variables:
					//MATRIX *mat; // $s0
					//struct _SVector location; // stack offset -72
					//struct _SVector vel; // stack offset -64
			/* end block 1.1.2 */
			// End offset: 0x8008C894
			// End Line: 3321

			/* begin block 1.1.3 */
				// Start line: 3325
				// Start offset: 0x8008C8A8
				// Variables:
					struct Object *flame; // $v0

				/* begin block 1.1.3.1 */
					// Start line: 3332
					// Start offset: 0x8008C8B8
					// Variables:
						struct _Model *model; // $s0
				/* end block 1.1.3.1 */
				// End offset: 0x8008C910
				// End Line: 3338
			/* end block 1.1.3 */
			// End offset: 0x8008C91C
			// End Line: 3340

			/* begin block 1.1.4 */
				// Start line: 3345
				// Start offset: 0x8008C95C
				// Variables:
					//MATRIX *mat; // $s0
					//struct _SVector location; // stack offset -56
					//struct _SVector vel; // stack offset -48
					//struct _SVector accel; // stack offset -40
					int n; // $s1
					int cnt; // $s4
			/* end block 1.1.4 */
			// End offset: 0x8008CA5C
			// End Line: 3364
		/* end block 1.1 */
		// End offset: 0x8008CA5C
		// End Line: 3365
	/* end block 1 */
	// End offset: 0x8008CB04
	// End Line: 3387

	/* begin block 2 */
		// Start line: 7012
	/* end block 2 */
	// End Line: 7013
					UNIMPLEMENTED();
}


void MON_DefaultInit(struct _Instance* instance)  // Matching - 100%
{
	struct _MonsterAttributes* ma;
	struct _MonsterVars* mv;
	struct _HModel* hModel;
	struct _HPrim* hprim;
	int i;
	int state;
	struct Level* level;

	mv = (struct _MonsterVars*)instance->extraData;
	ma = (struct _MonsterAttributes*)instance->data;
	if (mv->mvFlags & 0x1000000)
	{
		MONAPI_CheckGenerator(instance);
	}
	if (MON_OnGround(instance) != 0)
	{
		mv->mvFlags |= 2;
	}
	else
	{
		mv->mvFlags &= ~2;
	}
	if (instance->hModelList != NULL)
	{
		hModel = instance->hModelList + instance->currentModel;
		hprim = (struct _HPrim*)&hModel->hPrimList->hpFlags;
		for (i = hModel->numHPrims; i != 0; i--, hprim++)
		{
			if (hprim->segment != 1)
			{
				hprim->withFlags &= 165;
			}
		}
	}
	if (ma->neckSegment != 0)
	{
		G2Anim_AttachControllerToSeg(&instance->anim, ma->neckSegment, 14);
		G2Anim_DisableController(&instance->anim, ma->neckSegment, 14);
	}
	if ((ma->spineSegment != 0) && (ma->spineSegment != ma->neckSegment))
	{
		G2Anim_AttachControllerToSeg(&instance->anim, ma->spineSegment, 14);
		G2Anim_DisableController(&instance->anim, ma->spineSegment, 14);
	}
	if (!(instance->object->oflags & 0x80000))
	{
		level = STREAM_GetLevelWithID(theCamera.focusInstance->currentStreamUnitID);
		if ((MATH3D_LengthXYZ(instance->position.x - theCamera.core.position.x, instance->position.y - theCamera.core.position.y,
			instance->position.z - theCamera.core.position.z) < level->fogNear) != 0)
		{
			instance->fadeValue = 4096;
			MON_StartSpecialFade(instance, 0, 20);
		}
	}
	state = 0;
	if (!(instance->flags & 2))
	{
		if (mv->behaviorState == 4)
		{
			state = 20;
		}
		else if (mv->behaviorState == 16)
		{
			state = 26;
		}
		else if (mv->behaviorState == 13)
		{
			state = 23;
			mv->damageType = 0;
		}
		else if (mv->mvFlags & 2)
		{
			state = 2;
		}
		else
		{
			state = 4;
		}
	}
	MON_SwitchState(instance, (enum MonsterState)state);
}


void MON_CleanUp(struct _Instance* instance)  // Matching - 100%
{
	struct _MonsterVars* mv;
	struct _MonsterAttributes* ma;

	mv = (struct _MonsterVars*)instance->extraData;
	ma = (struct _MonsterAttributes*)instance->data;
	MON_DropAllObjects(instance);
	if (instance->LinkParent != NULL)
	{
		MON_UnlinkFromRaziel(instance);
	}
	if ((mv->causeOfDeath == 3) && (mv->effect != NULL))
	{
		SndEndLoop((unsigned long)mv->effect);
		mv->effect = NULL;
	}
	if (((signed char)mv->pathSlotID) != -1)
	{
		ENMYPLAN_ReleasePlanningWorkspace((signed char)mv->pathSlotID);
	}
	if (ma->neckSegment != 0)
	{
		G2Anim_DetachControllerFromSeg(&instance->anim, ma->neckSegment, 14);
	}
	if ((ma->spineSegment != 0) && (ma->spineSegment != ma->neckSegment))
	{
		G2Anim_DetachControllerFromSeg(&instance->anim, ma->spineSegment, 14);
	}
	if ((INSTANCE_Query(instance, 1) & 0xC000) != 0)
	{
		GlobalSave->humanOpinionOfRaziel++;
	}
}
