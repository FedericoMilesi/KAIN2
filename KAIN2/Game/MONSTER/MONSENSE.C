#include "Game/CORE.H"
#include "MONSENSE.H"
#include "MONSTER.H"
#include "Game/PHYSOBS.H"

static int gNumMonsters; // offset 0x800D1AE8
static struct _MonsterVars* monsterSenseArray[40]; // offset 0x800D62B4
static int lastSenseFrame; // offset 0x800D637C
static int gNumMaterialMonsters; // offset 0x800D1AF0
static int gNumSpectralMonsters; // offset 0x800D1AEC
static char monsterSensed[40]; // offset 0x800D6354

struct _MonsterIR* MONSENSE_FindIR(struct _MonsterVars* mv, struct _Instance* instance)  // Matching - 100%
{
	struct _MonsterIR* mir;

	mir = mv->monsterIRList;

	while (mir != NULL)
	{
		if (mir->instance == instance)
		{
			break;
		}

		mir = mir->next;
	}

	return mir;
}


// autogenerated function stub: 
// int /*$ra*/ MONSENSE_See(struct _Instance *instance /*$s2*/, struct evCollideInstanceStatsData *data /*$s1*/)
int MONSENSE_See(struct _Instance *instance, struct evCollideInstanceStatsData *data)
{ // line 97, offset 0x80085adc
	/* begin block 1 */
		// Start line: 98
		// Start offset: 0x80085ADC
		// Variables:
			struct _MonsterVars *mv; // $v0
			struct _MonsterSenses *senses; // $s0

		/* begin block 1.1 */
			// Start line: 104
			// Start offset: 0x80085B20
			// Variables:
				int arc; // $a1
				int elevation; // $a2

			/* begin block 1.1.1 */
				// Start line: 114
				// Start offset: 0x80085B70
				// Variables:
					struct _Instance *target; // $s0

				/* begin block 1.1.1.1 */
					// Start line: 118
					// Start offset: 0x80085B88
					// Variables:
						//struct evPhysicsLOSData losData; // stack offset -40

					/* begin block 1.1.1.1.1 */
						// Start line: 122
						// Start offset: 0x80085B98
						// Variables:
							MATRIX *mat; // $v0
					/* end block 1.1.1.1.1 */
					// End offset: 0x80085B98
					// End Line: 122

					/* begin block 1.1.1.1.2 */
						// Start line: 128
						// Start offset: 0x80085BD4
						// Variables:
							//short _x1; // $v1
							//short _y1; // $a0
							//short _z1; // $a1
							//_Position *_v0; // $v0
							//_Position *_v1; // $v0
					/* end block 1.1.1.1.2 */
					// End offset: 0x80085BF0
					// End Line: 128

					/* begin block 1.1.1.1.3 */
						// Start line: 132
						// Start offset: 0x80085C00
						// Variables:
							//MATRIX *mat; // $v1
					/* end block 1.1.1.1.3 */
					// End offset: 0x80085C00
					// End Line: 132

					/* begin block 1.1.1.1.4 */
						// Start line: 138
						// Start offset: 0x80085C24
						// Variables:
							//short _x1; // $v1
							//short _y1; // $a0
							//short _z1; // $a1
							//_Position *_v0; // $v0
							//_Position *_v1; // $v0
					/* end block 1.1.1.1.4 */
					// End offset: 0x80085C44
					// End Line: 138
				/* end block 1.1.1.1 */
				// End offset: 0x80085C5C
				// End Line: 141
			/* end block 1.1.1 */
			// End offset: 0x80085C5C
			// End Line: 144
		/* end block 1.1 */
		// End offset: 0x80085C5C
		// End Line: 145
	/* end block 1 */
	// End offset: 0x80085C60
	// End Line: 148

	/* begin block 2 */
		// Start line: 194
	/* end block 2 */
	// End Line: 195
							UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ MONSENSE_Hear(struct _Instance *instance /*$a0*/, struct evCollideInstanceStatsData *data /*$s1*/)
int MONSENSE_Hear(struct _Instance *instance, struct evCollideInstanceStatsData *data)
{ // line 153, offset 0x80085c78
	/* begin block 1 */
		// Start line: 154
		// Start offset: 0x80085C78
		// Variables:
			struct _MonsterVars *mv; // $v0
			struct _MonsterSenses *senses; // $s0
			long mode; // $a0
	/* end block 1 */
	// End offset: 0x80085CF4
	// End Line: 171

	/* begin block 2 */
		// Start line: 270
	/* end block 2 */
	// End Line: 271
			UNIMPLEMENTED();
	return 0;
}

int MONSENSE_Smell(struct _Instance* instance, struct evCollideInstanceStatsData* data)  // Matching - 100%
{
	struct _MonsterVars* mv;

	mv = (struct _MonsterVars*)instance->extraData;

	return data->distance < mv->subAttr->senses->scentRadius;
}


// autogenerated function stub: 
// struct _MonsterIR * /*$ra*/ MONSENSE_FirstSense(struct _Instance *instance /*$s2*/, struct _Instance *sensed /*$s4*/)
struct _MonsterIR * MONSENSE_FirstSense(struct _Instance *instance, struct _Instance *sensed)
{ // line 186, offset 0x80085d30
	UNIMPLEMENTED();
	return NULL;
}


// autogenerated function stub: 
// void /*$ra*/ MONSENSE_SetupMIR(struct _Instance *instance /*$s3*/, struct evCollideInstanceStatsData *data /*$s1*/, int flags /*$s2*/)
void MONSENSE_SetupMIR(struct _Instance* instance, struct evCollideInstanceStatsData* data, int flags)
{ // line 233, offset 0x80085ed4
	UNIMPLEMENTED();
}


void MONSENSE_SenseInstance(struct _Instance* instance, struct evCollideInstanceStatsData* data) // Matching - 100%
{
	struct _MonsterVars* mv;
	long flags;
	unsigned long whatAmI;

	flags = 0;

	mv = (struct _MonsterVars*)instance->extraData;

	whatAmI = INSTANCE_Query(data->instance, 1);

	if (!(mv->mvFlags & 0x200))
	{
		if ((whatAmI & 0x20))
		{
			struct PhysObProperties* prop;

			prop = (struct PhysObProperties*)data->instance->data;

			if ((prop->family == 3) && (data->xyDistance < (((struct PhysObInteractProperties*)(prop))->engageXYDistance >> 1))
				&& (data->zDelta < ((struct PhysObInteractProperties*)(prop))->engageZMaxDelta)
				&& (((struct PhysObInteractProperties*)(prop))->engageZMinDelta < data->zDelta))
			{
				if ((((struct PhysObInteractProperties*)(prop))->conditions & 0x40))
				{
					INSTANCE_Post(instance, 0x100000C, 32);
				}

				if ((((struct PhysObInteractProperties*)(prop))->conditions & 0x8))
				{
					INSTANCE_Post(instance, 0x100000C, 64);
				}

				if ((((struct PhysObInteractProperties*)(prop))->conditions & 0x10))
				{
					INSTANCE_Post(instance, 0x100000C, 16);
				}
			}
		}
		else if (mv->alertCount != 0)
		{
			if (MONSENSE_Smell(instance, data) != 0)
			{
				flags = 0x80;
			}

			if (MONSENSE_See(instance, data) != 0)
			{
				flags |= 0x20;
			}

			if (MONSENSE_Hear(instance, data) != 0)
			{
				flags |= 0x40;
			}

			if ((whatAmI & mv->subAttr->allegiances->allies))
			{
				if (data->distance < mv->subAttr->senses->allyRadius)
				{
					flags |= 0x2;
				}
			}

			MONSENSE_SetupMIR(instance, data, flags);
		}
	}
}


void MONSENSE_StartMonsterIRList(struct _Instance* instance) // Matching - 100%
{
	struct _MonsterVars* mv;
	struct _MonsterIR* mir;
	struct _MonsterIR* newlist;
	int enemyOnList;
	char unk;  // not from SYMDUMP

	unk = 0;

	mv = (struct _MonsterVars*)instance->extraData;

	newlist = NULL;

	enemyOnList = 0;

	if (mv->alertCount != 0)
	{
		struct _MonsterIR* next;

		for (mir = mv->monsterIRList; mir != NULL; mir = next)
		{
			next = mir->next;

			if ((mir->handle != mir->instance->instanceID) || ((!(mir->mirFlags & 0xE0)) && (mir->forgetTimer < MON_GetTime(instance))))
			{
				if (mv != NULL)  // garbage code for reodering
				{
					unk = -unk;
				}

				mir->next = mv->freeIRs;

				mv->freeIRs = mir;
			}
			else
			{
				mir->next = newlist;

				newlist = mir;

				newlist->mirFlags &= ~0xE0;

				if (mv->enemy == newlist)
				{
					enemyOnList = 1;
				}
			}
		}


		if (enemyOnList == 0)
		{
			mv->enemy = NULL;
		}

		mv->monsterIRList = newlist;
	}
}

struct _MonsterIR* MONSENSE_GetMonsterIR(struct _MonsterVars* mv)  // Matching - 100%
{
	struct _MonsterIR* mir;

	if (mv->freeIRs != NULL)
	{
		mir = mv->freeIRs;
		mv->freeIRs = mir->next;
	}
	else
	{
		mir = NULL;
	}

	return mir;
}

void MONSENSE_InitIRList(struct _MonsterVars* mv, struct _MonsterIR* list, int num)  // Matching - 100%
{
	int i;

	i = num;
	
	mv->freeIRs = list;

	while (--i != 0)
	{
		list->next = (list + 1);

		list = list->next;
	}

	list->next = NULL;

	mv->monsterIRList = NULL;
}

// autogenerated function stub: 
// struct _MonsterIR * /*$ra*/ MONSENSE_SetEnemy(struct _Instance *instance /*$s1*/, struct _Instance *newenemy /*$s2*/)
struct _MonsterIR * MONSENSE_SetEnemy(struct _Instance *instance, struct _Instance *newenemy)
{ // line 512, offset 0x8008665c
	/* begin block 1 */
		// Start line: 513
		// Start offset: 0x8008665C
		// Variables:
			struct _MonsterVars *mv; // $s0
			struct _MonsterIR *mir; // $a2

		/* begin block 1.1 */
			// Start line: 532
			// Start offset: 0x800866D0
			// Variables:
				long angle; // $v0
		/* end block 1.1 */
		// End offset: 0x8008672C
		// End Line: 538
	/* end block 1 */
	// End offset: 0x80086760
	// End Line: 548

	/* begin block 2 */
		// Start line: 1049
	/* end block 2 */
	// End Line: 1050
				UNIMPLEMENTED();
	return null;
}


// autogenerated function stub: 
// void /*$ra*/ MONSENSE_ProcessIRList(struct _Instance *instance /*$s7*/)
void MONSENSE_ProcessIRList(struct _Instance *instance)
{ // line 554, offset 0x8008677c
	/* begin block 1 */
		// Start line: 555
		// Start offset: 0x8008677C
		// Variables:
			struct _MonsterVars *mv; // $s4
			struct _MonsterIR *mir; // $s0
			struct _MonsterIR *closestEnemy; // $s1
			struct _MonsterIR *closestLeader; // $s2
			struct _MonsterIR *closestAlly; // $s3
			struct _MonsterIR *player; // $s6
			struct _MonsterCombatAttributes *combatAttr; // $s5
	/* end block 1 */
	// End offset: 0x80086968
	// End Line: 612

	/* begin block 2 */
		// Start line: 1138
	/* end block 2 */
	// End Line: 1139
			UNIMPLEMENTED();
}


void MONSENSE_SetupSenses(struct _Instance* instance)  // Matching - 100%
{
	struct _MonsterAllegiances* allegiances;
	struct _MonsterVars* mv;
	int num;

	mv = (struct _MonsterVars*)instance->extraData;
	allegiances = mv->subAttr->allegiances;

	MONSENSE_InitIRList(mv, (struct _MonsterIR*)&mv[1], 5);

	instance->flags2 |= 0x400;
	if (allegiances != NULL)
	{
		instance->checkMask = allegiances->enemies | allegiances->allies | allegiances->food | allegiances->gods;
	}

	instance->maxCheckDistance = 12000;
	instance->checkMask |= 11;
	mv->enemy = NULL;
	mv->leader = NULL;
	monsterSenseArray[gNumMonsters] = mv;
	mv->senseIndex = gNumMonsters;
	if (gNumMonsters == 0)
	{
		lastSenseFrame = -1;
	}

	gNumMonsters++;
	if ((((struct _MonsterAttributes*)instance->data)->whatAmI) & 0x1804)  // double check if data is getting cast to the correct struct here
	{
		num = ++gNumSpectralMonsters;
	}
	else
	{
		num = ++gNumMaterialMonsters;
	}

	if (((6 < num) && (instance->parent == NULL)) && (instance->currentStreamUnitID != instance->birthStreamUnitID))
	{
		instance->flags |= 0x20;
		instance->flags2 |= 0x20000;
	}

	return;
}


void MONSENSE_RemoveSenses(struct _Instance* instance) // Matching - 100%
{
	struct _MonsterVars* mv;
	int i;

	mv = (struct _MonsterVars*)instance->extraData;

	gNumMonsters--;

	if ((((struct _MonsterAttributes*)(instance->data))->whatAmI & 0x1804))
	{
		gNumSpectralMonsters--;
	}
	else
	{
		gNumMaterialMonsters--;
	}

	for (i = mv->senseIndex; i < gNumMonsters; i++)
	{
		monsterSenseArray[i] = monsterSenseArray[i + 1];

		monsterSenseArray[i]->senseIndex = i;
	}
}


// autogenerated function stub: 
// void /*$ra*/ MONSENSE_Radar(struct _Instance *instance /*$s0*/)
void MONSENSE_Radar(struct _Instance *instance)
{ // line 847, offset 0x80086ba8
	/* begin block 1 */
		// Start line: 848
		// Start offset: 0x80086BA8
		// Variables:
			struct _MonsterVars *mv; // $s1
			SVECTOR newPos; // stack offset -96
			SVECTOR oldPos; // stack offset -88
			//struct _PCollideInfo pCollideInfo; // stack offset -80
			int index; // $s3
	/* end block 1 */
	// End offset: 0x80086DC0
	// End Line: 919

	/* begin block 2 */
		// Start line: 1840
	/* end block 2 */
	// End Line: 1841
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// short /*$ra*/ MONSENSE_GetClosestFreeDirection(struct _Instance *instance /*$a0*/, short angle /*$t1*/, long range /*$a2*/)
short MONSENSE_GetClosestFreeDirection(struct _Instance *instance, short angle, long range)
{ // line 924, offset 0x80086de4
	/* begin block 1 */
		// Start line: 925
		// Start offset: 0x80086DE4
		// Variables:
			struct _MonsterVars *mv; // $t0
			int bit; // $a1
			int search; // $a0
	/* end block 1 */
	// End offset: 0x80086EE0
	// End Line: 958

	/* begin block 2 */
		// Start line: 2013
	/* end block 2 */
	// End Line: 2014
			UNIMPLEMENTED();
	return 0;
}

int MONSENSE_GetDistanceInDirection(struct _Instance* instance, short angle)  // Matching - 100%
{
	struct _MonsterVars* mv;
	int bit;
	
	bit = (angle + 256) & 0xFFF;

	mv = (struct _MonsterVars*)instance->extraData;

	if (bit < 0)
	{
		bit += 0x1FF;
	}

	return mv->radarDistance[bit >> 9];
}


void MONSENSE_DoSenses(struct _Instance* instance) // Matching - 100%
{
	struct _MonsterVars* mv;
	static int doneThisFrame; 

	mv = (struct _MonsterVars*)instance->extraData;

	MONSENSE_ProcessIRList(instance);

	if (lastSenseFrame < (long)gameTrackerX.frameCount)
	{
		if (lastSenseFrame < (long)(gameTrackerX.frameCount - 1))
		{
			memset(&monsterSensed, 0, 40);

			lastSenseFrame = gameTrackerX.frameCount - 1;
		}

		doneThisFrame = 0;
	}

	if ((doneThisFrame == 0) && (monsterSensed[mv->senseIndex] == 0))
	{
		lastSenseFrame = gameTrackerX.frameCount;

		monsterSensed[mv->senseIndex] = 1;

		doneThisFrame = 1;

		mv->alertCount = 1;

		if (!(mv->auxFlags & 0x20000000))
		{
			MONSENSE_Radar(instance);
		}
	}
	else
	{
		mv->alertCount = 0;
	}
}


// autogenerated function stub: 
// void /*$ra*/ MONSENSE_AdjustRadarFromObjects(struct _Instance *instance /*$s3*/)
void MONSENSE_AdjustRadarFromObjects(struct _Instance *instance)
{ // line 1010, offset 0x80087018
	/* begin block 1 */
		// Start line: 1011
		// Start offset: 0x80087018
		// Variables:
			struct _MonsterVars *mv; // $s4
			struct _Instance *physob; // $s2

		/* begin block 1.1 */
			// Start line: 1019
			// Start offset: 0x80087068
			// Variables:
				struct PhysObProperties *prop; // $s1

			/* begin block 1.1.1 */
				// Start line: 1022
				// Start offset: 0x80087080

				/* begin block 1.1.1.1 */
					// Start line: 1028
					// Start offset: 0x800870BC
					// Variables:
						long dist; // $s0

					/* begin block 1.1.1.1.1 */
						// Start line: 1033
						// Start offset: 0x800870F0
						// Variables:
							int i; // $v1
							int min; // $a1
							int max; // $a2
							int ang; // $s0
					/* end block 1.1.1.1.1 */
					// End offset: 0x800871CC
					// End Line: 1060
				/* end block 1.1.1.1 */
				// End offset: 0x800871CC
				// End Line: 1061
			/* end block 1.1.1 */
			// End offset: 0x800871CC
			// End Line: 1063
		/* end block 1.1 */
		// End offset: 0x800871CC
		// End Line: 1064
	/* end block 1 */
	// End offset: 0x800871DC
	// End Line: 1066

	/* begin block 2 */
		// Start line: 2191
	/* end block 2 */
	// End Line: 2192

	/* begin block 3 */
		// Start line: 2195
	/* end block 3 */
	// End Line: 2196
							UNIMPLEMENTED();
}




