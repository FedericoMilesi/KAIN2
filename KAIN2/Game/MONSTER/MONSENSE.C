#include "Game/CORE.H"
#include "MONSENSE.H"
#include "MONSTER.H"
#include "Game/PHYSOBS.H"
#include <Game/MATH3D.H>

static int gNumMonsters; // offset 0x800D1AE8
static struct _MonsterVars* monsterSenseArray[40]; // offset 0x800D62B4
static int lastSenseFrame; // offset 0x800D637C
static int gNumMaterialMonsters; // offset 0x800D1AF0
static int gNumSpectralMonsters; // offset 0x800D1AEC
static char monsterSensed[40]; // offset 0x800D6354

struct _MonsterIR* MONSENSE_FindIR(struct _MonsterVars* mv, struct _Instance* instance)  // Matching - 100%
{
	struct _MonsterIR* mir;

	mir = mv->monsterIRList;

	while (mir != NULL)
	{
		if (mir->instance == instance)
		{
			break;
		}

		mir = mir->next;
	}

	return mir;
}


// autogenerated function stub: 
// int /*$ra*/ MONSENSE_See(struct _Instance *instance /*$s2*/, struct evCollideInstanceStatsData *data /*$s1*/)
int MONSENSE_See(struct _Instance *instance, struct evCollideInstanceStatsData *data)
{ // line 97, offset 0x80085adc
	/* begin block 1 */
		// Start line: 98
		// Start offset: 0x80085ADC
		// Variables:
			struct _MonsterVars *mv; // $v0
			struct _MonsterSenses *senses; // $s0

		/* begin block 1.1 */
			// Start line: 104
			// Start offset: 0x80085B20
			// Variables:
				int arc; // $a1
				int elevation; // $a2

			/* begin block 1.1.1 */
				// Start line: 114
				// Start offset: 0x80085B70
				// Variables:
					struct _Instance *target; // $s0

				/* begin block 1.1.1.1 */
					// Start line: 118
					// Start offset: 0x80085B88
					// Variables:
						//struct evPhysicsLOSData losData; // stack offset -40

					/* begin block 1.1.1.1.1 */
						// Start line: 122
						// Start offset: 0x80085B98
						// Variables:
							MATRIX *mat; // $v0
					/* end block 1.1.1.1.1 */
					// End offset: 0x80085B98
					// End Line: 122

					/* begin block 1.1.1.1.2 */
						// Start line: 128
						// Start offset: 0x80085BD4
						// Variables:
							//short _x1; // $v1
							//short _y1; // $a0
							//short _z1; // $a1
							//_Position *_v0; // $v0
							//_Position *_v1; // $v0
					/* end block 1.1.1.1.2 */
					// End offset: 0x80085BF0
					// End Line: 128

					/* begin block 1.1.1.1.3 */
						// Start line: 132
						// Start offset: 0x80085C00
						// Variables:
							//MATRIX *mat; // $v1
					/* end block 1.1.1.1.3 */
					// End offset: 0x80085C00
					// End Line: 132

					/* begin block 1.1.1.1.4 */
						// Start line: 138
						// Start offset: 0x80085C24
						// Variables:
							//short _x1; // $v1
							//short _y1; // $a0
							//short _z1; // $a1
							//_Position *_v0; // $v0
							//_Position *_v1; // $v0
					/* end block 1.1.1.1.4 */
					// End offset: 0x80085C44
					// End Line: 138
				/* end block 1.1.1.1 */
				// End offset: 0x80085C5C
				// End Line: 141
			/* end block 1.1.1 */
			// End offset: 0x80085C5C
			// End Line: 144
		/* end block 1.1 */
		// End offset: 0x80085C5C
		// End Line: 145
	/* end block 1 */
	// End offset: 0x80085C60
	// End Line: 148

	/* begin block 2 */
		// Start line: 194
	/* end block 2 */
	// End Line: 195
							UNIMPLEMENTED();
	return 0;
}


int MONSENSE_Hear(struct _Instance* instance, struct evCollideInstanceStatsData* data) // Matching - 100%
{
	struct _MonsterVars* mv;
	struct _MonsterSenses* senses;
	long mode;

	mv = (struct _MonsterVars*)instance->extraData;

	senses = mv->subAttr->senses;

	mode = INSTANCE_Query(data->instance, 10);

	if ((!(mode & 0x10B0143)) || ((mode & 0x200000)))
	{
		if (data->distance < (unsigned)senses->soundRadius)
		{
			return MATH3D_ConeDetect(&data->relativePosition, senses->soundArc, senses->soundElevation);
		}
	}

	return 0;
}

int MONSENSE_Smell(struct _Instance* instance, struct evCollideInstanceStatsData* data)  // Matching - 100%
{
	struct _MonsterVars* mv;

	mv = (struct _MonsterVars*)instance->extraData;

	return data->distance < mv->subAttr->senses->scentRadius;
}


// autogenerated function stub: 
// struct _MonsterIR * /*$ra*/ MONSENSE_FirstSense(struct _Instance *instance /*$s2*/, struct _Instance *sensed /*$s4*/)
struct _MonsterIR * MONSENSE_FirstSense(struct _Instance *instance, struct _Instance *sensed)
{ // line 186, offset 0x80085d30
	UNIMPLEMENTED();
	return NULL;
}


void MONSENSE_SetupMIR(struct _Instance* instance, struct evCollideInstanceStatsData* data, int flags) // Matching - 99.65%
{
	struct _MonsterIR* mir;
	struct _MonsterVars* mv;

	mv = (struct _MonsterVars*)instance->extraData;

	mir = MONSENSE_FindIR(mv, data->instance);

	if (mir == NULL)
	{
		if (flags != 0)
		{
			mir = MONSENSE_FirstSense(instance, data->instance);
		}
	}
	else if (flags != 0)
	{
		mir->forgetTimer = MON_GetTime(instance) + (mv->subAttr->forgetTime * 1000);
	}

	if (mir != NULL)
	{
		long mode;

		mir->mirFlags |= flags;
		mir->distance = (short)data->distance;

		{
			short _x1;
			short _y1;
			short _z1;
			struct _SVector* _v0;
			struct _SVector* _v1;

			_v0 = &data->relativePosition;
			_v1 = &mir->relativePosition;

			_x1 = _v0->x;
			_y1 = _v0->y;
			_z1 = _v0->z;

			_v1->x = _x1;
			_v1->y = _y1;
			_v1->z = _z1;
		}

		if ((mv->subAttr->combatAttributes != NULL) && (mv->subAttr->combatAttributes->combatRange > mir->distance))
		{
			mir->mirConditions |= 0x8;
		}
		else
		{
			mir->mirConditions &= ~0x8;
		}

		if (((short)((MATH3D_AngleFromPosToPos(&mir->instance->position, &instance->position) - mir->instance->rotation.z) + 1024) & 0xFFF) >= 2049)
		{
			mir->mirConditions |= 0x2;
		}
		else
		{
			mir->mirConditions &= ~0x2;
		}

		mode = INSTANCE_Query(mir->instance, 10);

		if ((mode & 0x208000) == 0x208000)
		{
			mode &= ~0x200000;
		}

		if ((mode & 0x4))
		{
			mir->mirConditions |= 0x1;
		}
		else
		{
			mir->mirConditions &= ~0x1;
		}

		if ((mir->mirFlags & 0x400))
		{
			if (!(mode & 0x200000))
			{
				mir->mirFlags &= ~0x400;
				mir->mirConditions &= ~0x820;

				if (((mir->mirFlags & 0x1)) && (!(mir->mirConditions & 0x400)))
				{
					mir->mirConditions |= 0x4;
				}
			}
		}
		else
		{
			if ((mode & 0x200000))
			{
				int run;
				int distance;

				run = mode & 0x4;

				if (mv->subAttr->combatAttributes != NULL)
				{
					if (run != 0)
					{
						distance = mv->subAttr->combatAttributes->enemyRunAttackRange;
					}
					else
					{
						distance = mv->subAttr->combatAttributes->enemyAttackRange;
					}

					mir->mirConditions &= ~0xE4;
					mir->mirFlags |= 0x400;

					if ((mir->distance < distance) && (((short)((MATH3D_AngleFromPosToPos(&mir->instance->position, &instance->position) - mir->instance->rotation.z) + 512) & 0xFFF) < 2048))
					{
						if (run != 0)
						{
							mir->mirConditions |= 0x20;
						}

						mir->mirConditions |= 0x800;
					}
				}
			}
		}

		if ((mir->mirFlags & 0x800))
		{
			if (mode != 1)
			{
				mir->mirFlags &= ~0x800;
				mir->mirConditions &= ~0x10;
			}
			else if ((!(mir->mirConditions & 0x10)) && (mir->idleTime < MON_GetTime(instance)))
			{
				mir->mirConditions |= 0x10;
			}
		}
		else if (mode == 1)
		{
			mir->mirFlags |= 0x800;
			mir->idleTime = MON_GetTime(instance) + 4950;
		}

		if ((mir->mirFlags & 0x200))
		{
			if (((mv->subAttr->combatAttributes->allyRange + 300) < mir->distance) || ((INSTANCE_Query(mir->instance, 0) & 0x44000000)))
			{
				mir->mirFlags &= ~0x200;
			}
		}
		else if ((mir->mirFlags & 0x2))
		{
			if (mir->distance < mv->subAttr->combatAttributes->allyRange)
			{
				mir->mirFlags |= 0x200;
			}
		}
	}
}


void MONSENSE_SenseInstance(struct _Instance* instance, struct evCollideInstanceStatsData* data) // Matching - 100%
{
	struct _MonsterVars* mv;
	long flags;
	unsigned long whatAmI;

	flags = 0;

	mv = (struct _MonsterVars*)instance->extraData;

	whatAmI = INSTANCE_Query(data->instance, 1);

	if (!(mv->mvFlags & 0x200))
	{
		if ((whatAmI & 0x20))
		{
			struct PhysObProperties* prop;

			prop = (struct PhysObProperties*)data->instance->data;

			if ((prop->family == 3) && (data->xyDistance < (((struct PhysObInteractProperties*)(prop))->engageXYDistance >> 1))
				&& (data->zDelta < ((struct PhysObInteractProperties*)(prop))->engageZMaxDelta)
				&& (((struct PhysObInteractProperties*)(prop))->engageZMinDelta < data->zDelta))
			{
				if ((((struct PhysObInteractProperties*)(prop))->conditions & 0x40))
				{
					INSTANCE_Post(instance, 0x100000C, 32);
				}

				if ((((struct PhysObInteractProperties*)(prop))->conditions & 0x8))
				{
					INSTANCE_Post(instance, 0x100000C, 64);
				}

				if ((((struct PhysObInteractProperties*)(prop))->conditions & 0x10))
				{
					INSTANCE_Post(instance, 0x100000C, 16);
				}
			}
		}
		else if (mv->alertCount != 0)
		{
			if (MONSENSE_Smell(instance, data) != 0)
			{
				flags = 0x80;
			}

			if (MONSENSE_See(instance, data) != 0)
			{
				flags |= 0x20;
			}

			if (MONSENSE_Hear(instance, data) != 0)
			{
				flags |= 0x40;
			}

			if ((whatAmI & mv->subAttr->allegiances->allies))
			{
				if (data->distance < mv->subAttr->senses->allyRadius)
				{
					flags |= 0x2;
				}
			}

			MONSENSE_SetupMIR(instance, data, flags);
		}
	}
}


void MONSENSE_StartMonsterIRList(struct _Instance* instance) // Matching - 100%
{
	struct _MonsterVars* mv;
	struct _MonsterIR* mir;
	struct _MonsterIR* newlist;
	int enemyOnList;
	char unk;  // not from SYMDUMP

	unk = 0;

	mv = (struct _MonsterVars*)instance->extraData;

	newlist = NULL;

	enemyOnList = 0;

	if (mv->alertCount != 0)
	{
		struct _MonsterIR* next;

		for (mir = mv->monsterIRList; mir != NULL; mir = next)
		{
			next = mir->next;

			if ((mir->handle != mir->instance->instanceID) || ((!(mir->mirFlags & 0xE0)) && (mir->forgetTimer < MON_GetTime(instance))))
			{
				if (mv != NULL)  // garbage code for reodering
				{
					unk = -unk;
				}

				mir->next = mv->freeIRs;

				mv->freeIRs = mir;
			}
			else
			{
				mir->next = newlist;

				newlist = mir;

				newlist->mirFlags &= ~0xE0;

				if (mv->enemy == newlist)
				{
					enemyOnList = 1;
				}
			}
		}


		if (enemyOnList == 0)
		{
			mv->enemy = NULL;
		}

		mv->monsterIRList = newlist;
	}
}

struct _MonsterIR* MONSENSE_GetMonsterIR(struct _MonsterVars* mv)  // Matching - 100%
{
	struct _MonsterIR* mir;

	if (mv->freeIRs != NULL)
	{
		mir = mv->freeIRs;
		mv->freeIRs = mir->next;
	}
	else
	{
		mir = NULL;
	}

	return mir;
}

void MONSENSE_InitIRList(struct _MonsterVars* mv, struct _MonsterIR* list, int num)  // Matching - 100%
{
	int i;

	i = num;
	
	mv->freeIRs = list;

	while (--i != 0)
	{
		list->next = (list + 1);

		list = list->next;
	}

	list->next = NULL;

	mv->monsterIRList = NULL;
}

// autogenerated function stub: 
// struct _MonsterIR * /*$ra*/ MONSENSE_SetEnemy(struct _Instance *instance /*$s1*/, struct _Instance *newenemy /*$s2*/)
struct _MonsterIR * MONSENSE_SetEnemy(struct _Instance *instance, struct _Instance *newenemy)
{ // line 512, offset 0x8008665c
	/* begin block 1 */
		// Start line: 513
		// Start offset: 0x8008665C
		// Variables:
			struct _MonsterVars *mv; // $s0
			struct _MonsterIR *mir; // $a2

		/* begin block 1.1 */
			// Start line: 532
			// Start offset: 0x800866D0
			// Variables:
				long angle; // $v0
		/* end block 1.1 */
		// End offset: 0x8008672C
		// End Line: 538
	/* end block 1 */
	// End offset: 0x80086760
	// End Line: 548

	/* begin block 2 */
		// Start line: 1049
	/* end block 2 */
	// End Line: 1050
				UNIMPLEMENTED();
	return null;
}


void MONSENSE_ProcessIRList(struct _Instance* instance) // Matching - 99.11%
{
	struct _MonsterVars* mv;
	struct _MonsterIR* mir;
	struct _MonsterIR* closestEnemy;
	struct _MonsterIR* closestLeader;
	struct _MonsterIR* closestAlly;
	struct _MonsterIR* player;
	struct _MonsterCombatAttributes* combatAttr;

	closestEnemy = NULL;

	closestLeader = NULL;

	closestAlly = NULL;

	mv = (struct _MonsterVars*)instance->extraData;

	mir = mv->monsterIRList;

	combatAttr = mv->subAttr->combatAttributes;

	player = NULL;

	while (mir != NULL)
	{
		if (mir->instance->instanceID == mir->handle)
		{
			if ((mir->mirFlags & 0x1))
			{
				if ((INSTANCE_Query(mir->instance, 1) & 0x1))
				{
					player = mir;
				}

				if ((closestEnemy == NULL) || (closestEnemy->distance > mir->distance))
				{
					closestEnemy = mir;
				}

				if ((mir->mirFlags & 0x100))
				{
					if ((combatAttr != NULL) && (combatAttr->surpriseRange > mir->distance))
					{
						INSTANCE_Post(instance, 0x100000E, (int)mir);
					}
					else
					{
						INSTANCE_Post(instance, 0x1000012, (int)mir);
					}
				}
			}

			if (((mir->mirFlags & 0x10)) && ((closestLeader == NULL) || (closestLeader->distance > mir->distance)))
			{
				closestLeader = mir;
			}

			if (((mir->mirFlags & 0x2)) && (!(INSTANCE_Query(mir->instance, 1) & 0x4)) && ((closestAlly == NULL) || (closestAlly->distance > mir->distance)))
			{
				closestAlly = mir;
			}

			mir->mirFlags &= ~0x100;
		}

		mir = mir->next;
	}

	if ((player != NULL) && ((combatAttr == NULL) || (combatAttr->hitPoints == 0) || (mv->hitPoints != 0)))
	{
		mv->enemy = player;
	}
	else
	{
		mv->enemy = closestEnemy;
	}

	mv->leader = closestLeader;
	mv->ally = closestAlly;
}


void MONSENSE_SetupSenses(struct _Instance* instance)  // Matching - 100%
{
	struct _MonsterAllegiances* allegiances;
	struct _MonsterVars* mv;
	int num;

	mv = (struct _MonsterVars*)instance->extraData;
	allegiances = mv->subAttr->allegiances;

	MONSENSE_InitIRList(mv, (struct _MonsterIR*)&mv[1], 5);

	instance->flags2 |= 0x400;
	if (allegiances != NULL)
	{
		instance->checkMask = allegiances->enemies | allegiances->allies | allegiances->food | allegiances->gods;
	}

	instance->maxCheckDistance = 12000;
	instance->checkMask |= 11;
	mv->enemy = NULL;
	mv->leader = NULL;
	monsterSenseArray[gNumMonsters] = mv;
	mv->senseIndex = gNumMonsters;
	if (gNumMonsters == 0)
	{
		lastSenseFrame = -1;
	}

	gNumMonsters++;
	if ((((struct _MonsterAttributes*)instance->data)->whatAmI) & 0x1804)  // double check if data is getting cast to the correct struct here
	{
		num = ++gNumSpectralMonsters;
	}
	else
	{
		num = ++gNumMaterialMonsters;
	}

	if (((6 < num) && (instance->parent == NULL)) && (instance->currentStreamUnitID != instance->birthStreamUnitID))
	{
		instance->flags |= 0x20;
		instance->flags2 |= 0x20000;
	}

	return;
}


void MONSENSE_RemoveSenses(struct _Instance* instance) // Matching - 100%
{
	struct _MonsterVars* mv;
	int i;

	mv = (struct _MonsterVars*)instance->extraData;

	gNumMonsters--;

	if ((((struct _MonsterAttributes*)(instance->data))->whatAmI & 0x1804))
	{
		gNumSpectralMonsters--;
	}
	else
	{
		gNumMaterialMonsters--;
	}

	for (i = mv->senseIndex; i < gNumMonsters; i++)
	{
		monsterSenseArray[i] = monsterSenseArray[i + 1];

		monsterSenseArray[i]->senseIndex = i;
	}
}


// autogenerated function stub: 
// void /*$ra*/ MONSENSE_Radar(struct _Instance *instance /*$s0*/)
void MONSENSE_Radar(struct _Instance *instance)
{ // line 847, offset 0x80086ba8
	/* begin block 1 */
		// Start line: 848
		// Start offset: 0x80086BA8
		// Variables:
			struct _MonsterVars *mv; // $s1
			SVECTOR newPos; // stack offset -96
			SVECTOR oldPos; // stack offset -88
			//struct _PCollideInfo pCollideInfo; // stack offset -80
			int index; // $s3
	/* end block 1 */
	// End offset: 0x80086DC0
	// End Line: 919

	/* begin block 2 */
		// Start line: 1840
	/* end block 2 */
	// End Line: 1841
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// short /*$ra*/ MONSENSE_GetClosestFreeDirection(struct _Instance *instance /*$a0*/, short angle /*$t1*/, long range /*$a2*/)
short MONSENSE_GetClosestFreeDirection(struct _Instance *instance, short angle, long range)
{ // line 924, offset 0x80086de4
	/* begin block 1 */
		// Start line: 925
		// Start offset: 0x80086DE4
		// Variables:
			struct _MonsterVars *mv; // $t0
			int bit; // $a1
			int search; // $a0
	/* end block 1 */
	// End offset: 0x80086EE0
	// End Line: 958

	/* begin block 2 */
		// Start line: 2013
	/* end block 2 */
	// End Line: 2014
			UNIMPLEMENTED();
	return 0;
}

int MONSENSE_GetDistanceInDirection(struct _Instance* instance, short angle)  // Matching - 100%
{
	struct _MonsterVars* mv;
	int bit;
	
	bit = (angle + 256) & 0xFFF;

	mv = (struct _MonsterVars*)instance->extraData;

	if (bit < 0)
	{
		bit += 0x1FF;
	}

	return mv->radarDistance[bit >> 9];
}


void MONSENSE_DoSenses(struct _Instance* instance) // Matching - 100%
{
	struct _MonsterVars* mv;
	static int doneThisFrame; 

	mv = (struct _MonsterVars*)instance->extraData;

	MONSENSE_ProcessIRList(instance);

	if (lastSenseFrame < (long)gameTrackerX.frameCount)
	{
		if (lastSenseFrame < (long)(gameTrackerX.frameCount - 1))
		{
			memset(&monsterSensed, 0, 40);

			lastSenseFrame = gameTrackerX.frameCount - 1;
		}

		doneThisFrame = 0;
	}

	if ((doneThisFrame == 0) && (monsterSensed[mv->senseIndex] == 0))
	{
		lastSenseFrame = gameTrackerX.frameCount;

		monsterSensed[mv->senseIndex] = 1;

		doneThisFrame = 1;

		mv->alertCount = 1;

		if (!(mv->auxFlags & 0x20000000))
		{
			MONSENSE_Radar(instance);
		}
	}
	else
	{
		mv->alertCount = 0;
	}
}


// autogenerated function stub: 
// void /*$ra*/ MONSENSE_AdjustRadarFromObjects(struct _Instance *instance /*$s3*/)
void MONSENSE_AdjustRadarFromObjects(struct _Instance *instance)
{ // line 1010, offset 0x80087018
	/* begin block 1 */
		// Start line: 1011
		// Start offset: 0x80087018
		// Variables:
			struct _MonsterVars *mv; // $s4
			struct _Instance *physob; // $s2

		/* begin block 1.1 */
			// Start line: 1019
			// Start offset: 0x80087068
			// Variables:
				struct PhysObProperties *prop; // $s1

			/* begin block 1.1.1 */
				// Start line: 1022
				// Start offset: 0x80087080

				/* begin block 1.1.1.1 */
					// Start line: 1028
					// Start offset: 0x800870BC
					// Variables:
						long dist; // $s0

					/* begin block 1.1.1.1.1 */
						// Start line: 1033
						// Start offset: 0x800870F0
						// Variables:
							int i; // $v1
							int min; // $a1
							int max; // $a2
							int ang; // $s0
					/* end block 1.1.1.1.1 */
					// End offset: 0x800871CC
					// End Line: 1060
				/* end block 1.1.1.1 */
				// End offset: 0x800871CC
				// End Line: 1061
			/* end block 1.1.1 */
			// End offset: 0x800871CC
			// End Line: 1063
		/* end block 1.1 */
		// End offset: 0x800871CC
		// End Line: 1064
	/* end block 1 */
	// End offset: 0x800871DC
	// End Line: 1066

	/* begin block 2 */
		// Start line: 2191
	/* end block 2 */
	// End Line: 2192

	/* begin block 3 */
		// Start line: 2195
	/* end block 3 */
	// End Line: 2196
							UNIMPLEMENTED();
}




