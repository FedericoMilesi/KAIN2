#include "Game/CORE.H"
#include "MONMSG.H"
#include "Game/STATE.H"
#include <Game/MATH3D.H>
#include "Game/GENERIC.H"
#include <Game/PSX/COLLIDES.H>

int MON_GroundMoveQueueHandler(struct _Instance* instance)  // Matching - 100%
{
	struct _MonsterVars* mv;
	struct __Event* message;
	int ret;

	ret = 0;
	mv = (struct _MonsterVars*)instance->extraData;
	while (TRUE)
	{
		message = DeMessageQueue(&mv->messageQueue);
		if (message == NULL) break;
		if (message->ID == 0x4010080)
		{
			ret = 0x4010080;
		}
		else
		{
			MON_IdleMessageHandler(instance, message);
		}
	}
	return ret;
}


// autogenerated function stub: 
// void /*$ra*/ MON_PupateMessageHandler(struct _Instance *instance /*$s2*/, struct __Event *message /*$a1*/)
void MON_PupateMessageHandler(struct _Instance *instance, struct __Event *message)
{ // line 60, offset 0x80084840
	/* begin block 1 */
		// Start line: 61
		// Start offset: 0x80084840
		// Variables:
			struct _MonsterVars *mv; // $s0
			long id; // $v1

		/* begin block 1.1 */
			// Start line: 72
			// Start offset: 0x800848F4
			// Variables:
				struct evMonsterAlarmData *data; // $s1
		/* end block 1.1 */
		// End offset: 0x8008497C
		// End Line: 79

		/* begin block 1.2 */
			// Start line: 86
			// Start offset: 0x800849BC
			// Variables:
				//struct evFXHitData data; // stack offset -40
		/* end block 1.2 */
		// End offset: 0x800849FC
		// End Line: 93
	/* end block 1 */
	// End offset: 0x80084A6C
	// End Line: 165

	/* begin block 2 */
		// Start line: 128
	/* end block 2 */
	// End Line: 129
				UNIMPLEMENTED();
}

void MON_PossessedMessageHandler(struct _Instance* instance, struct __Event* message)
{ // line 75, offset 0x8007c0b0
	/* begin block 1 */
		// Start line: 76
		// Start offset: 0x8007C0B0
		// Variables:
	struct _MonsterVars* mv; // $s0
	long id; // $s1
	int state; // $s2

/* begin block 1.1 */
	// Start line: 125
	// Start offset: 0x8007C228
	// Variables:
	short target; // $a1
	int nochange; // $s5

/* begin block 1.1.1 */
	// Start line: 132
	// Start offset: 0x8007C23C
	// Variables:
	short speed; // $a2
/* end block 1.1.1 */
// End offset: 0x8007C364
// End Line: 148
/* end block 1.1 */
// End offset: 0x8007C3AC
// End Line: 162
/* end block 1 */
// End offset: 0x8007C3AC
// End Line: 169

/* begin block 2 */
	// Start line: 161
/* end block 2 */
// End Line: 162
	UNIMPLEMENTED();
}

void MON_IdleMessageHandler(struct _Instance* instance, struct __Event* message) // Matching - 100%
{
	struct _MonsterVars* mv;
	long id;
	char temp;  // not from SYMDUMP

	temp = 0;

	id = message->ID;

	mv = (struct _MonsterVars*)instance->extraData;

	switch (id)
	{
	case 0x1000002:
	case 0x100000A:
	case 0x1000023:
		if (message != NULL)  // garbage code for reodering 
		{
			temp = -temp;
		}

		if (message->Data == 0)
		{
			MON_SwitchState(instance, MONSTER_STATE_PARRY);
		}

		MON_DefaultMessageHandler(instance, message);
		break;
	case 0x100000E:
		if (!(mv->mvFlags & 0x4))
		{
			struct _MonsterIR* mir;

			mir = (struct _MonsterIR*)message->Data;

			if ((INSTANCE_Query(mir->instance, 1) & 0x1))
			{
				MON_ChangeBehavior(instance, mv->triggeredBehavior);
			}

			MON_SwitchState(instance, MONSTER_STATE_SURPRISED);
		}

		break;
	case 0x1000012:
		if (!(mv->mvFlags & 0x4))
		{
			struct _MonsterIR* mir;

			mir = (struct _MonsterIR*)message->Data;

			if ((INSTANCE_Query(mir->instance, 1) & 0x1))
			{
				MON_ChangeBehavior(instance, mv->triggeredBehavior);
			}

			MON_SwitchState(instance, MONSTER_STATE_NOTICE);
		}

		break;
	default:
		MON_DefaultMessageHandler(instance, message);
	}
}

void MON_DefaultMessageHandler(struct _Instance* instance, struct __Event* message) // Matching - 99.79%
{
    struct _MonsterAttributes* ma;
    struct _MonsterVars* mv;
    long id;
    typedef void (*MONTABLE_DamageEffectFunc)(struct _Instance*, int); // not from SYMDUMP 
    int temp; // not from SYMDUMP
    short temp2; // not from SYMDUMP
    struct evMonsterImpaleData* temp3; // not from SYMDUMP

    id = message->ID;

    ma = (struct _MonsterAttributes*)instance->data;

    mv = (struct _MonsterVars*)instance->extraData;

    switch (id)
    {
    case 0x1000021:
    case 0x100001F:
    {
        struct evMonsterHitData* data;
        int fatal;
        int damage;

        fatal = 0;

        if (!(mv->mvFlags & 0x200040))
        {
            data = (struct evMonsterHitData*)message->Data;

            mv->damageType = (short)data->power;

            damage = 0;

            switch (mv->damageType)
            {
            case 32:
                if ((id == 0x1000021) && ((INSTANCE_Query(instance, 0) & 0x10000000)))
                {
                    fatal = 1;
                }
                else
                {
                    struct _MonsterCombatAttributes* combat;

                    combat = mv->subAttr->combatAttributes;

                    mv->mvFlags |= 0x800110;
                    mv->damageTimer = MON_GetTime(instance) + combat->damageTime;
                    mv->stunTimer = MON_GetTime(instance) + combat->stunTime;

                    damage = 24576;
                }

                break;
            default:
                if ((instance->flags2 & 0x8000000))
                {
                    damage = 8192;
                }
                else
                {
                    damage = 12288;
                }
            }

            if (fatal != 0)
            {
                MON_SwitchState(instance, MONSTER_STATE_GENERALDEATH);
            }

            if (damage == 0)
            {
                mv->mvFlags |= 0x40;
                break;
            }
            else
            {
                data->power = damage;
            }
        }
    }
    case 0x1000000:
        if ((!(mv->mvFlags & 0x200040)) && (instance->currentMainState != 10))
        {
            int state;
            struct evMonsterHitData* data;

            data = (struct evMonsterHitData*)message->Data;

            if (data->power >= 12288)
            {
                instance->constrictAngle = 0;
            }

            mv->mvFlags |= 0x40;

            if (INSTANCE_Query(data->sender, 1) == 32)
            {
                MONSENSE_SetEnemy(instance, gameTrackerX.playerInstance);
            }
            else
            {
                MONSENSE_SetEnemy(instance, data->sender);
            }

            if (MON_TakeDamage(instance, data->power, 256) == 0)
            {
                state = 8;
            }
            else if (state = 9, ((mv->mvFlags & 0x2000)))
            {
                state = 16;
            }

            if (state != -1)
            {
                MON_SwitchState(instance, (enum MonsterState)state);
            }

            mv->damageType = 256;
            mv->messageData = data;
        }

        break;
    case 0x1000023:
        if (message->Data != 0)
        {
            if (message->Data == 4096)
            {
                MONSENSE_SetEnemy(instance, gameTrackerX.playerInstance);

                mv->damageType = 1024;

                instance->flags2 |= 0x1000;

                MON_SwitchState(instance, MONSTER_STATE_GENERALDEATH);
            }
            else
            {
                MON_SwitchState(instance, MONSTER_STATE_STUNNED);
            }
        }

        break;
    case 0x1000009:
    {
        struct evMonsterSoulSuckData* data;

        data = (struct evMonsterSoulSuckData*)message->Data;

        if (MATH3D_LengthXYZ(instance->position.x - data->Destination.x, instance->position.y - data->Destination.y, instance->position.z - data->Destination.z) < 7000)
        {
            MON_SwitchState(instance, MONSTER_STATE_GRABBED);
        }

        break;
    }
    case 0x1000014:
        if (message->Data != 0)
        {
            if (mv->soulJuice < 8192)
            {
                mv->soulJuice = 0;
                mv->damageType = 0;

                MON_SwitchState(instance, MONSTER_STATE_GENERALDEATH);
            }
            else
            {
                MON_SwitchState(instance, MONSTER_STATE_EMBRACE);
            }
        }

        break;
    case 0x1000002:
        if (message->Data != 0)
        {
            MONSENSE_SetEnemy(instance, gameTrackerX.playerInstance);

            MON_SwitchState(instance, MONSTER_STATE_GRABBED);

            mv->mvFlags &= ~0x2;
        }
        else if (mv->enemy != NULL)
        {
            mv->enemy->mirConditions |= 0x40;
        }

        break;
    case 0x100000B:
        MON_SwitchState(instance, MONSTER_STATE_FALL);
        break;
    case 0x100000C:
        if ((!(mv->mvFlags & 0x1)) || (instance->currentMainState != 11))
        {
            int vuln;

            switch (message->Data)
            {
            case 16:
                vuln = mv->subAttr->waterVuln;
                break;
            case 32:
                vuln = 0;

                if (!(mv->mvFlags & 0x400))
                {
                    vuln = mv->subAttr->fireVuln;
                }

                break;
            case 64:
                vuln = mv->subAttr->sunVuln;
                break;
            default:
                vuln = 0;
            }

            if (vuln != 0)
            {
                mv->damageType = message->Data;

                INSTANCE_Post(instance, 0x400000, SetFXHitData(NULL, 0, 0, message->Data));
            }

            if (vuln == 1)
            {
                MON_SwitchState(instance, MONSTER_STATE_ENVIRONMENTDAMAGE);
            }
            else if ((vuln != 0) && (vuln < 4))
            {
                mv->mvFlags |= 0x200000;

                MON_SwitchState(instance, MONSTER_STATE_GENERALDEATH);
            }
        }

        break;
    case 0x1000019:
        MONSENSE_SetEnemy(instance, gameTrackerX.playerInstance);

        mv->held = (struct _Instance*)message->Data;

        MON_SwitchState(instance, MONSTER_STATE_MISSILEHIT);
        break;
    case 0x100000A:
        temp3 = (struct evMonsterImpaleData*)message->Data;

        if (temp3 != NULL)
        {
            mv->held = (struct _Instance*)temp3->weapon;

            temp2 = temp3->position.x + ((temp3->distance * rsin(temp3->direction.z)) / 4096);

            instance->position.y = temp3->position.y - ((temp3->distance * rcos(temp3->direction.z)) / 4096);
            instance->position.x = temp2;
            instance->rotation.z = (temp3->direction.z + 2048) & 0xFFF;

            MON_SwitchState(instance, MONSTER_STATE_IMPALEDEATH);
        }
        else if (mv->enemy != NULL)
        {
            mv->enemy->mirConditions |= 0x80;
        }

        break;
    case 0x100001C:
        mv->terrainImpaleID = message->Data;

        MON_MoveInstanceToImpalePoint(instance);

        MON_SwitchState(instance, MONSTER_STATE_TERRAINIMPALEDEATH);
        break;
    case 0x400000:
        ((MONTABLE_DamageEffectFunc)MONTABLE_GetDamageEffectFunc(instance))(instance, message->Data);
        break;
    case 0x1000011:
    {
        struct evMonsterAlarmData* data;
        struct _Instance* enemy;

        data = (struct evMonsterAlarmData*)message->Data;

        enemy = data->sender;

        if ((enemy != NULL) && ((INSTANCE_Query(enemy, 1) & 0xB)) && (MONSENSE_FindIR(mv, enemy) == 0) && (MATH3D_LengthXYZ(instance->position.x - data->position.x, instance->position.y - data->position.y, instance->position.z - data->position.z) < mv->subAttr->senses->alarmRadius))
        {
            struct _MonsterIR* mir;

            mir = MONSENSE_SetEnemy(instance, enemy);

            if (mir != NULL)
            {
                INSTANCE_Post(instance, 0x1000012, (int)mir);
            }
        }

        break;
    }
    case 0x1000012:
    case 0x100000E:
    {
        struct _MonsterIR* mir;

        if ((!(mv->mvFlags & 0x4)) && (mir = (struct _MonsterIR*)message->Data, ((INSTANCE_Query(mir->instance, 1) & 0x1))))
        {
            mv->behaviorState = mv->triggeredBehavior;
        }

        break;
    }
    case 0x1000016:
        if (mv->subAttr->combatAttributes->hitPoints != 0)
        {
            int hp;

            hp = mv->hitPoints + message->Data;

            if (hp >= 24577)
            {
                hp = 24576;
            }

            mv->hitPoints = hp;
        }

        break;
    case 0x100001A:
        if (message->Data != 0)
        {
            if (!(mv->mvFlags & 0x20000000))
            {
                mv->mvFlags |= 0x20000000;
                mv->hitPoints *= 2;
            }
        }
        else if ((mv->mvFlags & 0x20000000))
        {
            mv->mvFlags &= ~0x20000000;
            mv->hitPoints = (mv->hitPoints + 1) / 2;
        }

        break;
    case 0x80005:
        if (mv->subAttr->fireVuln != 0)
        {
            struct evFXHitData data;

            MON_SetFXHitData(instance, &data, 32, 1);

            mv->damageType = 32;

            ((MONTABLE_DamageEffectFunc)MONTABLE_GetDamageEffectFunc(instance))(instance, (int)&data);

            MON_SwitchState(instance, MONSTER_STATE_GENERALDEATH);
            break;
        }
    case 0x80006:
        if (!(ma->whatAmI & 0x10008))
        {
            MON_SwitchState(instance, MONSTER_STATE_GENERALDEATH);

            MON_MonsterGlow(instance, 0xFFFFFF, 70, 10, 20);

            mv->damageType = 64;
        }
        else
        {
            INSTANCE_Post(instance, 0x1000011, SetMonsterAlarmData(gameTrackerX.playerInstance, &gameTrackerX.playerInstance->position, 2));
        }

        break;
    case 0x80002:
        if (instance->petrifyValue == 0)
        {
            MON_SwitchState(instance, MONSTER_STATE_PETRIFIED);

            instance->petrifyValue = 4096;
        }

        break;
    case 0x80004:
        if ((mv->subAttr->waterVuln != 0) && (!(ma->whatAmI & 0x8)))
        {
            MON_SwitchState(instance, MONSTER_STATE_STUNNED);

            MON_MonsterGlow(instance, 0xFF0000, 70, 10, 20);

            mv->damageType = 16;
        }
        else
        {
            INSTANCE_Post(instance, 0x1000011, SetMonsterAlarmData(gameTrackerX.playerInstance, &gameTrackerX.playerInstance->position, 2));
        }

        break;
    case 0x80003:
        if (mv->subAttr->soundVuln != 0)
        {
            struct evFXHitData data;

            MON_SetFXHitData(instance, &data, 512, 16);

            mv->damageType = 512;
            mv->hitPoints = 0;
            mv->mvFlags |= 0x800000;

            ((MONTABLE_DamageEffectFunc)MONTABLE_GetDamageEffectFunc(instance))(instance, (int)&data);

            MON_SwitchState(instance, MONSTER_STATE_STUNNED);
        }
        else
        {
            INSTANCE_Post(instance, 0x1000011, SetMonsterAlarmData(gameTrackerX.playerInstance, &gameTrackerX.playerInstance->position, 2));
        }

        break;
    case 0x80001:
        if ((instance->zVel == 0) && (!(mv->mvFlags & 0x200000)))
        {
            temp = MATH3D_AngleFromPosToPos(&gameTrackerX.playerInstance->position, &instance->position);

            instance->position.z += 120;
            instance->oldPos.z += 120;

            MON_LaunchMonster(instance, temp, 100, 70);
        }

        break;
    case 0x40009:
        mv->damageType = 8192;

        MON_SwitchState(instance, MONSTER_STATE_STUNNED);
        break;
    case 0x4000D:
    {
        struct evPositionData* posData;

        posData = (struct evPositionData*)message->Data;

        mv->auxFlags |= 0x10000000;
        mv->destination.z = posData->z;
        break;
    }
    case 0x40016:
    case 0x4000C:
    {
        struct evPositionData* posData;

        posData = (struct evPositionData*)message->Data;

        mv->destination.x = posData->x;
        mv->destination.y = posData->y;
        mv->destination.z = posData->z;
        mv->mvFlags |= 0x40000;

        MON_SwitchState(instance, MONSTER_STATE_WANDER);
        break;
    }
    case 0x4000F:
    {
        struct evPositionData* posData;

        posData = (struct evPositionData*)message->Data;

        mv->mvFlags |= 0x80000000;
        mv->lookAtPosData.x = posData->x;
        mv->lookAtPosData.y = posData->y;
        mv->lookAtPosData.z = posData->z;
        break;
    }
    case 0x40010:
        mv->mvFlags &= ~0x80000000;
        break;
    case 0x40017:
    {
        static int deaths[9];

        mv->damageType = deaths[message->Data];

        MON_SwitchState(instance, MONSTER_STATE_GENERALDEATH);
        break;
    }
    case 0x2000002:
    {
        struct evMonsterHitData* data;

        data = (struct evMonsterHitData*)message->Data;

        INSTANCE_Post(data->sender, 0x1000000, SetMonsterHitData(instance, NULL, data->power, mv->attackType->knockBackDistance, mv->attackType->knockBackDuration));
        break;
    }
    case 0x40003:
    {
        struct evActionPlayHostAnimationData* data;
        int i;

        data = (struct evActionPlayHostAnimationData*)message->Data;

        for (i = mv->subAttr->numSections - 1; i >= 0; i--)
        {
            G2EmulationInstanceToInstanceSwitchAnimation(instance, data->host, i, data->newAnim, data->newFrame, data->frames, data->mode);
        }

        break;
    }
    case 0x8000008:
    {
        struct evAnimationInstanceSwitchData* data;

        data = (struct evAnimationInstanceSwitchData*)message->Data;

        MON_PlayAnimID(instance, data->anim, data->mode);
        break;
    }
    case 0x1000008:
        break;
    case 0x1000007:
        break;
    case 0x4010080:
        break;
    }
}

void MON_PupateQueueHandler(struct _Instance* instance)  // Matching - 100%
{
	struct _MonsterVars* mv;
	struct __Event* message;

	mv = (struct _MonsterVars*)instance->extraData;

	while (message = DeMessageQueue(&mv->messageQueue))
	{
		MON_PupateMessageHandler(instance, message);
	}
}

void MON_IdleQueueHandler(struct _Instance *instance)  // Matching - 100%
{
	struct _MonsterVars* mv;
	struct __Event* message;

	mv = (struct _MonsterVars*)instance->extraData;

	while (message = DeMessageQueue(&mv->messageQueue))
	{
		MON_IdleMessageHandler(instance, message);
	}
}

void MON_DefaultQueueHandler(struct _Instance* instance)  // Matching - 100%
{
	struct _MonsterVars* mv;
	struct __Event* message;

	mv = (struct _MonsterVars*)instance->extraData;

	while (message = DeMessageQueue(&mv->messageQueue))
	{
		MON_DefaultMessageHandler(instance, message);
	}
}