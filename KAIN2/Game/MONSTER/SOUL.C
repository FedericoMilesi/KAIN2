#include "Game/CORE.H"
#include "SOUL.H"
#include "Game/STATE.H"
#include "Game/MATH3D.H"

struct _MonsterFunctionTable SOUL_FunctionTable;

void SOUL_QueueHandler(struct _Instance* instance)  // Matching - 100%
{
	struct _MonsterVars* mv;
	struct __Event* message;
	mv = (struct _MonsterVars*)instance->extraData;
	while (message = DeMessageQueue(&mv->messageQueue), message != NULL)
	{
		if (message->ID == 0x100000D)
		{
			if (instance->currentMainState != 23)
			{
				MON_SwitchState(instance, (MonsterState)23);
			}
			continue;
		}
		MON_DefaultMessageHandler(instance, message);
	}
}

void SOUL_Physics(struct _Instance* instance, long time)  // Matching - 100%
{
	struct _MonsterVars* mv;
	int a;
	mv = (struct _MonsterVars*)instance->extraData;
	a = -4;
	if ((mv->ambushRange & 0x1F) < 16)
	{
		a = 4;
	}
	instance->zAccl += a;
	mv->ambushRange += 1;
	PhysicsMove(instance, &instance->position, time);
}

void SOUL_Fade(struct _Instance* instance)  // Matching - 99.89%
{
	struct _MonsterVars* mv;
	unsigned long time;
	mv = (struct _MonsterVars*)instance->extraData;
	time = MON_GetTime(instance);
	if ((gameTrackerX.gameFlags & 0x80) == 0)
	{
		if (((unsigned long)mv->lookAtPos < time) != 0)
		{
			if (instance->fadeValue == 0)
			{
				MON_StartSpecialFade(instance, 4096, 100);
			}
			if ((instance->fadeValue < 4096) == 0)
			{
				instance->flags2 |= 0x8000000;
				MORPH_SetupInstanceFlags(instance);
				instance->fadeValue = 0;
			}
		}
	}
	else
	{
		mv->lookAtPos = (_Position*)(time + 6500);
	}
}

void SOUL_MoveToDest(struct _Instance* instance, long maxAccel, long time)  // Matching - 100%
{
	struct _MonsterVars* mv;
	mv = (struct _MonsterVars*)instance->extraData;
	instance->xAccl = (mv->lookAtPosData.y - instance->position.x) - instance->xVel;
	instance->yAccl = (mv->lookAtPosData.z - instance->position.y) - instance->yVel;
	instance->zAccl = (mv->guardRange - instance->position.z) - instance->zVel;
	if ((instance->xAccl < -maxAccel) != 0)
	{
		instance->xAccl = -maxAccel;
	}
	else
	{
		if (maxAccel < instance->xAccl)
		{
			instance->xAccl = maxAccel;
		}
	}
	if (instance->yAccl < -maxAccel)
	{
		instance->yAccl = -maxAccel;
	}
	else
	{
		if (maxAccel < instance->yAccl)
		{
			instance->yAccl = maxAccel;
		}
	}
	if (instance->zAccl < -maxAccel)
	{
		instance->zAccl = -maxAccel;
	}
	else
	{
		if (maxAccel < instance->zAccl)
		{
			instance->zAccl = maxAccel;
		}
	}
	SOUL_Physics(instance, time);
}


// autogenerated function stub: 
// void /*$ra*/ SOUL_MovePastWall(struct _Instance *instance /*$s2*/, struct _Instance *sucker /*$a1*/)
void SOUL_MovePastWall(struct _Instance *instance, struct _Instance *sucker)
{ // line 162, offset 0x8008d974
	/* begin block 1 */
		// Start line: 163
		// Start offset: 0x8008D974
		// Variables:
			//struct _PCollideInfo pcollideInfo; // stack offset -88
			_Position newPos; // stack offset -40
			_Position oldPos; // stack offset -32
			_Position delta; // stack offset -24
			MATRIX *to; // $a0
			MATRIX *from; // $v1
			long tmp; // $v0

		/* begin block 1.1 */
			// Start line: 163
			// Start offset: 0x8008D974
			// Variables:
				short _y0; // $v0
				short _z0; // $a0
				short _y1; // $a1
				short _z1; // $a2
				_Position *_v; // $s0
				_Position *_v0; // $s1
				_Position *_v1; // $t0
		/* end block 1.1 */
		// End offset: 0x8008D974
		// End Line: 163

		/* begin block 1.2 */
			// Start line: 188
			// Start offset: 0x8008DA58
			// Variables:
				//short _x0; // $v0
				//short _y0; // $v1
				//short _z0; // $a2
				//short _x1; // $a3
				//short _y1; // $t1
				//short _z1; // $t0
				//_Position *_v1; // $t0
		/* end block 1.2 */
		// End offset: 0x8008DA58
		// End Line: 188
	/* end block 1 */
	// End offset: 0x8008DACC
	// End Line: 201

	/* begin block 2 */
		// Start line: 336
	/* end block 2 */
	// End Line: 337
				UNIMPLEMENTED();
}

void SOUL_Init(struct _Instance* instance)  // Matching - 100%
{
	struct _MonsterVars* mv;
	mv = (struct _MonsterVars*)instance->extraData;
	MON_DefaultInit(instance);
	mv->mvFlags |= 0x200000 | 0x880;
	instance->maxXVel = 0x258;
	instance->maxYVel = 0x258;
	instance->maxZVel = 0x258;
	instance->flags2 |= 0x20000;
	mv->ambushRange = 0;
	mv->lookAtPos = (_Position*)(MON_GetTime(instance) + 0x1964);
	if (instance->parent != NULL)
	{
		mv->soulID = instance->parent->introUniqueID;
	}
	if ((instance->flags & 2) == 0)
	{
		instance->flags2 |= 0x8000000;
		MON_SwitchState(instance, (MonsterState)2);
	}
}

void SOUL_CleanUp(struct _Instance* instance)
{
	MON_CleanUp(instance);
}

void SOUL_BirthEntry(struct _Instance* instance)//Matching - 99.76%
{
	struct _MonsterVars* mv;

	mv = (struct _MonsterVars*)instance->extraData;

	instance->maxXVel = 15;
	instance->maxYVel = 15;
	instance->maxZVel = 17;

	instance->zAccl = 0;

	instance->zVel = 0;

	instance->position.z += 120;

	mv->generalTimer = MON_GetTime(instance) + 1500;
}

void SOUL_Birth(struct _Instance* instance)  // Matching - 99.81%
{
	struct _MonsterVars* mv;
	instance->zAccl = 0;
	mv = (struct _MonsterVars*)instance->extraData;
	SOUL_Physics(instance, gameTrackerX.timeMult);
	if (MON_GetTime(instance) > ((unsigned int*)&mv->destination.y)[0])
	{
		MON_SwitchState(instance, (MonsterState)2);
	}
	SOUL_QueueHandler(instance);
}

void SOUL_SoulSuckEntry(struct _Instance* instance)
{
	instance->maxXVel = 600;
	instance->maxYVel = 600;
	instance->maxZVel = 17;

	instance->flags &= ~0x800u;
}

long SOUL_CalcAccel(long delta, long vel, long magnitude)//Matching - 43.75%
{
	long rv;

	if (delta > 0)
	{
		if (vel < 0)
		{
			rv = (delta * 16) / magnitude;
		}
		else
		{
			rv = (delta * 5) / magnitude;
		}
	}
	else
	{
		if (vel > 0)
		{
			rv = (delta * 16) / magnitude;
		}
		else
		{
			rv = (delta * 5) / magnitude;
		}
	}

	return rv;
}


// autogenerated function stub: 
// void /*$ra*/ SOUL_SoulSuck(struct _Instance *instance /*$s2*/)
void SOUL_SoulSuck(struct _Instance *instance)
{ // line 313, offset 0x8008dcec
	/* begin block 1 */
		// Start line: 314
		// Start offset: 0x8008DCEC
		// Variables:
			struct _MonsterVars *mv; // $s3
			struct __Event *message; // $s0
			struct _Instance *sucker; // $s4
			struct _Instance *collidedWith; // $s6
			int collisionCnt; // $s5

		/* begin block 1.1 */
			// Start line: 330
			// Start offset: 0x8008DD98
			// Variables:
				long distance; // $s1
				struct evMonsterSoulSuckData *suckData; // $s0

			/* begin block 1.1.1 */
				// Start line: 357
				// Start offset: 0x8008DEBC
				// Variables:
					struct _SVector dir; // stack offset -48

				/* begin block 1.1.1.1 */
					// Start line: 368
					// Start offset: 0x8008DEF0
					// Variables:
						long animLen; // $s0
						long curTim; // $v0

					/* begin block 1.1.1.1.1 */
						// Start line: 379
						// Start offset: 0x8008DF88
						// Variables:
							short _x0; // $a3
							short _y0; // $a0
							short _z0; // $v1
							short _x1; // $v0
							short _y1; // $a2
							short _z1; // $a1
							struct _SVector *_v; // $s7
							_Position *_v0; // $v1
							_Position *_v1; // $a1
					/* end block 1.1.1.1.1 */
					// End offset: 0x8008DF88
					// End Line: 379
				/* end block 1.1.1.1 */
				// End offset: 0x8008E03C
				// End Line: 389
			/* end block 1.1.1 */
			// End offset: 0x8008E03C
			// End Line: 389
		/* end block 1.1 */
		// End offset: 0x8008E074
		// End Line: 398

		/* begin block 1.2 */
			// Start line: 452
			// Start offset: 0x8008E1E8
			// Variables:
				struct _Instance *body; // $v0
		/* end block 1.2 */
		// End offset: 0x8008E208
		// End Line: 456
	/* end block 1 */
	// End offset: 0x8008E264
	// End Line: 469

	/* begin block 2 */
		// Start line: 681
	/* end block 2 */
	// End Line: 682
				UNIMPLEMENTED();
}

void SOUL_WanderEntry(struct _Instance* instance)  // Matching - 100%
{
	struct _MonsterVars* mv;
	mv = (struct _MonsterVars*)instance->extraData;

	instance->maxXVel = 10;
	instance->maxYVel = 10;
	instance->maxZVel = 17;
	if (!(mv->mvFlags & 0x40000))
	{
		if (instance->intro != NULL)
		{
			MON_GetRandomDestinationInWorld(instance, &instance->intro->position, mv->wanderRange);
		}
		else
		{
			MON_GetRandomDestinationInWorld(instance, &instance->position, mv->wanderRange);
		}
	}
}

void SOUL_Wander(struct _Instance* instance) // Matching - 99.95%
{
	struct _MonsterVars* mv;

	mv = (struct _MonsterVars*)instance->extraData;

	if (!(mv->mvFlags & 0x40000))
	{
		if (instance->intro)
		{
			MON_GetRandomDestinationInWorld(instance, &instance->intro->position, mv->lookAngleX);
			instance->zAccl = 0;
		}
		else
		{
			MON_GetRandomDestinationInWorld(instance, &instance->position, mv->lookAngleX);
			instance->zAccl = 0;
		}
	}
	else
	{
		if (MATH3D_LengthXY(mv->lookAtPosData.y - instance->position.x, mv->lookAtPosData.z - instance->position.y) < 100)
		{
			MON_SwitchState(instance, MONSTER_STATE_IDLE);
			instance->zAccl = 0;
		}
		else
		{
			instance->xAccl = mv->lookAtPosData.y - instance->position.x - instance->xVel;
			instance->yAccl = mv->lookAtPosData.z - instance->position.y - instance->yVel;

			if (instance->xAccl >= -2)
			{
				if (instance->xAccl >= 3)
				{
					instance->xAccl = 2;
				}
			}
			else
			{
				instance->xAccl = -2;
			}

			if (instance->yAccl >= -2)
			{
				if (instance->yAccl >= 3)
				{
					instance->yAccl = 2;
				}
			}
			else
			{
				instance->yAccl = -2;
			}
			instance->zAccl = 0;
		}
	}

	SOUL_Physics(instance, gameTrackerX.timeMult);
	if (!(mv->mvFlags & 4))
	{
		if (!(instance->flags2 & 0x8000000))
		{
			SOUL_Fade(instance);
		}

		if (mv->enemy)
		{
			MON_SwitchState(instance, MONSTER_STATE_FLEE);
		}
	}

	SOUL_QueueHandler(instance);
}

void SOUL_FleeEntry(struct _Instance* instance)
{
	instance->maxXVel = 15;
	instance->maxYVel = 15;
	instance->maxZVel = 17;

	MON_FleeEntry(instance);
}


// autogenerated function stub: 
// void /*$ra*/ SOUL_Flee(struct _Instance *instance /*$s0*/)
void SOUL_Flee(struct _Instance *instance)
{ // line 543, offset 0x8008e4c4
	/* begin block 1 */
		// Start line: 544
		// Start offset: 0x8008E4C4
		// Variables:
			struct _MonsterVars *mv; // $v0

		/* begin block 1.1 */
			// Start line: 553
			// Start offset: 0x8008E500
			// Variables:
				struct _Instance *enemy; // $a0
				int dx; // $s1
				int dy; // $v0
		/* end block 1.1 */
		// End offset: 0x8008E5E4
		// End Line: 568
	/* end block 1 */
	// End offset: 0x8008E614
	// End Line: 574

	/* begin block 2 */
		// Start line: 1186
	/* end block 2 */
	// End Line: 1187
				UNIMPLEMENTED();
}

void SOUL_IdleEntry(struct _Instance* instance) // Matching - 100%
{
	struct _MonsterVars* mv;

	mv = (struct _MonsterVars*)instance->extraData;
	instance->maxXVel = 15;
	instance->maxYVel = 15;
	instance->maxZVel = 17;
	*(long*)&mv->destination.y = MON_GetTime(instance) + 3000 + (rand() % 3000);
	mv->mvFlags &= 0xFFFBFFFF;
}

void SOUL_Idle(struct _Instance* instance) // Matching - 99.92%
{
	struct _MonsterVars* mv;
	long xAccl;
	long yAccl;

	mv = (struct _MonsterVars*)instance->extraData;
	xAccl = 3;
	if (instance->xVel >= -3)
	{
		xAccl = -3;
		if (instance->xVel < 4)
		{
			xAccl = 0 - instance->xVel;
		}
	}
	yAccl = 3;
	if (instance->yVel >= -3)
	{
		yAccl = -3;
		if (instance->yVel < 4)
		{
			yAccl = 0 - instance->yVel;
		}
	}
	instance->xAccl = xAccl;
	instance->yAccl = yAccl;
	instance->zAccl = 0;
	SOUL_Physics(instance, gameTrackerX.timeMult);
	if (!(mv->mvFlags & 4))
	{
		if (mv->enemy != 0)
		{
			MON_SwitchState(instance, MONSTER_STATE_FLEE);
		}
		else if ((MON_GetTime(instance)) > *(unsigned int*)&mv->destination.y)
		{
			MON_SwitchState(instance, MONSTER_STATE_WANDER);
		}

		if (!(instance->flags2 & 0x08000000))
		{
			SOUL_Fade(instance);
		}
	}
	SOUL_QueueHandler(instance);
}

void SOUL_ReanimateEntry(struct _Instance* instance) // Matching - 100%
{
	struct _MonsterVars* mv;
	struct _Instance* body;

	mv = (struct _MonsterVars*)instance->extraData;
	body = INSTANCE_Find(mv->soulID);
	mv->lookAtPosData.y = body->position.x;
	mv->lookAtPosData.z = body->position.y;
	mv->guardRange = body->position.z + 160;
	MON_TurnOffBodySpheres(instance);
}

void SOUL_Reanimate(struct _Instance* instance) // Matching - 99.89%
{
	struct _MonsterVars* mv;
	struct _Instance* body;

	mv = (struct _MonsterVars*)instance->extraData;
	SOUL_MoveToDest(instance, 16, gameTrackerX.timeMult);
	if (MATH3D_LengthXY((instance->position).x - mv->lookAtPosData.y, instance->position.y - mv->lookAtPosData.z) < 250)
	{
		if (mv->soulID != 0)
		{
			body = INSTANCE_Find(mv->soulID);
			if (body != 0)
			{
				INSTANCE_Post(body, 0x0100000D, 0);
			}
			SAVE_DeleteInstance(instance);
		}
		MON_KillMonster(instance);
		return;
	}
	while (DeMessageQueue(&mv->messageQueue));
}

void SOUL_Effect(struct _Instance* instance, struct evFXHitData* data)
{
}