#include "CORE.H"
#include "SPLINE.H"


void _SplineS2Pos(struct vecS* p, long s, struct SplineKey* key, struct SplineKey* key2) // Matching - 100%
{
	long s2;
	long s3;
	long h0;
	long h1;
	long h2;
	long h3;
	int temp, temp2; // not from SYMDUMP

	if (s != 0)
	{
		s2 = (s * s) >> 15;

		temp = s2 * 2;

		s3 = (s2 * s) >> 15;

		temp2 = s3 * 2;

		h0 = (temp2 - (s2 * 3)) + 32768;

		h1 = (temp - temp2) + s2;

		h2 = (s3 - temp) + s;

		h3 = s3 - s2;

		p->x = (short)(((key->point.x * h0) + (key2->point.x * h1) + (key->dd.x * h2) + (key2->ds.x * h3)) >> 15);
		p->y = (short)(((key->point.y * h0) + (key2->point.y * h1) + (key->dd.y * h2) + (key2->ds.y * h3)) >> 15);
		p->z = (short)(((key->point.z * h0) + (key2->point.z * h1) + (key->dd.z * h2) + (key2->ds.z * h3)) >> 15);
	}
	else
	{
		p->x = key->point.x;
		p->y = key->point.y;
		p->z = key->point.z;
	}
}


// autogenerated function stub: 
// void /*$ra*/ SplineSetDefDenom(struct Spline *spline /*$a0*/, struct SplineDef *def /*$a1*/, int denomFlag /*$a2*/)
void SplineSetDefDenom(struct Spline *spline, struct SplineDef *def, int denomFlag)
{ // line 132, offset 0x80040d88
	/* begin block 1 */
		// Start line: 140
		// Start offset: 0x80040D88
		// Variables:
			unsigned long denom; // $v1
	/* end block 1 */
	// End offset: 0x80040E44
	// End Line: 165

	/* begin block 2 */
		// Start line: 264
	/* end block 2 */
	// End Line: 265

	/* begin block 3 */
		// Start line: 257
	/* end block 3 */
	// End Line: 258

	/* begin block 4 */
		// Start line: 263
	/* end block 4 */
	// End Line: 264
			UNIMPLEMENTED();
}


unsigned short SplineGetFrameNumber(struct Spline* spline, struct SplineDef* def) // Matching - 100%
{
	unsigned short frame;
	unsigned int i;
	struct SplineKey* key;
	struct SplineDef temp;

	if ((spline == NULL) || (def == NULL))
	{
		frame = 0xFFFF;
	}
	else
	{
		key = spline->key;

		temp = *def;

		frame = 0;

		for (i = 0; i < (unsigned)def->currkey; i++, key++)
		{
			frame += key->count;
		}

		temp.currkey = i;

		SplineSetDefDenom(spline, &temp, 0);

		frame += (unsigned short)(temp.fracCurr >> 12);
	}

	return frame & 0xFFFF;
}


// autogenerated function stub: 
// short /*$ra*/ SplineSetDef2FrameNumber(struct Spline *spline /*$a0*/, struct SplineDef *def /*$a1*/, unsigned short frame_number /*$a2*/)
short SplineSetDef2FrameNumber(struct Spline *spline, struct SplineDef *def, unsigned short frame_number)
{ // line 288, offset 0x80040ee0
	/* begin block 1 */
		// Start line: 289
		// Start offset: 0x80040EE0
		// Variables:
			unsigned long isRot; // $t3
			short status; // $t4
			struct SplineKey *key; // $t0
			struct SplineRotKey *rkey; // $a3
			unsigned short frame; // $t2
			short deltaFrame; // $t1
	/* end block 1 */
	// End offset: 0x80041004
	// End Line: 347

	/* begin block 2 */
		// Start line: 481
	/* end block 2 */
	// End Line: 482

	/* begin block 3 */
		// Start line: 493
	/* end block 3 */
	// End Line: 494
			UNIMPLEMENTED();
	return 0;
}


short SplineIsWhere(struct Spline* spline, struct SplineDef* def) // Matching - 100%
{
	short curr;

	curr = (short)(def->fracCurr >> 12);

	if (curr == 0)
	{
		if (def->currkey == 0)
		{
			return -1;
		}
	}

	if ((curr == (spline->numkeys - 1)) && (def->currkey == 0))
	{
		return 1;
	}

	return 0;
}


short SplineMultiIsWhere(struct MultiSpline* multi) // Matching - 100%
{
	short where;

	where = 0;

	if (multi->positional != NULL)
	{
		where = SplineIsWhere(multi->positional, &multi->curPositional);
	}

	if ((multi->rotational != NULL) && (where == 0))
	{
		where = SplineIsWhere((struct Spline*)multi->rotational, &multi->curRotational);
	}

	if ((multi->scaling != NULL) && (where == 0))
	{
		where = SplineIsWhere(multi->scaling, &multi->curScaling);
	}

	return where;
}

struct _G2Quat_Type* SplineGetFirstRot(struct RSpline* rspline, struct SplineDef* def)  // Matching - 100%
{
	if (rspline == NULL)
	{
		return NULL;
	}

	def->fracCurr = 0;
	def->currkey = 0;
	def->denomFlag = 0;

	return &rspline->key->q;
}

struct _SVector* SplineGetFirstPoint(struct Spline* spline, struct SplineDef* def)  // Matching - 100%
{
	if (spline == NULL)
	{
		return NULL;
	}

	def->fracCurr = 0;
	def->currkey = 0;
	def->denomFlag = 0;

	return (struct _SVector*)&spline->key->point;
}

struct _SVector* SplineGetNextPoint(struct Spline* spline, struct SplineDef* def)  // Matching - 100%
{
	static struct _SVector point;

	if (SplineGetNext(spline, def) != 0)
	{
		if (SplineGetData(spline, def, &point) != 0)
		{
			return &point;
		}
	}

	return NULL;
}

struct _SVector* SplineGetPreviousPoint(struct Spline* spline, struct SplineDef* def)  // Matching - 100%
{
	static struct _SVector point;

	if (SplineGetPrev(spline, def) != 0)
	{
		if (SplineGetData(spline, def, &point) != 0)
		{
			return &point;
		}
	}

	return NULL;
}


// autogenerated function stub: 
// struct _SVector * /*$ra*/ SplineGetNearestPoint(struct Spline *spline /*$fp*/, struct _SVector *point /*$s4*/, struct SplineDef *def /*$t1*/)
struct _SVector * SplineGetNearestPoint(struct Spline *spline, struct _SVector *point, struct SplineDef *def)
{ // line 539, offset 0x80041204
	/* begin block 1 */
		// Start line: 540
		// Start offset: 0x80041204
		// Variables:
			static struct _SVector dpoint; // offset 0x18
			long dist; // $a1
			long dist1; // $v0
			long closest_dist; // $s6
			int closest_keyframe; // $s3
			int adjacent_keyframe; // $s5
			int closest_ib; // $s2
			int saved_closest_key_dist; // stack offset -56
			int i; // $s0
			int frame_count; // $s7
			int swapped_keys; // stack offset -52
			struct SplineKey *key; // $a3
			struct _Vector d; // stack offset -80
			struct SplineDef tempdef; // stack offset -64
	/* end block 1 */
	// End offset: 0x80041578
	// End Line: 681

	/* begin block 2 */
		// Start line: 900
	/* end block 2 */
	// End Line: 901
			UNIMPLEMENTED();
	return null;
}


// autogenerated function stub: 
// unsigned long /*$ra*/ SplineGetData(struct Spline *spline /*$s1*/, struct SplineDef *def /*$s0*/, void *p /*$s4*/)
unsigned long SplineGetData(struct Spline *spline, struct SplineDef *def, void *p)
{ // line 933, offset 0x800415c0
	/* begin block 1 */
		// Start line: 934
		// Start offset: 0x800415C0
		// Variables:
			unsigned long gotDataOk; // $s3
			unsigned long isRot; // $s2
			int count; // $v1
			struct _G2Quat_Type quat; // stack offset -40
			struct _G2EulerAngles_Type ea; // stack offset -32

		/* begin block 1.1 */
			// Start line: 965
			// Start offset: 0x80041694
		/* end block 1.1 */
		// End offset: 0x80041694
		// End Line: 966

		/* begin block 1.2 */
			// Start line: 976
			// Start offset: 0x800416D0
		/* end block 1.2 */
		// End offset: 0x800416D0
		// End Line: 977

		/* begin block 1.3 */
			// Start line: 990
			// Start offset: 0x8004174C
			// Variables:
				short _x1; // $v1
				short _y1; // $a0
				short _z1; // $v0
				struct vecS *_v1; // $v0
		/* end block 1.3 */
		// End offset: 0x80041778
		// End Line: 990
	/* end block 1 */
	// End offset: 0x800417AC
	// End Line: 1000

	/* begin block 2 */
		// Start line: 1866
	/* end block 2 */
	// End Line: 1867
				UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// unsigned long /*$ra*/ SplineGetQuatData(struct Spline *spline /*$s1*/, struct SplineDef *def /*$s0*/, void *p /*$s3*/)
unsigned long SplineGetQuatData(struct Spline *spline, struct SplineDef *def, void *p)
{ // line 1003, offset 0x800417d0
	/* begin block 1 */
		// Start line: 1004
		// Start offset: 0x800417D0
		// Variables:
			unsigned long gotDataOk; // $s2
			int count; // $a0
			struct _G2Quat_Type quat; // stack offset -32

		/* begin block 1.1 */
			// Start line: 1023
			// Start offset: 0x80041868
		/* end block 1.1 */
		// End offset: 0x80041868
		// End Line: 1024
	/* end block 1 */
	// End offset: 0x800418E4
	// End Line: 1039

	/* begin block 2 */
		// Start line: 1703
	/* end block 2 */
	// End Line: 1704
			UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// unsigned long /*$ra*/ SplineGetNext(struct Spline *spline /*$s1*/, struct SplineDef *def /*$s0*/)
unsigned long SplineGetNext(struct Spline *spline, struct SplineDef *def)
{ // line 1052, offset 0x80041904
	/* begin block 1 */
		// Start line: 1053
		// Start offset: 0x80041904
		// Variables:
			unsigned long movedSplineOk; // $s3
			int count; // $s2
	/* end block 1 */
	// End offset: 0x80041A00
	// End Line: 1106

	/* begin block 2 */
		// Start line: 1805
	/* end block 2 */
	// End Line: 1806
			UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// unsigned long /*$ra*/ SplineGetPrev(struct Spline *spline /*$s0*/, struct SplineDef *def /*$s1*/)
unsigned long SplineGetPrev(struct Spline *spline, struct SplineDef *def)
{ // line 1118, offset 0x80041a20
	/* begin block 1 */
		// Start line: 1119
		// Start offset: 0x80041A20
		// Variables:
			unsigned long movedSplineOk; // $s2
			unsigned long isRot; // $a1
			int count; // $v0
	/* end block 1 */
	// End offset: 0x80041B30
	// End Line: 1184

	/* begin block 2 */
		// Start line: 1941
	/* end block 2 */
	// End Line: 1942
			UNIMPLEMENTED();
	return 0;
}


unsigned long SplineGetOffsetNext(struct Spline* spline, struct SplineDef* def, long fracOffset) // Matching - 100%
{
	unsigned long movedSplineOk;
	unsigned long isRot;
	int count;

	movedSplineOk = 0;

	if ((spline != NULL) && (def != NULL))
	{
		isRot = spline->type == 1;

		if (def->currkey < spline->numkeys)
		{
			movedSplineOk = 1;

			if (isRot != 0)
			{
				count = ((struct RSpline*)spline)->key[def->currkey].count;
			}
			else
			{
				count = spline->key[def->currkey].count;
			}

			if (count <= 0)
			{
				count = 1;
			}

			SplineSetDefDenom(spline, def, 0);

			def->fracCurr += fracOffset;

			while (count < (def->fracCurr >> 12))
			{
				def->currkey++;
				def->fracCurr -= count << 12;

				if ((spline->numkeys - 1) < def->currkey)
				{
					if (((spline->flags & 0x4)) || ((spline->flags & 0x2)))
					{
						def->currkey = 0;
					}
					else
					{
						def->currkey = spline->numkeys - 1;

						movedSplineOk = 0;
					}
				}

				if ((spline->numkeys - 1) >= def->currkey)
				{
					if (isRot != 0)
					{
						count = ((struct RSpline*)spline)->key[def->currkey].count;
					}
					else
					{
						count = spline->key[def->currkey].count;
					}

					if (count <= 0)
					{
						count = 1;
					}
				}
			}
		}
		else
		{
			printf("def->currkey=%d spline->numkeys=%d\n", def->currkey, spline->numkeys);
		}
	}

	return movedSplineOk;
}


// autogenerated function stub: 
// unsigned long /*$ra*/ SplineGetOffsetPrev(struct Spline *spline /*$s1*/, struct SplineDef *def /*$s0*/, long fracOffset /*$s3*/)
unsigned long SplineGetOffsetPrev(struct Spline *spline, struct SplineDef *def, long fracOffset)
{ // line 1284, offset 0x80041d30
	/* begin block 1 */
		// Start line: 1285
		// Start offset: 0x80041D30
		// Variables:
			unsigned long movedSplineOk; // $s2
			unsigned long isRot; // $a1
			int count; // $v1
	/* end block 1 */
	// End offset: 0x80041E84
	// End Line: 1350

	/* begin block 2 */
		// Start line: 2280
	/* end block 2 */
	// End Line: 2281
			UNIMPLEMENTED();
	return 0;
}

struct _SVector* SplineGetOffsetNextPoint(struct Spline* spline, struct SplineDef* def, long offset)  // Matching - 100%
{
	static struct _SVector point;

	if (SplineGetOffsetNext(spline, def, offset) != 0)
	{
		if (SplineGetData(spline, def, &point) != 0)
		{
			return &point;
		}
	}

	return NULL;
}

struct _SVector* SplineGetOffsetPreviousPoint(struct Spline* spline, struct SplineDef* def, long offset)  // Matching - 100%
{
	static struct _SVector point;

	if (SplineGetOffsetPrev(spline, def, offset) != 0)
	{
		if (SplineGetData(spline, def, &point) != 0)
		{
			return &point;
		}
	}

	return NULL;
}