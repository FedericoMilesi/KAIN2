#include "CORE.H"
#include "GAMELOOP.H"
#include "SOUND.H"
#include "PSX/AADSFX.H"
#include "PSX/AADLIB.H"
#include "STRMLOAD.H"
#include "FONT.H"
#include "MEMPACK.H"
#include "STREAM.H"
#include "Game/CAMERA.H"
#include "Game/MATH3D.H"

char soundBuffer[sizeof(struct AadMemoryStruct) + (sizeof(struct _AadSequenceSlot) * 4)];

struct MusicLoadInfo musicInfo; // offset 0x800D1510

int gSramFreeBlocks; // offset 0x800D1500

int gSramFullAlarm; // offset 0x800CEA88

int gSramFullMsgCnt; // offset 0x800CEA8C

int gSramLargestFree; // offset 0x800D12BC

int gSramTotalFree; // offset 0x800D150C

int gSramTotalUsed; // offset 0x800D1508

int gSramUsedBlocks; // offset 0x800D1504

struct SoundEffectChannel soundEffectChannelTbl[16];

struct SoundEffectChannel* SndOpenSfxChannel(unsigned char* channelNum)
{
	int i;
	
	for (i = 0; i < 16; i++)
	{
		if (soundEffectChannelTbl[i].inUse == 1)
		{
			soundEffectChannelTbl[i].inUse = 255;
			soundEffectChannelTbl[i].pitchChangeTime = 0;
			soundEffectChannelTbl[i].volumeChangeTime = 0;

			channelNum[0] = i;

			return &soundEffectChannelTbl[i];
		}
	}

	return NULL;
}

void SndCloseSfxChannel(int channelNum)
{
	if (channelNum < 16)
	{
		soundEffectChannelTbl[channelNum].inUse = 0;
	}
}

struct SoundEffectChannel* SndGetSfxChannel(int channelNum)
{
	if (channelNum < 16)
	{
		return &soundEffectChannelTbl[channelNum];
	}

	return NULL;
}

void SOUND_ProcessInstanceSounds(unsigned char* sfxFileData, struct SoundInstance* soundInstTbl, struct _Position* position, int livesInOnePlace, int inSpectral, int hidden, int burning, long* triggerFlags)//Matching - 84.70%
{
	int numSounds;
	int numSfxIDs;
	int i;

	if (gameTrackerX.gameMode != 6 && sfxFileData != NULL && soundInstTbl != NULL &&
		*sfxFileData++ == 190 && *sfxFileData++ == 239)
	{
		numSounds = *sfxFileData;

		sfxFileData += 2;

		for (i = 0; i < numSounds; i++)
		{
			switch (*sfxFileData)
			{
			default:
			{
				sfxFileData += 3;
			}
			break;
			case 0:
			{
				processPeriodicSound(position, livesInOnePlace, inSpectral, hidden, burning, soundInstTbl, (struct ObjectPeriodicSound*)sfxFileData);

				numSfxIDs = (sfxFileData[1] * 2) + 18;

				break;
			}
			case 1:
			{
				processEventSound(position, soundInstTbl, (struct ObjectEventSound*)sfxFileData);

				numSfxIDs = (sfxFileData[1] * 2) + 14;

				break;
			}
			case 2:
			case 3:
			case 4:
			{
				processOneShotSound(position, hidden, burning, triggerFlags, soundInstTbl, (struct ObjectOneShotSound*)sfxFileData);

				numSfxIDs = (sfxFileData[1] * 2) + 14;

				break;
			}
			}

			sfxFileData += numSfxIDs;

			soundInstTbl++;
		}
	}
}


// autogenerated function stub: 
// void /*$ra*/ SOUND_EndInstanceSounds(unsigned char *sfxFileData /*$s0*/, struct SoundInstance *soundInstTbl /*$a1*/)
void SOUND_EndInstanceSounds(unsigned char *sfxFileData, struct SoundInstance *soundInstTbl)
{ // line 149, offset 0x8003e86c
	UNIMPLEMENTED();
}


int isOkayToPlaySound(int flags, int spectralPlane, int hidden, int burning) // Matching - 99.93%
{
	int mask;
	int tod;

	if ((flags & 0x0F) != 0)
	{
		tod = GAMELOOP_GetTimeOfDay();

		switch (tod)
		{
		case 600:
			mask = 1;
			break;
		case 700:
		default:
			mask = 2;
			break;
		case 0x708:
			mask = 4;
			break;
		case 0x76C:
			mask = 8;
			break;
		}

		if ((flags & mask) == 0)
		{
			return 0;
		}
	}

	if ((flags & 0x10) != 0 && spectralPlane == 0)
	{
		return 0;
	}

	if ((flags & 0x20) != 0 && spectralPlane != 0)
	{
		return 0;
	}

	if ((flags & 0x40) != 0 && hidden != 0)
	{
		return 0;
	}

	if ((flags & 0x80) != 0 && burning == 0)
	{
		return 0;
	}

	return 1;
}


// autogenerated function stub: 
// void /*$ra*/ setPeriodicSoundStateOff(struct SoundInstance *soundInst /*$s0*/, struct ObjectPeriodicSound *sound /*$s1*/)
void setPeriodicSoundStateOff(struct SoundInstance *soundInst, struct ObjectPeriodicSound *sound)
{ // line 266, offset 0x8003eaec
	UNIMPLEMENTED();
}


void processPeriodicSound(struct _Position* position, int livesInOnePlane, int inSpectral, int hidden, int burning, struct SoundInstance* soundInst, struct ObjectPeriodicSound* sound) // Matching - 86.78%
{
	struct SoundEffectChannel* channel;
	int sfxIDNum;
	int sfxToneID;
	int spectralPlane;

	spectralPlane = gameTrackerX.gameData.asmData.MorphType;

	switch (soundInst->state & 0xf)
	{
		default:
		case 0:
		{
			soundInst->channel = -1;
			soundInst->state = 1;
			soundInst->delay = sound->initialDelay;

			if (sound->initialDelayVariation == 0)
			{
				return;
			}

			soundInst->delay += (sound->initialDelayVariation - (char)(rand() % ((unsigned int)sound->initialDelayVariation << 1)));
			return;
		}
		case 3:
		case 1:
		{
			if (!(livesInOnePlane == 0 || (inSpectral != 0 ? spectralPlane != 0 : spectralPlane == 0)))
			{
				return;
			}

			if (!isOkayToPlaySound(sound->flags, spectralPlane, hidden, burning))
			{
				return;
			}

			if (soundInst->delay != 0)
			{
				soundInst->delay--;
				return;
			}

			channel = SndOpenSfxChannel(&soundInst->channel);
			if (channel == NULL)
			{
				return;
			}

			channel->volume = (unsigned short)sound->maxVolume;
			if (sound->maxVolVariation != 0)
			{
				channel->volume += ((unsigned short)sound->maxVolVariation - (short)(rand() % ((unsigned int)sound->maxVolVariation << 1)));
			}

			channel->pitch = sound->pitch;
			if (sound->pitchVariation != 0)
			{
				channel->pitch += (sound->pitchVariation - (short)(rand() % ((unsigned int)sound->pitchVariation << 1)));
			}

			if (sound->numSfxIDs >= 2)
			{
				sfxIDNum = rand() % (unsigned int)sound->numSfxIDs;
			}
			else
			{
				sfxIDNum = 0;
			}

			sfxIDNum <<= 1;
			sfxToneID = *((unsigned short*)&((struct ObjectPeriodicSound*)((*(int*)&sound) + sfxIDNum))[1]);

			channel->handle = SOUND_Play3dSound(position, sfxToneID, channel->pitch, channel->volume, sound->minVolDistance);
			if (channel->handle != 0)
			{
				soundInst->state = 2;
				soundInst->delay = sound->onTime;

				if (sound->onTimeVariation == 0)
				{
					return;
				}

				soundInst->delay += (sound->onTimeVariation - (char)(rand() % ((unsigned int)sound->onTimeVariation << 1)));
				return;
			}

			SndCloseSfxChannel(soundInst->channel);
			soundInst->channel = -1;
			return;
		}
		case 2:
		{
			channel = SndGetSfxChannel(soundInst->channel);

			if (SndIsPlayingOrRequested(channel->handle) == 0)
			{
				setPeriodicSoundStateOff(soundInst, sound);
				return;
			}

			if (SndIsPlaying(channel->handle) == 0)
			{
				return;
			}

			if (!(livesInOnePlane == 0 || (inSpectral != 0 ? spectralPlane != 0 : spectralPlane == 0)))
			{
				return;
			}

			if (isOkayToPlaySound(sound->flags, spectralPlane, hidden, burning))
			{
				if (soundInst->delay == 0)
				{
					if (sound->offTime != 0)
					{
						SndEndLoop(channel->handle);
						setPeriodicSoundStateOff(soundInst, sound);
					}
					else
					{
						if (sound->maxVolVariation != 0)
						{
							channel->volume = sound->maxVolume;
							channel->volume += ((unsigned short)sound->maxVolVariation - (short)(rand() % ((unsigned int)sound->maxVolVariation << 1)));
						}

						if (sound->pitchVariation != 0)
						{
							channel->pitch = sound->pitch;
							channel->pitch += (sound->pitchVariation - (short)(rand() % ((unsigned int)sound->pitchVariation << 1)));
						}

						soundInst->delay = sound->onTime;
						if (sound->onTimeVariation != 0)
						{
							soundInst->delay += (sound->onTimeVariation - (char)(rand() % ((unsigned int)sound->onTimeVariation << 1)));
						}
					}
				}
				else
				{
					soundInst->delay--;
				}

				if ((soundInst->state & 0x10) == 0)
				{
					break;
				}

				soundInst->state &= 0xef;

				if (SOUND_Update3dSound(position, channel->handle, channel->pitch, channel->volume, sound->minVolDistance))
				{
					return;
				}
			}

			SndEndLoop(channel->handle);
			setPeriodicSoundStateOff(soundInst, sound);

			return;
		}
	}

	soundInst->state |= 0x10;
}

void processEventSound(struct _Position* position, struct SoundInstance* soundInst, struct ObjectEventSound* sound)//Matching - 88.07%
{
	int spectralPlane;
	int sfxIDNum;
	struct SoundEffectChannel* channel;

	spectralPlane = gameTrackerX.gameData.asmData.MorphType;
	sfxIDNum = soundInst->state & 0xF;

	if (sfxIDNum != 1)
	{
		if (sfxIDNum < 2 || (soundInst->state & 0xF) != 2)
		{
			soundInst->channel = -1;
			soundInst->state = 1;
			soundInst->delay = 0;

			return;
		}
		
		channel = SndGetSfxChannel(soundInst->channel);

		if (channel)
		{
			if (!SndIsPlayingOrRequested(channel->handle))
			{
				SndCloseSfxChannel(soundInst->channel);

				soundInst->channel = -1;
				
				soundInst->state = 1;
				return;
			}

			if (SndIsPlaying(channel->handle))
			{
				if (channel->pitchChangeTime)
				{
					channel->pitch = channel->pitch + channel->pitchChangePerUpdate;
					
					channel->pitchChangeError = channel->pitchChangeError + channel->pitchChangeErrPerUpdate;

					if (channel->pitchChangeError >= channel->pitchChangeTimeSave)
					{
						channel->pitch += channel->pitchChangeSign;
						
						channel->pitchChangeError = channel->pitchChangeError - channel->pitchChangeTimeSave;
					}
					
					--channel->pitchChangeTime;
				}
				if (channel->volumeChangeTime)
				{
					channel->volume = channel->volume + channel->volumeChangePerUpdate;
					
					channel->volumeChangeError = channel->volumeChangeError + channel->volumeChangeErrPerUpdate;
					
					if (channel->volumeChangeError >= channel->volumeChangeTimeSave)
					{
						channel->volume += channel->volumeChangeSign;
						channel->volumeChangeError = channel->volumeChangeError - channel->volumeChangeTimeSave;
					}
					
					--channel->volumeChangeTime;
				}

				if ((soundInst->state & 0x10) != 0)
				{
					soundInst->state &= 0xEF;

					if (!SOUND_Update3dSound(position, channel->handle, channel->pitch, channel->volume, sound->minVolDistance))
					{
						SndEndLoop(channel->handle);

						SndCloseSfxChannel(soundInst->channel);

						soundInst->channel = -1;
					}
				}
				else
				{
					soundInst->state |= 0x10;
				}

				if (!isOkayToPlaySound(sound->flags, spectralPlane, 0, 0))
				{
					SndEndLoop(channel->handle);

					SndCloseSfxChannel(soundInst->channel);

					soundInst->channel = -1;
				}
			}
		}
		else if (isOkayToPlaySound(sound->flags, spectralPlane, 0, 0))
		{
			channel = SndOpenSfxChannel(&soundInst->channel);

			if (channel != NULL)
			{
				channel->volume = sound->maxVolume;
				
				if (sound->maxVolVariation)
				{
					channel->volume += (sound->maxVolVariation - (rand() % (2 * sound->maxVolVariation)));
				}

				channel->pitch = sound->pitch;
				
				if (sound->pitchVariation)
				{
					channel->pitch += sound->pitchVariation - rand() % (2 * sound->pitchVariation);
				}

				sfxIDNum = (sound->numSfxIDs < 2) ? 0 : ((rand() % sound->numSfxIDs));

				channel->handle = SOUND_Play3dSound(position, ((unsigned short*)(sound + 1))[sfxIDNum], channel->pitch, channel->volume, sound->minVolDistance);
				
				if (!channel)
				{
					SndCloseSfxChannel(soundInst->channel);
				}

				soundInst->channel = -1;
			}
		}
	}
}

void SOUND_StartInstanceSound(struct SoundInstance* soundInst)
{
	if ((soundInst->state & 0xF) == 1)
	{
		soundInst->state = 2;
	}
}

void SOUND_StopInstanceSound(struct SoundInstance* soundInst)//Matching - 99.35%
{
	struct SoundEffectChannel* channel;

	channel = (struct SoundEffectChannel*)SndGetSfxChannel(soundInst->channel);
	
	if (channel != NULL)
	{
		SndEndLoop(channel->handle);

		SndCloseSfxChannel(soundInst->channel);

		soundInst->channel = -1;
	}

	soundInst->state = 1;
}


// autogenerated function stub: 
// int /*$ra*/ SOUND_IsInstanceSoundLoaded(unsigned char *sfxFileData /*$a0*/, long soundNumber /*$a1*/)
int SOUND_IsInstanceSoundLoaded(unsigned char* sfxFileData, long soundNumber)
{ // line 594, offset 0x8003f438
	UNIMPLEMENTED();
	return 0;
}

// autogenerated function stub: 
// void /*$ra*/ SOUND_SetInstanceSoundPitch(struct SoundInstance *soundInst /*$a0*/, long pitchChangeAmt /*$s1*/, long time /*$s0*/)
void SOUND_SetInstanceSoundPitch(struct SoundInstance *soundInst, long pitchChangeAmt, long time)
{ // line 665, offset 0x8003f534
	UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ SOUND_SetInstanceSoundVolume(struct SoundInstance *soundInst /*$a0*/, long volumeChangeAmt /*$s0*/, long time /*$s1*/)
void SOUND_SetInstanceSoundVolume(struct SoundInstance *soundInst, long volumeChangeAmt, long time)
{ // line 694, offset 0x8003f5f4
	UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ processOneShotSound(_Position *position /*$s6*/, int hidden /*$t0*/, int burning /*$t1*/, long *triggerFlags /*$s4*/, struct SoundInstance *soundInst /*stack 16*/, struct ObjectOneShotSound *sound /*stack 20*/)
void processOneShotSound(_Position *position, int hidden, int burning, long *triggerFlags, struct SoundInstance *soundInst, struct ObjectOneShotSound *sound)
{ // line 741, offset 0x8003f6f8
	/* begin block 1 */
		// Start line: 742
		// Start offset: 0x8003F6F8
		// Variables:
			struct SoundEffectChannel *channel; // $s0
			int sfxIDNum; // $v1
			int sfxToneID; // $a1
			long triggerMask; // $s3
			int spectralPlane; // $a1
	/* end block 1 */
	// End offset: 0x8003FA18
	// End Line: 848

	/* begin block 2 */
		// Start line: 1482
	/* end block 2 */
	// End Line: 1483
			UNIMPLEMENTED();
}

unsigned long SOUND_Play3dSound(_Position* position, int sfxToneID, int pitch, int maxVolume, int minVolDist)
{
	long dx;
	long dy;
	long dz;
	long objDist;
	long workMinVolDist;
	int angle;
	int quadrant;
	int qpos;
	int pan;
	int volume;

	if (maxVolume != 0)
	{
		if (minVolDist == 0)
		{
			return SndPlayVolPan(sfxToneID, maxVolume, 64, pitch);
		}
		
		workMinVolDist = minVolDist;

		if (theCamera.mode == 5 && (gameTrackerX.gameFlags & 0x10))
		{
			dx = position->x - theCamera.core.position.x;
			dy = position->y - theCamera.core.position.y;
			dz = position->z - theCamera.core.position.z;
		}
		else
		{
			dx = position->x - theCamera.focusInstance->position.x;
			dy = position->y - theCamera.focusInstance->position.y;
			dz = position->z - theCamera.focusInstance->position.z;
		}

		objDist = MATH3D_FastSqrt0(dx * dx + dy * dy + dz * dz);

		if (workMinVolDist >= objDist)
		{
			volume = (workMinVolDist - objDist) / (workMinVolDist / maxVolume);
			
			qpos = (theCamera.core.rotation.z - (ratan2(dy, dx) + 1024)) & 0x3FF;
			angle = (theCamera.core.rotation.z - (ratan2(dy, dx) + 1024)) & 0xFFF;
			quadrant = ((theCamera.core.rotation.z - (ratan2(dy, dx) + 1024)) & 0xFFF) >> 10;

			if (volume >= 128)
			{
				volume = 127;
			}

			if (quadrant == 1)
			{
				pan = qpos >> 4;
			}
			else if (quadrant == 2)
			{
				pan = angle + 64;
			}
			else if (quadrant == 0)
			{
				pan = 63 - qpos;
			}
			else
			{
				pan = 127 - (qpos >> 4);
			}

			if (pan < 64)
			{
				pan = (63 - ((63 - pan) * ((objDist << 8) / workMinVolDist))) >> 8;
			}

			pan = (((pan - 64) * ((objDist << 8) / workMinVolDist)) >> 8) + 64;
			
			return SndPlayVolPan(sfxToneID, volume, pan, pitch);
		}
	}

	return 0;
}


// autogenerated function stub: 
// unsigned long /*$ra*/ SOUND_Update3dSound(_Position *position /*$t0*/, unsigned long handle /*$s5*/, int pitch /*$s6*/, int maxVolume /*$s4*/, int minVolDist /*stack 16*/)
unsigned long SOUND_Update3dSound(_Position *position, unsigned long handle, int pitch, int maxVolume, int minVolDist)
{ // line 962, offset 0x8003fc7c
	/* begin block 1 */
		// Start line: 963
		// Start offset: 0x8003FC7C
		// Variables:
			long dx; // $s1
			long dy; // $s0
			long dz; // $a0
			long objDist; // $s3
			long workMinVolDist; // $s2
			int angle; // $v0
			int quadrant; // $a0
			int qpos; // $v1
			int pan; // $a2
			int volume; // $a1
	/* end block 1 */
	// End offset: 0x8003FE88
	// End Line: 1054

	/* begin block 2 */
		// Start line: 2084
	/* end block 2 */
	// End Line: 2085
			UNIMPLEMENTED();
	return 0;
}

void SOUND_HandleGlobalValueSignal(int name, long data)
{
}

void SOUND_Init()
{
	struct AadInitAttr initAttr;
	initAttr.numSlots = 4;
	initAttr.nonBlockLoadProc = LOAD_NonBlockingFileLoad;
	initAttr.nonBlockBufferedLoadProc = LOAD_NonBlockingBufferedLoad;
	initAttr.memoryMallocProc = MEMPACK_Malloc;
	initAttr.memoryFreeProc = MEMPACK_Free;
	initAttr.updateMode = 1;

	aadGetMemorySize(&initAttr);
	aadInit(&initAttr, (unsigned char*)&soundBuffer[0]);
	gameTrackerX.sound.gMasterVol = 16383;
	SOUND_SetMusicVolume(127);
	SOUND_SetSfxVolume(127);
	SOUND_SetVoiceVolume(80);
	gameTrackerX.sound.gSfxOn = 1;
	gameTrackerX.sound.gMusicOn = 1;
	gameTrackerX.sound.gVoiceOn = 1;
	gameTrackerX.sound.soundsLoaded = 0;
	SOUND_MusicInit();
	aadInitReverb();
}

void SOUND_Free()
{
	gameTrackerX.sound.soundsLoaded = 0;

	aadShutdown();
}

void SOUND_SetMusicVariable(int variable, int value)
{
	aadSetUserVariable(variable, value);
}

void SOUND_SetMusicVolume(int newVolume)
{ 
	if (newVolume == -1)
	{
		newVolume = gameTrackerX.sound.gMusicVol;
	}

	gameTrackerX.sound.gMusicVol = newVolume;

	aadSetMusicMasterVolume(newVolume);
}

void SOUND_SetSfxVolume(int newVolume)
{ 
	if (newVolume == -1)
	{
		newVolume = gameTrackerX.sound.gSfxVol;
	}

	gameTrackerX.sound.gSfxVol = newVolume;

	aadSetSfxMasterVolume(newVolume);
}

void SOUND_SetVoiceVolume(int newVolume)
{
	if (newVolume == -1)
	{
		newVolume = gameTrackerX.sound.gVoiceVol;
	}

	gameTrackerX.sound.gVoiceVol = newVolume;
}

void SOUND_PauseAllSound()
{
	if (gameTrackerX.sound.soundsLoaded != 0)
	{
		aadShutdownReverb();

		aadPauseSound();
	}
}

void SOUND_ResumeAllSound()
{
	if (gameTrackerX.sound.soundsLoaded != 0)
	{
		aadInitReverb();

		aadResumeSound();
	}
}

void SOUND_StopAllSound()
{ 
	if (gameTrackerX.sound.soundsLoaded != 0)
	{
		aadStopAllSfx();
		aadStopAllSlots();
		aadShutdownReverb();
		aadCancelPauseSound();
	}
}

void SOUND_ResetAllSound()
{ 
	if (gameTrackerX.sound.soundsLoaded != 0)
	{
		SOUND_StopAllSound();

		aadInitReverb();
	}
}

void SOUND_MusicOff()
{
	int slotNumber;

	for (slotNumber = 1; slotNumber < 4; slotNumber++)
	{
		aadDisableSlot(slotNumber);

		if (aadGetSlotStatus(slotNumber) == 1)
		{
			aadStopSlot(slotNumber);
			aadStartSlot(slotNumber);
		}
		slotNumber++;///?
	}
}

void SOUND_MusicOn()
{
	int slotNumber;

	slotNumber = 1;

	while (slotNumber < 4)
	{
		aadEnableSlot(slotNumber++);
	}
}

void SOUND_SfxOff()
{ 
	aadStopAllSfx();
}

void SOUND_SfxOn()
{
}

int SndIsPlaying(unsigned long handle)
{
	return aadIsSfxPlaying(handle);
}

int SndIsPlayingOrRequested(unsigned long handle)
{
	return aadIsSfxPlayingOrRequested(handle);
}

int SndTypeIsPlayingOrRequested(unsigned int sfxToneID)
{
	return aadIsSfxTypePlayingOrRequested(sfxToneID);
}

unsigned long SndPlay(unsigned int sample)
{ 
	if (gameTrackerX.sound.gSfxOn == 0)
	{
		return 0;
	}

	return aadPlaySfx(sample, 90, 64, 0);
}

void SndEndLoop(unsigned long handle)
{
	aadStopSfx(handle);
}

unsigned long SndPlayVolPan(unsigned int sample, unsigned short vol, unsigned short pan, short pitch)
{ 
	if (gameTrackerX.sound.gSfxOn != 0)
	{
		return aadPlaySfx(sample, vol & 0xFFFF, pan & 0xFFFF, pitch);
	}

	return 0;
}

unsigned long SndUpdateVolPanPitch(unsigned long handle, unsigned short vol, unsigned short pan, short pitch)
{ 
	if (gameTrackerX.sound.gSfxOn != 0)
	{
		return aadSetSfxVolPanPitch(handle, vol, pan, pitch);
	}

	return 0;
}

void musicLoadReturnFunc(int dynamicBankIndex, int errorStatus)
{ 
	musicInfo.errorStatus = errorStatus;
	musicInfo.state = musicInfo.nextState;
}

void musicFadeoutReturnFunc()
{
	musicInfo.state = musicInfo.nextState;
}

void musicEndCallbackFunc(long userData, int slot, int loopFlag)//Matching - 94.38%
{
	if (slot == 0)
	{
		aadInstallEndSequenceCallback(0, 0);

		if (aadAssignDynamicSequence(musicInfo.bankLoaded, 0, 0) == 0)
		{
			aadStartSlot(0);
			
			musicInfo.state = musicInfo.nextState;
		}
		else
		{

			musicInfo.state = 0;
		}
	}
}

void SOUND_PutMusicCommand(int cmdType, int cmdData)
{
	struct MusicLoadCmd* cmd;

	cmd = &musicInfo.commandQueue[musicInfo.commandIn];

	cmd->type = cmdType;
	cmd->data = cmdData;

	if (musicInfo.numCmdsInQueue < 3)
	{
		musicInfo.numCmdsInQueue++;
		musicInfo.commandIn = (musicInfo.commandIn + 1) & 0x3;
	}
}

void SOUND_MusicInit()
{
	musicInfo.state = 0;
	musicInfo.errorStatus = 0;
	musicInfo.checkMusicDelay = 0;
	musicInfo.currentMusicPlane = -1;
	musicInfo.currentMusicName[0] = 0;
	musicInfo.numCmdsInQueue = 0;
	musicInfo.commandOut = 0;
	musicInfo.commandIn = 0;
}

int SOUND_IsMusicLoading()
{
	if (musicInfo.state == 1 || musicInfo.state == 3 || musicInfo.state == 7)
	{
		return 1;
	}

	return 0;
}

void SOUND_ProcessMusicLoad()
{
	char musicName[8];
	char sndFileName[32];
	char smpFileName[32];
	struct MusicLoadCmd *cmd;
	struct Level *level;
	
	switch (musicInfo.state)
	{
	case 0:

		if (musicInfo.numCmdsInQueue != 0)
		{
			cmd = &musicInfo.commandQueue[musicInfo.commandOut];
			if (cmd->type == 0)
			{
				musicInfo.state = 11;
				musicInfo.nextState = 13;
				musicInfo.currentMusicPlane = cmd->data;
				aadStartMusicMasterVolFade(0, -3, musicFadeoutReturnFunc);
			}

			musicInfo.commandOut = (musicInfo.commandOut + 1) & 0x3;
			musicInfo.numCmdsInQueue--;
		}
		else
		{
			if (musicInfo.checkMusicDelay == 0)
			{
				if (aadMem->sramDefragInfo.status == 0)
				{
					musicInfo.checkMusicDelay = 30;

					level = STREAM_GetLevelWithID(gameTrackerX.playerInstance->currentStreamUnitID);

					if (level != NULL)
					{
						if (level->dynamicMusicName != NULL)
						{
							musicName[0] = level->dynamicMusicName[0];
							musicName[1] = level->dynamicMusicName[1];

							if (musicInfo.currentMusicPlane == -1)
							{
								musicInfo.currentMusicPlane = gameTrackerX.gameData.asmData.MorphType;
							}

							if (musicInfo.currentMusicPlane != 0)
							{
								musicName[2] = 's';
								musicName[3] = 'p';
							}
							else
							{
								musicName[2] = 'm';
								musicName[3] = 'a';
							}

							musicName[4] = 0;

#if defined(AKUJI)
							musicName[0] = 'r';
							musicName[1] = 'a';
							musicName[2] = 'i';
							musicName[3] = 'n';
							musicName[4] = '1';
							musicName[5] = 0;
#endif

#if defined(UWP)
							if (_strcmpi(musicName, musicInfo.currentMusicName) != 0)
#else
							if (strcmpi(musicName, musicInfo.currentMusicName) != 0)
#endif
							{
								if (musicInfo.currentMusicName[0] != 0)
								{
									sprintf(sndFileName, "\\kain2\\music\\%s\\%s.snd", musicName, musicName);

									if (LOAD_DoesFileExist(sndFileName) != 0)
									{
										strcpy(musicInfo.currentMusicName, musicName);
										strcpy(sndFileName, "\\kain2\\music\\uwtr\\uwtr.snd");
										strcpy(smpFileName, "\\kain2\\music\\uwtr\\uwtr.smp");
									
										musicInfo.state = 3;
										musicInfo.nextState = 4;

										aadLoadDynamicSoundBank(sndFileName, smpFileName, 1, 1, musicLoadReturnFunc);
									}
								}
								else
								{
									sprintf(sndFileName, "\\kain2\\music\\%s\\%s.snd", musicName, musicName);
									sprintf(smpFileName, "\\kain2\\music\\%s\\%s.smp", musicName, musicName);

									if (LOAD_DoesFileExist(sndFileName) != 0)
									{
										strcpy(musicInfo.currentMusicName, musicName);
										
										musicInfo.state = 1;
										musicInfo.nextState = 2;
										
										aadLoadDynamicSoundBank(sndFileName, smpFileName, 0, 1, musicLoadReturnFunc);
									}
								}
							}
						}
						else
						{
							if (musicInfo.currentMusicName[0] != 0)
							{
								musicInfo.currentMusicName[0] = 0;
								musicInfo.state = 11;
								musicInfo.nextState = 12;
								aadStartMusicMasterVolFade(0, -1, musicFadeoutReturnFunc);
							}
						}
					}
				}
			}
			else
			{
				musicInfo.checkMusicDelay--;
			}
		}
		break;
	case 2:
#if defined(AKUJI)
		if (aadAssignDynamicSequence(0, 0, 0) == 0)
#else
		if (aadAssignDynamicSequence(0, 0, 0) == 0)
#endif
		{
			aadStartSlot(0);
			musicInfo.state = 0;
		}
		break;
	case 4:
		if (musicInfo.errorStatus == 0)
		{
			musicInfo.state = 5;
			musicInfo.nextState = 6;
			musicInfo.bankLoaded = 1;

			aadInstallEndSequenceCallback(musicEndCallbackFunc, 0);
		}
		else
		{
			musicInfo.state = 0;
		}
		break;
	case 6:
		if (aadMem->sramDefragInfo.status == 0)
		{
			sprintf(sndFileName, "\\kain2\\music\\%s\\%s.snd", musicInfo.currentMusicName, musicInfo.currentMusicName);
			sprintf(smpFileName, "\\kain2\\music\\%s\\%s.smp", musicInfo.currentMusicName, musicInfo.currentMusicName);

			aadLoadDynamicSoundBank(sndFileName, smpFileName, 0, 1, musicLoadReturnFunc);
			musicInfo.state = 7;
			musicInfo.nextState = 8;
		}
		break;
	case 8:
		if (musicInfo.errorStatus == 0)
		{
			musicInfo.state = 9;
			musicInfo.nextState = 10;
			musicInfo.bankLoaded = 0;

			aadInstallEndSequenceCallback(musicEndCallbackFunc, 0);
			aadSetUserVariable(0x7F, 1);
		}
		else
		{
			musicInfo.state = 0;
		}
		break;
	case 10:
		aadFreeDynamicSoundBank(1);
		musicInfo.state = 0;
		break;
	case 12:
		aadStopAllSlots();
		aadFreeDynamicSoundBank(0);
		aadStartMusicMasterVolFade(gameTrackerX.sound.gMusicVol, 1, NULL);
		musicInfo.state = 0;
		break;
	case 13:
		aadStopAllSlots();
		aadFreeDynamicSoundBank(0);
		aadStartMusicMasterVolFade(gameTrackerX.sound.gMusicVol, 1, NULL);
		musicInfo.currentMusicName[0] = 0;
		musicInfo.checkMusicDelay = 0;
		musicInfo.state = 0;
		break;
	}
}

void SOUND_UpdateSound()//Matching - 88.37%
{
	aadProcessLoadQueue();

	if ((gameTrackerX.debugFlags & 0x40000) || gSramFullAlarm == 0 && gSramFullMsgCnt != 0)
	{
		if (gSramFullMsgCnt == 0)
		{
			gSramFullMsgCnt = 60;
		}
		else
		{
			gSramFullMsgCnt--;
		}

		FONT_Print("$\n\n\n\n\n\n\n\n\n\nsound memory full!\nu = % d % d f = % d % d lf = % d", gSramTotalUsed, gSramUsedBlocks, gSramTotalFree, gSramFreeBlocks, gSramLargestFree);
	}

	if (gameTrackerX.sound.gMusicOn != 0)
	{
		SOUND_ProcessMusicLoad();
	}
}

void SOUND_PlaneShift(int newPlane)
{ 
	if (gameTrackerX.sound.gMusicOn != 0)
	{
		SOUND_PutMusicCommand(0, newPlane);
	}
	else
	{
		musicInfo.currentMusicPlane = -1;
	}
}

void SOUND_ShutdownMusic()
{
	aadStopAllSlots();
	EnterCriticalSection();

	if (musicInfo.state == 1 || musicInfo.state == 3 || musicInfo.state == 7)
	{
		musicInfo.nextState = 0;
		ExitCriticalSection();

		while (musicInfo.state != 0)
		{
			STREAM_PollLoadQueue();
		}
	}
	else
	{
		ExitCriticalSection();
	}

	musicInfo.currentMusicName[0] = 0;
	aadFreeDynamicSoundBank(0);
	aadFreeDynamicSoundBank(1);
	musicInfo.state = 0;
	aadStartMusicMasterVolFade(gameTrackerX.sound.gMusicVol, 1, NULL);
}

void SOUND_SetMusicModifier(long modifier)
{
	switch (modifier)
	{
	case 0:
	{
		SOUND_SetMusicVariable(0x0, 0);

		break;
	}
	case 1:
	{
		SOUND_SetMusicVariable(0x0, 1);

		break;
	}
	case 2:
	{
		SOUND_SetMusicVariable(0x0, 0x3);

		break;
	}
	case 3:
	{
		SOUND_SetMusicVariable(0x0, 0x4);

		break;
	}
	case 4:
	{
		SOUND_SetMusicVariable(0x0, 2);

		break;
	}
	case 5:
	{
		SOUND_SetMusicVariable(0x1, 1);

		break;
	}
	case 6:
	{
		SOUND_SetMusicVariable(0x2, 1);

		break;
	}
	case 9:
	{
		SOUND_SetMusicVariable(0x7D, 1);

		break;
	}
	case 10:
	{
		SOUND_SetMusicVariable(0x7E, 1);

		break;
	}
	case 11:
	{
		SOUND_SetMusicVariable(0x7C, 1);

		break;
	}
	case 13:
	{
		SOUND_SetMusicVariable(0x78, 1);

		break;
	}
	case 14:
	{
		SOUND_SetMusicVariable(0x3, 1);

		break;
	}
	case 15:
	{
		SOUND_SetMusicVariable(0x77, 1);
	
		break;
	}
	}
}

void SOUND_ResetMusicModifier(long modifier) // Matching - 100%
{
	switch (modifier)
	{
	case 0:
	case 1:
	case 2:
	case 3:
	case 4:
	{
		SOUND_SetMusicVariable(0, 0);

		break;
	}
	case 5:
	{
		SOUND_SetMusicVariable(1, 0);

		break;
	}
	case 6:
	{
		SOUND_SetMusicVariable(2, 0);

		break;
	}
	case 9:
	{
		SOUND_SetMusicVariable(125, 0);

		break;
	}
	case 10:
	{
		SOUND_SetMusicVariable(126, 0);

		break;
	}
	case 11:
	{
		SOUND_SetMusicVariable(124, 0);

		break;
	}
	case 13:
	{
		SOUND_SetMusicVariable(120, 0);

		break;
	}
	case 14:
	{
		SOUND_SetMusicVariable(3, 0);

		break;
	}
	case 15:
	{
		SOUND_SetMusicVariable(119, 0);

		break;
	}
	}
}