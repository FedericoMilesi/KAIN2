#include "Game/CORE.H"
#include "Game/GAMELOOP.H"
#include "HEALTH.H"
#include "Game/FONT.H"
#include "RAZLIB.H"
#include "Game/G2/ANMCTRLR.H"
#include "RAZIEL.H"
#include "Game/STREAM.H"
#include "Game/RAZIEL/PUPPET.H"
#include "Game/FX.H"
#include "Game/RAZIEL/RAZIEL.H"
#include "Game/MATH3D.H"
#include "Game/RAZIEL/CONTROL.H"
#include "Game/DEBUG.H"
#include "Game/RAZIEL/SWIM.H"
#include "Game/RAZIEL/ATTACK.H"
#include "Game/STATE.H"
#include "Game/G2/TIMERG2.H"
#include "Game/G2/ANMG2ILF.H"
#include "Game/SOUND.H"
#include <Game/PSX/COLLIDES.H>
#include <Game/G2/INSTNCG2.H>

struct __Player Raziel;
static unsigned char PickupList[4];
struct __razController controllerList[] = { 
	{ 0x0000, 0x0026 },
	{ 0x0000, 0x0064 },
	{ 0x0000, 0x0020 },
	{ 0x0000, 0x0022 },
	{ 0x0000, 0x0008 },
	{ 0x0000, 0x000E },
	{ 0x0001, 0x0026 },
	{ 0x0001, 0x000E },
	{ 0x0001, 0x000A },
	{ 0x0011, 0x000E },
	{ 0x0011, 0x0008 },
	{ 0x0010, 0x000E },
	{ 0x000F, 0x000E },
	{ 0x000E, 0x000E },
	{ 0x000E, 0x0008 },
	{ 0x0030, 0x0008 },
	{ 0x0032, 0x004C },
	{ 0x0033, 0x0008 },
	{ 0x0034, 0x0008 },
	{ 0x0035, 0x0008 },
	{ 0x003A, 0x004C },
	{ 0x003B, 0x0008 },
	{ 0x003C, 0x0008 },
	{ 0x003D, 0x0008 },

}; // offset 0x800d1c64
static unsigned short cowlList[19]; // offset 0x800D1C3C

void razAlignYMoveRot(struct _Instance* dest, short distance, _Position* position, struct _Rotation* rotation, int extraZ)  // Matching - 100%
{
	SVECTOR d;
	SVECTOR dd;
	MATRIX mat;
	int temp; // not from SYMDUMP

	temp = 2048;

	d.vx = 0;
	d.vy = -distance;
	d.vz = 0;

	rotation->z = ((SVECTOR*)INSTANCE_Query(dest, 7))->vz + (extraZ + temp);
	MATH3D_SetUnityMatrix(&mat);
	RotMatrixZ(rotation->z, &mat);
	ApplyMatrixSV(&mat, &d, &dd);
	position->x = dest->position.x + dd.vx;
	position->y = dest->position.y + dd.vy;
}

void razAlignYRotMove(struct _Instance* dest, short distance, struct _Position* position, struct _Rotation* rotation, int extraZ) // Matching - 100%
{
	SVECTOR d;
	SVECTOR dd;
	SVECTOR rot;
	MATRIX mat;

	memset(&rot, 0, sizeof(SVECTOR));
	rotation->z = MATH3D_AngleFromPosToPos(position, &dest->position) + extraZ;
	rot.vz = rotation->z;
	RotMatrix(&rot, &mat);
	d.vx = 0;
	d.vz = 0;
	d.vy = distance;
	ApplyMatrixSV(&mat, &d, &dd);
	position->x = dest->position.x + dd.vx;
	position->y = dest->position.y + dd.vy;
}

void razAlignYRotMoveInterp(struct _Instance* source, struct _Instance* dest, short distance, unsigned char segNumber, int Frames, short extraZ) // Matching - 100%
{
	struct _Position position;
	struct _Rotation rotation;
	struct _G2SVector3_Type v;

	position = source->position;

	razAlignYRotMove(dest, distance, &position, &rotation, extraZ);

	v.x = position.x;
	v.y = position.y;
	v.z = position.z;

	source->position = position;

	v.x = 0;
	v.y = 0;
	v.z = rotation.z;

	G2Anim_EnableController(&source->anim, segNumber, 8);

	G2EmulationSetInterpController_Vector(source, segNumber, 8, &v, Frames, 0);

	source->rotation.z = rotation.z;
}

void razAlignYRotInterp(struct _Instance* source, struct _Position* dest, unsigned char segNumber, int Frames) // Matching - 100%
{
	source->rotation.z = MATH3D_AngleFromPosToPos(&source->position, dest);
}


// autogenerated function stub: 
// int /*$ra*/ razConstrictAngle(struct _Instance *instance /*$a0*/)
int razConstrictAngle(struct _Instance *instance)
{ // line 195, offset 0x800a546c
	/* begin block 1 */
		// Start line: 196
		// Start offset: 0x800A546C
		// Variables:
			int i; // $s0
			int j; // $s2
			int k; // $a2
			int Total; // $s1
			int outer; // stack offset -32
			int rc; // $s3
			struct _SVector point; // stack offset -40
	/* end block 1 */
	// End offset: 0x800A5564
	// End Line: 243

	/* begin block 2 */
		// Start line: 390
	/* end block 2 */
	// End Line: 391
			UNIMPLEMENTED();
	return 0;
}


void razRotateUpperBody(struct _Instance* instance, struct evActionLookAroundData* data)  // Matching - 100%
{
	int tx;
	int tz;
	struct _G2SVector3_Type Rot;

	if (*data->rotx < data->minx)
	{
		*data->rotx = data->minx;
	}
	else if (*data->rotx > data->maxx)
	{
		*data->rotx = data->maxx;
	}

	if (*data->rotz < data->minz)
	{
		*data->rotz = data->minz;
	}
	else if (*data->rotz > data->maxz)
	{
		*data->rotz = data->maxz;
	}

	tx = *data->rotx;
	tz = *data->rotz;
	Rot.y = 0;
	Rot.x = -tx / 2;
	Rot.z = tz / 2;

	MATH3D_ZYXtoXYZ((struct _Rotation*)&Rot);

	G2Anim_SetController_Vector((struct _G2Anim_Type*)&instance->anim, 14, 14, &Rot);

	Rot.y = 0;
	Rot.x = (-tx * 30) / 100;
	Rot.z = (tz * 30) / 100;

	MATH3D_ZYXtoXYZ((struct _Rotation*)&Rot);

	G2Anim_SetController_Vector((struct _G2Anim_Type*)&instance->anim, 16, 14, &Rot);

	Rot.y = 0;
	Rot.x = -tx / 5;
	Rot.z = tz / 5;

	MATH3D_ZYXtoXYZ((struct _Rotation*)&Rot);

	G2Anim_SetController_Vector((struct _G2Anim_Type*)&instance->anim, 17, 14, &Rot);
}

void razSetFadeEffect(short source, short dest, int steps) // Matching - 100%
{
	Raziel.effectsFadeSource = source;

	Raziel.effectsFadeDest = dest;

	Raziel.effectsFadeSteps = 0;

	Raziel.effectsFadeStep = steps;

	Raziel.effectsFlags |= 0x3;
}

int razPlaneShift(struct _Instance *instance) // Matching - 100%
{
	if (!(gameTrackerX.streamFlags & 0x40000))
	{
		if (Raziel.CurrentPlane == 1)
		{
			razSpectralShift();

			return 1;
		}
		else
		{
			razMaterialShift();

			return 1;
		}
	}

	return 0;
}

void razSpectralShift() // Matching - 100%
{
	struct _Instance* inst;

	if (!(gameTrackerX.streamFlags & 0x40000))
	{
		if (Raziel.CurrentPlane == 1)
		{
			inst = razGetHeldItem();

			if (inst != NULL)
			{
				INSTANCE_Post(inst, 0x800008, 4);

				razSetFadeEffect(4096, 0, 256);
			}

			gameTrackerX.playerInstance->flags2 |= 0x8000000;

			INSTANCE_Post(gameTrackerX.playerInstance, 0x100014, 0);

			if (Raziel.HitPoints == GetMaxHealth())
			{
				Raziel.HitPoints = 0x186A0;
			}
			else
			{
				Raziel.HitPoints = 0x14586;
			}

			Raziel.CurrentPlane = 2;

			razReaverOn();

			if (gameTrackerX.gameData.asmData.MorphType == 0)
			{
				MORPH_ToggleMorph();

				if (Raziel.State.SectionList[0].Process != StateHandlerGlyphs &&
					Raziel.State.SectionList[0].Process != StateHandlerPuppetShow)
				{
					INSTANCE_Post(gameTrackerX.playerInstance, 0x40005, 0);
				}
			}
		}
	}
}

void razMaterialShift() // Matching - 100%
{
	if (Raziel.CurrentPlane == 2)
	{
		if (Raziel.HitPoints == 100000)
		{
			Raziel.CurrentPlane = 1;

			gameTrackerX.playerInstance->flags2 &= ~0x8000000;

			Raziel.HitPoints = GetMaxHealth();

			Raziel.DamageFrequency = 0;

			razReaverOn();

			if (gameTrackerX.gameData.asmData.MorphType != 0)
			{
				MORPH_ToggleMorph();

				if (Raziel.State.SectionList[0].Process != StateHandlerGlyphs &&
					Raziel.State.SectionList[0].Process != StateHandlerPuppetShow)
				{
					INSTANCE_Post(gameTrackerX.playerInstance, 0x40005, 0);
				}

				if (Raziel.Senses.Portal != NULL)
				{
					FX_EndInstanceParticleEffects(Raziel.Senses.Portal);
				}
			}
		}
	}
}

int RAZIEL_OkToShift()
{
	if (Raziel.CurrentPlane == 2)
	{
		if (GetMaxHealth() == Raziel.HitPoints)
		{
			if ((Raziel.Abilities & 0x40))
			{
				if (!(Raziel.Abilities & 0x10))
				{
					FONT_Print("\nYOU CAN NOT HAVE SHIFT ANYTIME WITHOUT THE SWIM ABILITY");
					FONT_Print("\nBEAT THE ALUKA BOSS THEN WIN THE SECOND KAIN ENCOUNTER");

					return 0;
				}
				else
				{
					return 1;
				}
			}
			else
			{
				return 0 < (Raziel.Senses.Flags & 0x40);
			}
		}
		else
		{
			return 0;
		}
	}

	return 1;
}


int razPickupAndGrab(struct __CharacterState* In, int CurrentSection) // Matching - 100%
{
	int index;
	struct evObjectData* objData;

	if (!(Raziel.Senses.EngagedMask & 0x20))
	{
		return 1;
	}

	if (((razGetHeldItem() == NULL) && (Raziel.CurrentPlane == 1)) && !(Raziel.Senses.Flags & 0x80))
	{
		if (CurrentSection != 1)
		{
			return 0;
		}

		if (Raziel.Senses.EngagedList[5].instance->LinkParent != NULL)
		{
			INSTANCE_Query(Raziel.Senses.EngagedList[5].instance->LinkParent, 0);
		}

		objData = (struct evObjectData*)SetObjectData(0, 0, 8, In->CharacterInstance, CurrentSection);

		INSTANCE_Post(Raziel.Senses.EngagedList[5].instance, 0x80002E, (int)objData);

		if (objData->LinkNode == 0)
		{
			if (Raziel.Senses.EngagedList[5].instance->LinkParent != NULL)
			{
				INSTANCE_Post(Raziel.Senses.EngagedList[5].instance->LinkParent, 0x100001B, 0);

				INSTANCE_UnlinkFromParent(Raziel.Senses.EngagedList[5].instance);
			}

			objData = (struct evObjectData*)SetObjectData(0, 0, 8, In->CharacterInstance, 49);

			INSTANCE_Post(Raziel.Senses.EngagedList[5].instance, 0x800002, (int)objData);

			if (objData->LinkNode == 0)
			{
				struct __CharacterState* temp;  // not from SYMDUMP

				Raziel.Senses.Flags |= 0x80;

				temp = (struct __CharacterState*)&In->SectionList[0].Data1;

				razReaverOff();

				temp->SectionList[0].Data1 = 0;

				index = INSTANCE_Query(Raziel.Senses.EngagedList[5].instance, 4);

				if ((Raziel.Mode & 0x40000))
				{
					return 0;
				}

				G2EmulationSwitchAnimation(In, 1, PickupList[index], 0, 3, CurrentSection);

				Raziel.returnState = temp->SectionList[0].Process;

				StateSwitchStateData(In, 1, &StateHandlerPickupObject, 0);
			}
		}

		return 0;
	}

	return 1;
}

int razZeroAxis(long* x, long* y, int radius)//Matching - 99.79%
{
	unsigned long distance;

	distance = MATH3D_SquareLength(*x, *y, 0);

	if ((int)distance < radius)
	{
		distance = 0;

		*x = 0;
		*y = 0;
	}

	return distance;
}

int razAdjustSpeed(struct _Instance* instance, int minSpeed)//Matching - 90.51%
{
	long adjustment;
	int data;

	if (Raziel.movementMaxAnalog < Raziel.Magnitude)
	{
		adjustment = Raziel.movementMaxRate;
	}
	else if (Raziel.Magnitude < Raziel.movementMinAnalog)
	{
		adjustment = Raziel.movementMinRate;
	}
	else
	{
		adjustment = Raziel.movementMaxRate - ((Raziel.movementMaxRate - Raziel.movementMinRate) * (Raziel.movementMaxAnalog - Raziel.Magnitude)) / (Raziel.movementMaxAnalog - Raziel.movementMinAnalog);
	}

	G2Anim_SetSpeedAdjustment(&instance->anim, adjustment);

	return adjustment;
}

void razLaunchForce(struct _Instance* instance) // Matching - 96.11%
{
	PHYSOB_BirthProjectile(instance, 49, (char)Raziel.Abilities & 1);
	Raziel.effectsFlags |= 4;
	razSetupSoundRamp(instance, (struct _SoundRamp*)&Raziel.soundHandle, 12, PlayerData->forceMinPitch, PlayerData->forceMaxPitch,
		PlayerData->forceMinVolume, PlayerData->forceMaxVolume, PlayerData->forceRampTime * 30, 10000);
	Raziel.soundTimerNext = 0;
	Raziel.soundTimerData = 0;
}

struct _Instance* razGetHeldItem()
{
	struct _Instance* instance;

	instance = Raziel.State.CharacterInstance->LinkChild;

	if (Raziel.soulReaver && instance == Raziel.soulReaver && instance != NULL)
	{
		instance = instance->LinkSibling;
	}

	return instance;
}

struct _Instance* razGetHeldWeapon()
{
	struct _Instance* instance;

	instance = razGetHeldItem();

	if (instance == NULL)
	{
		if (Raziel.Senses.heldClass != 0)
		{
			return Raziel.soulReaver;
		}
	}
	else
	{
		if ((INSTANCE_Query(instance, 0x1) & 0x20))
		{
			return instance;
		}
	}

	return NULL;
}

void razReaverBladeOff()
{
	if (Raziel.soulReaver != NULL)
	{
		INSTANCE_Post(Raziel.soulReaver, 0x800109, 2);
	}
}

void razReaverBladeOn()
{
	if (Raziel.soulReaver != NULL && razGetHeldItem() == NULL)
	{
		INSTANCE_Post(Raziel.soulReaver, 0x800108, 2);
	}
}

int razReaverOff()//Matching - 95.86%
{
	struct _Instance* HeldWeapon;

	if (Raziel.soulReaver != NULL)
	{
		if (Raziel.Senses.heldClass == 4096)
		{
			HeldWeapon = razGetHeldWeapon();

			if ((INSTANCE_Query(Raziel.soulReaver, 0x28) & 0x1) != 0)
			{
				INSTANCE_Post(Raziel.soulReaver, 0x800101, 0);
			}
			if (HeldWeapon == Raziel.soulReaver)
			{
				Raziel.Senses.heldClass = 0;
			}
			return 1;
		}
	}

	return 0;
}

int razReaverOn()
{
	if (Raziel.soulReaver != NULL)
	{
		if (razGetHeldItem() == NULL)
		{
			if (GetMaxHealth() == Raziel.HitPoints || Raziel.CurrentPlane == 2)
			{
				if (!(INSTANCE_Query(Raziel.soulReaver, 0x28) & 0x1))
				{
					INSTANCE_Post(Raziel.soulReaver, 0x800100, 0);
				}
				
				Raziel.Senses.heldClass = 4096;

				if (Raziel.CurrentPlane == 2 && Raziel.currentSoulReaver != 1)
				{
					razReaverImbue(1);
				}
				
				if (Raziel.CurrentPlane == 1 && Raziel.currentSoulReaver == 1)
				{
					razReaverImbue(2);
				}
				
				return 1;
			}

			return 2;
		}
	}
	
	return 0;
}


void razReaverPickup(struct _Instance* instance, struct _Instance* soulReaver) // Matching - 100%
{
	INSTANCE_Post(soulReaver, 0x800002, (int)instance);

	Raziel.soulReaver = soulReaver;

	if (razGetHeldItem() != NULL)
	{
		razReaverOff();
	}

	Raziel.Abilities |= 0x8;

	if (Raziel.CurrentPlane == 1)
	{
		Raziel.currentSoulReaver = 2;

		Raziel.Abilities |= 0xC08;

		debugRazielFlags2 = 0x800;

		debugRazielFlags1 = Raziel.Abilities;

		INSTANCE_Post(soulReaver, 0x800103, Raziel.currentSoulReaver);
	}
	else
	{
		Raziel.currentSoulReaver = 1;

		Raziel.Abilities |= 0xC08;

		debugRazielFlags2 = 0x400;

		debugRazielFlags1 = Raziel.Abilities;

		INSTANCE_Post(soulReaver, 0x800103, Raziel.currentSoulReaver);
	}
}

void razReaverImbue(int reaverType)
{
	Raziel.currentSoulReaver = reaverType;

	debugRazielFlags2 = 1 << (reaverType + 9);

	INSTANCE_Post(Raziel.soulReaver, 0x800103, reaverType);
}

int razGetReaverFromMask(int reaverMask)
{
	int rc;

	rc = 0;

	reaverMask <<= 10;
	reaverMask &= 0xFF;

	while (reaverMask)
	{
		reaverMask >>= 1;
		rc++;
	}

	return rc;
}

void razReaverScale(int scale)
{
	struct _Instance* Inst;

	Inst = razGetHeldWeapon();

	if (Raziel.soulReaver != NULL && Inst == Raziel.soulReaver &&
		INSTANCE_Query(Inst, 0x28) & 0x2)
	{
		INSTANCE_Post(Inst, 0x800107, scale);
	}
}

void razGetForwardNormal(struct _Instance* inst, struct _Instance* target) // Matching - 99.74%
{
	struct _PCollideInfo CInfo;
	SVECTOR Old;
	SVECTOR New;

	CInfo.oldPoint = &Old;
	CInfo.newPoint = &New;
	Old.vx = (short)inst->matrix[1].t[0];
	Old.vy = (short)inst->matrix[1].t[1];
	Old.vz = (short)inst->matrix[1].t[2];
	New.vx = (short)target->matrix[1].t[0];
	New.vy = (short)target->matrix[1].t[1];
	New.vz = (short)target->matrix[1].t[2];
	PHYSICS_CheckLineInWorld(inst, &CInfo);
	if (((unsigned short)(CInfo.type - 2) < 2) || (CInfo.type == 5))
	{
		Raziel.Senses.ForwardNormal.x = CInfo.wNormal.vx;
		Raziel.Senses.ForwardNormal.y = CInfo.wNormal.vy;
		Raziel.Senses.ForwardNormal.z = CInfo.wNormal.vz;
	}
}

void razGetRotFromNormal(struct _SVector* normal, struct _Rotation* rot)//Matching - 99.74%
{
	struct _Position a;
	struct _Position b;

	a.x = normal->x;
	a.y = normal->y;
	a.z = normal->z;
	
	b.z = 0;
	b.y = 0;
	b.x = 0;
	
	MATH3D_RotationFromPosToPos(&a, &b, rot);
}


// autogenerated function stub: 
// void /*$ra*/ razCenterWithBlock(struct _Instance *inst /*$s3*/, struct _Instance *target /*$s1*/, int dist /*$s2*/)
void razCenterWithBlock(struct _Instance *inst, struct _Instance *target, int dist)
{ // line 811, offset 0x800a6324
	UNIMPLEMENTED();
}

void razSetPauseTranslation(struct _Instance* instance) // Matching - 99.66%
{
	struct _G2SVector3_Type Vec;

	if (G2Anim_IsControllerActive(&instance->anim, 0, 34) == G2FALSE)
	{
		G2Anim_EnableController(&instance->anim, 0, 34);
	}

	Vec.x = 0;
	Vec.y = 0;
	Vec.z = 0;
	G2Anim_SetController_Vector(&instance->anim, 0, 34, &Vec);
	ControlFlag |= 0x20000000;
}

void razResetPauseTranslation(struct _Instance* instance)
{
	if (G2Anim_IsControllerActive(&instance->anim, 0, 0x22))
	{
		G2Anim_DisableController(&instance->anim, 0, 0x22);
	}

	ControlFlag &= 0xDFFFFFFF;
}

void razSelectMotionAnim(struct __CharacterState* In, int CurrentSection, int Frames, int* Anim)//Matching - 95.73%
{
	struct _G2SVector3_Type Vec;
	int switchType;
	int frame;
	int adjustment;
	struct _G2AnimSection_Type* animSectionA;
	struct _G2AnimSection_Type* animSectionB;
	struct _G2AnimKeylist_Type* keylist;
	int keylistID;

	switchType = 0;

	frame = 0;

	if (Raziel.Magnitude >= 3769)
	{
		if (Raziel.nothingCounter == 0)
		{
			ControlFlag &= 0xFFFFDFFF;
		}

		if ((ControlFlag & 0x20000000))
		{
			razResetPauseTranslation(In->CharacterInstance);
		}

		if (Anim[0] == 60)
		{
			if ((Raziel.passedMask & 0xF))
			{
				switchType = 3;
			}

			if ((Raziel.passedMask & 0x8))
			{
				frame = 5;
			}

			if ((Raziel.passedMask & 0x1))
			{
				frame = 23;
			}

			if ((Raziel.passedMask & 0x2))
			{
				frame = 17;
			}

			if ((Raziel.passedMask & 0x4))
			{
				frame = 11;
			}
		}
		else if (Anim[0] == 64)
		{
			if ((Raziel.passedMask & 0xF0))
			{
				switchType = 3;
			}

			if ((Raziel.passedMask & 0x80))
			{
				frame = 5;
			}

			if ((Raziel.passedMask & 0x10))
			{
				frame = 23;
			}

			if ((Raziel.passedMask & 0x20))
			{
				frame = 17;
			}

			if ((Raziel.passedMask & 0x40))
			{
				frame = 11;
			}
		}
		else if (Anim[0] != 68)
		{
			switchType = 3;
		}
	}
	else
	{
		if ((unsigned)(Raziel.Magnitude - 2784) < 985)
		{
			ControlFlag &= 0xFFFFDFFF;

			if ((ControlFlag & 0x20000000))
			{
				razResetPauseTranslation(In->CharacterInstance);
			}

			if (Anim[0] == 60)
			{
				if ((Raziel.passedMask & 0xF))
				{
					switchType = 2;
				}

				if ((Raziel.passedMask & 0x8))
				{
					frame = 7;
				}

				if ((Raziel.passedMask & 0x1))
				{
					frame = 13;
				}

				if ((Raziel.passedMask & 0x2))
				{
					frame = 20;
				}

				if ((Raziel.passedMask & 0x4))
				{
					frame = 25;
				}
			}
			else if (Anim[0] == 68)
			{
				if ((Raziel.passedMask & 0xF00))
				{
					switchType = 2;
				}

				if ((Raziel.passedMask & 0x800))
				{
					frame = 7;
				}

				if ((Raziel.passedMask & 0x100))
				{
					frame = 13;
				}

				if ((Raziel.passedMask & 0x200))
				{
					frame = 20;
				}

				if ((Raziel.passedMask & 0x400))
				{
					frame = 25;
				}
			}
			else if (Anim[0] != 64)
			{
				switchType = 2;
			}
		}
		else if (Raziel.Magnitude < 2784)
		{
			ControlFlag |= 0x2000;

			if (Anim[0] == 64)
			{
				if ((Raziel.passedMask & 0xF0))
				{
					switchType = 1;
				}

				if ((Raziel.passedMask & 0x80))
				{
					frame = 12;
				}

				if ((Raziel.passedMask & 0x10))
				{
					frame = 20;
				}

				if ((Raziel.passedMask & 0x20))
				{
					frame = 32;
				}

				if ((Raziel.passedMask & 0x40))
				{
					frame = 0;
				}
			}
			else if (Anim[0] == 68)
			{
				if ((Raziel.passedMask & 0xF00))
				{
					switchType = 1;
				}

				if ((Raziel.passedMask & 0x800))
				{
					frame = 12;
				}

				if ((Raziel.passedMask & 0x100))
				{
					frame = 20;
				}

				if ((Raziel.passedMask & 0x200))
				{
					frame = 32;
				}

				if ((Raziel.passedMask & 0x400))
				{
					frame = 0;
				}
			}
			else if (Anim[0] != 60)
			{
				switchType = 1;
			}
		}
	}

	switch (switchType)
	{
	case 1:
	{
		if (CurrentSection == 2)
		{
			Raziel.passedMask = 0;
		}

		if (razSwitchVAnimGroup(In->CharacterInstance, CurrentSection, 60, frame, Frames) != 0)
		{
			G2EmulationSwitchAnimation(In, CurrentSection, 123, frame, Frames, 2);
		}

		Raziel.movementMinRate = 4096;

		Raziel.movementMaxRate = 7168;

		Raziel.movementMinAnalog = 2300;

		Raziel.movementMaxAnalog = 2783;

		Anim[0] = 60;

		break;
	}
	case 2:
	{
		if (CurrentSection == 2)
		{
			Raziel.passedMask = 0;
		}

		if ((razSwitchVAnimGroup(In->CharacterInstance, CurrentSection, 64, frame, Frames)) != 0)
		{
			G2EmulationSwitchAnimation(In, CurrentSection, 124, frame, Frames, 2);
		}

		Raziel.movementMinRate = 3276;

		Raziel.movementMaxRate = 6144;

		Raziel.movementMinAnalog = 2783;

		Raziel.movementMaxAnalog = 3768;

		Anim[0] = 64;

		break;
	}
	case 3:
	{
		if (CurrentSection == 2)
		{
			Raziel.passedMask = 0;
		}

		if ((razSwitchVAnimGroup(In->CharacterInstance, CurrentSection, 68, frame, Frames) != 0))
		{
			G2EmulationSwitchAnimation(In, CurrentSection, 2, frame, Frames, 2);
		}

		Raziel.movementMinRate = 3547;

		Raziel.movementMaxAnalog = 4096;

		Raziel.movementMinAnalog = 3768;

		Raziel.movementMaxRate = 4096;

		Anim[0] = 68;

		break;
	}
	}

	if (CurrentSection == 0)
	{
		if (!(ControlFlag & 0x20000000))
		{
			Vec.z = 0;
			Vec.x = 0;

			switch (Anim[0])
			{
			case 0x40:
			{
				Vec.y = -35;
				break;
			}
			case 0x3C:
			{
				Vec.y = -16;
				break;
			}
			case 0x44:
			{
				Vec.y = -60;
				break;
			}
			}

			adjustment = razAdjustSpeed(In->CharacterInstance, 1);

			Vec.y = (((Vec.y * (short)G2Timer_GetFrameTime()) * adjustment) >> 12) / 100;

			if (G2Anim_IsControllerActive(&In->CharacterInstance->anim, 0, 0x22) == 0)
			{
				G2Anim_EnableController(&In->CharacterInstance->anim, 0, 0x22);
			}

			G2Anim_SetController_Vector(&In->CharacterInstance->anim, 0, 0x22, &Vec);
		}

		if (CurrentSection != 0)
		{
			Frames = 6;

			if ((void*)In->SectionList[0].Process == (void*)&StateHandlerMove)
			{
				animSectionA = &In->CharacterInstance->anim.section[0];
				animSectionB = &In->CharacterInstance->anim.section[CurrentSection];

				if (G2AnimSection_IsInInterpolation(animSectionA) == 0 && G2AnimSection_IsInInterpolation(animSectionB) == 0)
				{
					if (G2AnimSection_GetKeyframeNumber(animSectionA) != G2AnimSection_GetKeyframeNumber(animSectionB))
					{
						keylist = animSectionA->keylist;
						keylistID = animSectionA->keylistID;

						frame = (G2AnimSection_GetKeyframeNumber(animSectionA) + Frames) % G2AnimKeylist_GetKeyframeCount(keylist);

						if (razSwitchVAnimGroup(In->CharacterInstance, CurrentSection, Anim[0], frame, Frames) != 0)
						{
							G2AnimSection_InterpToKeylistFrame(animSectionB, keylist, keylistID, frame, 600);
						}
					}
				}
			}
		}
	}
	else
	{
		Frames = 6;

		if ((void*)In->SectionList[0].Process == (void*)&StateHandlerMove)
		{
			animSectionA = &In->CharacterInstance->anim.section[0];
			animSectionB = &In->CharacterInstance->anim.section[CurrentSection];

			if (G2AnimSection_IsInInterpolation(animSectionA) == 0 && G2AnimSection_IsInInterpolation(animSectionB) == 0)
			{
				if (G2AnimSection_GetKeyframeNumber(animSectionA) != G2AnimSection_GetKeyframeNumber(animSectionB))
				{
					keylist = animSectionA->keylist;
					keylistID = animSectionA->keylistID;

					frame = (G2AnimSection_GetKeyframeNumber(animSectionA) + Frames) % G2AnimKeylist_GetKeyframeCount(keylist);

					if (razSwitchVAnimGroup(In->CharacterInstance, CurrentSection, Anim[0], frame, Frames) != 0)
					{
						G2AnimSection_InterpToKeylistFrame(animSectionB, keylist, keylistID, frame, 600);
					}
				}
			}
		}
	}
}


int razApplyMotion(struct __CharacterState* In, int CurrentSection)  // Matching - 100%
{
	struct _G2SVector3_Type Vec;
	struct _G2AnimSection_Type* animSection;
	int adjustment;

	memset(&Vec, 0, 6);
	if (CurrentSection == 0)
	{
		animSection = In->CharacterInstance->anim.section;
		if (animSection->keylist == G2Instance_GetKeylist(In->CharacterInstance, 2))
		{
			Vec.y = -60;
		}
		else if (animSection->keylist == G2Instance_GetKeylist(In->CharacterInstance, 124))
		{
			Vec.y = -35;
		}
		else if (animSection->keylist == G2Instance_GetKeylist(In->CharacterInstance, 123))
		{
			Vec.y = -16;
		}
		else if (G2Anim_IsControllerActive(&In->CharacterInstance->anim, 0, 34) != G2FALSE)
		{
			G2Anim_DisableController(&In->CharacterInstance->anim, 0, 34);
		}
		if (Vec.y != 0)
		{
			if (G2Anim_IsControllerActive(&In->CharacterInstance->anim, 0, 34) == G2FALSE)
			{
				G2Anim_EnableController(&In->CharacterInstance->anim, 0, 34);
			}
			adjustment = In->CharacterInstance->anim.section[0].speedAdjustment;
			Vec.y = (((Vec.y * G2Timer_GetFrameTime() * adjustment) >> 12) / 100);
			G2Anim_SetController_Vector(&In->CharacterInstance->anim, 0, 34, &Vec);
		}
	}
	return -Vec.y;
}

void razResetMotion(struct _Instance *instance)
{
	if ((G2Anim_IsControllerActive(&instance->anim, 0, 0x22)) != 0)
	{
		G2Anim_DisableController(&instance->anim, 0, 0x22);
	}

	Raziel.passedMask = 0;

	G2Anim_SetSpeedAdjustment(&instance->anim, 4096);
}

void razSetDampingPhysics(struct _Instance* instance)
{
	Raziel.RotationSegment = 0;
	
	Raziel.extraRot.x = 0;

	PhysicsMode = 4;

	SetDampingPhysics(instance, PlayerData->SwimPhysicsFallDamping);
}

void razEnterWater(struct __CharacterState* In, int CurrentSection, struct evPhysicsSwimData* SwimData)  // Matching - 100%
{
	struct _Instance* Inst;

	Inst = razGetHeldWeapon();

	if ((SwimData->rc & 0x10))
	{
		if ((Raziel.CurrentPlane == 1) && (!(Raziel.Abilities & 0x10)))
		{
			Raziel.HitPoints = 0x10000 | 0x86A0;

			SetPhysics(In->CharacterInstance, -16, 0, 0, 0);

			PhysicsMode = 0;
		}
		else if ((Inst != NULL) && (INSTANCE_Query(Inst, 4) == 3))
		{
			G2Anim_SetSpeedAdjustment(&In->CharacterInstance->anim, 2048);
		}
		else if ((!(Raziel.Mode & 0x40000)) && (Raziel.CurrentPlane == 1))
		{
			if (PhysicsMode != 4)
			{
				razSetDampingPhysics(In->CharacterInstance);
			}

			if ((In->CharacterInstance->zVel == 0) || ((Raziel.Mode & 0x400004)))
			{
				razResetMotion(In->CharacterInstance);
				StateSwitchStateCharacterData(In, StateHandlerSwim, 0);
			}

			TrailWaterFX(In->CharacterInstance, 9, 1, 1);
			TrailWaterFX(In->CharacterInstance, 13, 1, 1);
			TrailWaterFX(In->CharacterInstance, 31, 1, 1);
			TrailWaterFX(In->CharacterInstance, 41, 1, 1);
		}
	}

	if (((SwimData->rc & 0x800)) && (Raziel.Senses.heldClass == 1))
	{
		if (CurrentSection == 2)
		{
			G2EmulationSwitchAnimation(In, CurrentSection, 61, 0, 3, 2);
		}
		else
		{
			G2EmulationSwitchAnimation(In, CurrentSection, 63, 0, 16, 2);
		}
	}

	if (((SwimData->rc & 0x100)) && (CurrentSection == 0))
	{
		if (Inst != NULL)
		{
			INSTANCE_Query(Inst, 4);
		}
		else
		{
			razSetDampingPhysics(In->CharacterInstance);
		}

		PurgeMessageQueue(&In->SectionList[CurrentSection].Event);
		TrailWaterFX(In->CharacterInstance, 9, 4, 1);
		TrailWaterFX(In->CharacterInstance, 13, 4, 1);
	}
}

void _razSetSwimVelocity(struct _Instance* instance, int vel, int accl)//Matching - 99.76%
{
	instance->yAccl = 0;
	instance->xAccl = 0;
	instance->yVel = 0;
	instance->xVel = 0;

	Raziel.swimTargetSpeed = (short)(vel * instance->anim.section[0].speedAdjustment / 4096);

	if (vel < instance->zVel)
	{
		instance->zAccl = -accl;
	}
	else
	{
		instance->zAccl = accl;
	}
}

void razSetWallCrawlNodes(struct _Instance* instance, struct evPhysicsWallCrawlData* data)  // Matching - 100%
{
	struct _G2SVector3_Type vec;

	if ((data->rc & 8) != 0)
	{
		if ((((long)(MATH3D_SquareLength(data->NewPosition.x, data->NewPosition.y, data->NewPosition.z)) < 101)) == 0)
		{
			instance->position.x -= data->NewPosition.x;
			instance->position.y -= data->NewPosition.y;
		}
		vec.x = data->DropRotation.x;
		vec.y = data->DropRotation.y;
		vec.z = data->DropRotation.z;
		G2Anim_SetController_Vector(&instance->anim, 0, 8, &vec);
	}
	if (data->rc == 10)
	{
		vec.x = -data->ForwardXRotation;
		vec.y = 0;
		vec.z = 0;
		G2EmulationSetInterpController_Vector(instance, 14, 14, &vec, 3, 0);
	}
}

int razSwitchVAnimCharacterGroup(struct _Instance* instance, int animGroup, int* frame, int* frames)//Matching - 87.92%
{
	int i;
	int rc;
	int temp[3] = { 255, 255, 255 };

	if (frame == NULL)
	{
		frame = temp;
	}

	if (frames == NULL)
	{
		frames = temp;
	}

	for (i = 0; i < 3; i++)
	{
		rc = razSwitchVAnimGroup(instance, i, animGroup, frame[i], frames[i]);
	}

	return rc;
}

int razSwitchVAnimGroup(struct _Instance* instance, int section, int animGroup, int frame, int frames)//Matching - 99.35%
{
	int index;
	int rc;

	rc = 1;

	if (Raziel.Senses.heldClass != 0)
	{
		index = Raziel.Senses.heldClass - 1;

		if (index >= 3)
		{
			index = 3;
		}

		animGroup += index;

		razSwitchVAnim(instance, section, &PlayerData->virtualAnimations[animGroup], frame, frames);

		rc = 0;
	}
	
	return rc;
}


// autogenerated function stub: 
// void /*$ra*/ razSwitchVAnimCharacterSingle(struct _Instance *instance /*$s3*/, int anim /*$s4*/, int *frame /*$a2*/, int *frames /*$a3*/)
void razSwitchVAnimCharacterSingle(struct _Instance *instance, int anim, int *frame, int *frames)
{ // line 1561, offset 0x800a7348
	/* begin block 1 */
		// Start line: 1562
		// Start offset: 0x800A7348
		// Variables:
			int i; // $s0
			int temp[3]; // stack offset -40
	/* end block 1 */
	// End offset: 0x800A73E0
	// End Line: 1574

	/* begin block 2 */
		// Start line: 3336
	/* end block 2 */
	// End Line: 3337
			UNIMPLEMENTED();
}

void razSwitchVAnimSingle(struct _Instance* instance, int section, int anim, int frame, int frames)//Matching - 99.23%
{
	razSwitchVAnim(instance, section, &PlayerData->virtualAnimSingle[anim], frame, frames);
}

void razSwitchVAnim(struct _Instance* instance, int section, struct __VAnim* vAnim, int frame, int frames)//Matching - 99.90%
{
	if (frame == -1)
	{
		frame = vAnim->frame;
	}

	if (frames == -1)
	{
		frames = vAnim->frames;
	}

	switch (section)
	{
	case 0:
	{
		G2EmulationInstanceSwitchAnimationAlpha(instance, 0, vAnim->anim0, frame, frames, vAnim->mode, vAnim->alpha);
		break;
	}
	case 1:
	{
		G2EmulationInstanceSwitchAnimationAlpha(instance, 1, vAnim->anim1, frame, frames, vAnim->mode, vAnim->alpha);
		break;
	}
	case 2:
	{
		G2EmulationInstanceSwitchAnimationAlpha(instance, 2, vAnim->anim2, frame, frames, vAnim->mode, vAnim->alpha);
		break;
	}
	}
}

int razProcessSAnim(struct _Instance* instance, int mode)
{
	int rc;
	struct __SAnim* nextAnim;
	struct __VAnim* vanim;
	int i;

	rc = 0;

	switch (mode)
	{
	case 0x8000000:
		if (Raziel.currentSAnim->mode == 1)
		{
			rc = 1;
		}
		break;
	case 0x100015:
		if (Raziel.currentSAnim->mode == 2)
		{
			rc = 1;
		}
		break;
	case 0x8000003:
		if (Raziel.currentSAnim->mode == 3)
		{
			rc = 1;
		}
		break;
	}

	if (rc)
	{
		nextAnim = Raziel.currentSAnim->nextAnim;
		if (nextAnim)
		{
			Raziel.currentSAnim = Raziel.currentSAnim->nextAnim;
			vanim = nextAnim->anim;
			if (vanim)
			{
				for (i = 0; i < 3; i++)
				{
					razSwitchVAnim(instance, i, vanim, -1, -1);
					G2Anim_SetSpeedAdjustment(&instance->anim, Raziel.currentSAnim->speedAdjust);
				}
				if (Raziel.currentSAnim->mode == 2)
				{
					SetTimer(Raziel.currentSAnim->data);
				}
			}
		}
		else
		{
			G2Anim_SetSpeedAdjustment(&instance->anim, 4096);
			Raziel.currentSAnim = NULL;
			rc = 0;
		}

	}
	return rc;
}

void razSwitchStringAnimation(struct _Instance* instance, int anim)
{
	struct __VAnim* vanim;
	int i;
	
	Raziel.currentSAnim = PlayerData->stringAnimations[anim];

	vanim = Raziel.currentSAnim->anim;

	if (vanim != NULL)
	{
		for (i = 0; i < 3; i++)
		{
			razSwitchVAnim(instance, i, vanim, -1, -1);
		}

		G2Anim_SetSpeedAdjustment(&instance->anim, Raziel.currentSAnim->speedAdjust);

		if (Raziel.currentSAnim->mode == 2)
		{
			SetTimer(Raziel.currentSAnim->data);
		}
	}
}

int CheckStringAnimation(struct _Instance* instance, int mode)//Matching - 99.17%
{
	int rc;

	rc = 0;
	if (Raziel.currentSAnim == NULL || (rc = razProcessSAnim(instance, mode), Raziel.currentSAnim == NULL))
	{
		INSTANCE_Post(instance, 0x100000, 0);
	}

	return rc;
}


void razLaunchBubbles(int segments, int count, int type) // Matching - 100%
{
	if ((segments & 0x1))
	{
		TrailWaterFX(gameTrackerX.playerInstance, 32, count, type);

		TrailWaterFX(gameTrackerX.playerInstance, 42, count, type);
	}

	if ((segments & 0x2))
	{
		TrailWaterFX(gameTrackerX.playerInstance, 8, count, type);

		TrailWaterFX(gameTrackerX.playerInstance, 12, count, type);
	}
}

void razSetCowlNoDraw(int mode) // Matching - 99.89%
{
	unsigned short* temp;  // not from SYMDUMP

	temp = (unsigned short*)&cowlList;

	do
	{
		if (mode != 0)
		{
			gameTrackerX.playerInstance->object->modelList[gameTrackerX.playerInstance->currentModel]->faceList[*temp].flags |= 0x10;
		}
		else
		{
			gameTrackerX.playerInstance->object->modelList[gameTrackerX.playerInstance->currentModel]->faceList[*temp].flags &= ~0x10;
		}

		temp++;
	} while ((int)temp < (int)&cowlList[20]);
}

void razAttachControllers()
{
	int i;
	
	for (i = 0; i < 24; i++)
	{
		G2Anim_AttachControllerToSeg(&gameTrackerX.playerInstance->anim, controllerList[i].segment, controllerList[i].type);
		G2Anim_DisableController(&gameTrackerX.playerInstance->anim, controllerList[i].segment, controllerList[i].type);
	}
}

void razSetPlayerEvent()
{
	void (*process)(struct __CharacterState*, int, int);
	int message;
	int data;

	process = Raziel.State.SectionList[0].Process;
	
	message = 0;
	
	data = 0;

	if ((Raziel.Senses.EngagedMask & 0x1))
	{
		if (Raziel.Senses.heldClass != 3 && process == &StateHandlerIdle)
		{
			Raziel.playerEvent |= 0x1;
		}
	}

	if ((Raziel.Senses.EngagedMask & 0x4))
	{
		if (Raziel.Senses.heldClass != 3 && process == &StateHandlerCrouch)
		{
			Raziel.playerEvent |= 0x2;
		}
	}

	if ((Raziel.Senses.EngagedMask & 0x8))
	{
		if (Raziel.Senses.heldClass != 3 && process == &StateHandlerIdle)
		{
			if (INSTANCE_Query(Raziel.Senses.EngagedList[3].instance, 0x4) == 9)
			{
				Raziel.playerEvent |= 0x8;
			}
			else
			{
				Raziel.playerEvent |= 0x4;
			}
		}
	}

	if ((Raziel.Senses.EngagedMask & 0x20))
	{
		if (razGetHeldItem() == NULL)
		{
			if (Raziel.CurrentPlane == 1)
			{
				if (process == &StateHandlerIdle ||
					process == &StateHandlerStartMove ||
					process == &StateHandlerMove ||
					process == &StateHandlerJump ||
					process == &StateHandlerFall ||
					process == &StateHandlerSwim ||
					process == &StateHandlerAutoFace)
				{
					Raziel.playerEvent |= 0x10;
				}
			}
		}
	}

	if ((Raziel.Senses.EngagedMask & 0x40))
	{
		if (!(INSTANCE_Query(Raziel.Senses.EngagedList[6].instance, 0xA) & 0x4))
		{
			Raziel.playerEvent |= 0x20;
		}
	}

	if (StateHandlerDecodeHold(&message, &data) != 0 && data != 0)
	{
		if (message == 0x1000002)
		{
			Raziel.playerEvent |= 0x40;
		}

		if (message == 0x100000A)
		{
			Raziel.playerEvent |= 0x80;
		}

		if (message == 0x1000018)
		{
			Raziel.playerEvent |= 0x100;
		}
	}

	if ((Raziel.Mode & 0x20000) && (unsigned int)(Raziel.Senses.heldClass - 1) < 3)
	{
		Raziel.playerEvent |= 0x200;
	}

	if (message == 0x80000)
	{
		Raziel.playerEvent |= 0x400;
	}

	if ((Raziel.Senses.EngagedMask & 0x4000))
	{
		Raziel.playerEvent |= 0x800;
	}

	if ((Raziel.Senses.Flags & 0x40))
	{
		Raziel.playerEvent |= 0x2000;
	}
}

void razClearPlayerEvent()
{ 
	if ((ControlFlag & 0x100000))
	{
		Raziel.playerEvent &= 0x2000;

		return;
	}

	Raziel.playerEvent = 0;
}

void razSetPlayerEventHistory(unsigned long event)
{
	Raziel.playerEventHistory |= event;
}

int razSideMoveSpiderCheck(struct _Instance* instance, int x) // Matching - 100%
{
	SVECTOR startVec;
	SVECTOR endVec;

	PHYSICS_GenericLineCheckSetup(x, 0, 192, &startVec);
	PHYSICS_GenericLineCheckSetup(x, -320, 192, &endVec);
	if (!(PHYSICS_CheckForValidMove(instance, &startVec, &endVec, 0) & 1))
	{
		return 1;
	}
	PHYSICS_GenericLineCheckSetup(x, 0, 0, &startVec);
	PHYSICS_GenericLineCheckSetup(x, -320, 0, &endVec);
	return PHYSICS_CheckForValidMove(instance, &startVec, &endVec, 0) & 1 ^ 1;
}

struct _Instance* RAZIEL_QueryEngagedInstance(int index)
{
	if (!(Raziel.Senses.EngagedMask & (1 << index)))
	{
		return NULL;
	}
	else
	{
		return Raziel.Senses.EngagedList[index].instance;
	}
}


// autogenerated function stub: 
// int /*$ra*/ razUpdateSoundRamp(struct _Instance *instance /*$a0*/, struct _SoundRamp *sound /*$s0*/)
int razUpdateSoundRamp(struct _Instance *instance, struct _SoundRamp *sound)
{ // line 1955, offset 0x800a7db0
	UNIMPLEMENTED();
	return 0;
}


void razSetupSoundRamp(struct _Instance* instance, struct _SoundRamp* sound, int sfx, int startPitch, int endPitch, int startVolume, int endVolume, int timer, int distance)  // Matching - 100%
{
	if (sound->soundHandle == 0)
	{
		sound->soundHandle = SOUND_Play3dSound(&instance->position, sfx, startPitch, startVolume, distance);
	}
	if (timer == 0)
	{
		sound->soundHandle = 0;
	}
	sound->soundStartPitch = startPitch;
	sound->soundEndPitch = endPitch;
	sound->soundStartVolume = startVolume;
	sound->soundEndVolume = endVolume;
	sound->soundDistance = distance;
	sound->soundTotalTime = timer;
	sound->soundTimer = 0;
}

void RAZIEL_SetInteractiveMusic(int modifier, int action)
{
	int soundFlag;

	soundFlag = 1 << modifier;

	if (action != 0)
	{
		if (!(Raziel.soundModifier & soundFlag))
		{
			SOUND_SetMusicModifier(modifier);
		}

		Raziel.soundModifier |= soundFlag;
	}
	else
	{
		if ((Raziel.soundModifier & soundFlag))
		{
			SOUND_ResetMusicModifier(modifier);
		}

		Raziel.soundModifier &= ~soundFlag;
	}
}

void RAZIEL_DebugHurtRaziel()
{
	LoseHealth(4096);
}

void RAZIEL_StartNewGame()
{
	memset(&Raziel, 0, sizeof(Raziel));
}

int razInBaseArea(char* name, int length)
{
	char string[9];
	
	if (strcpy(string, gameTrackerX.baseAreaName) != NULL)
	{
		string[length] = 0;
	}
	
	return strcmp(name, string) == 0;
}

void razPrepGlyph()
{
	struct _Instance* heldInst;
	
	razReaverOff();

	heldInst = razGetHeldItem();

	if (heldInst != NULL)
	{
		razSetFadeEffect(0, 4096, 256);

		Raziel.throwInstance = heldInst;
	}

	ControlFlag |= 0x4000;
}
