#include "Game/CORE.H"
#include "Game/GAMELOOP.H"
#include "HEALTH.H"
#include "Game/FONT.H"
#include "RAZLIB.H"
#include "Game/G2/ANMCTRLR.H"
#include "RAZIEL.H"
#include "Game/STREAM.H"
#include "Game/RAZIEL/PUPPET.H"
#include "Game/FX.H"
#include "Game/RAZIEL/RAZIEL.H"
#include "Game/MATH3D.H"
#include "Game/RAZIEL/CONTROL.H"
#include "Game/DEBUG.H"
#include "Game/RAZIEL/SWIM.H"
#include "Game/RAZIEL/ATTACK.H"
#include "Game/STATE.H"
#include "Game/G2/TIMERG2.H"
#include "Game/G2/ANMG2ILF.H"

struct __Player Raziel;
struct __razController controllerList[] = { 
	{ 0x0000, 0x0026 },
	{ 0x0000, 0x0064 },
	{ 0x0000, 0x0020 },
	{ 0x0000, 0x0022 },
	{ 0x0000, 0x0008 },
	{ 0x0000, 0x000E },
	{ 0x0001, 0x0026 },
	{ 0x0001, 0x000E },
	{ 0x0001, 0x000A },
	{ 0x0011, 0x000E },
	{ 0x0011, 0x0008 },
	{ 0x0010, 0x000E },
	{ 0x000F, 0x000E },
	{ 0x000E, 0x000E },
	{ 0x000E, 0x0008 },
	{ 0x0030, 0x0008 },
	{ 0x0032, 0x004C },
	{ 0x0033, 0x0008 },
	{ 0x0034, 0x0008 },
	{ 0x0035, 0x0008 },
	{ 0x003A, 0x004C },
	{ 0x003B, 0x0008 },
	{ 0x003C, 0x0008 },
	{ 0x003D, 0x0008 },

}; // offset 0x800d1c64

// autogenerated function stub: 
// void /*$ra*/ razAlignYMoveRot(struct _Instance *dest /*$s3*/, short distance /*$a1*/, _Position *position /*$s4*/, struct _Rotation *rotation /*$s2*/, int extraZ /*stack 16*/)
void razAlignYMoveRot(struct _Instance *dest, short distance, _Position *position, struct _Rotation *rotation, int extraZ)
{ // line 12, offset 0x800a51b0
	/* begin block 1 */
		// Start line: 13
		// Start offset: 0x800A51B0
		// Variables:
			SVECTOR d; // stack offset -72
			SVECTOR dd; // stack offset -64
			//MATRIX mat; // stack offset -56
	/* end block 1 */
	// End offset: 0x800A51B0
	// End Line: 13

	/* begin block 2 */
		// Start line: 24
	/* end block 2 */
	// End Line: 25
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ razAlignYRotMove(struct _Instance *dest /*$s1*/, short distance /*$a1*/, _Position *position /*$s2*/, struct _Rotation *rotation /*$s4*/, int extraZ /*stack 16*/)
void razAlignYRotMove(struct _Instance *dest, short distance, _Position *position, struct _Rotation *rotation, int extraZ)
{ // line 54, offset 0x800a5274
	/* begin block 1 */
		// Start line: 55
		// Start offset: 0x800A5274
		// Variables:
			//SVECTORd; // stack offset -88
			//SVECTORdd; // stack offset -80
			//SVECTORrot; // stack offset -72
			//MATRIX mat; // stack offset -64
	/* end block 1 */
	// End offset: 0x800A5274
	// End Line: 55

	/* begin block 2 */
		// Start line: 136
	/* end block 2 */
	// End Line: 137
	UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ razAlignYRotMoveInterp(struct _Instance *source /*$s1*/, struct _Instance *dest /*$a1*/, short distance /*$a2*/, unsigned char segNumber /*$s0*/, int Frames /*stack 16*/, int extraZ /*stack 20*/)
void razAlignYRotMoveInterp(struct _Instance *source, struct _Instance *dest, short distance, unsigned char segNumber, int Frames, int extraZ)
{ // line 86, offset 0x800a534c
	/* begin block 1 */
		// Start line: 87
		// Start offset: 0x800A534C
		// Variables:
			_Position position; // stack offset -40
			struct _Rotation rotation; // stack offset -32
			struct _G2SVector3_Type v; // stack offset -24
	/* end block 1 */
	// End offset: 0x800A534C
	// End Line: 87

	/* begin block 2 */
		// Start line: 210
	/* end block 2 */
	// End Line: 211
			UNIMPLEMENTED();
}

void razAlignYRotInterp(struct _Instance* source, _Position* dest, unsigned char segNumber, int Frames)
{
	source->rotation.z = MATH3D_AngleFromPosToPos(&source->position, dest);
}


// autogenerated function stub: 
// int /*$ra*/ razConstrictAngle(struct _Instance *instance /*$a0*/)
int razConstrictAngle(struct _Instance *instance)
{ // line 195, offset 0x800a546c
	/* begin block 1 */
		// Start line: 196
		// Start offset: 0x800A546C
		// Variables:
			int i; // $s0
			int j; // $s2
			int k; // $a2
			int Total; // $s1
			int outer; // stack offset -32
			int rc; // $s3
			struct _SVector point; // stack offset -40
	/* end block 1 */
	// End offset: 0x800A5564
	// End Line: 243

	/* begin block 2 */
		// Start line: 390
	/* end block 2 */
	// End Line: 391
			UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// void /*$ra*/ razRotateUpperBody(struct _Instance *instance /*$s3*/, struct evActionLookAroundData *data /*$a1*/)
void razRotateUpperBody(struct _Instance *instance, struct evActionLookAroundData *data)
{ // line 247, offset 0x800a5580
	/* begin block 1 */
		// Start line: 248
		// Start offset: 0x800A5580
		// Variables:
			int tx; // $s0
			int tz; // $s2
			struct _G2SVector3_Type Rot; // stack offset -32
	/* end block 1 */
	// End offset: 0x800A5608
	// End Line: 268

	/* begin block 2 */
		// Start line: 555
	/* end block 2 */
	// End Line: 556
			UNIMPLEMENTED();
}

void razSetFadeEffect(short source, short dest, int steps)
{
	Raziel.effectsFadeSource = source;

	Raziel.effectsFadeDest = dest;

	Raziel.effectsFadeSteps = 0;

	Raziel.effectsFadeStep = steps;

	Raziel.effectsFlags |= 0x3;
}

int razPlaneShift(struct _Instance *instance)
{
	if (!(gameTrackerX.streamFlags & 0x40000))
	{
		if (Raziel.CurrentPlane == 1)
		{
			razSpectralShift();

			return 1;
		}
		else
		{
			razMaterialShift();

			return 1;
		}
	}

	return 0;
}

void razSpectralShift()
{
#if defined(PSX_VERSION)

	struct _Instance* inst;

	if (!(gameTrackerX.streamFlags & 0x40000))
	{
		if (Raziel.CurrentPlane == 1)
		{
			inst = razGetHeldItem();
			
			if (inst != NULL)
			{
				INSTANCE_Post(inst, 0x800008, 4);

				razSetFadeEffect(4096, 0, 256);
			}

			gameTrackerX.playerInstance->flags2 |= 0x8000000;

			INSTANCE_Post(gameTrackerX.playerInstance, 0x100014, 0);

			if (Raziel.HitPoints == gameTrackerX.playerInstance->flags2)
			{
				Raziel.HitPoints = 0x186A0;
			}
			else
			{
				Raziel.HitPoints = 0x14586;
			}

			Raziel.CurrentPlane = 2;

			razReaverOn();

			if (gameTrackerX.gameData.asmData.MorphType == 0)
			{
				MORPH_ToggleMorph();

				if (Raziel.State.SectionList[0].Process != StateHandlerGlyphs &&
				    Raziel.State.SectionList[0].Process != StateHandlerPuppetShow)
				{
					INSTANCE_Post(gameTrackerX.playerInstance, 0x40005, 0);
				}
			}
		}
	}

#elif defined(PC_VERSION)
	struct _Instance* LinkChild; // edx
	struct _Instance* LinkSibling; // eax
	struct _Instance* v2; // eax
	int v3; // eax
	int v4; // eax
	struct _Instance* v5; // eax

	if ((gameTrackerX.streamFlags & 0x40000) != 0 || dword_B08850 != 1)
		return;
	LinkChild = stru_B0841C.CharacterInstance->LinkChild;
	LinkSibling = LinkChild;
	if (Inst && LinkChild == Inst)
	{
		if (!LinkChild)
			goto LABEL_15;
		LinkSibling = LinkChild->LinkSibling;
	}
	if (LinkSibling)
	{
		if (dword_B08804 == 8)
		{
			v2 = stru_B0841C.CharacterInstance->LinkChild;
			if (Inst && LinkChild == Inst && LinkChild)
				v2 = LinkChild->LinkSibling;
			INSTANCE_PlainDeath(v2);
		}
		else
		{
			INSTANCE_Post(LinkSibling, 0x800008, 4);
			v3 = dword_B08934;
			LOBYTE(v3) = dword_B08934 | 3;
			word_B08938 = 4096;
			dword_B08934 = v3;
			word_B0893A = 0;
			dword_B08940 = 0;
			dword_B0893C = 256;
		}
	}
LABEL_15:
	gameTrackerX.playerInstance->flags2 |= 0x8000000u;
	INSTANCE_Post(gameTrackerX.playerInstance, 0x100014, 0);
	if (dword_B08850 == 2)
		v4 = 100000;
	else
		v4 = 100000 * (word_B08810 + 1);
	dword_B08850 = 2;
	current_health = v4 != current_health ? 83334 : 100000;
	if (Inst)
	{
		v5 = stru_B0841C.CharacterInstance->LinkChild;
		if (v5 == Inst)
		{
			if (!v5)
			{
			LABEL_23:
				if ((INSTANCE_Query(Inst, 40) & 1) == 0)
					INSTANCE_Post(Inst, 0x800100, 0);
				dword_B08804 = 4096;
				if (dword_B08850 == 2 && dword_B0884C != 1)
				{
					dword_B0884C = 1;
					debugRazielFlags2 = 1024;
					INSTANCE_Post(Inst, 0x800103, 1);
				}
				if (dword_B08850 == 1 && dword_B0884C == 1)
				{
					dword_B0884C = 2;
					debugRazielFlags2 = 2048;
					INSTANCE_Post(Inst, 0x800103, 2);
				}
				goto LABEL_31;
			}
			v5 = v5->LinkSibling;
		}
		if (!v5)
			goto LABEL_23;
	}
LABEL_31:
	if (!gameTrackerX.gameData.asmData.MorphType)
	{
		MORPH_ToggleMorph();
		if ((int(__cdecl*)(int, int, int))stru_B0841C.SectionList[0].Process != StateHandlerGlyphs
			&& (int(__cdecl*)(struct __CharacterState*, int, int))stru_B0841C.SectionList[0].Process != StateHandlerPuppetShow)
		{
			INSTANCE_Post(gameTrackerX.playerInstance, 262149, 0);
		}
	}
#endif
}

void razMaterialShift()
{
	if (Raziel.CurrentPlane == 2)
	{
		if (Raziel.HitPoints == 0x186A0)
		{
			Raziel.CurrentPlane = 1;

			gameTrackerX.playerInstance->flags &= 0xF7FFFFFF;

			Raziel.HitPoints = GetMaxHealth();

			Raziel.DamageFrequency = 0;

			razReaverOn();

			if (gameTrackerX.gameData.asmData.MorphType != 0)
			{
				MORPH_ToggleMorph();

				if (Raziel.State.SectionList[0].Process != StateHandlerGlyphs &&
					Raziel.State.SectionList[0].Process != StateHandlerPuppetShow)
				{
					INSTANCE_Post(gameTrackerX.playerInstance, 0x40005, 0);
				}

				if (Raziel.Senses.Portal != NULL)
				{
					FX_EndInstanceParticleEffects(Raziel.Senses.Portal);
				}
			}
		}
	}
}

int RAZIEL_OkToShift()
{
#if defined(PSX_VERSION)

	if (Raziel.CurrentPlane == 2)
	{
		if (GetMaxHealth() == Raziel.HitPoints)
		{
			if ((Raziel.Abilities & 0x40))
			{
				if (!(Raziel.Abilities & 0x10))
				{
					FONT_Print("\nYOU CAN NOT HAVE SHIFT ANYTIME WITHOUT THE SWIM ABILITY");
					FONT_Print("\nBEAT THE ALUKA BOSS THEN WIN THE SECOND KAIN ENCOUNTER");

					return 0;
				}
				else
				{
					return 1;
				}
			}
			else
			{
				return 0 < (Raziel.Senses.Flags & 0x40);
			}
		}
		else
		{
			return 0;
		}
	}

	return 1;

#elif defined(PC_VERSION)
	if (dword_B08850 != 2)
		return 1;
	if (current_health != 100000)
		return 0;
	if ((dword_B08820 & 0x40) != 0)
		return (unsigned __int8)(dword_B08820 & 0x10) >> 4;
	return (unsigned __int8)(dword_B087B4 & 0x40) >> 6;
#endif
}


// autogenerated function stub: 
// int /*$ra*/ razPickupAndGrab(struct __CharacterState *In /*$s1*/, int CurrentSection /*$s2*/)
int razPickupAndGrab(struct __CharacterState *In, int CurrentSection)
{ // line 409, offset 0x800a5a44
#if defined(PC_VERSION)
	struct _Instance* LinkChild; // eax
	struct _Instance* LinkParent; // eax
	int v5; // esi
	struct _Instance* v6; // eax
	int v7; // esi
	int v8; // edx
	struct _Instance* v9; // eax
	struct _Instance* v10; // esi
	struct _Instance* v11; // esi
	unsigned int v12; // eax

	if ((dword_B087F4 & 0x20) == 0)
		return 1;
	LinkChild = stru_B0841C.CharacterInstance->LinkChild;
	if (Inst && LinkChild == Inst)
	{
		if (!LinkChild)
			goto LABEL_7;
		LinkChild = LinkChild->LinkSibling;
	}
	if (LinkChild)
		return 1;
LABEL_7:
	if (dword_B08850 != 1 || (dword_B087B4 & 0x80u) != 0)
		return 1;
	if (CurrentSection != 1)
		return 0;
	LinkParent = dword_B087F0[10]->LinkParent;
	if (LinkParent && !(INSTANCE_Query(LinkParent, 0) | 0x40000000))
		return 0;
	v5 = SetObjectData(0, 0, 8, In->CharacterInstance, 1);
	INSTANCE_Post(dword_B087F0[10], 0x80002E, v5);
	if (*(_WORD*)(v5 + 6))
		return 0;
	v6 = dword_B087F0[10]->LinkParent;
	if (v6)
	{
		INSTANCE_Post(v6, 0x100001B, 0);
		INSTANCE_UnlinkFromParent(dword_B087F0[10]);
	}
	v7 = SetObjectData(0, 0, 8, In->CharacterInstance, 49);
	INSTANCE_Post(dword_B087F0[10], 0x800002, v7);
	if (*(_WORD*)(v7 + 6))
		return 0;
	v8 = dword_B087B4;
	v9 = Inst;
	LOBYTE(v8) = dword_B087B4 | 0x80;
	dword_B087B4 = v8;
	if (!Inst || dword_B08804 != 4096)
		goto LABEL_32;
	v10 = stru_B0841C.CharacterInstance->LinkChild;
	if (v10 == Inst)
	{
		if (!v10)
			goto LABEL_26;
		v10 = v10->LinkSibling;
	}
	if (v10)
	{
		v11 = (INSTANCE_Query(v10, 1) & 0x20) != 0 ? v10 : 0;
		v9 = Inst;
		goto LABEL_28;
	}
LABEL_26:
	v11 = Inst;
LABEL_28:
	if ((INSTANCE_Query(v9, 40) & 1) != 0)
		INSTANCE_Post(Inst, 0x800101, 0);
	if (v11 == Inst)
		dword_B08804 = 0;
LABEL_32:
	In->SectionList[1].Data1 = 0;
	v12 = INSTANCE_Query(dword_B087F0[10], 4);
	if ((dword_B08778 & 0x40000) == 0)
	{
		G2EmulationSwitchAnimation(In, 1, (unsigned __int8)byte_4F4900[v12], 0, 3, 1);
		dword_B08920 = (int)In->SectionList[1].Process;
		StateSwitchStateData(In, 1, StateHandlerPickupObject, 0);
	}
	return 0;
#else
	UNIMPLEMENTED();
	return 0;
#endif
}

int razZeroAxis(long* x, long* y, int radius)//Matching - 99.79%
{
#if defined(PSX_VERSION)
	unsigned long distance;

	distance = MATH3D_SquareLength(*x, *y, 0);

	if (distance < radius)
	{
		distance = 0;

		*x = 0;
		*y = 0;
	}

	return distance;

#elif defined(PC_VERSION)
	int result; // eax

	result = MATH3D_SquareLength(*x, *y, 0);
	if (result < (unsigned int)radius)
	{
		*x = 0;
		*y = 0;
		return 0;
	}
	return result;
#endif
}

int razAdjustSpeed(struct _Instance* instance, int minSpeed)//Matching - 90.51%
{
#if defined(PSX_VERSION)
	long adjustment;
	int data;

	if (Raziel.movementMaxAnalog < Raziel.Magnitude)
	{
		adjustment = Raziel.movementMaxRate;
	}
	else if (Raziel.Magnitude < Raziel.movementMinAnalog)
	{
		adjustment = Raziel.movementMinRate;
	}
	else
	{
		adjustment = Raziel.movementMaxRate - ((Raziel.movementMaxRate - Raziel.movementMinRate) * (Raziel.movementMaxAnalog - Raziel.Magnitude)) / (Raziel.movementMaxAnalog - Raziel.movementMinAnalog);
	}

	G2Anim_SetSpeedAdjustment(&instance->anim, adjustment);

	return adjustment;
#elif defined(PC_VERSION)
	int v2; // esi

	if (dword_B0878C <= word_B087B2)
	{
		if (dword_B0878C >= word_B087B0)
			v2 = word_B087AE - (word_B087B2 - dword_B0878C) * (word_B087AE - word_B087AC) / (word_B087B2 - word_B087B0);
		else
			v2 = word_B087AC;
	}
	else
	{
		v2 = word_B087AE;
	}
	G2Anim_SetSpeedAdjustment(&instance->anim, v2);
	return v2;
#endif
}


// autogenerated function stub: 
// void /*$ra*/ razLaunchForce(struct _Instance *instance /*$s0*/)
void razLaunchForce(struct _Instance *instance)
{ // line 558, offset 0x800a5d50
#if defined(PC_VERSION)
	int v2; // edi
	int v3; // ebx
	__int32 v4; // esi
	__int16 v5; // [esp+10h] [ebp-4h]
	__int16 parent; // [esp+18h] [ebp+4h]

	PHYSOB_BirthProjectile(instance, 49, (dword_B08820 & 0x100) != 0);
	dword_B08934 |= 4u;
	v2 = *(__int16*)(dword_B08B3C + 60);
	v3 = *(__int16*)(dword_B08B3C + 56);
	parent = *(_WORD*)(dword_B08B3C + 58);
	v5 = *(_WORD*)(dword_B08B3C + 62);
	v4 = 30 * *(_DWORD*)(dword_B08B3C + 64);
	if (!sound.soundHandle)
		sound.soundHandle = SOUND_Play3dSound(&instance->position, 12, v3, v2, 10000);
	if (!v4)
		sound.soundHandle = 0;
	sound.soundStartVolume = v2;
	sound.soundTotalTime = v4;
	sound.soundStartPitch = v3;
	sound.soundEndPitch = parent;
	sound.soundEndVolume = v5;
	sound.soundDistance = 10000;
	sound.soundTimer = 0;
	dword_B089B0 = 0;
	dword_B089B4 = 0;
#else
	UNIMPLEMENTED();
#endif
}

struct _Instance* razGetHeldItem()
{
#if defined(PSX_VERSION)
	struct _Instance* instance;

	instance = Raziel.State.CharacterInstance->LinkChild;

	if (Raziel.soulReaver && instance == Raziel.soulReaver && instance != NULL)
	{
		instance = instance->LinkSibling;
	}

	return instance;

#elif defined(PC_VERSION)
	struct _Instance* result; // eax

	result = stru_B0841C.CharacterInstance->LinkChild;
	if (Inst && result == Inst)
	{
		if (result)
			return result->LinkSibling;
	}
	return result;
#endif
}

struct _Instance* razGetHeldWeapon()
{
#if defined(PSX_VERSION)
	struct _Instance* instance;

	instance = razGetHeldItem();

	if (instance == NULL)
	{
		if (Raziel.Senses.heldClass != 0)
		{
			return Raziel.soulReaver;
		}
	}
	else
	{
		if ((INSTANCE_Query(instance, 0x1) & 0x20))
		{
			return instance;
		}
	}

	return NULL;
#elif defined(PC_VERSION)
	struct _Instance* LinkChild; // esi

	LinkChild = stru_B0841C.CharacterInstance->LinkChild;
	if (Inst && LinkChild == Inst)
	{
		if (!LinkChild)
			return dword_B08804 != 0 ? Inst : 0;
		LinkChild = LinkChild->LinkSibling;
	}
	if (!LinkChild)
		return dword_B08804 != 0 ? Inst : 0;
	return (INSTANCE_Query(LinkChild, 1) & 0x20) != 0 ? LinkChild : 0;
#endif
}

void razReaverBladeOff()
{
	if (Raziel.soulReaver != NULL)
	{
		INSTANCE_Post(Raziel.soulReaver, 0x800109, 2);
	}
}

void razReaverBladeOn()
{
	if (Raziel.soulReaver != NULL && razGetHeldItem() == NULL)
	{
		INSTANCE_Post(Raziel.soulReaver, 0x800108, 2);
	}
}


// autogenerated function stub: 
// int /*$ra*/ razReaverOff()
int razReaverOff()
{ // line 649, offset 0x800a5ee8
	UNIMPLEMENTED();
	return 0;
}

int razReaverOn()
{
#if defined(PSX_VERSION)
	
	if (Raziel.soulReaver != NULL)
	{
		if (razGetHeldItem() == NULL)
		{
			if (GetMaxHealth() == Raziel.HitPoints || Raziel.CurrentPlane == 2)
			{
				if (!(INSTANCE_Query(Raziel.soulReaver, 0x28) & 0x1))
				{
					INSTANCE_Post(Raziel.soulReaver, 0x800100, 0);
				}
				
				Raziel.Senses.heldClass = 4096;

				if (Raziel.CurrentPlane == 2 && Raziel.currentSoulReaver != 1)
				{
					razReaverImbue(1);
				}
				
				if (Raziel.CurrentPlane == 1 && Raziel.currentSoulReaver == 1)
				{
					razReaverImbue(2);
				}
				
				return 1;
			}

			return 2;
		}
	}
	
	return 0;

#elif defined(PC_VERSION)
	struct _Instance* LinkChild; // eax
	int v1; // eax

	if (!Inst)
		return 0;
	LinkChild = stru_B0841C.CharacterInstance->LinkChild;
	if (LinkChild == Inst)
	{
		if (!LinkChild)
			goto LABEL_6;
		LinkChild = LinkChild->LinkSibling;
	}
	if (LinkChild)
		return 0;
LABEL_6:
	if (dword_B08850 == 2)
		v1 = 100000;
	else
		v1 = 100000 * (word_B08810 + 1);
	if (current_health != v1 && dword_B08850 != 2)
		return 0;
	if ((INSTANCE_Query(Inst, 40) & 1) == 0)
		INSTANCE_Post(Inst, 0x800100, 0);
	dword_B08804 = 4096;
	if (dword_B08850 == 2 && dword_B0884C != 1)
	{
		dword_B0884C = 1;
		debugRazielFlags2 = 1024;
		INSTANCE_Post(Inst, 0x800103, 1);
	}
	if (dword_B08850 == 1 && dword_B0884C == 1)
	{
		dword_B0884C = 2;
		debugRazielFlags2 = 2048;
		INSTANCE_Post(Inst, 0x800103, 2);
	}
	return 1;
#endif
}


// autogenerated function stub: 
// void /*$ra*/ razReaverPickup(struct _Instance *instance /*$a2*/, struct _Instance *soulReaver /*$s0*/)
void razReaverPickup(struct _Instance *instance, struct _Instance *soulReaver)
{ // line 691, offset 0x800a6054
	UNIMPLEMENTED();
}

void razReaverImbue(int reaverType)
{
#if defined(PSX_VERSION)
	Raziel.currentSoulReaver = reaverType;

	debugRazielFlags2 = 1 << (reaverType + 9);

	INSTANCE_Post(Raziel.soulReaver, 0x800103, reaverType);

#elif defined(PC_VERSION)
	if (reaverType == 1 || reaverType == 2 || reaverType == 6)
	{
		dword_B0884C = reaverType;
		debugRazielFlags2 = 1 << (reaverType + 9);
		INSTANCE_Post(Inst, 0x800103, reaverType);
	}
#endif
}

int razGetReaverFromMask(int reaverMask)
{
	int rc;

	rc = 0;

	reaverMask <<= 10;
	reaverMask &= 0xFF;

	while (reaverMask)
	{
		reaverMask >>= 1;
		rc++;
	}

	return rc;
}


// autogenerated function stub: 
// void /*$ra*/ razReaverScale(int scale /*$s1*/)
void razReaverScale(int scale)
{ // line 745, offset 0x800a618c
	UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ razGetForwardNormal(struct _Instance *inst /*$a0*/, struct _Instance *target /*$a1*/)
void razGetForwardNormal(struct _Instance *inst, struct _Instance *target)
{ // line 760, offset 0x800a61f4
#if defined(PC_VERSION)
	MATRIX* matrix; // eax
	MATRIX* v3; // eax
	__int16 v4[4]; // [esp+0h] [ebp-3Ch] BYREF
	__int16 v5[4]; // [esp+8h] [ebp-34h] BYREF
	struct _PCollideInfo v6; // [esp+10h] [ebp-2Ch] BYREF

	v6.newPoint = (struct SVECTOR*)v5;
	v6.oldPoint = (struct SVECTOR*)v4;
	matrix = inst->matrix;
	v4[0] = matrix[1].t[0];
	v4[1] = matrix[1].t[1];
	v4[2] = matrix[1].t[2];
	v3 = target->matrix;
	v5[0] = v3[1].t[0];
	v5[1] = v3[1].t[1];
	v5[2] = v3[1].t[2];
	PHYSICS_CheckLineInWorld(inst, &v6);
	if (v6.type == 2 || v6.type == 3 || v6.type == 5)
	{
		stru_B087B8.x = v6.wNormal.vx;
		stru_B087B8.y = v6.wNormal.vy;
		stru_B087B8.z = v6.wNormal.vz;
	}
#else
	UNIMPLEMENTED();
#endif
}


// autogenerated function stub: 
// void /*$ra*/ razGetRotFromNormal(struct _SVector *normal /*$a0*/, struct _Rotation *rot /*$a2*/)
void razGetRotFromNormal(struct _SVector *normal, struct _Rotation *rot)
{ // line 797, offset 0x800a62d8
	UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ razCenterWithBlock(struct _Instance *inst /*$s3*/, struct _Instance *target /*$s1*/, int dist /*$s2*/)
void razCenterWithBlock(struct _Instance *inst, struct _Instance *target, int dist)
{ // line 811, offset 0x800a6324
#if defined(PC_VERSION)
	int z; // eax
	__int16 x; // bp
	int v5; // ecx
	__int16 v6; // ax
	int v7; // ebx
	int v8; // edx
	int v9; // eax
	__int16 y; // ax
	__int16 v11; // cx
	int v12; // [esp+10h] [ebp-54h]
	_Position to; // [esp+14h] [ebp-50h] BYREF
	_Position from; // [esp+1Ch] [ebp-48h] BYREF
	struct _G2SVector3_Type vec; // [esp+24h] [ebp-40h] BYREF
	SVECTOR v0; // [esp+2Ch] [ebp-38h] BYREF
	SVECTOR v1; // [esp+34h] [ebp-30h] BYREF
	struct _Rotation rot; // [esp+3Ch] [ebp-28h] BYREF
	MATRIX mat; // [esp+44h] [ebp-20h] BYREF

	v12 = 0;
	razGetForwardNormal(inst, target);
	from = stru_B087B8;
	to.z = 0;
	to.y = 0;
	to.x = 0;
	MATH3D_RotationFromPosToPos(&from, &to, &rot);
	z = stru_B087B8.z;
	if (stru_B087B8.z < 0)
		z = -stru_B087B8.z;
	if (z > 1000)
		v12 = 1;
	MATH3D_SetUnityMatrix(&mat);
	RotMatrixZ(rot.z, &mat);
	v0.vy = 320 - dist;
	v0.vz = 0;
	v0.vx = 0;
	ApplyMatrixSV(&mat, &v0, &v1);
	x = inst->position.x;
	LOWORD(v5) = inst->position.y - target->position.y;
	v6 = x - target->position.x;
	v0.vy = v5;
	v0.vx = v6;
	v7 = v6;
	v8 = v6;
	if (v6 < 0)
		v8 = -v6;
	v9 = (__int16)v5;
	v5 = (__int16)v5;
	if ((v5 & 0x8000u) != 0)
		v5 = -(__int16)v5;
	if (v8 >= v5)
	{
		v0.vy = v9 / 2;
		if (v12)
			v0.vx = v1.vx;
	}
	else
	{
		v0.vx = v7 / 2;
		if (v12)
			v0.vy = v1.vy;
	}
	y = inst->position.y;
	vec.x = x + v1.vx - v0.vx;
	v11 = inst->position.z;
	vec.y = y + v1.vy - v0.vy;
	vec.z = v11;
	if (!G2Anim_IsControllerActive(&inst->anim, 0, 32))
		G2Anim_EnableController(&inst->anim, 0, 32);
	G2EmulationSetInterpController_Vector(inst, 0, 32, &vec, 6, 0);
	inst->rotation.z = rot.z;
#else
	UNIMPLEMENTED();
#endif
}


// autogenerated function stub: 
// void /*$ra*/ razSetPauseTranslation(struct _Instance *instance /*$a0*/)
void razSetPauseTranslation(struct _Instance *instance)
{ // line 870, offset 0x800a64f4
	UNIMPLEMENTED();
}

void razResetPauseTranslation(struct _Instance* instance)
{
	if (G2Anim_IsControllerActive(&instance->anim, 0, 0x22))
	{
		G2Anim_DisableController(&instance->anim, 0, 0x22);
	}

	ControlFlag &= 0xDFFFFFFF;
}

void razSelectMotionAnim(struct __CharacterState* In, int CurrentSection, int Frames, int* Anim)//Matching - 95.73%
{
	struct _G2SVector3_Type Vec;
	int switchType;
	int frame;
	int adjustment;
	struct _G2AnimSection_Type* animSectionA;
	struct _G2AnimSection_Type* animSectionB;
	struct _G2AnimKeylist_Type* keylist;
	int keylistID;

	switchType = 0;

	frame = 0;

	if (Raziel.Magnitude >= 3769)
	{
		if (Raziel.nothingCounter == 0)
		{
			ControlFlag &= 0xFFFFDFFF;
		}

		if ((ControlFlag & 0x20000000))
		{
			razResetPauseTranslation(In->CharacterInstance);
		}

		if (Anim[0] == 60)
		{
			if ((Raziel.passedMask & 0xF))
			{
				switchType = 3;
			}

			if ((Raziel.passedMask & 0x8))
			{
				frame = 5;
			}

			if ((Raziel.passedMask & 0x1))
			{
				frame = 23;
			}

			if ((Raziel.passedMask & 0x2))
			{
				frame = 17;
			}

			if ((Raziel.passedMask & 0x4))
			{
				frame = 11;
			}
		}
		else if (Anim[0] == 64)
		{
			if ((Raziel.passedMask & 0xF0))
			{
				switchType = 3;
			}

			if ((Raziel.passedMask & 0x80))
			{
				frame = 5;
			}

			if ((Raziel.passedMask & 0x10))
			{
				frame = 23;
			}

			if ((Raziel.passedMask & 0x20))
			{
				frame = 17;
			}

			if ((Raziel.passedMask & 0x40))
			{
				frame = 11;
			}
		}
		else if (Anim[0] != 68)
		{
			switchType = 3;
		}
	}
	else
	{
		if ((unsigned)(Raziel.Magnitude - 2784) < 985)
		{
			ControlFlag &= 0xFFFFDFFF;

			if ((ControlFlag & 0x20000000))
			{
				razResetPauseTranslation(In->CharacterInstance);
			}

			if (Anim[0] == 60)
			{
				if ((Raziel.passedMask & 0xF))
				{
					switchType = 2;
				}

				if ((Raziel.passedMask & 0x8))
				{
					frame = 7;
				}

				if ((Raziel.passedMask & 0x1))
				{
					frame = 13;
				}

				if ((Raziel.passedMask & 0x2))
				{
					frame = 20;
				}

				if ((Raziel.passedMask & 0x4))
				{
					frame = 25;
				}
			}
			else if (Anim[0] == 68)
			{
				if ((Raziel.passedMask & 0xF00))
				{
					switchType = 2;
				}

				if ((Raziel.passedMask & 0x800))
				{
					frame = 7;
				}

				if ((Raziel.passedMask & 0x100))
				{
					frame = 13;
				}

				if ((Raziel.passedMask & 0x200))
				{
					frame = 20;
				}

				if ((Raziel.passedMask & 0x400))
				{
					frame = 25;
				}
			}
			else if (Anim[0] != 64)
			{
				switchType = 2;
			}
		}
		else if (Raziel.Magnitude < 2784)
		{
			ControlFlag |= 0x2000;

			if (Anim[0] == 64)
			{
				if ((Raziel.passedMask & 0xF0))
				{
					switchType = 1;
				}

				if ((Raziel.passedMask & 0x80))
				{
					frame = 12;
				}

				if ((Raziel.passedMask & 0x10))
				{
					frame = 20;
				}

				if ((Raziel.passedMask & 0x20))
				{
					frame = 32;
				}

				if ((Raziel.passedMask & 0x40))
				{
					frame = 0;
				}
			}
			else if (Anim[0] == 68)
			{
				if ((Raziel.passedMask & 0xF00))
				{
					switchType = 1;
				}

				if ((Raziel.passedMask & 0x800))
				{
					frame = 12;
				}

				if ((Raziel.passedMask & 0x100))
				{
					frame = 20;
				}

				if ((Raziel.passedMask & 0x200))
				{
					frame = 32;
				}

				if ((Raziel.passedMask & 0x400))
				{
					frame = 0;
				}
			}
			else if (Anim[0] != 60)
			{
				switchType = 1;
			}
		}
	}

	switch (switchType)
	{
	case 1:
	{
		if (CurrentSection == 2)
		{
			Raziel.passedMask = 0;
		}

		if (razSwitchVAnimGroup(In->CharacterInstance, CurrentSection, 60, frame, Frames) != 0)
		{
			G2EmulationSwitchAnimation(In, CurrentSection, 123, frame, Frames, 2);
		}

		Raziel.movementMinRate = 4096;

		Raziel.movementMaxRate = 7168;

		Raziel.movementMinAnalog = 2300;

		Raziel.movementMaxAnalog = 2783;

		Anim[0] = 60;

		break;
	}
	case 2:
	{
		if (CurrentSection == 2)
		{
			Raziel.passedMask = 0;
		}

		if ((razSwitchVAnimGroup(In->CharacterInstance, CurrentSection, 64, frame, Frames)) != 0)
		{
			G2EmulationSwitchAnimation(In, CurrentSection, 124, frame, Frames, 2);
		}

		Raziel.movementMinRate = 3276;

		Raziel.movementMaxRate = 6144;

		Raziel.movementMinAnalog = 2783;

		Raziel.movementMaxAnalog = 3768;

		Anim[0] = 64;

		break;
	}
	case 3:
	{
		if (CurrentSection == 2)
		{
			Raziel.passedMask = 0;
		}

		if ((razSwitchVAnimGroup(In->CharacterInstance, CurrentSection, 68, frame, Frames) != 0))
		{
			G2EmulationSwitchAnimation(In, CurrentSection, 2, frame, Frames, 2);
		}

		Raziel.movementMinRate = 3547;

		Raziel.movementMaxAnalog = 4096;

		Raziel.movementMinAnalog = 3768;

		Raziel.movementMaxRate = 4096;

		Anim[0] = 68;

		break;
	}
	}

	if (CurrentSection == 0)
	{
		if (!(ControlFlag & 0x20000000))
		{
			Vec.z = 0;
			Vec.x = 0;

			switch (Anim[0])
			{
			case 0x40:
			{
				Vec.y = -35;
				break;
			}
			case 0x3C:
			{
				Vec.y = -16;
				break;
			}
			case 0x44:
			{
				Vec.y = -60;
				break;
			}
			}

			adjustment = razAdjustSpeed(In->CharacterInstance, 1);

			Vec.y = (((Vec.y * (short)G2Timer_GetFrameTime()) * adjustment) >> 12) / 100;

			if (G2Anim_IsControllerActive(&In->CharacterInstance->anim, 0, 0x22) == 0)
			{
				G2Anim_EnableController(&In->CharacterInstance->anim, 0, 0x22);
			}

			G2Anim_SetController_Vector(&In->CharacterInstance->anim, 0, 0x22, &Vec);
		}

		if (CurrentSection != 0)
		{
			Frames = 6;

			if ((void*)In->SectionList[0].Process == (void*)&StateHandlerMove)
			{
				animSectionA = &In->CharacterInstance->anim.section[0];
				animSectionB = &In->CharacterInstance->anim.section[CurrentSection];

				if (G2AnimSection_IsInInterpolation(animSectionA) == 0 && G2AnimSection_IsInInterpolation(animSectionB) == 0)
				{
					if (G2AnimSection_GetKeyframeNumber(animSectionA) != G2AnimSection_GetKeyframeNumber(animSectionB))
					{
						keylist = animSectionA->keylist;
						keylistID = animSectionA->keylistID;

						frame = (G2AnimSection_GetKeyframeNumber(animSectionA) + Frames) % G2AnimKeylist_GetKeyframeCount(keylist);

						if (razSwitchVAnimGroup(In->CharacterInstance, CurrentSection, Anim[0], frame, Frames) != 0)
						{
							G2AnimSection_InterpToKeylistFrame(animSectionB, keylist, keylistID, frame, 600);
						}
					}
				}
			}
		}
	}
	else
	{
		Frames = 6;

		if ((void*)In->SectionList[0].Process == (void*)&StateHandlerMove)
		{
			animSectionA = &In->CharacterInstance->anim.section[0];
			animSectionB = &In->CharacterInstance->anim.section[CurrentSection];

			if (G2AnimSection_IsInInterpolation(animSectionA) == 0 && G2AnimSection_IsInInterpolation(animSectionB) == 0)
			{
				if (G2AnimSection_GetKeyframeNumber(animSectionA) != G2AnimSection_GetKeyframeNumber(animSectionB))
				{
					keylist = animSectionA->keylist;
					keylistID = animSectionA->keylistID;

					frame = (G2AnimSection_GetKeyframeNumber(animSectionA) + Frames) % G2AnimKeylist_GetKeyframeCount(keylist);

					if (razSwitchVAnimGroup(In->CharacterInstance, CurrentSection, Anim[0], frame, Frames) != 0)
					{
						G2AnimSection_InterpToKeylistFrame(animSectionB, keylist, keylistID, frame, 600);
					}
				}
			}
		}
	}
}


// autogenerated function stub: 
// int /*$ra*/ razApplyMotion(struct __CharacterState *In /*$s1*/, int CurrentSection /*$s0*/)
int razApplyMotion(struct __CharacterState *In, int CurrentSection)
{ // line 1199, offset 0x800a6c30
#if defined(PC_VERSION)
	struct _Instance* CharacterInstance; // edi
	int speedAdjustment; // edi
	struct _G2SVector3_Type vector; // [esp+8h] [ebp-8h] BYREF

	vector.x = 0;
	vector.y = 0;
	vector.z = 0;
	if (!CurrentSection)
	{
		CharacterInstance = In->CharacterInstance;
		if (CharacterInstance->anim.section[0].keylist == G2Instance_GetKeylist(In->CharacterInstance, 2))
		{
			vector.y = -60;
		}
		else if (CharacterInstance->anim.section[0].keylist == G2Instance_GetKeylist(In->CharacterInstance, 124))
		{
			vector.y = -35;
		}
		else if (CharacterInstance->anim.section[0].keylist == G2Instance_GetKeylist(In->CharacterInstance, 123))
		{
			vector.y = -16;
		}
		else if (G2Anim_IsControllerActive(&In->CharacterInstance->anim, 0, 34))
		{
			G2Anim_DisableController(&In->CharacterInstance->anim, 0, 34);
		}
		if (vector.y)
		{
			if (!G2Anim_IsControllerActive(&In->CharacterInstance->anim, 0, 34))
				G2Anim_EnableController(&In->CharacterInstance->anim, 0, 34);
			speedAdjustment = In->CharacterInstance->anim.section[0].speedAdjustment;
			vector.y = (__int16)((vector.y * speedAdjustment * (__int16)G2Timer_GetFrameTime()) >> 12) / 100;
			G2Anim_SetController_Vector(&In->CharacterInstance->anim, 0, 34, &vector);
		}
	}
	return -vector.y;
#else
	UNIMPLEMENTED();
	return 0;
#endif
}

void razResetMotion(struct _Instance *instance)
{
	if ((G2Anim_IsControllerActive(&instance->anim, 0, 0x22)) != 0)
	{
		G2Anim_DisableController(&instance->anim, 0, 0x22);
	}

	Raziel.passedMask = 0;

	G2Anim_SetSpeedAdjustment(&instance->anim, 4096);
}

void razSetDampingPhysics(struct _Instance* instance)
{
#if defined(PSX_VERSION)
	Raziel.RotationSegment = 0;
	
	Raziel.extraRot.x = 0;

	PhysicsMode = 4;

	SetDampingPhysics(instance, PlayerData->SwimPhysicsFallDamping);
#elif defined(PC_VERSION)
	dword_B08780 = 0;
	LOWORD(dword_B08928) = 0;
	Mode = 4;
	SetDampingPhysics(instance, *(_DWORD*)(dword_B08B3C + 68));
#endif
}


// autogenerated function stub: 
// void /*$ra*/ razEnterWater(struct __CharacterState *In /*$s0*/, int CurrentSection /*$s1*/, struct evPhysicsSwimData *SwimData /*$s3*/)
void razEnterWater(struct __CharacterState *In, int CurrentSection, struct evPhysicsSwimData *SwimData)
{ // line 1311, offset 0x800a6e4c
#if defined(PC_VERSION)
	struct _Instance* LinkChild; // esi
	struct _Instance* v4; // ebp
	struct _Instance* CharacterInstance; // eax
	struct _Instance* v6; // eax
	struct _G2Anim_Type* p_anim; // edi
	struct _Instance* v8; // eax

	LinkChild = stru_B0841C.CharacterInstance->LinkChild;
	if (Inst && LinkChild == Inst)
	{
		if (!LinkChild)
		{
		LABEL_6:
			v4 = dword_B08804 != 0 ? Inst : 0;
			goto LABEL_8;
		}
		LinkChild = LinkChild->LinkSibling;
	}
	if (!LinkChild)
		goto LABEL_6;
	v4 = (INSTANCE_Query(LinkChild, 1) & 0x20) != 0 ? LinkChild : 0;
LABEL_8:
	if ((SwimData->rc & 0x10) != 0)
	{
		if (dword_B08850 != 1 || (dword_B08820 & 0x10) != 0)
		{
			if (v4 && INSTANCE_Query(v4, 4) == 3)
			{
				G2Anim_SetSpeedAdjustment(&In->CharacterInstance->anim, 2048);
			}
			else if ((dword_B08778 & 0x40000) == 0 && dword_B08850 == 1)
			{
				if (Mode != 4)
				{
					CharacterInstance = In->CharacterInstance;
					Mode = 4;
					dword_B08780 = 0;
					LOWORD(dword_B08928) = 0;
					SetDampingPhysics(CharacterInstance, *(_DWORD*)(dword_B08B3C + 68));
				}
				v6 = In->CharacterInstance;
				if (!In->CharacterInstance->zVel || (dword_B08778 & 0x400004) != 0)
				{
					p_anim = &v6->anim;
					if (G2Anim_IsControllerActive(&v6->anim, 0, 34))
						G2Anim_DisableController(p_anim, 0, 34);
					dword_B08924 = 0;
					G2Anim_SetSpeedAdjustment(p_anim, 4096);
					StateSwitchStateCharacterData(In, StateHandlerSwim, 0);
				}
				TrailWaterFX(In->CharacterInstance, 9, 1, 1);
				TrailWaterFX(In->CharacterInstance, 13, 1, 1);
				TrailWaterFX(In->CharacterInstance, 31, 1, 1);
				TrailWaterFX(In->CharacterInstance, 41, 1, 1);
			}
		}
		else
		{
			current_health = 100000;
			SetPhysics(In->CharacterInstance, -16, 0, 0, 0);
			Mode = 0;
		}
	}
	if ((SwimData->rc & 0x800) != 0 && dword_B08804 == 1)
	{
		if (CurrentSection == 2)
			G2EmulationSwitchAnimation(In, 2, 61, 0, 3, 2);
		else
			G2EmulationSwitchAnimation(In, CurrentSection, 63, 0, 16, 2);
	}
	if ((SwimData->rc & 0x100) != 0 && !CurrentSection)
	{
		if (v4)
		{
			INSTANCE_Query(v4, 4);
		}
		else
		{
			v8 = In->CharacterInstance;
			dword_B08780 = 0;
			LOWORD(dword_B08928) = 0;
			Mode = 4;
			SetDampingPhysics(v8, *(_DWORD*)(dword_B08B3C + 68));
		}
		PurgeMessageQueue(&In->SectionList[0].Event);
		TrailWaterFX(In->CharacterInstance, 9, 4, 1);
		TrailWaterFX(In->CharacterInstance, 13, 4, 1);
	}
#else
	UNIMPLEMENTED();
#endif
}


// autogenerated function stub: 
// void /*$ra*/ razSetSwimVelocity(struct _Instance *instance /*$a0*/, int vel /*$a1*/, int accl /*$a2*/)
void razSetSwimVelocity(struct _Instance *instance, int vel, int accl)
{ // line 1436, offset 0x800a70f0
	/* begin block 1 */
		// Start line: 1438
		// Start offset: 0x800A70F0
	/* end block 1 */
	// End offset: 0x800A713C
	// End Line: 1452

	/* begin block 2 */
		// Start line: 3055
	/* end block 2 */
	// End Line: 3056

	/* begin block 3 */
		// Start line: 3056
	/* end block 3 */
	// End Line: 3057

	/* begin block 4 */
		// Start line: 3062
	/* end block 4 */
	// End Line: 3063
	UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ razSetWallCrawlNodes(struct _Instance *instance /*$s1*/, struct evPhysicsWallCrawlData *data /*$s0*/)
void razSetWallCrawlNodes(struct _Instance *instance, struct evPhysicsWallCrawlData *data)
{ // line 1455, offset 0x800a7144
#if defined(PC_VERSION)
	__int16 y; // ax
	__int16 z; // cx
	struct _G2SVector3_Type vector; // [esp+8h] [ebp-8h] BYREF

	if ((data->rc & 8) != 0)
	{
		if ((int)MATH3D_SquareLength(data->NewPosition.x, data->NewPosition.y, data->NewPosition.z) > 100)
		{
			instance->position.x -= data->NewPosition.x;
			instance->position.y -= data->NewPosition.y;
		}
		y = data->DropRotation.y;
		z = data->DropRotation.z;
		vector.x = data->DropRotation.x;
		vector.y = y;
		vector.z = z;
		G2Anim_SetController_Vector(&instance->anim, 0, 8, &vector);
	}
	if (data->rc == 10)
	{
		vector.x = -data->ForwardXRotation;
		vector.y = 0;
		vector.z = 0;
		G2EmulationSetInterpController_Vector(instance, 14, 14, &vector, 3, 0);
	}
#else
	UNIMPLEMENTED();
#endif
}


// autogenerated function stub: 
// int /*$ra*/ razSwitchVAnimCharacterGroup(struct _Instance *instance /*$s3*/, int animGroup /*$s4*/, int *frame /*$a2*/, int *frames /*$a3*/)
int razSwitchVAnimCharacterGroup(struct _Instance *instance, int animGroup, int *frame, int *frames)
{ // line 1516, offset 0x800a7230
	/* begin block 1 */
		// Start line: 1517
		// Start offset: 0x800A7230
		// Variables:
			int i; // $s0
			int rc; // $v1
			int temp[3]; // stack offset -40
	/* end block 1 */
	// End offset: 0x800A72CC
	// End Line: 1530

	/* begin block 2 */
		// Start line: 3233
	/* end block 2 */
	// End Line: 3234
			UNIMPLEMENTED();
	return 0;
}

int razSwitchVAnimGroup(struct _Instance* instance, int section, int animGroup, int frame, int frames)//Matching - 99.35%
{
	int index;
	int rc;

	rc = 1;

	if (Raziel.Senses.heldClass != 0)
	{
		index = Raziel.Senses.heldClass - 1;

		if (index >= 3)
		{
			index = 3;
		}

		animGroup += index;

		razSwitchVAnim(instance, section, &PlayerData->virtualAnimations[animGroup], frame, frames);

		rc = 0;
	}
	
	return rc;
}


// autogenerated function stub: 
// void /*$ra*/ razSwitchVAnimCharacterSingle(struct _Instance *instance /*$s3*/, int anim /*$s4*/, int *frame /*$a2*/, int *frames /*$a3*/)
void razSwitchVAnimCharacterSingle(struct _Instance *instance, int anim, int *frame, int *frames)
{ // line 1561, offset 0x800a7348
	/* begin block 1 */
		// Start line: 1562
		// Start offset: 0x800A7348
		// Variables:
			int i; // $s0
			int temp[3]; // stack offset -40
	/* end block 1 */
	// End offset: 0x800A73E0
	// End Line: 1574

	/* begin block 2 */
		// Start line: 3336
	/* end block 2 */
	// End Line: 3337
			UNIMPLEMENTED();
}

void razSwitchVAnimSingle(struct _Instance* instance, int section, int anim, int frame, int frames)//Matching - 99.23%
{
	razSwitchVAnim(instance, section, &PlayerData->virtualAnimSingle[anim], frame, frames);
}

void razSwitchVAnim(struct _Instance* instance, int section, struct __VAnim* vAnim, int frame, int frames)//Matching - 99.90%
{
#if defined(PSX_VERSION)
	if (frame == -1)
	{
		frame = vAnim->frame;
	}

	if (frames == -1)
	{
		frames = vAnim->frames;
	}

	switch (section)
	{
	case 0:
	{
		G2EmulationInstanceSwitchAnimationAlpha(instance, 0, vAnim->anim0, frame, frames, vAnim->mode, vAnim->alpha);
		break;
	}
	case 1:
	{
		G2EmulationInstanceSwitchAnimationAlpha(instance, 1, vAnim->anim1, frame, frames, vAnim->mode, vAnim->alpha);
		break;
	}
	case 2:
	{
		G2EmulationInstanceSwitchAnimationAlpha(instance, 2, vAnim->anim2, frame, frames, vAnim->mode, vAnim->alpha);
		break;
	}
	}

#elif defined(PC_VERSION)
	int v5; // ecx
	int v6; // esi

	v5 = frame;
	if (frame == -1)
		v5 = vAnim->frame;
	v6 = frames;
	if (frames == -1)
		v6 = vAnim->frames;
	if (section)
	{
		if (section == 1)
		{
			G2EmulationInstanceSwitchAnimationAlpha(instance, 1, vAnim->anim1, v5, v6, vAnim->mode, vAnim->alpha);
		}
		else if (section == 2)
		{
			G2EmulationInstanceSwitchAnimationAlpha(instance, 2, vAnim->anim2, v5, v6, vAnim->mode, vAnim->alpha);
		}
	}
	else
	{
		G2EmulationInstanceSwitchAnimationAlpha(instance, 0, vAnim->anim0, v5, v6, vAnim->mode, vAnim->alpha);
	}
#endif
}


// autogenerated function stub: 
// int /*$ra*/ razProcessSAnim(struct _Instance *instance /*$s3*/, int mode /*$a1*/)
int razProcessSAnim(struct _Instance *instance, int mode)
{ // line 1615, offset 0x800a7500
#if defined(PC_VERSION)
	int v2; // ebp
	unsigned __int8** v3; // eax
	unsigned __int8* v4; // esi
	int v5; // eax
	int v6; // ecx
	int v8; // [esp+10h] [ebp-4h]

	v2 = 0;
	v8 = 0;
	if (mode == 1048597)
	{
		if (*(WORD*)(dword_B089C4 + 8) != 2)
			goto LABEL_10;
		goto LABEL_9;
	}
	if (mode == 0x8000000)
	{
		if (*(WORD*)(dword_B089C4 + 8) != 1)
			goto LABEL_10;
		goto LABEL_9;
	}
	if (mode == 0x8000003 && *(WORD*)(dword_B089C4 + 8) == 3)
		LABEL_9:
	v8 = 1;
LABEL_10:
	if (v8)
	{
		v3 = *(unsigned __int8***)(dword_B089C4 + 4);
		if (v3)
		{
			dword_B089C4 = *(DWORD*)(dword_B089C4 + 4);
			v4 = *v3;
			if (*v3)
			{
				do
				{
					v5 = *((unsigned __int16*)v4 + 3);
					v6 = v4[3];
					if (v2)
					{
						if (v2 == 1)
						{
							G2EmulationInstanceSwitchAnimationAlpha(instance, 1, v4[1], v5, v6, v4[4], v4[5]);
						}
						else if (v2 == 2)
						{
							G2EmulationInstanceSwitchAnimationAlpha(instance, 2, v4[2], v5, v6, v4[4], v4[5]);
						}
					}
					else
					{
						G2EmulationInstanceSwitchAnimationAlpha(instance, 0, *v4, v5, v6, v4[4], v4[5]);
					}
					G2Anim_SetSpeedAdjustment(&instance->anim, *(__int16*)(dword_B089C4 + 12));
					++v2;
				} while (v2 <= 2);
				if (*(WORD*)(dword_B089C4 + 8) == 2)
				{
					dword_B08960 = *(__int16*)(dword_B089C4 + 10) << 12;
					return v8;
				}
			}
		}
		else
		{
			G2Anim_SetSpeedAdjustment(&instance->anim, 4096);
			dword_B089C4 = 0;
			return 0;
		}
	}
	return v8;
#else
	UNIMPLEMENTED();
	return 0;
#endif
}


// autogenerated function stub: 
// void /*$ra*/ razSwitchStringAnimation(struct _Instance *instance /*$s2*/, int anim /*$a1*/)
void razSwitchStringAnimation(struct _Instance *instance, int anim)
{ // line 1667, offset 0x800a7678
	/* begin block 1 */
		// Start line: 1668
		// Start offset: 0x800A7678
		// Variables:
			struct __VAnim *vanim; // $s1
			int i; // $s0
	/* end block 1 */
	// End offset: 0x800A7724
	// End Line: 1684

	/* begin block 2 */
		// Start line: 3564
	/* end block 2 */
	// End Line: 3565

	/* begin block 3 */
		// Start line: 3568
	/* end block 3 */
	// End Line: 3569
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// int /*$ra*/ CheckStringAnimation(struct _Instance *instance /*$s1*/, int mode /*$a1*/)
int CheckStringAnimation(struct _Instance *instance, int mode)
{ // line 1687, offset 0x800a7740
	/* begin block 1 */
		// Start line: 1688
		// Start offset: 0x800A7740
		// Variables:
			int rc; // $s0
	/* end block 1 */
	// End offset: 0x800A7788
	// End Line: 1698

	/* begin block 2 */
		// Start line: 3614
	/* end block 2 */
	// End Line: 3615

	/* begin block 3 */
		// Start line: 3617
	/* end block 3 */
	// End Line: 3618
			UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// void /*$ra*/ razLaunchBubbles(int segments /*$s2*/, int count /*$s0*/, int type /*$s1*/)
void razLaunchBubbles(int segments, int count, int type)
{ // line 1752, offset 0x800a77a0
	/* begin block 1 */
		// Start line: 3504
	/* end block 1 */
	// End Line: 3505
	UNIMPLEMENTED();
}

void razSetCowlNoDraw(int mode)
{
#if 0
	sub_800A76C4:
	move    $t0, $a0
		addiu   $a2, $gp, -0x595C
		addiu   $a3, $gp, -0x5936

		loc_800A76D0 :
		beqz    $t0, loc_800A7718
		nop
		lw      $v0, -0x420C($gp)
		lhu     $a1, 0($a2)
		lh      $a0, 0x126($v0)
		lw      $v0, 0x1C($v0)
		sll     $v1, $a1, 1
		lw      $v0, 0xC($v0)
		sll     $a0, 2
		addu    $a0, $v0
		lw      $v0, 0($a0)
		addu    $v1, $a1
		lw      $v0, 0x14($v0)
		sll     $v1, 2
		addu    $v1, $v0
		lbu     $v0, 7($v1)
		j       loc_800A7758
		ori     $v0, 0x10

		loc_800A7718:
	lw      $v0, -0x420C($gp)
		lhu     $a1, 0($a2)
		lh      $a0, 0x126($v0)
		lw      $v0, 0x1C($v0)
		sll     $v1, $a1, 1
		lw      $v0, 0xC($v0)
		sll     $a0, 2
		addu    $a0, $v0
		lw      $v0, 0($a0)
		addu    $v1, $a1
		lw      $v0, 0x14($v0)
		sll     $v1, 2
		addu    $v1, $v0
		lbu     $v0, 7($v1)
		nop
		andi    $v0, 0xEF

		loc_800A7758:
	sb      $v0, 7($v1)
		addiu   $a2, 2
		slt     $v0, $a2, $a3
		bnez    $v0, loc_800A76D0
		nop
		jr      $ra
		nop
#endif
}

void razAttachControllers()
{
	int i;
	
	for (i = 0; i < 24; i++)
	{
		G2Anim_AttachControllerToSeg(&gameTrackerX.playerInstance->anim, controllerList[i].segment, controllerList[i].type);
		G2Anim_DisableController(&gameTrackerX.playerInstance->anim, controllerList[i].segment, controllerList[i].type);
	}
}

void razSetPlayerEvent()
{
	void (*process)(struct __CharacterState*, int, int);
	int message;
	int data;

	process = Raziel.State.SectionList[0].Process;
	
	message = 0;
	
	data = 0;

	if ((Raziel.Senses.EngagedMask & 0x1))
	{
		if (Raziel.Senses.heldClass != 3 && process == &StateHandlerIdle)
		{
			Raziel.playerEvent |= 0x1;
		}
	}

	if ((Raziel.Senses.EngagedMask & 0x4))
	{
		if (Raziel.Senses.heldClass != 3 && process == &StateHandlerCrouch)
		{
			Raziel.playerEvent |= 0x2;
		}
	}

	if ((Raziel.Senses.EngagedMask & 0x8))
	{
		if (Raziel.Senses.heldClass != 3 && process == &StateHandlerIdle)
		{
			if (INSTANCE_Query(Raziel.Senses.EngagedList[3].instance, 0x4) == 9)
			{
				Raziel.playerEvent |= 0x8;
			}
			else
			{
				Raziel.playerEvent |= 0x4;
			}
		}
	}

	if ((Raziel.Senses.EngagedMask & 0x20))
	{
		if (razGetHeldItem() == NULL)
		{
			if (Raziel.CurrentPlane == 1)
			{
				if (process == &StateHandlerIdle ||
					process == &StateHandlerStartMove ||
					process == &StateHandlerMove ||
					process == &StateHandlerJump ||
					process == &StateHandlerFall ||
					process == &StateHandlerSwim ||
					process == &StateHandlerAutoFace)
				{
					Raziel.playerEvent |= 0x10;
				}
			}
		}
	}

	if ((Raziel.Senses.EngagedMask & 0x40))
	{
		if (!(INSTANCE_Query(Raziel.Senses.EngagedList[6].instance, 0xA) & 0x4))
		{
			Raziel.playerEvent |= 0x20;
		}
	}

	if (StateHandlerDecodeHold(&message, &data) != 0 && data != 0)
	{
		if (message == 0x1000002)
		{
			Raziel.playerEvent |= 0x40;
		}

		if (message == 0x100000A)
		{
			Raziel.playerEvent |= 0x80;
		}

		if (message == 0x1000018)
		{
			Raziel.playerEvent |= 0x100;
		}
	}

	if ((Raziel.Mode & 0x20000) && (unsigned int)(Raziel.Senses.heldClass - 1) < 3)
	{
		Raziel.playerEvent |= 0x200;
	}

	if (message == 0x80000)
	{
		Raziel.playerEvent |= 0x400;
	}

	if ((Raziel.Senses.EngagedMask & 0x4000))
	{
		Raziel.playerEvent |= 0x800;
	}

	if ((Raziel.Senses.Flags & 0x40))
	{
		Raziel.playerEvent |= 0x2000;
	}
}

void razClearPlayerEvent()
{ 
	if ((ControlFlag & 0x100000))
	{
		Raziel.playerEvent &= 0x2000;

		return;
	}

	Raziel.playerEvent = 0;
}

void razSetPlayerEventHistory(unsigned long event)
{
	Raziel.playerEventHistory |= event;
}


// autogenerated function stub: 
// int /*$ra*/ razSideMoveSpiderCheck(struct _Instance *instance /*$s2*/, int x /*$a1*/)
int razSideMoveSpiderCheck(struct _Instance *instance, int x)
{ // line 1905, offset 0x800a7cac
#if defined(PC_VERSION)
	SVECTORendVec; // [esp+8h] [ebp-10h] BYREF
	SVECTORstartVec; // [esp+10h] [ebp-8h] BYREF

	PHYSICS_GenericLineCheckSetup(x, 0, 192, &startVec);
	PHYSICS_GenericLineCheckSetup(x, -320, 192, &endVec);
	if ((PHYSICS_CheckForValidMove(instance, &startVec, &endVec, 0) & 1) == 0)
		return 1;
	PHYSICS_GenericLineCheckSetup(x, 0, 0, &startVec);
	PHYSICS_GenericLineCheckSetup(x, -320, 0, &endVec);
	return (PHYSICS_CheckForValidMove(instance, &startVec, &endVec, 0) & 1) == 0;
#else
	UNIMPLEMENTED();
	return 0;
#endif
}

struct _Instance* RAZIEL_QueryEngagedInstance(int index)
{
#if defined(PSX_VERSION)

	if (!(Raziel.Senses.EngagedMask & (1 << index)))
	{
		return NULL;
	}
	else
	{
		return Raziel.Senses.EngagedList[index].instance;
	}

#elif defined(PC_VERSION)
	if ((dword_B087F4 & (1 << index)) != 0)
		return dword_B087F0[2 * index];
	else
		return 0;
#endif
}


// autogenerated function stub: 
// int /*$ra*/ razUpdateSoundRamp(struct _Instance *instance /*$a0*/, struct _SoundRamp *sound /*$s0*/)
int razUpdateSoundRamp(struct _Instance *instance, struct _SoundRamp *sound)
{ // line 1955, offset 0x800a7db0
#if defined(PC_VERSION)
	int v2; // edi
	__int32 soundTotalTime; // ebx
	__int32 v4; // eax
	__int32 soundTimer; // ecx

	v2 = 0;
	if (sound->soundHandle)
	{
		soundTotalTime = sound->soundTotalTime;
		v4 = gameTrackerX.timeMult + sound->soundTimer;
		sound->soundTimer = v4;
		if (v4 > soundTotalTime)
			sound->soundTimer = soundTotalTime;
		if (soundTotalTime)
		{
			soundTimer = sound->soundTimer;
			if (soundTimer <= soundTotalTime)
			{
				v2 = sound->soundStartVolume
					+ sound->soundTimer * (sound->soundEndVolume - sound->soundStartVolume) / soundTotalTime;
				if (!SOUND_Update3dSound(
					&instance->position,
					sound->soundHandle,
					sound->soundStartPitch + soundTimer * (sound->soundEndPitch - sound->soundStartPitch) / soundTotalTime,
					v2,
					sound->soundDistance))
				{
					SndEndLoop(sound->soundHandle);
					sound->soundHandle = 0;
				}
			}
		}
	}
	return v2;
#else
	UNIMPLEMENTED();
	return 0;
#endif
}


// autogenerated function stub: 
// void /*$ra*/ razSetupSoundRamp(struct _Instance *instance /*$a0*/, struct _SoundRamp *sound /*$s0*/, int sfx /*$a1*/, int startPitch /*$s2*/, int endPitch /*stack 16*/, int startVolume /*stack 20*/, int endVolume /*stack 24*/, int timer /*stack 28*/, int distance /*stack 32*/)
void razSetupSoundRamp(struct _Instance *instance, struct _SoundRamp *sound, int sfx, int startPitch, int endPitch, int startVolume, int endVolume, int timer, int distance)
{ // line 1995, offset 0x800a7eb4
#if defined(PC_VERSION)
	if (!sound->soundHandle)
		sound->soundHandle = SOUND_Play3dSound(&instance->position, sfx, startPitch, startVolume, distance);
	if (!timer)
		sound->soundHandle = 0;
	sound->soundDistance = distance;
	sound->soundStartPitch = startPitch;
	sound->soundEndPitch = endPitch;
	sound->soundStartVolume = startVolume;
	sound->soundEndVolume = endVolume;
	sound->soundTotalTime = timer;
	sound->soundTimer = 0;
#else
	UNIMPLEMENTED();
#endif
}


// autogenerated function stub: 
// void /*$ra*/ RAZIEL_SetInteractiveMusic(int modifier /*$a0*/, int action /*$a1*/)
void RAZIEL_SetInteractiveMusic(int modifier, int action)
{ // line 2019, offset 0x800a7f58
#if defined(PC_VERSION)
	int v2; // esi

	v2 = 1 << modifier;
	if (action)
	{
		if ((dword_B08974 & v2) == 0)
			SOUND_SetMusicModifier(modifier);
		dword_B08974 |= v2;
	}
	else
	{
		if ((dword_B08974 & v2) != 0)
			SOUND_ResetMusicModifier(modifier);
		dword_B08974 &= ~v2;
	}
#else
	UNIMPLEMENTED();
#endif
}

void RAZIEL_DebugHurtRaziel()
{
#if defined(PSX_VERSION)
	LoseHealth(4096);
#elif defined(PC_VERSION)
	struct _Instance* v0; // eax
	struct _Instance* LinkChild; // esi
	struct _Instance* v2; // esi

	if ((ControlFlag & 0x1000000) == 0 && !dword_B0881C && current_health > 525)
	{
		current_health -= 20000;
		dword_B08818 -= 20000;
		dword_B0881C = 122880 * *(__int16*)(dword_B08B3C + 52);
		if (dword_B08850 != 1 || (v0 = Inst) == 0)
		{
		LABEL_19:
			if (SLOBYTE(gameTrackerX.gameFlags) >= 0)
				GAMEPAD_Shock0(1, 9000);
			return;
		}
		if (dword_B08804 != 4096)
		{
		LABEL_17:
			if (v0)
			{
				INSTANCE_Post(v0, (int)&memwpsx[3112401], 0);
				dword_B0884C = 2;
				debugRazielFlags2 = 2048;
				INSTANCE_Post(Inst, (int)&memwpsx[3112403], 2);
			}
			goto LABEL_19;
		}
		LinkChild = stru_B0841C.CharacterInstance->LinkChild;
		if (LinkChild == Inst)
		{
			if (!LinkChild)
				goto LABEL_11;
			LinkChild = LinkChild->LinkSibling;
		}
		if (LinkChild)
		{
			v2 = (INSTANCE_Query(LinkChild, 1) & 0x20) != 0 ? LinkChild : 0;
			v0 = Inst;
			goto LABEL_13;
		}
	LABEL_11:
		v2 = Inst;
	LABEL_13:
		if ((INSTANCE_Query(v0, 40) & 1) != 0)
			INSTANCE_Post(Inst, (int)&memwpsx[3112401], 0);
		v0 = Inst;
		if (v2 == Inst)
			dword_B08804 = 0;
		goto LABEL_17;
	}
#endif
}

void RAZIEL_StartNewGame()
{
#if defined(PSX_VERSION)
	memset(&Raziel, 0, sizeof(Raziel));
#elif defined(PC_VERSION)
	memset(&player, 0, sizeof(player));
#endif
}

int razInBaseArea(char* name, int length)
{
	char string[9];
	
	if (strcpy(string, gameTrackerX.baseAreaName) != NULL)
	{
		string[length] = 0;
	}
	else
	{
		return strcmp(name, string) < 1;
	}
	
	return 0;
}


// autogenerated function stub: 
// void /*$ra*/ razPrepGlyph()
void razPrepGlyph()
{ // line 2073, offset 0x800a8078
	/* begin block 1 */
		// Start line: 2074
		// Start offset: 0x800A8078
		// Variables:
			struct _Instance *heldInst; // $s0
	/* end block 1 */
	// End offset: 0x800A80AC
	// End Line: 2083

	/* begin block 2 */
		// Start line: 4416
	/* end block 2 */
	// End Line: 4417
			UNIMPLEMENTED();
}




