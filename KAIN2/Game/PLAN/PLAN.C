#include "Game/CORE.H"
#include "PLAN.H"
#include "Game/PLAN/PLANPOOL.H"
#include "Game/PLAN/PLANCOLL.H"
#include "Game/MATH3D.H"
#include <Game/STREAM.H>

// autogenerated function stub: 
// long /*$ra*/ PLAN_CalcMinDistFromExistingNodes(_Position *pos /*$s0*/, struct PlanningNode *planningPool /*$a1*/, int distanceType /*$s1*/)
long PLAN_CalcMinDistFromExistingNodes(_Position *pos, struct PlanningNode *planningPool, int distanceType)
{ // line 129, offset 0x80097188
	/* begin block 1 */
		// Start line: 130
		// Start offset: 0x80097188
		// Variables:
			struct PlanningNode *closestNode; // $a2
			long minDist; // $v0
	/* end block 1 */
	// End offset: 0x80097210
	// End Line: 148

	/* begin block 2 */
		// Start line: 258
	/* end block 2 */
	// End Line: 259
			UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// void /*$ra*/ PLAN_UpdatePlanMkrNodes(struct PlanningNode *planningPool /*stack 0*/, _Position *playerPos /*$fp*/)
void PLAN_UpdatePlanMkrNodes(struct PlanningNode *planningPool, _Position *playerPos)
{ // line 158, offset 0x80097224
	/* begin block 1 */
		// Start line: 159
		// Start offset: 0x80097224
		// Variables:
			int i; // $s4
			int d; // stack offset -48
			long zDiff; // $v1
			struct _StreamUnit *streamUnit; // $s7

		/* begin block 1.1 */
			// Start line: 169
			// Start offset: 0x80097288
			// Variables:
				int numPlanMkrs; // $s5
				struct _PlanMkr *planMkr; // $s2
				long suID; // stack offset -44

			/* begin block 1.1.1 */
				// Start line: 181
				// Start offset: 0x800972F8
				// Variables:
					long nodeType; // $s0
					long nodeID; // $s3
			/* end block 1.1.1 */
			// End offset: 0x8009736C
			// End Line: 203
		/* end block 1.1 */
		// End offset: 0x80097380
		// End Line: 206
	/* end block 1 */
	// End offset: 0x80097440
	// End Line: 221

	/* begin block 2 */
		// Start line: 316
	/* end block 2 */
	// End Line: 317
					UNIMPLEMENTED();
}


void PLAN_UpdatePlayerNode(struct PlanningNode* planningPool, struct _Position* playerPos) // Matching - 100%
{
	struct PlanningNode* playerNode;
	int nodePlacement;
	int foundHit;
	struct _PlanCollideInfo pci;

	playerNode = PLANPOOL_GetFirstNodeOfSource(planningPool, 1);

	if (playerNode != NULL)
	{
		foundHit = PLANCOLL_CheckUnderwaterPoint(playerPos);

		if (foundHit != -1)
		{
			PLANPOOL_ChangeNodePosition(playerPos, playerNode, planningPool);

			playerNode->nodeType = 25;

			playerNode->streamUnitID = foundHit;

			return;
		}

		{
			short _x1;
			short _y1;
			short _z1;
			struct _Position* _v0;


			_v0 = &pci.collidePos;

			_x1 = playerPos->x;
			_y1 = playerPos->y;
			_z1 = playerPos->z;

			_v0->x = _x1;
			_v0->y = _y1;
			_v0->z = _z1;
		}

		if (PLANCOLL_FindTerrainHitFinal(&pci, &nodePlacement, 256, -640, 0, 5) != 0)
		{
			PLANPOOL_ChangeNodePosition(&pci.collidePos, playerNode, planningPool);

			playerNode->nodeType = ((((short)nodePlacement & 3) * 8) | 1);

			playerNode->streamUnitID = pci.StreamUnitID;
		}
		else if (MATH3D_LengthXYZ(playerPos->x - playerNode->pos.x, playerPos->y - playerNode->pos.y, playerPos->z - playerNode->pos.z) >= 12001)
		{
			PLANPOOL_ChangeNodePosition(playerPos, playerNode, planningPool);

			playerNode->nodeType = 1;

			playerNode->streamUnitID = gameTrackerX.playerInstance->currentStreamUnitID;
		}
	}
}


void PLAN_AddRandomNode(struct PlanningNode* planningPool, struct _Position* playerPos) // Matching - 100%
{
	int i;
	struct _PlanCollideInfo pci;
	int successFlag;

	successFlag = 0;

	for (i = 0; i < 5; i++)
	{
		short _x1;
		short _y1;
		short _z1;
		struct _Position* _v0;

		_v0 = &pci.collidePos;

		_x1 = playerPos->x;
		_y1 = playerPos->y;
		_z1 = playerPos->z;

		_v0->x = _x1;
		_v0->y = _y1;
		_v0->z = _z1;

		pci.collidePos.x += (rand() % 24000) - 12000;

		pci.collidePos.y += (rand() % 24000) - 12000;

		if ((MATH3D_LengthXYZ(playerPos->x - pci.collidePos.x, playerPos->y - pci.collidePos.y, playerPos->z - pci.collidePos.z) < 12000) && (PLAN_CalcMinDistFromExistingNodes(&pci.collidePos, planningPool, 0) >= 1001))
		{
			successFlag = 1;
			break;
		}
	}

	if ((successFlag == 1) && ((PLANCOLL_FindTerrainHitFinal(&pci, 0, 256, -2000, 0, 0) != 0) || (PLANCOLL_FindTerrainHitFinal(&pci, 0, 2000, 0, 0, 0) != 0)))
	{
		struct _SVector normal;

		COLLIDE_GetNormal(pci.tFace->normal, (short*)(STREAM_GetLevelWithID(pci.StreamUnitID))->terrain->normalList, &normal);

		if (normal.z >= 2049)
		{
			PLANPOOL_AddNodeToPool(&pci.collidePos, planningPool, 0, 0, pci.StreamUnitID);
		}
	}
}

void PLAN_DeleteRandomNode(struct PlanningNode* planningPool) // Matching - 100%
{ 
	PLANPOOL_DeleteNodeFromPool(PLANPOOL_GetFirstNodeOfSource(planningPool, 0), planningPool);
}


void PLAN_DeleteOutOfRangeNodesOfSource(struct PlanningNode* planningPool, struct _Position* playerPos, int nodeSourceToCheck, long removeDist) // Matching - 100%
{
	int i;

	for (i = 0; i < poolManagementData->numNodesInPool; i++)
	{
		if (((planningPool[i].nodeType & 7) == nodeSourceToCheck) && (removeDist < MATH3D_LengthXYZ(playerPos->x - planningPool[i].pos.x, playerPos->y - planningPool[i].pos.y, playerPos->z - planningPool[i].pos.z)))
		{
			PLANPOOL_DeleteNodeFromPool(&planningPool[i], planningPool);
		}
	}
}

void PLAN_AddOrRemoveRandomNodes(struct PlanningNode* planningPool, struct _Position* playerPos) // Matching - 100%
{
	int numNodeError;

	numNodeError = poolManagementData->numNodesInPool - 16;

	if (numNodeError < 0)
	{
		PLAN_AddRandomNode(planningPool, playerPos);
	}
	else
	{
		if (numNodeError > 0)
		{
			PLAN_DeleteRandomNode(planningPool);
		}
	}
}


void PLAN_AddInitialNodes(struct PlanningNode* planningPool, struct _Instance* player) // Matching - 100%
{
	struct _PlanCollideInfo pci;
	short _x1;
	short _y1;
	short _z1;
	struct _Position* _v0;
	struct _Position* _v1;

	_v0 = &pci.collidePos;
	_v1 = &player->position;
	_x1 = _v1->x;
	_y1 = _v1->y;
	_z1 = _v1->z;
	_v0->x = _x1;
	_v0->y = _y1;
	_v0->z = _z1;
	PLANCOLL_FindTerrainHitFinal(&pci, NULL, 256, -1024, 0, 0);
	PLANPOOL_AddNodeToPool(&pci.collidePos, planningPool, 1, 0, player->currentStreamUnitID);
	PLAN_UpdatePlanMkrNodes(planningPool, &player->position);
	poolManagementData->playerPosAtLastPlanMkrUpdate = player->position;
}

void PLAN_AddOrRemoveNodes(struct PlanningNode* planningPool, struct _Instance* player) // Matching - 100%
{
	if (MATH3D_LengthXYZ(
		player->position.x - poolManagementData->playerPosAtLastPlanMkrUpdate.x,
		player->position.y - poolManagementData->playerPosAtLastPlanMkrUpdate.y,
		player->position.z - poolManagementData->playerPosAtLastPlanMkrUpdate.z)
		> 500)
	{
		PLAN_UpdatePlayerNode(planningPool, &player->position);
		PLAN_UpdatePlanMkrNodes(planningPool, &player->position);
		PLAN_DeleteOutOfRangeNodesOfSource(planningPool, &player->position, 0, 12000);
		PLAN_DeleteOutOfRangeNodesOfSource(planningPool, &player->position, 2, 12000);
		PLAN_DeleteOutOfRangeNodesOfSource(planningPool, &player->position, 3, 12000);
		poolManagementData->playerPosAtLastPlanMkrUpdate = player->position;
	}
	PLAN_AddOrRemoveRandomNodes(planningPool, &player->position);
}

struct PlanningNode* PLAN_FindNodeMostInNeedOfConnectivityExpansion(struct PlanningNode* planningPool) // Matching - 100%
{
	int i;
	int numConnections;
	int minNumConnections;
	struct PlanningNode* nodeToReturn;

	minNumConnections = 65535;

	nodeToReturn = NULL;

	for (i = 0; i < poolManagementData->numNodesInPool; i++)
	{
		numConnections = PLANPOOL_NumConnectionsForNode(&planningPool[i]);

		if ((numConnections < minNumConnections) && (PLANPOOL_NumConnectionsExaminedForNode(&planningPool[i]) != poolManagementData->numNodesInPool))
		{
			minNumConnections = numConnections;

			nodeToReturn = &planningPool[i];
		}
	}

	return nodeToReturn;
}