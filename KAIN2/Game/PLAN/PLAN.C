#include "Game/CORE.H"
#include "PLAN.H"
#include "Game/PLAN/PLANPOOL.H"
#include "Game/PLAN/PLANCOLL.H"
#include "Game/MATH3D.H"

// autogenerated function stub: 
// long /*$ra*/ PLAN_CalcMinDistFromExistingNodes(_Position *pos /*$s0*/, struct PlanningNode *planningPool /*$a1*/, int distanceType /*$s1*/)
long PLAN_CalcMinDistFromExistingNodes(_Position *pos, struct PlanningNode *planningPool, int distanceType)
{ // line 129, offset 0x80097188
	/* begin block 1 */
		// Start line: 130
		// Start offset: 0x80097188
		// Variables:
			struct PlanningNode *closestNode; // $a2
			long minDist; // $v0
	/* end block 1 */
	// End offset: 0x80097210
	// End Line: 148

	/* begin block 2 */
		// Start line: 258
	/* end block 2 */
	// End Line: 259
			UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// void /*$ra*/ PLAN_UpdatePlanMkrNodes(struct PlanningNode *planningPool /*stack 0*/, _Position *playerPos /*$fp*/)
void PLAN_UpdatePlanMkrNodes(struct PlanningNode *planningPool, _Position *playerPos)
{ // line 158, offset 0x80097224
	/* begin block 1 */
		// Start line: 159
		// Start offset: 0x80097224
		// Variables:
			int i; // $s4
			int d; // stack offset -48
			long zDiff; // $v1
			struct _StreamUnit *streamUnit; // $s7

		/* begin block 1.1 */
			// Start line: 169
			// Start offset: 0x80097288
			// Variables:
				int numPlanMkrs; // $s5
				struct _PlanMkr *planMkr; // $s2
				long suID; // stack offset -44

			/* begin block 1.1.1 */
				// Start line: 181
				// Start offset: 0x800972F8
				// Variables:
					long nodeType; // $s0
					long nodeID; // $s3
			/* end block 1.1.1 */
			// End offset: 0x8009736C
			// End Line: 203
		/* end block 1.1 */
		// End offset: 0x80097380
		// End Line: 206
	/* end block 1 */
	// End offset: 0x80097440
	// End Line: 221

	/* begin block 2 */
		// Start line: 316
	/* end block 2 */
	// End Line: 317
					UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ PLAN_UpdatePlayerNode(struct PlanningNode *planningPool /*$s3*/, _Position *playerPos /*$s2*/)
void PLAN_UpdatePlayerNode(struct PlanningNode *planningPool, _Position *playerPos)
{ // line 226, offset 0x80097470
	/* begin block 1 */
		// Start line: 227
		// Start offset: 0x80097470
		// Variables:
			struct PlanningNode *playerNode; // $s1
			int nodePlacement; // stack offset -32
			int foundHit; // $s0
			//struct _PlanCollideInfo pci; // stack offset -48

		/* begin block 1.1 */
			// Start line: 245
			// Start offset: 0x800974D8
			// Variables:
				short _x1; // $v0
				short _y1; // $v1
				short _z1; // $a3
				_Position *_v0; // $s0
		/* end block 1.1 */
		// End offset: 0x800974D8
		// End Line: 245
	/* end block 1 */
	// End offset: 0x800975A8
	// End Line: 265

	/* begin block 2 */
		// Start line: 539
	/* end block 2 */
	// End Line: 540
				UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ PLAN_AddRandomNode(struct PlanningNode *planningPool /*$s5*/, _Position *playerPos /*$s0*/)
void PLAN_AddRandomNode(struct PlanningNode *planningPool, _Position *playerPos)
{ // line 273, offset 0x800975c4
	/* begin block 1 */
		// Start line: 274
		// Start offset: 0x800975C4
		// Variables:
			int i; // $s2
			//struct _PlanCollideInfo pci; // stack offset -56
			int successFlag; // $s4

		/* begin block 1.1 */
			// Start line: 282
			// Start offset: 0x80097600
			// Variables:
				short _x1; // $v0
				short _y1; // $v1
				short _z1; // $a0
				_Position *_v0; // $s1
		/* end block 1.1 */
		// End offset: 0x80097600
		// End Line: 282

		/* begin block 1.2 */
			// Start line: 301
			// Start offset: 0x8009771C

			/* begin block 1.2.1 */
				// Start line: 307
				// Start offset: 0x8009775C
				// Variables:
					struct _SVector normal; // stack offset -40
			/* end block 1.2.1 */
			// End offset: 0x800977AC
			// End Line: 313
		/* end block 1.2 */
		// End offset: 0x800977AC
		// End Line: 314
	/* end block 1 */
	// End offset: 0x800977AC
	// End Line: 315

	/* begin block 2 */
		// Start line: 643
	/* end block 2 */
	// End Line: 644
					UNIMPLEMENTED();
}

void PLAN_DeleteRandomNode(struct PlanningNode* planningPool)
{ 
	PLANPOOL_DeleteNodeFromPool(PLANPOOL_GetFirstNodeOfSource(planningPool, 0), planningPool);
}


// autogenerated function stub: 
// void /*$ra*/ PLAN_DeleteOutOfRangeNodesOfSource(struct PlanningNode *planningPool /*$s3*/, _Position *playerPos /*$s2*/, int nodeSourceToCheck /*$s4*/, long removeDist /*$s5*/)
void PLAN_DeleteOutOfRangeNodesOfSource(struct PlanningNode *planningPool, _Position *playerPos, int nodeSourceToCheck, long removeDist)
{ // line 332, offset 0x80097804
	/* begin block 1 */
		// Start line: 333
		// Start offset: 0x80097804
		// Variables:
			int i; // $s1
	/* end block 1 */
	// End offset: 0x800978B8
	// End Line: 345

	/* begin block 2 */
		// Start line: 795
	/* end block 2 */
	// End Line: 796

	/* begin block 3 */
		// Start line: 799
	/* end block 3 */
	// End Line: 800
			UNIMPLEMENTED();
}

void PLAN_AddOrRemoveRandomNodes(struct PlanningNode* planningPool, struct _Position* playerPos)//Matching - 99.25%
{
	int numNodeError;

	numNodeError = poolManagementData->numNodesInPool - 16;

	if (numNodeError < 0)
	{
		PLAN_AddRandomNode(planningPool, playerPos);
	}
	else
	{
		if (numNodeError > 0)
		{
			PLAN_DeleteRandomNode(planningPool);
		}
	}
}


void PLAN_AddInitialNodes(struct PlanningNode* planningPool, struct _Instance* player) // Matching - 99.89%
{
	struct _PlanCollideInfo pci;
	short _x1;
	short _y1;
	short _z1;
	struct _Position* _v0;
	struct _Position* _v1;

	_v0 = &pci.collidePos;
	_v1 = &player->position;
	_x1 = _v1->x;
	_y1 = _v1->y;
	_z1 = _v1->z;
	_v0->x = _x1;
	_v0->y = _y1;
	_v0->z = _z1;
	PLANCOLL_FindTerrainHitFinal(&pci, NULL, 256, -1024, 0, 0);
	PLANPOOL_AddNodeToPool(&pci.collidePos, planningPool, 1, 0, player->currentStreamUnitID);
	PLAN_UpdatePlanMkrNodes(planningPool, &player->position);
	poolManagementData->playerPosAtLastPlanMkrUpdate = player->position;
}

void PLAN_AddOrRemoveNodes(struct PlanningNode* planningPool, struct _Instance* player) // Matching - 99.83%
{
	if (MATH3D_LengthXYZ(
		player->position.x - poolManagementData->playerPosAtLastPlanMkrUpdate.x,
		player->position.y - poolManagementData->playerPosAtLastPlanMkrUpdate.y,
		player->position.z - poolManagementData->playerPosAtLastPlanMkrUpdate.z)
		> 500)
	{
		PLAN_UpdatePlayerNode(planningPool, &player->position);
		PLAN_UpdatePlanMkrNodes(planningPool, &player->position);
		PLAN_DeleteOutOfRangeNodesOfSource(planningPool, &player->position, 0, 12000);
		PLAN_DeleteOutOfRangeNodesOfSource(planningPool, &player->position, 2, 12000);
		PLAN_DeleteOutOfRangeNodesOfSource(planningPool, &player->position, 3, 12000);
		poolManagementData->playerPosAtLastPlanMkrUpdate = player->position;
	}
	PLAN_AddOrRemoveRandomNodes(planningPool, &player->position);
}

struct PlanningNode* PLAN_FindNodeMostInNeedOfConnectivityExpansion(struct PlanningNode* planningPool) // Matching - 100%
{
	int i;
	int numConnections;
	int minNumConnections;
	struct PlanningNode* nodeToReturn;

	minNumConnections = 65535;

	nodeToReturn = NULL;

	for (i = 0; i < poolManagementData->numNodesInPool; i++)
	{
		numConnections = PLANPOOL_NumConnectionsForNode(&planningPool[i]);

		if ((numConnections < minNumConnections) && (PLANPOOL_NumConnectionsExaminedForNode(&planningPool[i]) != poolManagementData->numNodesInPool))
		{
			minNumConnections = numConnections;

			nodeToReturn = &planningPool[i];
		}
	}

	return nodeToReturn;
}