#include "Game/CORE.H"
#include "PLANCOLL.H"
#include "Game/MATH3D.H"

struct _fth directionList[6];

// autogenerated function stub: 
// int /*$ra*/ PLANCOLL_DoesLOSExistFinal(_Position *startPos /*$a0*/, _Position *endPos /*$a1*/, int collideType /*$a2*/, int passThroughHit /*$s0*/, int zoffset /*stack 16*/)
int PLANCOLL_DoesLOSExistFinal(_Position *startPos, _Position *endPos, int collideType, int passThroughHit, int zoffset)
{ // line 75, offset 0x80098b14
	/* begin block 1 */
		// Start line: 76
		// Start offset: 0x80098B14
		// Variables:
			//struct _PCollideInfo pcollideinfo; // stack offset -72
			SVECTOR startPt; // stack offset -24
			SVECTOR endPt; // stack offset -16

		/* begin block 1.1 */
			// Start line: 76
			// Start offset: 0x80098B14
			// Variables:
				short _x1; // $v0
				short _y1; // $a2
				short _z1; // $a0
				_Position *_v0; // $v1
		/* end block 1.1 */
		// End offset: 0x80098B14
		// End Line: 76

		/* begin block 1.2 */
			// Start line: 76
			// Start offset: 0x80098B14
			// Variables:
				//short _x1; // $v0
				//short _y1; // $a0
				//short _z1; // $a1
				//_Position *_v0; // $v0
		/* end block 1.2 */
		// End offset: 0x80098B14
		// End Line: 76
	/* end block 1 */
	// End offset: 0x80098C08
	// End Line: 98

	/* begin block 2 */
		// Start line: 150
	/* end block 2 */
	// End Line: 151
				UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ PLANCOLL_CheckUnderwaterPoint(_Position *position /*$s5*/)
int PLANCOLL_CheckUnderwaterPoint(_Position *position)
{ // line 108, offset 0x80098c18
	/* begin block 1 */
		// Start line: 109
		// Start offset: 0x80098C18
		// Variables:
			struct _StreamUnit *streamUnit; // $s4
			struct Level *level; // $s2
			struct BSPTree *tree; // $a3
			struct _Sphere_noSq *sphere; // $s0
			_Position *offset; // $a3
			int d; // $s3
			_Position center; // stack offset -40

		/* begin block 1.1 */
			// Start line: 124
			// Start offset: 0x80098C74
			// Variables:
				short _x1; // $v1
				short _y1; // $v0
				short _z1; // $a0
				_Position *_v0; // $s6
		/* end block 1.1 */
		// End offset: 0x80098C74
		// End Line: 124
	/* end block 1 */
	// End offset: 0x80098D5C
	// End Line: 146

	/* begin block 2 */
		// Start line: 241
	/* end block 2 */
	// End Line: 242
				UNIMPLEMENTED();
	return 0;
}

int PLANCOLL_FindTerrainHitFinal(struct _PlanCollideInfo* pci, int* placement, int distBefore, int distAfter, int start, int end)
{
	struct _PCollideInfo pcollideinfo;
	struct _fth* current;
	struct _fth* last;
	SVECTOR startPt;
	SVECTOR endPt;
	struct _SVector normal;
	short _x1;
	short _y1;
	short _z1;
	struct _Position* _v0;
	struct _Position* _v1;

	pcollideinfo.collideType = 1;
	pcollideinfo.oldPoint = &startPt;
	pcollideinfo.newPoint = &endPt;

	current = &directionList[start];

	last = &directionList[end + 1];

	pcollideinfo.instance = NULL;

	while (current++ < last)
	{
		_v0 = (struct _Position*)&startPt;
		_v1 = (struct _Position*)&pci->collidePos;

		_x1 = _v1->x;
		_y1 = _v1->y;
		_z1 = _v1->z;

		_v0->x = _x1;
		_v0->y = _y1;
		_v0->z = _z1;

		_x1 = _v1->x;
		_y1 = _v1->y;
		_z1 = _v1->z;

		endPt.vx = _x1;
		endPt.vy = _y1;
		endPt.vz = _z1;

		_x1 += current->x * distBefore;

		startPt.vx = _x1;

		_y1 += current->y * distBefore;

		startPt.vy = _y1;

		_z1 += current->z * distBefore;

		startPt.vz = _z1;


		_x1 += current->x * distAfter;

		endPt.vx = _x1;

		_y1 += current->y * distAfter;

		endPt.vy = _y1;

		_z1 += current->z * distAfter;

		endPt.vz = _z1;

		COLLIDE_PointAndWorld(&pcollideinfo, NULL);

		if (pcollideinfo.type == 3)
		{
			if (placement != 0)
			{
				placement[0] = current->nodeType;
			}

			((unsigned int*)pci)[0] = ((unsigned int*)&pcollideinfo.inst->extraLightDir)[0];

			pci->tFace = (struct _TFace*)pcollideinfo.prim;

			COLLIDE_GetNormal((short)((struct _Model*)pcollideinfo.prim)->numNormals, (short*)((struct _Terrain*)((unsigned long*)&pcollideinfo)[0])->normalList, &normal);

			_x1 = normal.x * 20;

			if (_x1 < 0)
			{
				_x1 += 4095;
			}

			endPt.vx += _x1 >> 12;

			_y1 = normal.y * 20;

			if (_y1 < 0)
			{
				_y1 += 4095;
			}

			endPt.vz += _z1 >> 12;

			_z1 = normal.z * 20;

			if (_z1 < 0)
			{
				_z1 += 4095;
			}

			endPt.vz += _z1 >> 12;

			pci->collidePos.x = endPt.vx;
			pci->collidePos.y = endPt.vy;
			pci->collidePos.z = endPt.vz;

			return 1;
		}
	}
	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ PLANCOLL_DoesStraightLinePathExist(_Position *startPos /*$s2*/, _Position *endPos /*$s3*/, int collideType /*$s4*/)
int PLANCOLL_DoesStraightLinePathExist(_Position *startPos, _Position *endPos, int collideType)
{ // line 214, offset 0x80099044
	/* begin block 1 */
		// Start line: 215
		// Start offset: 0x80099044
	/* end block 1 */
	// End offset: 0x800990AC
	// End Line: 221

	/* begin block 2 */
		// Start line: 581
	/* end block 2 */
	// End Line: 582
	UNIMPLEMENTED();
	return 0;
}


int PLANCOLL_DoesWaterPathUpExist(_Position* startPos, _Position* endPos, int collideType, _Position* peakPos, int passThroughHit) // Matching - 100%
{
	long time_ftop;
	long time_ptow;
	long time_tot;
	_Position diff;

	time_ftop = MATH3D_FastSqrt(0x50000);
	peakPos->z = (startPos->z - endPos->z) + 0x280;
	time_ptow = MATH3D_FastSqrt((peakPos->z * 0x20000) / 3);
	if (time_ptow < 0)
	{
		time_ptow += 15;
	}
	time_tot = time_ptow >> 4;
	diff.x = startPos->x - endPos->x;
	diff.y = startPos->y - endPos->y;
	peakPos->x = endPos->x + (short)((diff.x * time_tot) / (time_ftop + time_tot));
	peakPos->y = endPos->y + (short)((diff.y * time_tot) / (time_ftop + time_tot));
	return PLANCOLL_DoesLOSExistFinal(startPos, peakPos, collideType, passThroughHit, 0);
}