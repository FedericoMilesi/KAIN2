#include "Game/CORE.H"
#include "Game/PLAN/PLANAPI.H"
#include "Game/STREAM.H"
#include "Game/PLAN/PLANCOLL.H"
#include "Game/PLAN/PLANSRCH.H"
#include "Game/PLAN/PLANPOOL.H"
#include <Game/TIMER.H>
#include "PLAN.H"
#include <Game/MATH3D.H>

struct PoolManagementData* poolManagementData;
struct PoolManagementData poolManagementDataStorage;
long timerArray[10];
long timerIndex;

// autogenerated function stub: 
// void /*$ra*/ PLANAPI_ConvertPlanIntoEnmyPlanDataFormat(struct PlanningNode *goalNode /*$a0*/, struct EnemyPlanData *planData /*$s1*/, struct PlanningNode *planningPool /*$s2*/)
void PLANAPI_ConvertPlanIntoEnmyPlanDataFormat(struct PlanningNode *goalNode, struct EnemyPlanData *planData, struct PlanningNode *planningPool)
{ // line 131, offset 0x80097b8c
	/* begin block 1 */
		// Start line: 132
		// Start offset: 0x80097B8C
		// Variables:
			struct PlanningNode *currentNode; // $s0
			int i; // $a0
	/* end block 1 */
	// End offset: 0x80097C28
	// End Line: 151

	/* begin block 2 */
		// Start line: 262
	/* end block 2 */
	// End Line: 263
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// int /*$ra*/ PLANAPI_FindPathBetweenNodes(struct PlanningNode *startNode /*$v0*/, struct PlanningNode *goalNode /*$v1*/, struct EnemyPlanData *planData /*$s3*/, int validNodeTypes /*$a3*/)
int PLANAPI_FindPathBetweenNodes(struct PlanningNode *startNode, struct PlanningNode *goalNode, struct EnemyPlanData *planData, int validNodeTypes)
{ // line 157, offset 0x80097c40
	/* begin block 1 */
		// Start line: 158
		// Start offset: 0x80097C40
		// Variables:
			struct PlanningNode *planningPool; // $s1
			int successFlag; // $s2
	/* end block 1 */
	// End offset: 0x80097CA8
	// End Line: 172

	/* begin block 2 */
		// Start line: 317
	/* end block 2 */
	// End Line: 318
			UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// void /*$ra*/ PLANAPI_DoTimingCalcsAndDrawing(long startTime /*$a0*/, struct PlanningNode *planningPool /*$s2*/)
void PLANAPI_DoTimingCalcsAndDrawing(long startTime, struct PlanningNode *planningPool)
{ // line 177, offset 0x80097cc8
	/* begin block 1 */
		// Start line: 178
		// Start offset: 0x80097CC8
		// Variables:
			int i; // $a1
			long minTime; // $s1
			long maxTime; // $s0

		/* begin block 1.1 */
			// Start line: 199
			// Start offset: 0x80097D70
		/* end block 1.1 */
		// End offset: 0x80097DCC
		// End Line: 221
	/* end block 1 */
	// End offset: 0x80097DCC
	// End Line: 222

	/* begin block 2 */
		// Start line: 361
	/* end block 2 */
	// End Line: 362
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// int /*$ra*/ PLANAPI_AddNodeOfTypeToPool(_Position *pos /*$s0*/, int type /*$s2*/)
int PLANAPI_AddNodeOfTypeToPool(_Position *pos, int type)
{ // line 269, offset 0x80097de4
	/* begin block 1 */
		// Start line: 270
		// Start offset: 0x80097DE4
		// Variables:
			struct PlanningNode *planningPool; // $s1
			int foundHit; // $v1
			int nodePlacement; // stack offset -24
			//struct _PlanCollideInfo pci; // stack offset -40

		/* begin block 1.1 */
			// Start line: 284
			// Start offset: 0x80097E30
			// Variables:
				short _x1; // $v0
				short _y1; // $v1
				short _z1; // $t0
				_Position *_v0; // $s0
		/* end block 1.1 */
		// End offset: 0x80097E30
		// End Line: 284
	/* end block 1 */
	// End offset: 0x80097EAC
	// End Line: 294

	/* begin block 2 */
		// Start line: 552
	/* end block 2 */
	// End Line: 553
				UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// void /*$ra*/ PLANAPI_DeleteNodesFromPoolByType(int nodeSource /*$s3*/)
void PLANAPI_DeleteNodesFromPoolByType(int nodeSource)
{ // line 306, offset 0x80097ec4
	/* begin block 1 */
		// Start line: 307
		// Start offset: 0x80097EC4
		// Variables:
			struct PlanningNode *planningPool; // $s2
			struct PlanningNode *nodeToDelete; // $s0
			int i; // $s1
	/* end block 1 */
	// End offset: 0x80097F44
	// End Line: 324

	/* begin block 2 */
		// Start line: 612
	/* end block 2 */
	// End Line: 613

	/* begin block 3 */
		// Start line: 626
	/* end block 3 */
	// End Line: 627
			UNIMPLEMENTED();
}

void PLANAPI_DeleteNodeFromPoolByUnit(long streamUnitID)//Matching - 99.47%
{
	struct PlanningNode* nodeToDelete;
	struct PlanningNode* planningPool;
	int i;

	nodeToDelete = (struct PlanningNode*)gameTrackerX.planningPool;
	planningPool = (struct PlanningNode*)gameTrackerX.planningPool;

	for (i = 0; i < poolManagementData->numNodesInPool;)
	{
		if (nodeToDelete->streamUnitID == streamUnitID)
		{
			PLANPOOL_DeleteNodeFromPool(nodeToDelete, planningPool);
		}
		else
		{
			++i;
			++nodeToDelete;
		}
	}
}


// autogenerated function stub: 
// int /*$ra*/ PLANAPI_FindPathInGraphToTarget(_Position *startPos /*$a0*/, struct EnemyPlanData *planData /*$s1*/, int validNodeTypes /*$s2*/)
int PLANAPI_FindPathInGraphToTarget(_Position *startPos, struct EnemyPlanData *planData, int validNodeTypes)
{ // line 388, offset 0x80097ff8
	/* begin block 1 */
		// Start line: 389
		// Start offset: 0x80097FF8
		// Variables:
			struct PlanningNode *planningPool; // $s0
			struct PlanningNode *startNode; // $s0
	/* end block 1 */
	// End offset: 0x80097FF8
	// End Line: 389

	/* begin block 2 */
		// Start line: 827
	/* end block 2 */
	// End Line: 828
			UNIMPLEMENTED();
	return 0;
}

void PLANAPI_InitPlanning(void* planningPool)//Matching - 92.66%
{
	int i;
	int j;

	poolManagementData = &poolManagementDataStorage;

	poolManagementData->state = 0;

	poolManagementData->numNodesInPool = 0;

	poolManagementData->distanceMatrix[0] = (unsigned short*)((intptr_t)planningPool + (sizeof(PlanningNode) * 32));

	for (i = 0; i < 32; i++)
	{
		for (j = 0; j < 32; j++)
		{
			*(unsigned short*)(poolManagementData->distanceMatrix[0] + i * 32 + j) = 0;
		}
	}

	for (i = 0; i < 10; i++)
	{
		timerArray[i] = 0;
	}

	timerIndex = 0;
}

short PLANAPI_PairType(struct PlanningNode* node1, struct PlanningNode* node2)
{
	short placement1;
	short placement2;

	placement1 = (node1->nodeType >> 3) & 0x3;
	placement2 = (node2->nodeType >> 3) & 0x3;

	if (placement2 < placement1)
	{
		placement1 = placement2 ^ placement1;
		placement2 = placement1 ^ placement2;
	}

	return (placement1 << 8) | placement2;//Not ready, see DECOMP.ME!
}


// autogenerated function stub: 
// int /*$ra*/ PLANAPI_PassThroughHit(struct PlanningNode *node1 /*$a0*/, struct PlanningNode *node2 /*$a1*/)
int PLANAPI_PassThroughHit(struct PlanningNode *node1, struct PlanningNode *node2)
{ // line 462, offset 0x80098124
	/* begin block 1 */
		// Start line: 464
		// Start offset: 0x80098124
		// Variables:
			int src1; // $a0
			int src2; // $v1
			int res; // $v1
	/* end block 1 */
	// End offset: 0x80098188
	// End Line: 485

	/* begin block 2 */
		// Start line: 997
	/* end block 2 */
	// End Line: 998

	/* begin block 3 */
		// Start line: 998
	/* end block 3 */
	// End Line: 999

	/* begin block 4 */
		// Start line: 1002
	/* end block 4 */
	// End Line: 1003
			UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ PLANAPI_CheckTargetToEnemyNode(struct PlanningNode **node1 /*$s2*/, struct PlanningNode **node2 /*$s3*/)
int PLANAPI_CheckTargetToEnemyNode(struct PlanningNode **node1, struct PlanningNode **node2)
{ // line 487, offset 0x80098190
	/* begin block 1 */
		// Start line: 488
		// Start offset: 0x80098190
		// Variables:
			struct PlanningNode *planningPool; // $s0
			struct PlanningNode *temp1; // $s1
			struct PlanningNode *temp2; // $a1
	/* end block 1 */
	// End offset: 0x80098284
	// End Line: 511

	/* begin block 2 */
		// Start line: 1048
	/* end block 2 */
	// End Line: 1049
			UNIMPLEMENTED();
	return 0;
}


void PLANAPI_UpdatePlanningDatabase(struct GameTracker* gameTracker, struct _Instance* instance)  // Matching - 100%
{
	struct PlanningNode* planningPool;
	struct PlanningNode* node1;
	struct PlanningNode* node2;
	long startTime;
	int pathExistsAbove;
	int pathExistsBelow;
	struct PlanningNode* temp;

	planningPool = (struct PlanningNode*)gameTracker->planningPool;
	startTime = (GetRCnt(RCntCNT0) & 0xFFFF) | (gameTimer << 16);
	gameTrackerX.plan_collide_override = 1;
	switch ((unsigned char)poolManagementData->state)
	{
	case 0:
		PLAN_AddInitialNodes(planningPool, instance);
		poolManagementData->state = 1;
		break;
	case 1:
		PLAN_AddOrRemoveNodes(planningPool, instance);
		poolManagementData->state = 2;
		break;
	case 2:
		node1 = PLAN_FindNodeMostInNeedOfConnectivityExpansion(planningPool);
		node2 = PLANPOOL_GetClosestUnexploredValidNeighbor(node1, planningPool);
		poolManagementData->state = 1;
		if ((node1 == NULL) || (node2 == NULL))
		{
			break;
		}
		if (MATH3D_LengthXYZ(node1->pos.x - node2->pos.x, node1->pos.y - node2->pos.y, node1->pos.z - node2->pos.z) < 6000)
		{
			poolManagementData->pairType = PLANAPI_PairType(node1, node2);
			switch (poolManagementData->pairType)
			{
			case 0:
			case 514:
				pathExistsAbove = PLANCOLL_DoesLOSExistFinal(&node1->pos, &node2->pos, 0, PLANAPI_PassThroughHit(node1, node2), 256);
				pathExistsBelow = PLANCOLL_DoesLOSExistFinal(&node1->pos, &node2->pos, 0, PLANAPI_PassThroughHit(node1, node2), -256);
				break;
			case 3:
				if (((node1->nodeType >> 3) & 3) == poolManagementData->pairType)
				{
					temp = node1;
					node1 = node2;
					node2 = temp;
				}
				pathExistsAbove = PLANCOLL_DoesWaterPathUpExist(&node1->pos, &node2->pos, 0, &poolManagementData->peakPos, PLANAPI_PassThroughHit(node1, node2));
				pathExistsBelow = PLANCOLL_DoesLOSExistFinal(&node2->pos, &poolManagementData->peakPos, 0, PLANAPI_PassThroughHit(node1, node2), 0);
				break;
			default:
				pathExistsBelow = PLANCOLL_DoesLOSExistFinal(&node1->pos, &node2->pos, 0, PLANAPI_PassThroughHit(node1, node2), 0);
				pathExistsAbove = pathExistsBelow;
				break;
			}
			poolManagementData->expansionNode1 = node1;
			poolManagementData->expansionNode2 = node2;
			if ((pathExistsAbove != 0) && (pathExistsBelow != 0))
			{
				PLANPOOL_MarkTwoNodesAsConnected(node1, node2, planningPool);
			}
			else
			{
				PLANPOOL_MarkTwoNodesAsNotConnected(node1, node2, planningPool);
			}
			poolManagementData->state = 3;
			break;
		}
		PLANPOOL_MarkTwoNodesAsNotConnected(node1, node2, planningPool);
		PLANPOOL_MarkTwoNodesAsNotConnected(node2, node1, planningPool);
		break;
	case 3:
		node1 = poolManagementData->expansionNode1;
		node2 = poolManagementData->expansionNode2;
		switch (poolManagementData->pairType)
		{
		case 0:
		case 514:
			pathExistsAbove = PLANCOLL_DoesLOSExistFinal(&node2->pos, &node1->pos, 0, PLANAPI_PassThroughHit(node2, node1), 256);
			pathExistsBelow = PLANCOLL_DoesLOSExistFinal(&node2->pos, &node1->pos, 0, PLANAPI_PassThroughHit(node2, node1), -256);
			break;
		case 3:
			pathExistsAbove = PLANCOLL_DoesWaterPathUpExist(&node2->pos, &node1->pos, 0, &poolManagementData->peakPos, PLANAPI_PassThroughHit(node2, node1));
			pathExistsBelow = PLANCOLL_DoesLOSExistFinal(&node1->pos, &poolManagementData->peakPos, 0, PLANAPI_PassThroughHit(node2, node1), 0);
			break;
		default:
			pathExistsBelow = PLANCOLL_DoesLOSExistFinal(&node2->pos, &node1->pos, 0, PLANAPI_PassThroughHit(node2, node1), 0);
			pathExistsAbove = pathExistsBelow;
			break;
		}
		if ((pathExistsAbove != 0) && (pathExistsBelow != 0))
		{
			PLANPOOL_MarkTwoNodesAsConnected(node2, node1, planningPool);
		}
		else
		{
			PLANPOOL_MarkTwoNodesAsNotConnected(node2, node1, planningPool);
		}
		poolManagementData->state = 1;
		break;
	default:
		poolManagementData->state = 1;
		break;
	}
	PLANAPI_DoTimingCalcsAndDrawing(startTime, planningPool);
	gameTrackerX.plan_collide_override = 0;
}

int PLANAPI_NumNodesInPool(void* planningPool)
{
	return poolManagementData->numNodesInPool;
}

void PLANAPI_InitPlanMkrList(struct _StreamUnit* streamUnit)//Matching - 97.47%
{
	int i;
	int terrainFoundFlag;
	struct Level* level;
	unsigned short numPlanMkrs;
	struct _PlanMkr* planMkrList;
	struct _PlanCollideInfo pci;
	short _x1;
	short _y1;
	short _z1;
	struct _Position* _v0;

	level = streamUnit->level;

	planMkrList = level->PlanMarkerList;

	numPlanMkrs = (unsigned short)level->NumberOfPlanMarkers;

	if (planMkrList != NULL)
	{
		_v0 = &pci.collidePos;

		for (i = 0; i < (numPlanMkrs); i++)
		{
			_x1 = planMkrList[i].pos.x;
			_y1 = planMkrList[i].pos.y;
			_z1 = planMkrList[i].pos.z;

			_v0->x = _x1;
			_v0->y = _y1;
			_v0->z = _z1;

			if (!(planMkrList[i].id & 0x5000))
			{
				if ((planMkrList[i].id & 0x8000))
				{
					terrainFoundFlag = PLANCOLL_FindTerrainHitFinal(&pci, NULL, -256, 640, 1, 4);
				}
				else if ((planMkrList[i].id & 0x2000))
				{
					terrainFoundFlag = PLANCOLL_FindTerrainHitFinal(&pci, NULL, -256, 640, 5, 5);
				}
				else
				{
					terrainFoundFlag = PLANCOLL_FindTerrainHitFinal(&pci, NULL, 128, -1024, 0, 0);
				}

				if (terrainFoundFlag != 0)
				{
					_x1 = _v0->x;
					_y1 = _v0->y;
					_z1 = _v0->z;

					planMkrList[i].pos.x = _x1;
					planMkrList[i].pos.y = _y1;
					planMkrList[i].pos.z = _z1;
				}
			}
		}
	}
}


// autogenerated function stub: 
// int /*$ra*/ PLANAPI_GetFlags(int type /*$a0*/)
int PLANAPI_GetFlags(int type)
{ // line 755, offset 0x80098884
	/* begin block 1 */
		// Start line: 757
		// Start offset: 0x80098884
		// Variables:
			int chk; // $v0
	/* end block 1 */
	// End offset: 0x800988E4
	// End Line: 779

	/* begin block 2 */
		// Start line: 1510
	/* end block 2 */
	// End Line: 1511

	/* begin block 3 */
		// Start line: 1641
	/* end block 3 */
	// End Line: 1642

	/* begin block 4 */
		// Start line: 1643
	/* end block 4 */
	// End Line: 1644
			UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ PLANAPI_FindNodePositionInUnit(struct _StreamUnit *streamUnit /*$a0*/, _Position *pos /*$s3*/, int id /*$s2*/, int type /*$a3*/)
int PLANAPI_FindNodePositionInUnit(struct _StreamUnit *streamUnit, _Position *pos, int id, int type)
{ // line 781, offset 0x800988ec
	/* begin block 1 */
		// Start line: 782
		// Start offset: 0x800988EC

		/* begin block 1.1 */
			// Start line: 785
			// Start offset: 0x80098910
			// Variables:
				struct Level *level; // $v0
				int numPlanMkrs; // $s0
				struct _PlanMkr *planMkr; // $s1
				int i; // $s0

			/* begin block 1.1.1 */
				// Start line: 795
				// Start offset: 0x80098944
				// Variables:
					short _x1; // $v1
					short _y1; // $a0
					short _z1; // $a1
			/* end block 1.1.1 */
			// End offset: 0x80098944
			// End Line: 795
		/* end block 1.1 */
		// End offset: 0x80098970
		// End Line: 799
	/* end block 1 */
	// End offset: 0x80098974
	// End Line: 801

	/* begin block 2 */
		// Start line: 1692
	/* end block 2 */
	// End Line: 1693
					UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ PLANAPI_FindClosestNodePositionInUnit(struct _StreamUnit *streamUnit /*$a0*/, _Position *target /*$s3*/, _Position *pos /*$fp*/, int offset /*stack 12*/, int max /*stack 16*/, int type /*stack 20*/, int distanceCheck /*stack 24*/)
int PLANAPI_FindClosestNodePositionInUnit(struct _StreamUnit *streamUnit, _Position *target, _Position *pos, int offset, int max, int type, int distanceCheck)
{ // line 806, offset 0x80098990
	/* begin block 1 */
		// Start line: 807
		// Start offset: 0x80098990
		// Variables:
			struct Level *level; // $v0
			int numPlanMkrs; // $s0
			struct _PlanMkr *planMkr; // $s1
			_Position *ptr; // $s4
			int dist; // $v1
			int min_dist; // $s5
			int chk; // $s7
			int res; // $s6
			int i; // $s2

		/* begin block 1.1 */
			// Start line: 846
			// Start offset: 0x80098AC8
			// Variables:
				short _x1; // $v0
				short _y1; // $v1
				short _z1; // $a0
		/* end block 1.1 */
		// End offset: 0x80098AE0
		// End Line: 846
	/* end block 1 */
	// End offset: 0x80098AE0
	// End Line: 849

	/* begin block 2 */
		// Start line: 1749
	/* end block 2 */
	// End Line: 1750
				UNIMPLEMENTED();
	return 0;
}




