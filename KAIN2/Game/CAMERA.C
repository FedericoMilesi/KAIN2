#include "CORE.H"
#include "CAMERA.H"
#include "MATH3D.H"
#include "GAMELOOP.H"
#include "STREAM.H"
#include "LIGHT3D.H"
#include "GAMELOOP.H"
#include "COLLIDE.H"
#include "PSX/COLLIDES.H"
#include "RAZIEL/RAZLIB.H"

short camera_still;
short shorten_flag;
short shorten_count;
short combat_cam_debounce;

struct _SVector camera_shakeOffset[16];
MATRIX wcTransformX;
MATRIX wcTransform2X;
MATRIX cwTransform2X;

long playerCameraMode;
short Camera_lookHeight;
short Camera_lookDist;
int CameraCenterDelay;
short CenterFlag;
short combat_cam_distance;
long roll_target;
long current_roll_amount;
int roll_inc;
short combat_cam_angle;
short combat_cam_weight;

short CameraLookStickyFlag;

void CAMERA_CalculateViewVolumeNormals(struct Camera *camera)
{
	short projDistance;
	struct _Normal n0;
	struct _Normal n1;
	struct _Normal n2;
	struct _Normal n3;
	int x1;
	int x2;
	int y1;
	int y2;

	x1 = ((unsigned int)camera->core.leftX - 160) << 4;
	projDistance = camera->core.projDistance << 4;
	x2 = ((unsigned int)camera->core.rightX - 160) << 4;
	y1 = ((unsigned int)camera->core.topY - 120) << 4;
	y2 = ((unsigned int)camera->core.bottomY - 120) << 4;

	n0.z = projDistance;
	n1.z = projDistance;
	n2.z = projDistance;
	n3.z = projDistance;

	n0.x = x1;
	n0.y = y1;

	n1.x = x2;
	n1.y = y1;

	n2.x = x1;
	n2.y = y2;

	n3.x = x2;
	n3.y = y2;

	camera->core.viewVolumeNormal[0].x = 0;
	camera->core.viewVolumeNormal[0].y = 0;
	camera->core.viewVolumeNormal[0].z = 4096;

	camera->core.viewVolumeNormal[1].x = (((unsigned int)(n0.y * n1.z) - (unsigned int)(n0.z * n1.y)) >> 12);
	camera->core.viewVolumeNormal[1].y = -(((unsigned int)(n0.x * n1.z) - (unsigned int)(n0.z * n1.x)) >> 12);
	camera->core.viewVolumeNormal[1].z = (((unsigned int)(n0.x * n1.y) - (unsigned int)(n0.y * n1.x)) >> 12);

	CAMERA_Normalize((_SVector*)&camera->core.viewVolumeNormal[1]);

	camera->core.viewVolumeNormal[2].x = (((unsigned int)(n2.y * n0.z) - (unsigned int)(n2.z * n0.y)) >> 12);
	camera->core.viewVolumeNormal[2].y = -(((unsigned int)(n2.x * n0.z) - (unsigned int)(n2.z * n0.x)) >> 12);
	camera->core.viewVolumeNormal[2].z = (((unsigned int)(n2.x * n0.y) - (unsigned int)(n2.y * n0.x)) >> 12);

	CAMERA_Normalize((_SVector*)&camera->core.viewVolumeNormal[2]);

	camera->core.viewVolumeNormal[3].x = (((unsigned int)(n1.y * n3.z) - (unsigned int)(n1.z * n3.y)) >> 12);
	camera->core.viewVolumeNormal[3].y = -(((unsigned int)(n1.x * n3.z) - (unsigned int)(n1.z * n3.x)) >> 12);
	camera->core.viewVolumeNormal[3].z = (((unsigned int)(n1.x * n3.y) - (unsigned int)(n1.y * n3.x)) >> 12);

	CAMERA_Normalize((_SVector*)&camera->core.viewVolumeNormal[3]);

	camera->core.viewVolumeNormal[4].x = (((unsigned int)(n3.y * n2.z) - (unsigned int)(n3.z * n2.y)) >> 12);
	camera->core.viewVolumeNormal[4].y = -(((unsigned int)(n3.x * n2.z) - (unsigned int)(n3.z * n2.x)) >> 12);
	camera->core.viewVolumeNormal[4].z = (((unsigned int)(n3.x * n2.y) - (unsigned int)(n3.y * n2.x)) >> 12);

	CAMERA_Normalize((_SVector*)&camera->core.viewVolumeNormal[4]);
}

void CAMERA_CalcVVClipInfo(struct Camera* camera)
{
	ApplyMatrixSV(camera->core.cwTransform2, (SVECTOR*)&camera->core.viewVolumeNormal[0], (SVECTOR*)&camera->core.vvNormalWorVecMat[0].m[0][0]);
	ApplyMatrixSV(camera->core.cwTransform2, (SVECTOR*)&camera->core.viewVolumeNormal[1], (SVECTOR*)&camera->core.vvNormalWorVecMat[0].m[1][0]);
	ApplyMatrixSV(camera->core.cwTransform2, (SVECTOR*)&camera->core.viewVolumeNormal[2], (SVECTOR*)&camera->core.vvNormalWorVecMat[0].m[2][0]);
	ApplyMatrixSV(camera->core.cwTransform2, (SVECTOR*)&camera->core.viewVolumeNormal[3], (SVECTOR*)&camera->core.vvNormalWorVecMat[1].m[0][0]);
	ApplyMatrixSV(camera->core.cwTransform2, (SVECTOR*)&camera->core.viewVolumeNormal[4], (SVECTOR*)&camera->core.vvNormalWorVecMat[1].m[1][0]);

	gte_SetRotMatrix(&camera->core.vvNormalWorVecMat[0]);
	gte_ldv0(&camera->core.position);
	gte_mvmva(1, 0, 0, 3, 0);
	gte_stlvnl(&camera->core.vvPlaneConsts[0]);

	gte_SetRotMatrix(&camera->core.vvNormalWorVecMat[1]);
	gte_ldv0(&camera->core.position);
	gte_mvmva(1, 0, 0, 3, 0);
	gte_stlvnl(&camera->core.vvPlaneConsts[3]);
}

void CAMERA_SetViewVolume(struct Camera *camera)
{
	CAMERA_CalculateViewVolumeNormals(camera);
	CAMERA_CalcVVClipInfo(camera);
}

void CAMERA_SetProjDistance(struct Camera *camera, long distance)
{
	struct Level* level;
	int i;

	SetGeomScreen(distance);

	camera->core.projDistance = distance;

	CAMERA_CalculateViewVolumeNormals(camera);
	
	for (i = 0; i < 16; i++)
	{
		if (StreamTracker.StreamList[i].used == 2)
		{
			level = StreamTracker.StreamList[i].level;

			SetFogNearFar(level->fogNear, level->fogFar, camera->core.projDistance);

			LIGHT_CalcDQPTable(level);
		}
	}
}


// autogenerated function stub: 
// void /*$ra*/ CAMERA_CreateNewFocuspoint(struct Camera *camera /*$s0*/)
void CAMERA_CreateNewFocuspoint(struct Camera *camera)
{ // line 302, offset 0x80014c14
	/* begin block 1 */
		// Start line: 303
		// Start offset: 0x80014C14
		// Variables:
			struct _SVector sv; // stack offset -24

		/* begin block 1.1 */
			// Start line: 303
			// Start offset: 0x80014C14
			// Variables:
				short _x0; // $v1
				short _y0; // $a0
				short _z0; // $a1
				short _x1; // $v0
				short _y1; // $a2
				short _z1; // $a3
				struct _SVector *_v; // $v0
		/* end block 1.1 */
		// End offset: 0x80014C14
		// End Line: 303

		/* begin block 1.2 */
			// Start line: 303
			// Start offset: 0x80014C14
			// Variables:
				//short _x0; // $v0
				//short _y0; // $v0
				//short _z0; // $v1
				//_Position *_v; // $a2
		/* end block 1.2 */
		// End offset: 0x80014C14
		// End Line: 303
	/* end block 1 */
	// End offset: 0x80014C14
	// End Line: 303

	/* begin block 2 */
		// Start line: 644
	/* end block 2 */
	// End Line: 645
				UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ CAMERA_SaveMode(struct Camera *camera /*$a0*/, long mode /*$a1*/)
void CAMERA_SaveMode(struct Camera *camera, long mode)
{ // line 315, offset 0x80014cb8
	/* begin block 1 */
		// Start line: 317
		// Start offset: 0x80014CB8
		// Variables:
			long i; // $t4
	/* end block 1 */
	// End offset: 0x80014FE8
	// End Line: 357

	/* begin block 2 */
		// Start line: 674
	/* end block 2 */
	// End Line: 675

	/* begin block 3 */
		// Start line: 675
	/* end block 3 */
	// End Line: 676

	/* begin block 4 */
		// Start line: 677
	/* end block 4 */
	// End Line: 678
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ CAMERA_RestoreMode(struct Camera *camera /*$s0*/)
void CAMERA_RestoreMode(struct Camera *camera)
{ // line 359, offset 0x80014ff0
	/* begin block 1 */
		// Start line: 360
		// Start offset: 0x80014FF0

		/* begin block 1.1 */
			// Start line: 372
			// Start offset: 0x80015014
			// Variables:
				long mode; // $s1
		/* end block 1.1 */
		// End offset: 0x80015484
		// End Line: 485
	/* end block 1 */
	// End offset: 0x80015484
	// End Line: 486

	/* begin block 2 */
		// Start line: 770
	/* end block 2 */
	// End Line: 771
				UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ CAMERA_Save(struct Camera *camera /*$a0*/, long save /*$a1*/)
void CAMERA_Save(struct Camera *camera, long save)
{ // line 489, offset 0x80015498
	/* begin block 1 */
		// Start line: 490
		// Start offset: 0x80015498

		/* begin block 1.1 */
			// Start line: 493
			// Start offset: 0x800154A8
			// Variables:
				int i; // $a2
		/* end block 1.1 */
		// End offset: 0x80015510
		// End Line: 505
	/* end block 1 */
	// End offset: 0x80015558
	// End Line: 520

	/* begin block 2 */
		// Start line: 1060
	/* end block 2 */
	// End Line: 1061
				UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ CAMERA_Restore(struct Camera *camera /*$a0*/, long restore /*$a1*/)
void CAMERA_Restore(struct Camera *camera, long restore)
{ // line 524, offset 0x80015568
	/* begin block 1 */
		// Start line: 1133
	/* end block 1 */
	// End Line: 1134
	UNIMPLEMENTED();
}


// autogenerated function stub: 
// struct _SVector * /*$ra*/ SplineGetNextPointDC(struct Spline *spline /*$s0*/, struct SplineDef *def /*$s1*/)
struct _SVector * SplineGetNextPointDC(struct Spline *spline, struct SplineDef *def)
{ // line 564, offset 0x80015624
	/* begin block 1 */
		// Start line: 565
		// Start offset: 0x80015624
		// Variables:
			static struct _SVector point; // offset 0x0
	/* end block 1 */
	// End offset: 0x8001566C
	// End Line: 576

	/* begin block 2 */
		// Start line: 1219
	/* end block 2 */
	// End Line: 1220
			UNIMPLEMENTED();
	return null;
}


// autogenerated function stub: 
// void /*$ra*/ CAMERA_SetMode(struct Camera *camera /*$s2*/, long mode /*$s3*/)
void CAMERA_SetMode(struct Camera *camera, long mode)
{ // line 578, offset 0x80015680
	/* begin block 1 */
	//	// Start line: 579
	//	// Start offset: 0x80015680
	//	// Variables:
	//		int oldMode; // $s0
	//		struct SplineDef curPositional; // stack offset -56
	//		struct _SVector sv; // stack offset -48

	//	/* begin block 1.1 */
	//		// Start line: 624
	//		// Start offset: 0x80015754
	//		// Variables:
	//			short _x1; // $v0
	//			short _y1; // $a0
	//			short _z1; // $a1
	//			struct _Rotation *_v0; // $v0
	//			struct _Rotation *_v1; // $v1
	//	/* end block 1.1 */
	//	// End offset: 0x80015754
	//	// End Line: 624

	//	/* begin block 1.2 */
	//		// Start line: 624
	//		// Start offset: 0x80015754
	//		// Variables:
	//			short _x1; // $v0
	//			short _y1; // $a0
	//			short _z1; // $v1
	//			struct _Rotation *_v0; // $v0
	//	/* end block 1.2 */
	//	// End offset: 0x80015754
	//	// End Line: 624

	//	/* begin block 1.3 */
	//		// Start line: 624
	//		// Start offset: 0x80015754
	//		// Variables:
	//			short _x0; // $v0
	//			short _y0; // $a1
	//			short _z0; // $v1
	//			short _x1; // $a2
	//			short _y1; // $a3
	//			short _z1; // $t0
	//			struct _SVector *_v; // $a0
	//			_Position *_v0; // $v1
	//	/* end block 1.3 */
	//	// End offset: 0x80015754
	//	// End Line: 624

	//	/* begin block 1.4 */
	//		// Start line: 684
	//		// Start offset: 0x800158B0
	//		// Variables:
	//			struct _SVector *camPos; // stack offset -32
	//			struct _SVector *targetPos; // $a0

	//		/* begin block 1.4.1 */
	//			// Start line: 689
	//			// Start offset: 0x800158C4
	//			// Variables:
	//				_Position pos; // stack offset -40
	//		/* end block 1.4.1 */
	//		// End offset: 0x800158C4
	//		// End Line: 691

	//		/* begin block 1.4.2 */
	//			// Start line: 705
	//			// Start offset: 0x80015970
	//			// Variables:
	//				short _x1; // $v0
	//				short _y1; // $v1
	//				short _z1; // $a0
	//				_Position *_v0; // $v0
	//		/* end block 1.4.2 */
	//		// End offset: 0x80015970
	//		// End Line: 705

	//		/* begin block 1.4.3 */
	//			// Start line: 715
	//			// Start offset: 0x800159C4
	//			// Variables:
	//				short _x1; // $v0
	//				short _y1; // $v1
	//				short _z1; // $a0
	//				_Position *_v0; // $v0
	//		/* end block 1.4.3 */
	//		// End offset: 0x800159E0
	//		// End Line: 715
	//	/* end block 1.4 */
	//	// End offset: 0x800159E0
	//	// End Line: 719
	///* end block 1 */
	//// End offset: 0x80015B14
	//// End Line: 771

	///* begin block 2 */
	//	// Start line: 1252
	///* end block 2 */
	//// End Line: 1253
	UNIMPLEMENTED();
}

void CAMERA_Initialize(struct Camera *camera)
{
	long i;

	memset(camera, 0, sizeof(struct Camera));

	for (i = 0; i < 16; i++)
	{
#define RAND(i, c) int r = rand(); int r2 = r; if(r < 0) { r2 = r + 255; } camera_shakeOffset[i].c = (r - ((r2 >> 8) << 8)) - 128;

		//RAND(i, x);
		//RAND(i, y);
		//RAND(i, z);

		int r = rand();
		int r2 = r;

		if (r < 0)
		{
			r2 = r + 255;
		}

		camera_shakeOffset[i].x = (r - ((r2 >> 8) << 8)) - 128;

		r = rand();
		r2 = r >> 8;
		if (r < 0)
		{
			r2 = r + 255;
		}
		r2 <<= 8;
		camera_shakeOffset[i].y = (r - r2) - 128;

		r = rand();
		r2 = r >> 8;
		if (r < 0)
		{
			r2 = r + 255;
		}

		r2 <<= 8;
		camera_shakeOffset[i].z = (r - r2) - 128;
	}

	camera->core.rotation.x = 4039;
	camera->targetRotation.x = 4039;
	camera->focusRotation.x = 4039;
	camera->targetFocusRotation.x = 4039;

	long* test = &camera->focusDistanceList[0][0];

	camera->focusDistanceList[0][0] = 1500;
	camera->focusDistanceList[1][0] = 1500;
	camera->focusDistanceList[0][1] = 2250;
	camera->focusDistanceList[1][1] = 2000;
	camera->focusDistanceList[2][2] = 2000;
	
	camera->focusDistanceList[0][2] = 3200;
	camera->focusDistanceList[1][2] = 2600;
	camera->focusDistanceList[2][0] = 1200;
	camera->focusDistanceList[2][1] = 1600;
	
	camera->tiltList[0][0] = 4039;
	camera->tiltList[0][1] = 4039;
	camera->tiltList[0][2] = 4039;
	camera->tiltList[1][0] = 4039;
	camera->tiltList[1][1] = 4039;
	camera->tiltList[1][2] = 4039;
	camera->tiltList[2][0] = 4039;
	camera->tiltList[2][1] = 4039;
	camera->tiltList[2][2] = 4039;

	camera->smallBaseSphere.radiusSquared = 78400;
	camera->focusSphere.radiusSquared = 78400;
	camera->posSphere.radiusSquared = 78400;
	camera->smallBaseSphere.radius = 320;
	camera->focusSphere.radius = 320;
	camera->posSphere.radius = 320;
	camera->core.nearPlane = 50;
	camera->core.projDistance = 320;
	camera->targetFocusDistance = (short)camera->focusDistanceList[0][1];
	camera->focusDistance = (short)camera->focusDistanceList[0][1];
	camera->core.farPlane = 12000;
	camera->core.bottomY = 240;
	camera->core.wcTransform = &wcTransformX;
	camera->core.wcTransform2 = &wcTransform2X;
	camera->core.cwTransform2 = &cwTransform2X;
	camera->smooth = 16;
	camera->core.leftX = 0;
	camera->core.rightX = 320;
	camera->core.topY = 0;
	camera->maxVel = 200;
	camera->always_rotate_flag = 0;
	camera->follow_flag = 0;
	camera->real_focuspoint.x = camera->focusPoint.x;
	camera->real_focuspoint.y = camera->focusPoint.y;
	camera->real_focuspoint.z = camera->focusPoint.z;
	camera->minFocusDistance = 512;
	camera->Spline01 = NULL;
	camera->Spline00 = NULL;

	shorten_count = 0;
	shorten_flag = 0;

	camera->maxFocusDistance = 4096;

	camera->focuspoint_fallz = camera->focusPoint.z;

	camera->flags |= 0x800;

	if (camera->focusInstance != NULL)
	{
		CAMERA_EndLook(camera);
	}

	camera->presetIndex = 1;
	camera->mode = 0;

	CAMERA_SetMode(camera, playerCameraMode);

	camera->maxXYDist = 3000;
	camera->minXYDist = 0;
	camera->rotDirection = 1;

	camera->core.screenScale.z = 4096;
	camera->core.screenScale.y = 4096;
	camera->core.screenScale.x = 4096;

	camera->stack = -1;
	camera->targetStack = -1;

	camera->flags |= 0x8000;

	for (i = 0; i < 3; i++)
	{
		camera->savedMode[i] = 0;
	}

	camera->core.projDistance = 320;

	CAMERA_SetProjDistance(camera, 320);

	camera->data.Cinematic.cinema_done = 0;

	Camera_lookHeight = 512;
	Camera_lookDist = 650;
	CameraCenterDelay = 10;
	CenterFlag = -1;
	combat_cam_distance = 3000;
	roll_target = 0;
	current_roll_amount = 0;
	roll_inc = 0;
	combat_cam_angle = 0;
	combat_cam_weight = 4096;
	combat_cam_debounce = 0;
}

void CAMERA_SetInstanceFocus(struct Camera *camera, struct _Instance *instance)
{
	camera->focusInstance = instance;
	camera->flags |= 0x800;

	camera->newFocusInstancePos.x = instance->position.x;
	camera->newFocusInstancePos.y = instance->position.y;
	camera->newFocusInstancePos.z = instance->position.z;

	if (instance->object != NULL)
	{
		if (instance == gameTrackerX.playerInstance)
		{
			camera->focusOffset.z = 352;
		}
		else
		{
			camera->focusOffset.z = 512;
		}

		camera->focusOffset.x = 0;
		camera->focusOffset.y = 0;
	}
}

void CAMERA_SetZRotation(struct Camera* camera, short zrot)
{
	camera->core.rotation.z = zrot;
	camera->focusRotation.z = zrot;
	camera->targetRotation.z = zrot;
	camera->targetFocusRotation.z = zrot;
	camera->rotationAccl.z = 0;
	camera->rotationVel.z = 0;
	camera->rotationAccl.z = 0;
	camera->rotationVel.z = 0;
}

long CAMERA_LengthSVector(struct _SVector* sv)
{
	return MATH3D_FastSqrt0((sv->x * sv->x) + (sv->y * sv->y) + (sv->z * sv->z));
}


// autogenerated function stub: 
// void /*$ra*/ CAMERA_SetValue(struct Camera *camera /*$a0*/, long index /*$a1*/, long value /*$a2*/)
void CAMERA_SetValue(struct Camera *camera, long index, long value)
{ // line 1115, offset 0x80015f08
	/* begin block 1 */
		// Start line: 1117
		// Start offset: 0x80015F08
		// Variables:
			long min; // $t1
			long max; // $t0
			long minTilt; // $a3
			long maxTilt; // $a1
	/* end block 1 */
	// End offset: 0x8001632C
	// End Line: 1169

	/* begin block 2 */
		// Start line: 2680
	/* end block 2 */
	// End Line: 2681

	/* begin block 3 */
		// Start line: 2681
	/* end block 3 */
	// End Line: 2682
			UNIMPLEMENTED();
}

short CAMERA_AngleDifference(short angle0, short angle1)
{
	angle0 &= 0xFFF;
	angle1 &= 0xFFF;

#define GET_ANGLE(x, y) ((x - y) > 2048) ? (x | 4096) : (x)

	angle0 = GET_ANGLE(angle0, angle1);
	angle1 = GET_ANGLE(angle1, angle0);

	if (angle1 < angle0)
	{
		angle1 = angle0;
	}

	if (angle0 < angle1)
	{
		angle0 = angle1;
	}

	return angle1 - angle0;
}

short CAMERA_SignedAngleDifference(short angle0, short angle1)
{ 
	return AngleDiff(angle1, angle0);
}

unsigned long CAMERA_QueryMode(struct Camera *camera)
{
	unsigned long mode;

	mode = INSTANCE_Query(camera->focusInstance, 10);

	if (camera->focusInstance == gameTrackerX.playerInstance)
	{
		if ((mode & 0x2000000))
		{
			combat_cam_debounce = 1;
		}
		else
		{
			if (combat_cam_debounce > 0)
			{
				combat_cam_debounce--;

				mode |= 0x2000000;
			}
		}
	}
	else
	{
		mode &= 0xFDFFFFFF;
	}

	if (WARPGATE_IsWarpgateActive() != 0)
	{
		mode |= 0x80000000;
	}

	return mode;
}

void CAMERA_SetMaxVel(struct Camera* camera)
{
	long extraVel;
	long targetMaxVel;
	struct _SVector cam_dist;
	static long maxVelAccl;
	static long maxVelVel;
	short _x0;
	short _y0;
	short _z0;
	short _x1;
	short _y1;
	short _z1;
	struct _SVector* _v;
	struct _Position* _v0;
	struct _Position* _v1;

	_v0 = &camera->focusPoint;
	_v1 = &camera->targetFocusPoint;

	_x0 = _v0->x;
	_y0 = _v0->y;
	_z0 = _v0->z;

	_x1 = _v1->x;
	_y1 = _v1->y;
	_z1 = _v1->z;

	_v = &cam_dist;

	_v->x = _x0 - _x1;
	_v->y = _y0 - _y1;
	_v->z = _z0 - _z1;

	extraVel = camera->focusDistance / 100;
	
	if (extraVel < 20)
	{
		extraVel = 20;
	}

	targetMaxVel = camera->forced_movement;

	if (targetMaxVel != 0)
	{
		extraVel += extraVel << 2;
	}

	targetMaxVel = ((short)CAMERA_LengthSVector(_v) + extraVel - camera->maxVel) >> 2;

	targetMaxVel = targetMaxVel - maxVelVel;

	maxVelVel += targetMaxVel;

	maxVelAccl = targetMaxVel;

	camera->maxVel += maxVelVel;

	if (camera->maxVel <= 0)
	{
		camera->maxVel = 1;
	}
}


// autogenerated function stub: 
// void /*$ra*/ CAMERA_SetTarget(struct Camera *camera /*$s0*/, _Position *pos /*$s1*/)
void CAMERA_SetTarget(struct Camera *camera, _Position *pos)
{ // line 1267, offset 0x80016584
	/* begin block 1 */
		// Start line: 1268
		// Start offset: 0x80016584
		// Variables:
			struct _SVector sv; // stack offset -24

		/* begin block 1.1 */
			// Start line: 1268
			// Start offset: 0x80016584
			// Variables:
				short _x0; // $v0
				short _y0; // $v1
				short _z0; // $a1
				short _x1; // $a2
				short _y1; // $a3
				short _z1; // $t0
				struct _SVector *_v; // $a0
		/* end block 1.1 */
		// End offset: 0x80016584
		// End Line: 1268
	/* end block 1 */
	// End offset: 0x80016584
	// End Line: 1268

	/* begin block 2 */
		// Start line: 3007
	/* end block 2 */
	// End Line: 3008
				UNIMPLEMENTED();
}

void CAMERA_CalcPosition(_Position* position, _Position* base, struct _Rotation* rotation, short distance)
{
	SVECTOR sv;
	VECTOR v;
	MATRIX matrix;
	struct _Vector vectorPos;
	short _x1;
	short _y1;
	short _z1;
	struct _Vector* _v1;

	distance = -distance;

	sv.vx = 0;
	sv.vy = distance;
	sv.vz = 0;

	MATH3D_SetUnityMatrix(&matrix);

	RotMatrixX(rotation->x, &matrix);
	RotMatrixY(rotation->y, &matrix);
	RotMatrixZ(rotation->z, &matrix);

	gte_SetRotMatrix(&matrix);

	gte_ldv0(&sv);

	gte_rtv0();

	gte_stlvnl(&v);

	vectorPos.x = v.vx + base->x;
	vectorPos.y = v.vy + base->y;
	vectorPos.z = v.vz + base->z;

	_v1 = &vectorPos;

	_x1 = _v1->x;
	_y1 = _v1->y;
	_z1 = _v1->z;

	position->x = _x1;
	position->y = _y1;
	position->z = _z1;
}

void CAMERA_SetFocus(struct Camera *camera, _Position *targetfocusPoint)
{
	struct _Instance* focusInstance; // $s0
	struct _Model* model; // $v0
	struct _SVector temp1; // stack offset -64
	struct _SVector offset; // stack offset -56
	struct _SVector* segPosVector; // $v1
	struct _Vector temp2; // stack offset -48
	short _x1; // $v0, v0, v1
	short _y1; // $a0, v1, a0
	short _z1; // $v1, a0, v0
	struct _SVector* _v0; // $s2
	struct _Position* _v1; // $v0
	short _x0; // $v0 v0 v1
	short _y0; // $a2 v0 a0
	short _z0; //     v1 a1
	struct _Instance* instance; // $v0
	struct _SVector output; // stack offset -32

	///@TODO
	UNIMPLEMENTED();
}

void CAMERA_Lock(struct Camera* camera, long lock)
{
#if defined(PSX_VERSION)
	camera->lock |= lock;
#elif defined(PC_VERSION)
	camera->lock |= lock;
#endif
}

void CAMERA_Unlock(struct Camera* camera, long unlock)
{
#if defined(PSX_VERSION)
	camera->lock &= ~unlock;
#elif defined(PC_VERSION)
	camera->lock &= ~unlock;
#endif
}


// autogenerated function stub: 
// void /*$ra*/ CAMERA_SetSmoothValue(struct Camera *camera /*$a0*/, long smooth /*$a1*/)
void CAMERA_SetSmoothValue(struct Camera *camera, long smooth)
{ // line 1437, offset 0x800169cc
	/* begin block 1 */
		// Start line: 3394
	/* end block 1 */
	// End Line: 3395

	/* begin block 2 */
		// Start line: 3396
	/* end block 2 */
	// End Line: 3397
	UNIMPLEMENTED();
}

void CAMERA_SetTimer(struct Camera* camera, long time)
{
	CAMERA_Save(camera, -1);
}


void CAMERA_Adjust_tilt(struct Camera* camera, long tilt)
{
	camera->tiltState = 3;
	
	tilt &= 0xFFF;
	
	camera->signalRot.x = tilt;

	if (camera->smooth == 0)
	{
		camera->tilt = 0;

		camera->targetFocusRotation.x = tilt;

		camera->targetRotation.x = tilt;

		camera->tfaceTilt = tilt;

		camera->focusRotation.x = tilt;

		camera->actual_x_rot = tilt;
	}
}


// autogenerated function stub: 
// void /*$ra*/ CAMERA_Adjust_distance(struct Camera *camera /*$a0*/, long dist /*$a1*/)
void CAMERA_Adjust_distance(struct Camera *camera, long dist)
{ // line 1474, offset 0x80016a78
	/* begin block 1 */
		// Start line: 3471
	/* end block 1 */
	// End Line: 3472

	/* begin block 2 */
		// Start line: 3472
	/* end block 2 */
	// End Line: 3473
	UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ CAMERA_Adjust_rotation(struct Camera *camera /*$s0*/, long rotation /*$s1*/)
void CAMERA_Adjust_rotation(struct Camera *camera, long rotation)
{ // line 1492, offset 0x80016af4
	/* begin block 1 */
		// Start line: 3509
	/* end block 1 */
	// End Line: 3510
	UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ CAMERA_Adjust_roll(long roll_degrees /*$s0*/, int frames /*$s1*/)
void CAMERA_Adjust_roll(long roll_degrees, int frames)
{ // line 1511, offset 0x80016b78
	/* begin block 1 */
		// Start line: 3555
	/* end block 1 */
	// End Line: 3556
	UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ CAMERA_Adjust(struct Camera *camera /*$s1*/, long adjust /*$s2*/)
void CAMERA_Adjust(struct Camera *camera, long adjust)
{ // line 1527, offset 0x80016bfc
	/* begin block 1 */
		// Start line: 1528
		// Start offset: 0x80016BFC

		/* begin block 1.1 */
			// Start line: 1532
			// Start offset: 0x80016C24

			/* begin block 1.1.1 */
				// Start line: 1535
				// Start offset: 0x80016C30
				// Variables:
					struct _SVector dv; // stack offset -24

				/* begin block 1.1.1.1 */
					// Start line: 1536
					// Start offset: 0x80016C30
					// Variables:
						short _x0; // $v0
						short _y0; // $v1
						short _z0; // $a1
						short _x1; // $a2
						short _y1; // $t0
						short _z1; // $a3
						struct _SVector *_v; // $a0
						struct _SVector *_v1; // $a3
				/* end block 1.1.1.1 */
				// End offset: 0x80016C30
				// End Line: 1536
			/* end block 1.1.1 */
			// End offset: 0x80016C74
			// End Line: 1551
		/* end block 1.1 */
		// End offset: 0x80016CA4
		// End Line: 1582
	/* end block 1 */
	// End offset: 0x80016CA4
	// End Line: 1587

	/* begin block 2 */
		// Start line: 3589
	/* end block 2 */
	// End Line: 3590
						UNIMPLEMENTED();
}

void CAMERA_ChangeTo(struct Camera* camera, struct _CameraKey* cameraKey)
{
	camera->cameraKey = cameraKey;
}


// autogenerated function stub: 
// void /*$ra*/ CAMERA_SetShake(struct Camera *camera /*$t0*/, long shake /*$a1*/, long scale /*$a2*/)
void CAMERA_SetShake(struct Camera *camera, long shake, long scale)
{ // line 1595, offset 0x80016cc4
	/* begin block 1 */
		// Start line: 1596
		// Start offset: 0x80016CC4
		// Variables:
			int shock; // $a0
			int duration; // $a1
	/* end block 1 */
	// End offset: 0x80016D5C
	// End Line: 1615

	/* begin block 2 */
		// Start line: 3725
	/* end block 2 */
	// End Line: 3726
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ Decouple_AngleMoveToward(short *current_ptr /*$a0*/, short destination /*$a1*/, short step /*$a3*/)
void Decouple_AngleMoveToward(short *current_ptr, short destination, short step)
{ // line 1618, offset 0x80016d74
	/* begin block 1 */
		// Start line: 3771
	/* end block 1 */
	// End Line: 3772
	UNIMPLEMENTED();
}

void CriticalDampValue(long dampMode, short *sourceVal, short targetVal, short *vel, short *accl, int smooth)
{
	short maxVel;
	short useVel;

#if !defined(UWP)
	
	if (smooth != 0)
	{
		maxVel = smooth;

		if (smooth < 0)
		{
			maxVel = -4096 / smooth;
		}

		if (dampMode == 1)
		{
			if (dampMode == 5)
			{
				accl[0] = ((targetVal - sourceVal[0]) >> 1) - vel[0];

				useVel = vel[0] + accl[0];

				vel[0] = useVel;

				if (maxVel < useVel)
				{
					vel[0] = maxVel;

					if (gameTrackerX.timeMult != 4096)
					{
						useVel = (maxVel * gameTrackerX.timeMult) >> 12;
					}
				}
				else
				{
					if (useVel < -maxVel)
					{
						useVel = -maxVel;

						vel[0] = useVel;

						if (gameTrackerX.timeMult != 4096)
						{
							useVel = -(maxVel * gameTrackerX.timeMult) >> 12;
						}
					}
				}

				sourceVal[0] += useVel;
			}
			else if (dampMode == 6)
			{
				accl[0] = ((targetVal - sourceVal[0]) >> 3) - vel[0];

				useVel = vel[0] + accl[0];

				vel[0] = useVel;


				if (maxVel < useVel)
				{
					vel[0] = maxVel;

					if (gameTrackerX.timeMult != 4096)
					{
						useVel = (maxVel * gameTrackerX.timeMult) >> 12;
					}
				}
				else
				{
					if (useVel < -maxVel)
					{
						useVel = -maxVel;

						vel[0] = useVel;

						if (gameTrackerX.timeMult != 4096)
						{
							useVel = -(maxVel * gameTrackerX.timeMult) >> 12;
						}
					}
				}

				sourceVal[0] += useVel;
			}
			else
			{
				accl[0] = ((targetVal - sourceVal[0]) >> 2) - vel[0];

				useVel = vel[0] + accl[0];

				vel[0] = useVel;

				if (maxVel < useVel)
				{
					vel[0] = maxVel;

					if (gameTrackerX.timeMult != 4096)
					{
						useVel = (maxVel * gameTrackerX.timeMult) >> 12;
					}
				}
				else
				{
					if (useVel < -maxVel)
					{
						useVel = -maxVel;

						vel[0] = useVel;

						if (gameTrackerX.timeMult != 4096)
						{
							useVel = -(maxVel * gameTrackerX.timeMult) >> 12;
						}
					}
				}

				sourceVal[0] += useVel;
			}
		}
		else if (dampMode >= 2)
		{
			//loc_800171D4
			if (dampMode >= 7)
			{
				if (vel[0] == 0)
				{
					sourceVal[0] = targetVal;
				}
			}
			else if (dampMode >= 5)
			{
				if (dampMode == 5)
				{
					accl[0] = ((targetVal - sourceVal[0]) >> 1) - vel[0];
					
					useVel = vel[0] + accl[0];
					
					vel[0] = useVel;

					if (maxVel < useVel)
					{
						vel[0] = maxVel;

						if (gameTrackerX.timeMult != 4096)
						{
							useVel = (maxVel * gameTrackerX.timeMult) >> 12;
						}
					}
					else
					{
						if (useVel < -maxVel)
						{
							useVel = -maxVel;

							vel[0] = useVel;

							if (gameTrackerX.timeMult != 4096)
							{
								useVel = -(maxVel * gameTrackerX.timeMult) >> 12;
							}
						}
					}

					sourceVal[0] += useVel;
				}
				else if (dampMode == 6)
				{
					accl[0] = ((targetVal - sourceVal[0]) >> 3) - vel[0];
					
					useVel = vel[0] + accl[0];
					
					vel[0] = useVel;


					if (maxVel < useVel)
					{
						vel[0] = maxVel;

						if (gameTrackerX.timeMult != 4096)
						{
							useVel = (maxVel * gameTrackerX.timeMult) >> 12;
						}
					}
					else
					{
						if (useVel < -maxVel)
						{
							useVel = -maxVel;

							vel[0] = useVel;

							if (gameTrackerX.timeMult != 4096)
							{
								useVel = -(maxVel * gameTrackerX.timeMult) >> 12;
							}
						}
					}

					sourceVal[0] += useVel;
				}
				else
				{
					accl[0] = ((targetVal - sourceVal[0]) >> 2) - vel[0];
					
					useVel = vel[0] + accl[0];
					
					vel[0] = useVel;
					
					if (maxVel < useVel)
					{
						vel[0] = maxVel;

						if (gameTrackerX.timeMult != 4096)
						{
							useVel = (maxVel * gameTrackerX.timeMult) >> 12;
						}
					}
					else
					{
						if (useVel < -maxVel)
						{
							useVel = -maxVel;

							vel[0] = useVel;

							if (gameTrackerX.timeMult != 4096)
							{
								useVel = -(maxVel * gameTrackerX.timeMult) >> 12;
							}
						}
					}

					sourceVal[0] += useVel;
				}
			}
		}
		else if (dampMode == 0)
		{
			accl[0] = ((targetVal - sourceVal[0]) >> 2) - vel[0];
			
			vel[0] += accl[0];
			
			sourceVal[0] += vel[0];
		}

		if (vel[0] == 0)
		{
			sourceVal[0] = targetVal;
		}

	}
	else
	{
		sourceVal[0] = targetVal;
	}
#endif
}


// autogenerated function stub: 
// void /*$ra*/ CriticalDampPosition(long dampMode /*$a0*/, _Position *position /*$s1*/, _Position *targetPos /*$s3*/, struct _SVector *vel /*$s2*/, struct _SVector *accl /*stack 16*/, int smooth /*stack 20*/)
void CriticalDampPosition(long dampMode, _Position *position, _Position *targetPos, struct _SVector *vel, struct _SVector *accl, int smooth)
{ // line 1738, offset 0x80016f78
	///* begin block 1 */
	//	// Start line: 1739
	//	// Start offset: 0x80016F78
	//	// Variables:
	//		long length; // $s0
	//		struct _Vector vector; // stack offset -48
	//		struct _SVector svector; // stack offset -32
	//		short maxVel; // $s4
	//		int shift; // $a3

	//	/* begin block 1.1 */
	//		// Start line: 1760
	//		// Start offset: 0x80016FF4
	//		// Variables:
	//			long _x0; // $v0
	//			long _y0; // $a2
	//			long _z0; // $a1
	//			long _x1; // $v1
	//			long _y1; // $v1
	//			long _z1; // $a0
	//			struct _Vector *_v; // $v1
	//	/* end block 1.1 */
	//	// End offset: 0x80016FF4
	//	// End Line: 1760

	//	/* begin block 1.2 */
	//		// Start line: 1775
	//		// Start offset: 0x800170B0
	//		// Variables:
	//			long _x0; // $v0
	//			long _y0; // $a2
	//			long _z0; // $a1
	//			long _x1; // $v1
	//			long _y1; // $v1
	//			long _z1; // $a0
	//			struct _Vector *_v; // $v1
	//	/* end block 1.2 */
	//	// End offset: 0x800170B0
	//	// End Line: 1775

	//	/* begin block 1.3 */
	//		// Start line: 1809
	//		// Start offset: 0x80017254
	//		// Variables:
	//			short _x0; // $v0
	//			short _y0; // $v1
	//			short _z0; // $a1
	//			short _x1; // $a2
	//			short _y1; // $a3
	//			short _z1; // $t0
	//			struct _SVector *_v; // $s2
	//	/* end block 1.3 */
	//	// End offset: 0x80017254
	//	// End Line: 1809

	//	/* begin block 1.4 */
	//		// Start line: 1813
	//		// Start offset: 0x800172A8
	//		// Variables:
	//			short _x1; // $v0
	//			short _y1; // $v1
	//			short _z1; // $a0
	//	/* end block 1.4 */
	//	// End offset: 0x800172A8
	//	// End Line: 1813

	//	/* begin block 1.5 */
	//		// Start line: 1817
	//		// Start offset: 0x800172A8
	//		// Variables:
	//			short _x0; // $v0
	//			short _y0; // $v0
	//			short _z0; // $v1
	//			short _y1; // $a0
	//			short _z1; // $a1
	//	/* end block 1.5 */
	//	// End offset: 0x800172A8
	//	// End Line: 1817

	//	/* begin block 1.6 */
	//		// Start line: 1824
	//		// Start offset: 0x80017344
	//		// Variables:
	//			short _x0; // $v0
	//			short _y0; // $v1
	//			short _z0; // $a0
	//			short _x1; // $a1
	//			short _y1; // $a2
	//			short _z1; // $a3
	//			struct _SVector *_v; // $a1
	//	/* end block 1.6 */
	//	// End offset: 0x80017344
	//	// End Line: 1824

	//	/* begin block 1.7 */
	//		// Start line: 1838
	//		// Start offset: 0x800174D4
	//		// Variables:
	//			short _x1; // $v0
	//			short _y1; // $v1
	//			short _z1; // $a0
	//	/* end block 1.7 */
	//	// End offset: 0x800174D4
	//	// End Line: 1838

	//	/* begin block 1.8 */
	//		// Start line: 1869
	//		// Start offset: 0x80017604
	//		// Variables:
	//			short _x1; // $v0
	//			short _y1; // $v1
	//			short _z1; // $a0
	//	/* end block 1.8 */
	//	// End offset: 0x8001761C
	//	// End Line: 1869
	///* end block 1 */
	//// End offset: 0x8001761C
	//// End Line: 1871

	///* begin block 2 */
	//	// Start line: 4013
	///* end block 2 */
	//// End Line: 4014
UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ CriticalDampAngle(long dampMode /*$a0*/, short *currentVal /*$s0*/, short target /*$t1*/, short *vel /*$a3*/, short *accl /*stack 16*/, int smooth /*stack 20*/)
void CriticalDampAngle(long dampMode, short *currentVal, short target, short *vel, short *accl, int smooth)
{ // line 1873, offset 0x8001763c
	/* begin block 1 */
		// Start line: 1874
		// Start offset: 0x8001763C
		// Variables:
			short current; // stack offset -16
	/* end block 1 */
	// End offset: 0x80017698
	// End Line: 1889

	/* begin block 2 */
		// Start line: 4301
	/* end block 2 */
	// End Line: 4302
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// short /*$ra*/ CAMERA_CalcZRotation(_Position *target /*$a0*/, _Position *position /*$a1*/)
short CAMERA_CalcZRotation(_Position *target, _Position *position)
{ // line 1894, offset 0x800176dc
	/* begin block 1 */
		// Start line: 1895
		// Start offset: 0x800176DC
		// Variables:
			struct _SVector sv; // stack offset -24
			struct _SVector onPlane; // stack offset -16

		/* begin block 1.1 */
			// Start line: 1895
			// Start offset: 0x800176DC
			// Variables:
				short _x0; // $a2
				short _y0; // $v0
				short _z0; // $v1
				short _x1; // $a1
				short _y1; // $a3
				short _z1; // $t0
				struct _SVector *_v; // $a0
		/* end block 1.1 */
		// End offset: 0x800176DC
		// End Line: 1895
	/* end block 1 */
	// End offset: 0x800176DC
	// End Line: 1895

	/* begin block 2 */
		// Start line: 4353
	/* end block 2 */
	// End Line: 4354
				UNIMPLEMENTED();
	return 0;
}

void CAMERA_CalcRotation(struct _Rotation* rotation, _Position* target, _Position* position)
{
	struct _SVector sv;
	struct _SVector onPlane;
	short _x0;
	short _y0;
	short _z0;
	short _x1;
	short _y1;
	short _z1;
	struct _SVector* _v;

	_x0 = position->x;
	_y0 = position->y;
	_z0 = position->z;

	_x1 = target->x;
	_y1 = target->y;
	_z1 = target->z;

	_v = &sv;
	_v->x = _x0 - _x1;
	_v->y = _y0 - _y1;
	_v->z = _z0 - _z1;

	onPlane.x = _v->x;
	onPlane.z = 0;
	onPlane.y = _v->y;

	rotation->x = -ratan2(onPlane.z, CAMERA_LengthSVector(&onPlane));
	rotation->y = 0;
	rotation->z = ratan2(sv.y, sv.z) + 1024;
}


// autogenerated function stub: 
// void /*$ra*/ CAMERA_CalcFSRotation(struct Camera *camera /*$a0*/, struct _Rotation *rotation /*$s0*/, _Position *target /*$a2*/, _Position *position /*$a3*/)
void CAMERA_CalcFSRotation(struct Camera *camera, struct _Rotation *rotation, _Position *target, _Position *position)
{ // line 1928, offset 0x800177f0
	/* begin block 1 */
		// Start line: 1929
		// Start offset: 0x800177F0
		// Variables:
			struct _SVector sv; // stack offset -32
			struct _SVector onPlane; // stack offset -24
			struct _SVector sv2; // stack offset -16

		/* begin block 1.1 */
			// Start line: 1929
			// Start offset: 0x800177F0
			// Variables:
				short _x0; // $a1
				short _y0; // $v1
				short _z0; // $a0
				short _x1; // $v0
				short _y1; // $a3
				short _z1; // $a2
				struct _SVector *_v; // $v0
		/* end block 1.1 */
		// End offset: 0x800177F0
		// End Line: 1929

		/* begin block 1.2 */
			// Start line: 1929
			// Start offset: 0x800177F0
			// Variables:
				struct _SVector *_v0; // $v0
		/* end block 1.2 */
		// End offset: 0x800177F0
		// End Line: 1929
	/* end block 1 */
	// End offset: 0x800177F0
	// End Line: 1929

	/* begin block 2 */
		// Start line: 4430
	/* end block 2 */
	// End Line: 4431
				UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ CAMERA_Relocate(struct Camera *camera /*$a0*/, struct _SVector *offset /*$a1*/, int streamSignalFlag /*$a2*/)
void CAMERA_Relocate(struct Camera *camera, struct _SVector *offset, int streamSignalFlag)
{ // line 1948, offset 0x8001789c
	/* begin block 1 */
		// Start line: 4474
	/* end block 1 */
	// End Line: 4475

	/* begin block 2 */
		// Start line: 4479
	/* end block 2 */
	// End Line: 4480
	UNIMPLEMENTED();
}


// autogenerated function stub: 
// struct _TFace * /*$ra*/ CAMERA_SphereToSphereWithLines(struct Camera *camera /*$s6*/, struct CameraCollisionInfo *colInfo /*stack 4*/, int secondcheck_flag /*stack 8*/)
struct _TFace * CAMERA_SphereToSphereWithLines(struct Camera *camera, struct CameraCollisionInfo *colInfo, int secondcheck_flag)
{ // line 2017, offset 0x800179e8
	///* begin block 1 */
	//	// Start line: 2018
	//	// Start offset: 0x800179E8
	//	// Variables:
	//		long minLength; // stack offset -68
	//		struct _SVector sv; // stack offset -344
	//		struct _SVector startPt[5]; // stack offset -336
	//		struct _SVector endPt[5]; // stack offset -296
	//		struct _SVector startLine; // stack offset -256
	//		struct _Vector adjStartLine; // stack offset -248
	//		struct _SVector endLine; // stack offset -232
	//		struct _Vector adjEndLine; // stack offset -224
	//		struct _Vector CamLineNormalized; // stack offset -208
	//		struct _Rotation rotation; // stack offset -192
	//		MATRIX matrix; // stack offset -184
	//		struct _TFace *result; // stack offset -64
	//		long i; // stack offset -60
	//		long init; // stack offset -56
	//		struct Level *level; // stack offset -52
	//		struct _Instance *focusInstance; // $v0
	//		struct _Vector ACE_vect; // stack offset -152
	//		struct _LCollideInfo lcol; // stack offset -136
	//		int ACE_force; // $s2
	//		int in_warpRoom; // stack offset -48

	//	/* begin block 1.1 */
	//		// Start line: 2133
	//		// Start offset: 0x80017CF4
	//		// Variables:
	//			short _x0; // $v1
	//			short _y0; // $a0
	//			short _z0; // $v0
	//			short _x1; // $a1
	//			short _y1; // $a2
	//			short _z1; // $a3
	//			struct _SVector *_v; // $v1
	//			_Position *_v0; // $v0
	//	/* end block 1.1 */
	//	// End offset: 0x80017CF4
	//	// End Line: 2133

	//	/* begin block 1.2 */
	//		// Start line: 2133
	//		// Start offset: 0x80017CF4
	//		// Variables:
	//			short _x0; // $v1
	//			short _y0; // $a0
	//			short _z0; // $v0
	//			short _x1; // $a1
	//			short _y1; // $a2
	//			short _z1; // $a3
	//			struct _SVector *_v; // $v1
	//			_Position *_v0; // $v0
	//	/* end block 1.2 */
	//	// End offset: 0x80017CF4
	//	// End Line: 2133

	//	/* begin block 1.3 */
	//		// Start line: 2146
	//		// Start offset: 0x80017E00
	//		// Variables:
	//			short _x0; // $v1
	//			short _y0; // $a0
	//			short _z0; // $v0
	//			short _x1; // $a1
	//			short _y1; // $a2
	//			short _z1; // $a3
	//			struct _SVector *_v; // $s3
	//			_Position *_v0; // $v0
	//	/* end block 1.3 */
	//	// End offset: 0x80017E00
	//	// End Line: 2146

	//	/* begin block 1.4 */
	//		// Start line: 2146
	//		// Start offset: 0x80017E00
	//		// Variables:
	//			short _x0; // $v1
	//			short _y0; // $a1
	//			short _z0; // $v0
	//			short _x1; // $a2
	//			short _y1; // $a3
	//			short _z1; // $t0
	//			struct _SVector *_v; // $v1
	//			_Position *_v0; // $v0
	//	/* end block 1.4 */
	//	// End offset: 0x80017E00
	//	// End Line: 2146

	//	/* begin block 1.5 */
	//		// Start line: 2146
	//		// Start offset: 0x80017E00
	//		// Variables:
	//			short _x0; // $v1
	//			short _y0; // $a1
	//			short _z0; // $a2
	//			short _x1; // $a3
	//			short _y1; // $t0
	//			short _z1; // $t1
	//			struct _SVector *_v; // $v0
	//			_Position *_v1; // $v0
	//	/* end block 1.5 */
	//	// End offset: 0x80017E00
	//	// End Line: 2146

	//	/* begin block 1.6 */
	//		// Start line: 2146
	//		// Start offset: 0x80017E00
	//		// Variables:
	//			short _x0; // $v1
	//			short _y0; // $a1
	//			short _z0; // $a2
	//			short _x1; // $a3
	//			short _y1; // $t0
	//			short _z1; // $t1
	//			struct _SVector *_v; // $v0
	//			_Position *_v1; // $v0
	//	/* end block 1.6 */
	//	// End offset: 0x80017E00
	//	// End Line: 2146

	//	/* begin block 1.7 */
	//		// Start line: 2146
	//		// Start offset: 0x80017E00
	//		// Variables:
	//			short _x0; // $v1
	//			short _y0; // $a2
	//			short _z0; // $v0
	//			short _x1; // $a3
	//			short _y1; // $t0
	//			short _z1; // $t1
	//			struct _SVector *_v; // $v1
	//			_Position *_v0; // $v0
	//	/* end block 1.7 */
	//	// End offset: 0x80017E00
	//	// End Line: 2146

	//	/* begin block 1.8 */
	//		// Start line: 2146
	//		// Start offset: 0x80017E00
	//		// Variables:
	//			short _x0; // $v1
	//			short _y0; // $a3
	//			short _z0; // $v0
	//			short _x1; // $t0
	//			short _y1; // $t1
	//			short _z1; // $t2
	//			struct _SVector *_v; // $v1
	//			_Position *_v0; // $v0
	//	/* end block 1.8 */
	//	// End offset: 0x80017E00
	//	// End Line: 2146

	//	/* begin block 1.9 */
	//		// Start line: 2146
	//		// Start offset: 0x80017E00
	//		// Variables:
	//			short _x0; // $v0
	//			short _y0; // $v1
	//			short _z0; // $a3
	//			short _x1; // $t0
	//			short _y1; // $t2
	//			short _z1; // $t3
	//			struct _SVector *_v; // $v0
	//			struct _SVector *_v0; // $a3
	//			struct _SVector *_v1; // $t1
	//	/* end block 1.9 */
	//	// End offset: 0x80017E00
	//	// End Line: 2146

	//	/* begin block 1.10 */
	//		// Start line: 2146
	//		// Start offset: 0x80017E00
	//		// Variables:
	//			short _x0; // $v0
	//			short _y0; // $v1
	//			short _z0; // $a3
	//			short _x1; // $t0
	//			short _y1; // $t2
	//			short _z1; // $t1
	//			struct _SVector *_v; // $v0
	//	/* end block 1.10 */
	//	// End offset: 0x80017E00
	//	// End Line: 2146

	//	/* begin block 1.11 */
	//		// Start line: 2146
	//		// Start offset: 0x80017E00
	//		// Variables:
	//			short _x1; // $v1
	//			short _y1; // $a0
	//			short _z1; // $v0
	//			_Position *_v1; // $v0
	//	/* end block 1.11 */
	//	// End offset: 0x80017E00
	//	// End Line: 2146

	//	/* begin block 1.12 */
	//		// Start line: 2146
	//		// Start offset: 0x80017E00
	//		// Variables:
	//			short _x1; // $v1
	//			short _y1; // $a0
	//			short _z1; // $a2
	//			_Position *_v1; // $v0
	//	/* end block 1.12 */
	//	// End offset: 0x80017E00
	//	// End Line: 2146

	//	/* begin block 1.13 */
	//		// Start line: 2232
	//		// Start offset: 0x80018148
	//		// Variables:
	//			int clut; // $fp
	//			short backface_flag; // stack offset -72
	//			struct _PCollideInfo pCollideInfo; // stack offset -120

	//		/* begin block 1.13.1 */
	//			// Start line: 2257
	//			// Start offset: 0x800181A8
	//			// Variables:
	//				int n; // $s2

	//			/* begin block 1.13.1.1 */
	//				// Start line: 2262
	//				// Start offset: 0x800181B4
	//				// Variables:
	//					struct Level *thislevel; // $s1
	//			/* end block 1.13.1.1 */
	//			// End offset: 0x8001823C
	//			// End Line: 2279
	//		/* end block 1.13.1 */
	//		// End offset: 0x8001824C
	//		// End Line: 2280

	//		/* begin block 1.13.2 */
	//			// Start line: 2305
	//			// Start offset: 0x8001828C
	//			// Variables:
	//				short _x0; // $v0
	//				short _y0; // $v1
	//				short _z0; // $a0
	//				short _x1; // $a1
	//				short _y1; // $a2
	//				short _z1; // $a3
	//				struct _SVector *_v; // stack offset -44
	//		/* end block 1.13.2 */
	//		// End offset: 0x8001828C
	//		// End Line: 2305

	//		/* begin block 1.13.3 */
	//			// Start line: 2336
	//			// Start offset: 0x800183E0
	//			// Variables:
	//				short _x0; // $v0
	//				short _y0; // $v1
	//				short _z0; // $a0
	//				short _x1; // $a1
	//				short _y1; // $a2
	//				short _z1; // $a3
	//		/* end block 1.13.3 */
	//		// End offset: 0x800183E0
	//		// End Line: 2336
	//	/* end block 1.13 */
	//	// End offset: 0x80018460
	//	// End Line: 2361
	///* end block 1 */
	//// End offset: 0x800184F4
	//// End Line: 2380

	///* begin block 2 */
	//	// Start line: 4612
	///* end block 2 */
	//// End Line: 4613
UNIMPLEMENTED();
	return null;
}

long CAMERA_CalcTilt(struct _Normal* normal, short zRot)//Matching - 99.66%
{
	MATRIX matrix;
	VECTOR newNormal;

	MATH3D_SetUnityMatrix(&matrix);

	RotMatrixZ(-zRot, &matrix);

	ApplyMatrix(&matrix, (SVECTOR*)normal, &newNormal);

	return -(short)ratan2(newNormal.vy, newNormal.vz);
}


// autogenerated function stub: 
// void /*$ra*/ CAMERA_SetLookFocusAndBase(struct _Instance *focusInstance /*$a0*/, _Position *focusPoint /*$a1*/)
void CAMERA_SetLookFocusAndBase(struct _Instance *focusInstance, _Position *focusPoint)
{ // line 2399, offset 0x80018598
	/* begin block 1 */
		// Start line: 2400
		// Start offset: 0x80018598
		// Variables:
			_Position lookFocus; // stack offset -8
	/* end block 1 */
	// End offset: 0x80018598
	// End Line: 2400

	/* begin block 2 */
		// Start line: 5873
	/* end block 2 */
	// End Line: 5874

	/* begin block 3 */
		// Start line: 5878
	/* end block 3 */
	// End Line: 5879
			UNIMPLEMENTED();
}

void CAMERA_SetLookFocusAndDistance(struct Camera* camera, VECTOR* focuspoint, int distance)
{ 
	camera->targetFocusPoint.x = focuspoint->vx;
	camera->targetFocusPoint.y = focuspoint->vy;
	camera->targetFocusPoint.z = focuspoint->vz;

	Camera_lookDist = distance;
}


// autogenerated function stub: 
// void /*$ra*/ CAMERA_LookProcess(struct Camera *camera /*$s2*/)
void CAMERA_LookProcess(struct Camera *camera)
{ // line 2420, offset 0x80018608
	///* begin block 1 */
	//	// Start line: 2421
	//	// Start offset: 0x80018608
	//	// Variables:
	//		struct _Instance *focusInstance; // $s1
	//		int smooth; // $t0
	//		int distance; // $a3
	//		long dampMode; // $a0

	//	/* begin block 1.1 */
	//		// Start line: 2466
	//		// Start offset: 0x800186F8
	//		// Variables:
	//			short _x1; // $v1
	//			short _y1; // $a0
	//			short _z1; // $a1
	//			_Position *_v0; // $v0
	//			_Position *_v1; // $v0
	//	/* end block 1.1 */
	//	// End offset: 0x800186F8
	//	// End Line: 2466

	//	/* begin block 1.2 */
	//		// Start line: 2487
	//		// Start offset: 0x80018760
	//		// Variables:
	//			short _x1; // $v0
	//			short _y1; // $v1
	//			short _z1; // $a0
	//	/* end block 1.2 */
	//	// End offset: 0x80018760
	//	// End Line: 2487

	//	/* begin block 1.3 */
	//		// Start line: 2487
	//		// Start offset: 0x80018760
	//		// Variables:
	//			short _x1; // $v0
	//			short _y1; // $v1
	//			short _z1; // $a1
	//			struct _Rotation *_v0; // $v0
	//	/* end block 1.3 */
	//	// End offset: 0x80018760
	//	// End Line: 2487

	//	/* begin block 1.4 */
	//		// Start line: 2487
	//		// Start offset: 0x80018760
	//		// Variables:
	//			short _x1; // $v1
	//			short _y1; // $a0
	//			struct _Rotation *_v0; // $v0
	//	/* end block 1.4 */
	//	// End offset: 0x80018760
	//	// End Line: 2487
	///* end block 1 */
	//// End offset: 0x80018760
	//// End Line: 2493

	///* begin block 2 */
	//	// Start line: 5917
	///* end block 2 */
	//// End Line: 5918

	///* begin block 3 */
	//	// Start line: 5921
	///* end block 3 */
	//// End Line: 5922
	UNIMPLEMENTED();
}

void CAMERA_Normalize(struct _SVector *svector)
{
	long len;

	len = CAMERA_LengthSVector(svector);

	if (len != 0)
	{
		svector->x = (svector->x << 12) / len;
		svector->y = (svector->y << 12) / len;
		svector->z = (svector->z << 12) / len;
	}
}

void CAMERA_HandleTransitions(struct Camera *camera)
{
	if (camera->rotState == 3)
	{
		camera->targetFocusRotation.z = camera->signalRot.z;

		camera->collisionTargetFocusRotation.z = camera->signalRot.z;

		if (camera->forced_movement != 1 || (camera->lock & 0x4))
		{
			if (CAMERA_AngleDifference(camera->targetFocusRotation.z, camera->focusRotation.z) < 4)
			{
				camera->rotState = 0;
				camera->focusRotVel.z = 0;
				camera->focusRotAccl.z = 0;
			}
		}
		else
		{
			camera->rotState = 0;
			camera->focusRotVel.z = 0;
			camera->focusRotAccl.z = 0;
		}
	}

	if (camera->tiltState == 3)
	{
		camera->targetFocusRotation.x = camera->signalRot.x;

		if (camera->forced_movement != camera->tiltState || (camera->lock & 0x2))
		{
			if (CAMERA_AngleDifference(camera->focusRotation.x, camera->signalRot.x) < 4)
			{
				camera->tiltState = 0;
				camera->focusRotVel.x = 0;
				camera->focusRotAccl.x = 0;
			}
		}
		else
		{
			camera->tiltState = 0;
			camera->focusRotVel.x = 0;
			camera->focusRotAccl.x = 0;
		}
	}

	if (camera->distanceState == 3)
	{
		if (camera->forced_movement != 2 || (camera->lock & 0x1))
		{
			if (camera->targetFocusDistance - camera->signalFocusDistance >= 0)
			{
				if (camera->targetFocusDistance - camera->signalFocusDistance < 4)
				{
					camera->posState = 0;

					camera->focusDistanceVel = 0;

					camera->focusDistanceAccl = 0;

					camera->targetFocusDistance = camera->signalFocusDistance;
				}
				else
				{
					camera->targetFocusDistance = camera->signalFocusDistance;
				}
			}
			else
			{
				if (camera->signalFocusDistance - camera->targetFocusDistance < 4)
				{
					camera->distanceState = 0;
				}
				else
				{
					camera->targetFocusDistance = camera->signalFocusDistance;
				}
			}
		}
		else
		{
			camera->distanceState = 0;

			camera->focusDistanceVel = 0;

			camera->focusDistanceAccl = 0;

			camera->targetFocusDistance = camera->signalFocusDistance;
		}
	}

	if (camera->posState == 3)
	{
		if (camera->mode != 5 || (camera->flags & 0x1000))
		{
			camera->posState = 0;
		}
	}
}


// autogenerated function stub: 
// void /*$ra*/ CAMERA_CalcFocusOffset(struct _SVector *offset /*$a2*/, struct Camera *camera /*$a1*/)
void CAMERA_CalcFocusOffset(struct _SVector *offset, struct Camera *camera)
{ // line 2673, offset 0x80018a88
	/* begin block 1 */
		// Start line: 2674
		// Start offset: 0x80018A88
		// Variables:
			struct _Vector adjustedOffset; // stack offset -24
			struct _SVector temp; // stack offset -8
			struct _Instance *focusInstance; // $a0

		/* begin block 1.1 */
			// Start line: 2698
			// Start offset: 0x80018AC8
			// Variables:
				short _x1; // $v0
				short _y1; // $v1
				short _z1; // $a0
		/* end block 1.1 */
		// End offset: 0x80018AC8
		// End Line: 2698
	/* end block 1 */
	// End offset: 0x80018AC8
	// End Line: 2698

	/* begin block 2 */
		// Start line: 6474
	/* end block 2 */
	// End Line: 6475
				UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ CAMERA_CalcFocusOffsetForSwim(struct _SVector *offset /*$s0*/, struct Camera *camera /*$a1*/)
void CAMERA_CalcFocusOffsetForSwim(struct _SVector *offset, struct Camera *camera)
{ // line 2703, offset 0x80018b3c
	/* begin block 1 */
		// Start line: 2704
		// Start offset: 0x80018B3C
		// Variables:
			struct _Vector adjustedOffset; // stack offset -32
			struct _SVector temp; // stack offset -16
			struct _Instance *focusInstance; // $v1

		/* begin block 1.1 */
			// Start line: 2704
			// Start offset: 0x80018B3C
			// Variables:
				short _x1; // $v1
				short _y1; // $a0
				short _z1; // $v0
				struct _Vector *_v1; // $v0
		/* end block 1.1 */
		// End offset: 0x80018B3C
		// End Line: 2704
	/* end block 1 */
	// End offset: 0x80018B3C
	// End Line: 2704

	/* begin block 2 */
		// Start line: 6542
	/* end block 2 */
	// End Line: 6543
				UNIMPLEMENTED();
}


// autogenerated function stub: 
// short /*$ra*/ CAMERA_CalcIntersectAngle(struct _SVector *linept /*$s0*/, struct _SVector *vertex0 /*$a1*/, struct _SVector *vertex1 /*$a2*/, short *high /*$s2*/, short *low /*stack 16*/)
short CAMERA_CalcIntersectAngle(struct _SVector *linept, struct _SVector *vertex0, struct _SVector *vertex1, short *high, short *low)
{ // line 2727, offset 0x80018ba8
	/* begin block 1 */
		// Start line: 2728
		// Start offset: 0x80018BA8
		// Variables:
			struct _SVector point; // stack offset -24
			short zrot; // $a0
			long camera_plane_d; // $v0
	/* end block 1 */
	// End offset: 0x80018C80
	// End Line: 2747

	/* begin block 2 */
		// Start line: 6608
	/* end block 2 */
	// End Line: 6609

	/* begin block 3 */
		// Start line: 6613
	/* end block 3 */
	// End Line: 6614
			UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// short /*$ra*/ CAMERA_GetLineAngle(struct Camera *camera /*$a0*/, struct CameraCollisionInfo *colInfo /*$a1*/, struct _SVector *linept /*$a2*/, int line /*$s5*/)
short CAMERA_GetLineAngle(struct Camera *camera, struct CameraCollisionInfo *colInfo, struct _SVector *linept, int line)
{ // line 2749, offset 0x80018c98
	/* begin block 1 */
		// Start line: 2750
		// Start offset: 0x80018C98
		// Variables:
			struct _Terrain *terrain; // $t1
			struct _SVector *vertex0; // $s1
			struct _SVector *vertex1; // $s0
			struct _SVector *vertex2; // $s3
			struct _SVector new_linept; // stack offset -48
			short high; // stack offset -40
			short low; // stack offset -38
	/* end block 1 */
	// End offset: 0x80018E3C
	// End Line: 2779

	/* begin block 2 */
		// Start line: 6675
	/* end block 2 */
	// End Line: 6676
			UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// long /*$ra*/ CAMERA_ACForcedMovement(struct Camera *camera /*$s1*/, struct CameraCollisionInfo *colInfo /*$s0*/)
long CAMERA_ACForcedMovement(struct Camera *camera, struct CameraCollisionInfo *colInfo)
{ // line 2793, offset 0x80018e60
	/* begin block 1 */
		// Start line: 2794
		// Start offset: 0x80018E60
		// Variables:
			long dp; // $v0
			struct _Normal normal; // stack offset -32
			struct _SVector sv; // stack offset -24

		/* begin block 1.1 */
			// Start line: 2794
			// Start offset: 0x80018E60
			// Variables:
				short _x0; // $a1
				short _y0; // $a2
				short _z0; // $v0
				short _x1; // $a3
				short _y1; // $t0
				short _z1; // $v1
				struct _SVector *_v; // $a0
				_Position *_v0; // $v0
				_Position *_v1; // $v1
		/* end block 1.1 */
		// End offset: 0x80018E60
		// End Line: 2794
	/* end block 1 */
	// End offset: 0x80018F18
	// End Line: 2832

	/* begin block 2 */
		// Start line: 6883
	/* end block 2 */
	// End Line: 6884
				UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// void /*$ra*/ CAMERA_update_dist_debounced(struct Camera *camera /*$a0*/, short dist /*$a2*/)
void CAMERA_update_dist_debounced(struct Camera *camera, short dist)
{ // line 2835, offset 0x80018f30
	/* begin block 1 */
		// Start line: 6974
	/* end block 1 */
	// End Line: 6975

	/* begin block 2 */
		// Start line: 6975
	/* end block 2 */
	// End Line: 6976
	UNIMPLEMENTED();
}


// autogenerated function stub: 
// short /*$ra*/ CAMERA_dampgetline(short angle /*$a0*/)
short CAMERA_dampgetline(short angle)
{ // line 2847, offset 0x80018fa0
	/* begin block 1 */
		// Start line: 2848
		// Start offset: 0x80018FA0
		// Variables:
			static short target_angle; // offset 0x50
			static short angle_vel; // offset 0x52
			static short angle_accl; // offset 0x54
	/* end block 1 */
	// End offset: 0x80019038
	// End Line: 2865

	/* begin block 2 */
		// Start line: 6999
	/* end block 2 */
	// End Line: 7000
			UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// long /*$ra*/ CAMERA_ACNoForcedMovement(struct Camera *camera /*$s0*/, struct CameraCollisionInfo *colInfo /*$s1*/)
long CAMERA_ACNoForcedMovement(struct Camera *camera, struct CameraCollisionInfo *colInfo)
{ // line 2873, offset 0x8001904c
	/* begin block 1 */
		// Start line: 2874
		// Start offset: 0x8001904C
		// Variables:
			long hit; // $s2
			short playerSamePos; // $s3
			short angle; // $a0

		/* begin block 1.1 */
			// Start line: 2900
			// Start offset: 0x800190C4
			// Variables:
				int n; // $a0
				int flag; // $t1
				short dist; // $a1
		/* end block 1.1 */
		// End offset: 0x80019278
		// End Line: 2956
	/* end block 1 */
	// End offset: 0x80019534
	// End Line: 3124

	/* begin block 2 */
		// Start line: 7059
	/* end block 2 */
	// End Line: 7060
				UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// long /*$ra*/ CAMERA_AbsoluteCollision(struct Camera *camera /*$a0*/, struct CameraCollisionInfo *colInfo /*$a1*/)
long CAMERA_AbsoluteCollision(struct Camera *camera, struct CameraCollisionInfo *colInfo)
{ // line 3130, offset 0x80019550
	/* begin block 1 */
		// Start line: 3131
		// Start offset: 0x80019550
		// Variables:
			long hit; // $a3
	/* end block 1 */
	// End offset: 0x80019668
	// End Line: 3200

	/* begin block 2 */
		// Start line: 7592
	/* end block 2 */
	// End Line: 7593
			UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// short /*$ra*/ CAMERA_update_z_damped(struct Camera *camera /*$a0*/, short current /*$a3*/, short target /*$t0*/)
short CAMERA_update_z_damped(struct Camera *camera, short current, short target)
{ // line 3205, offset 0x80019678
	/* begin block 1 */
		// Start line: 3206
		// Start offset: 0x80019678
		// Variables:
			static short upvel; // offset 0x56
			static short upaccl; // offset 0x58
			static short upmaxVel; // offset 0x5a
			short current_tmp; // stack offset -16
	/* end block 1 */
	// End offset: 0x800198D8
	// End Line: 3250

	/* begin block 2 */
		// Start line: 7752
	/* end block 2 */
	// End Line: 7753
			UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// void /*$ra*/ CAMERA_CombatCamDist(struct Camera *camera /*$s0*/)
void CAMERA_CombatCamDist(struct Camera *camera)
{ // line 3310, offset 0x800198e8
	/* begin block 1 */
		// Start line: 3311
		// Start offset: 0x800198E8
		// Variables:
			DVECTOR xy; // stack offset -48
			DVECTOR xy2; // stack offset -40
			struct _SVector position; // stack offset -32
			long z; // stack offset -24
			struct _Instance *instance; // $s1
	/* end block 1 */
	// End offset: 0x80019B98
	// End Line: 3392

	/* begin block 2 */
		// Start line: 7966
	/* end block 2 */
	// End Line: 7967
			UNIMPLEMENTED();
}

void CAMERA_GenericCameraProcess(struct Camera* camera)
{
	struct _Instance* focusInstance;
	struct _Position targetCamPos;
	short angle;
	struct _Rotation test_rot;
	struct _Instance* warpInstance;
	int tmp;
	int mod;
	int dist;
	short _x1;
	short _y1;
	short _z1;
	struct _Position* _v0;
	struct _Position* _v1;
	struct _Position target;

	focusInstance = camera->focusInstance;

	if ((camera->flags & 0x1) || (camera->instance_mode & 0x4000000))
	{
		camera->rotationVel.z = 64;
	}

	if (!(camera->instance_mode & 0x2000000))
	{
		combat_cam_weight = 2048;
	}

	CAMERA_SetMaxVel(camera);

	CAMERA_SetFocus(camera, &camera->targetFocusPoint);

	if ((camera->flags & 0x10000) || (camera->instance_mode & 0x4000000))
	{
		CAMERA_FollowPlayerTilt(camera, focusInstance);
	}
	else
	{
		CAMERA_UpdateFocusRotationX(camera, focusInstance);

		if (camera->mode == 13 && camera->instance_xyvel > 0 && !(camera->instance_mode & 0x82000400) && camera->always_rotate_flag == 0 && camera->rotState != 3 && !(camera->instance_mode & 0x2000) && gameTrackerX.cheatMode != 1)
		{
			CAMERA_CalcRotation(&test_rot, &camera->targetFocusPoint, &camera->core.position);

			angle = CAMERA_SignedAngleDifference(test_rot.z, camera->focusRotation.z);

			if ((camera->instance_mode & 0x2))
			{
				angle >>= 1;
			}
			else
			{
				angle = (angle * 3) >> 2;
			}
			
			camera->targetFocusRotation.z = camera->focusRotation.z + angle;
		}
	}

	if (camera->instance_mode < 0)
	{
		warpInstance = RAZIEL_QueryEngagedInstance(14);

		if (warpInstance != NULL)
		{
			camera->tfaceTilt = 3988;

			camera->rotationVel.z = 64;

			camera->smooth = 8;

			camera->always_rotate_flag = 1;

			camera->forced_movement = 0;

			tmp = (((((warpInstance->rotation.z & 0xFFF) - 1025) < 0x7FF) ^ 1)) << 11;

			camera->collisionTargetFocusRotation.z = tmp;

			camera->targetFocusRotation.z = tmp;
		}
	}
	else
	{
		if ((camera->flags & 0x2000) || (camera->instance_mode & 0x20000000))
		{
			if (!(camera->instance_mode & 0x2000000))
			{
				camera->rotationVel.z = 64;

				CAMERA_FollowGoBehindPlayer(camera);
			}
		}
		else
		{
			if ((camera->flags & 0x10000) || (camera->instance_mode & 0x4000000))
			{
				CAMERA_FollowGoBehindPlayer(camera);
			}
			else
			{
				if ((camera->instance_mode & 0x400) && !(camera->prev_instance_mode & 0x400))
				{
					tmp = camera->core.rotation.z < 0 ? camera->core.rotation.z + 1023 : camera->core.rotation.z;
					tmp >>= 10;
					tmp <<= 10;

					mod = camera->core.rotation.z - tmp;

					if (mod >= 513)
					{
						mod = 1024 - mod;
					}
					else
					{
						mod = -mod;
					}

					if (mod < 0)
					{
						tmp = mod;
						tmp = -tmp;
					}
					else
					{
						tmp = mod;
					}

					if (tmp >= 129)
					{
						camera->targetFocusRotation.z = (mod + camera->core.rotation.z) & 0xFFF;
					}
				}

				CAMERA_FollowGoBehindPlayerWithTimer(camera);
			}
		}
	}

	if (!(camera->flags & 0x1800))
	{
		if ((camera->instance_mode & 0x2000000))
		{
			CAMERA_CombatCamDist(camera);
		}

		combat_cam_distance = camera->targetFocusDistance;

		CAMERA_CalcPosition(&targetCamPos, &camera->focusPoint, &camera->focusRotation, combat_cam_distance);
	
		camera->data.Follow.hit = CAMERA_DoCameraCollision2(camera, &targetCamPos, 0);
	}
	
	if (camera->instance_mode < 0)
	{
		camera->collisionTargetFocusDistance = 2000;
	}

	CAMERA_UpdateFocusDistance(camera);

	CAMERA_UpdateFocusTilt(camera);

	CAMERA_UpdateFocusRotate(camera);


	if ((camera->flags & 0x1800))
	{
		_v0 = &camera->targetFocusPoint;
		_v1 = &camera->focusPoint;

		_x1 = _v0->x;
		_y1 = _v0->y;
		_z1 = _v0->z;

		_v1->x = _x1;
		_v1->y = _y1;
		_v1->z = _z1;

		camera->focusDistance  = camera->targetFocusDistance;
	
		if ((camera->flags & 0x1000))
		{
			CAMERA_SetZRotation(camera, camera->teleportZRot);
		}
	}
	else
	{
		target.x = camera->targetFocusPoint.x;
		target.y = camera->targetFocusPoint.y;
		target.z = camera->targetFocusPoint.z;

		if (!(camera->flags & 0x10000))
		{
			target.z = camera->focusPoint.z;
		}

		CriticalDampPosition(1, &camera->focusPoint, &target, &camera->focusPointVel, &camera->focusPointAccl, camera->maxVel);

		if (!(camera->flags & 0x10000))
		{
			camera->focusPoint.z = CAMERA_update_z_damped(camera, camera->focusPoint.z, camera->targetFocusPoint.z);
		}
	}

	CAMERA_CalcFollowPosition(camera, &camera->focusRotation);

	CAMERA_CalculateLead(camera);

	CAMERA_UpdateFocusRoll(camera);
}


// autogenerated function stub: 
// void /*$ra*/ CAMERA_CinematicProcess(struct Camera *camera /*$s2*/)
void CAMERA_CinematicProcess(struct Camera *camera)
{ // line 3608, offset 0x8001a028
	///* begin block 1 */
	//	// Start line: 3609
	//	// Start offset: 0x8001A028
	//	// Variables:
	//		struct _SVector *camPos; // $s0
	//		struct _SVector *camTarget; // $s3
	//		struct MultiSpline *posSpline; // $s4
	//		struct MultiSpline *targetSpline; // $s1

	//	/* begin block 1.1 */
	//		// Start line: 3632
	//		// Start offset: 0x8001A0A0
	//		// Variables:
	//			short _x1; // $v0
	//			short _y1; // $v1
	//			short _z1; // $a0
	//	/* end block 1.1 */
	//	// End offset: 0x8001A0A0
	//	// End Line: 3632

	//	/* begin block 1.2 */
	//		// Start line: 3636
	//		// Start offset: 0x8001A0BC
	//		// Variables:
	//			short _x1; // $v1
	//			short _y1; // $a0
	//			short _z1; // $v0
	//			struct _SVector *_v1; // $v0
	//	/* end block 1.2 */
	//	// End offset: 0x8001A0D4
	//	// End Line: 3636

	//	/* begin block 1.3 */
	//		// Start line: 3641
	//		// Start offset: 0x8001A0E4
	//		// Variables:
	//			short _x1; // $v0
	//			short _y1; // $v1
	//			short _z1; // $a0
	//			struct _SVector *_v0; // $v0
	//	/* end block 1.3 */
	//	// End offset: 0x8001A0E4
	//	// End Line: 3641

	//	/* begin block 1.4 */
	//		// Start line: 3649
	//		// Start offset: 0x8001A12C
	//		// Variables:
	//			short _x1; // $v0
	//			short _y1; // $v1
	//			short _z1; // $a2
	//			_Position *_v0; // $v0
	//	/* end block 1.4 */
	//	// End offset: 0x8001A12C
	//	// End Line: 3649

	//	/* begin block 1.5 */
	//		// Start line: 3662
	//		// Start offset: 0x8001A18C
	//		// Variables:
	//			short _x1; // $v0
	//			short _y1; // $v1
	//			short _z1; // $a0
	//			_Position *_v0; // $v0
	//	/* end block 1.5 */
	//	// End offset: 0x8001A18C
	//	// End Line: 3662

	//	/* begin block 1.6 */
	//		// Start line: 3710
	//		// Start offset: 0x8001A3E0
	//	/* end block 1.6 */
	//	// End offset: 0x8001A4DC
	//	// End Line: 3727

	//	/* begin block 1.7 */
	//		// Start line: 3730
	//		// Start offset: 0x8001A4DC
	//		// Variables:
	//			short _x1; // $v0
	//			short _y1; // $v1
	//			short _z1; // $a0
	//			struct _Rotation *_v0; // $v0
	//	/* end block 1.7 */
	//	// End offset: 0x8001A4DC
	//	// End Line: 3730
	///* end block 1 */
	//// End offset: 0x8001A4DC
	//// End Line: 3730

	///* begin block 2 */
	//	// Start line: 8584
	///* end block 2 */
	//// End Line: 8585
	UNIMPLEMENTED();
}


// autogenerated function stub: 
// int /*$ra*/ CAMERA_GetDistSq(struct _SVector *point1 /*$a0*/, struct _SVector *point2 /*$a1*/)
int CAMERA_GetDistSq(struct _SVector *point1, struct _SVector *point2)
{ // line 3744, offset 0x8001a544
	/* begin block 1 */
		// Start line: 3745
		// Start offset: 0x8001A544
		// Variables:
			struct _Vector d; // stack offset -16
	/* end block 1 */
	// End offset: 0x8001A544
	// End Line: 3745

	/* begin block 2 */
		// Start line: 8869
	/* end block 2 */
	// End Line: 8870

	/* begin block 3 */
		// Start line: 8873
	/* end block 3 */
	// End Line: 8874
			UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// void /*$ra*/ CAMERA_NearestPointOnLineVec(struct _SVector *linePoint /*$s2*/, struct _SVector *start /*$s1*/, struct _SVector *line /*$s0*/, _Position *point /*$a3*/)
void CAMERA_NearestPointOnLineVec(struct _SVector *linePoint, struct _SVector *start, struct _SVector *line, _Position *point)
{ // line 3759, offset 0x8001a5c0
	/* begin block 1 */
		// Start line: 3760
		// Start offset: 0x8001A5C0
		// Variables:
			//MATRIX nmat; // stack offset -64
			struct _Vector dpv; // stack offset -32
			long t; // $a0
	/* end block 1 */
	// End offset: 0x8001A674
	// End Line: 3778

	/* begin block 2 */
		// Start line: 8903
	/* end block 2 */
	// End Line: 8904
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// int /*$ra*/ CAMERA_CheckPoint(int linePoint /*$a0*/, int linept1 /*$a1*/, int linept2 /*$a2*/)
int CAMERA_CheckPoint(int linePoint, int linept1, int linept2)
{ // line 3784, offset 0x8001a6ec
	/* begin block 1 */
		// Start line: 8966
	/* end block 1 */
	// End Line: 8967

	/* begin block 2 */
		// Start line: 8967
	/* end block 2 */
	// End Line: 8968
	UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ CAMERA_CheckIfPointOnLine(struct _SVector *linePoint /*$s0*/, struct _SVector *linept1 /*$s1*/, struct _SVector *linept2 /*$s2*/)
int CAMERA_CheckIfPointOnLine(struct _SVector *linePoint, struct _SVector *linept1, struct _SVector *linept2)
{ // line 3790, offset 0x8001a730
	/* begin block 1 */
		// Start line: 8978
	/* end block 1 */
	// End Line: 8979
	UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ CAMERA_FindLinePoint(_Position *point /*$s0*/, struct _SVector *linept1 /*$s5*/, struct _SVector *linept2 /*$s6*/, int target_dist_sq /*$s1*/, struct _SVector *results /*stack 16*/)
int CAMERA_FindLinePoint(_Position *point, struct _SVector *linept1, struct _SVector *linept2, int target_dist_sq, struct _SVector *results)
{ // line 3798, offset 0x8001a7c0
	///* begin block 1 */
	//	// Start line: 3799
	//	// Start offset: 0x8001A7C0
	//	// Variables:
	//		struct _SVector outPoint; // stack offset -56
	//		struct _SVector line; // stack offset -48
	//		int calc; // $s1
	//		int hits; // $s4

	//	/* begin block 1.1 */
	//		// Start line: 3799
	//		// Start offset: 0x8001A7C0
	//		// Variables:
	//			short _x0; // $v0
	//			short _y0; // $v1
	//			short _z0; // $a3
	//			short _x1; // $t0
	//			short _y1; // $t1
	//			short _z1; // $t2
	//			struct _SVector *_v; // $s2
	//	/* end block 1.1 */
	//	// End offset: 0x8001A7C0
	//	// End Line: 3799

	//	/* begin block 1.2 */
	//		// Start line: 3813
	//		// Start offset: 0x8001A854
	//		// Variables:
	//			struct _SVector linePoint; // stack offset -40
	//			int n; // $s3

	//		/* begin block 1.2.1 */
	//			// Start line: 3827
	//			// Start offset: 0x8001A908
	//			// Variables:
	//				short _x1; // $v0
	//				short _y1; // $v1
	//				short _z1; // $a0
	//		/* end block 1.2.1 */
	//		// End offset: 0x8001A908
	//		// End Line: 3827
	//	/* end block 1.2 */
	//	// End offset: 0x8001A95C
	//	// End Line: 3833
	///* end block 1 */
	//// End offset: 0x8001A95C
	//// End Line: 3835

	///* begin block 2 */
	//	// Start line: 8994
	///* end block 2 */
	//// End Line: 8995
	UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// void /*$ra*/ CAMERA_SplineGetNearestPoint2(struct Camera *camera /*stack 0*/, struct Spline *spline /*stack 4*/, struct _SVector *point /*stack 8*/, int *currkey /*stack 12*/, struct _SVector *ret_dpoint /*stack 16*/)
void CAMERA_SplineGetNearestPoint2(struct Camera *camera, struct Spline *spline, struct _SVector *point, int *currkey, struct _SVector *ret_dpoint)
{ // line 3838, offset 0x8001a984
	///* begin block 1 */
	//	// Start line: 3839
	//	// Start offset: 0x8001A984
	//	// Variables:
	//		struct SplineKey *key; // stack offset -56
	//		int n; // $s2
	//		int target_dist_sq; // stack offset -52
	//		long dist; // $fp

	//	/* begin block 1.1 */
	//		// Start line: 3839
	//		// Start offset: 0x8001A984
	//		// Variables:
	//			short _x1; // $v0
	//			short _y1; // $v1
	//			short _z1; // $a0
	//	/* end block 1.1 */
	//	// End offset: 0x8001A984
	//	// End Line: 3839

	//	/* begin block 1.2 */
	//		// Start line: 3858
	//		// Start offset: 0x8001AA38
	//		// Variables:
	//			struct _SVector point1; // stack offset -88
	//			struct _SVector point2; // stack offset -80
	//			struct _SVector results[2]; // stack offset -72
	//			int i; // $s1
	//			int hits; // $s3

	//		/* begin block 1.2.1 */
	//			// Start line: 3862
	//			// Start offset: 0x8001AA54
	//			// Variables:
	//				short _x1; // $v1
	//				short _y1; // $a2
	//				short _z1; // $v0
	//				struct _SVector *_v0; // $s7
	//				struct vecS *_v1; // $v0
	//		/* end block 1.2.1 */
	//		// End offset: 0x8001AA54
	//		// End Line: 3862

	//		/* begin block 1.2.2 */
	//			// Start line: 3862
	//			// Start offset: 0x8001AA54
	//			// Variables:
	//				short _x1; // $v0
	//				short _y1; // $a2
	//				short _z1; // $v1
	//				struct _SVector *_v0; // $s6
	//				struct vecS *_v1; // $v1
	//		/* end block 1.2.2 */
	//		// End offset: 0x8001AA54
	//		// End Line: 3862

	//		/* begin block 1.2.3 */
	//			// Start line: 3869
	//			// Start offset: 0x8001AACC
	//			// Variables:
	//				int tmpdist; // $a1

	//			/* begin block 1.2.3.1 */
	//				// Start line: 3880
	//				// Start offset: 0x8001AAE8
	//				// Variables:
	//					short _x1; // $v0
	//					short _y1; // $v1
	//					short _z1; // $a0
	//			/* end block 1.2.3.1 */
	//			// End offset: 0x8001AAE8
	//			// End Line: 3880
	//		/* end block 1.2.3 */
	//		// End offset: 0x8001AB0C
	//		// End Line: 3884
	//	/* end block 1.2 */
	//	// End offset: 0x8001AB1C
	//	// End Line: 3892
	///* end block 1 */
	//// End offset: 0x8001AB3C
	//// End Line: 3893

	///* begin block 2 */
	//	// Start line: 9111
	///* end block 2 */
	//// End Line: 9112
	UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ CAMERA_SplineGetNearestPoint(struct Spline *spline /*$s4*/, struct _SVector *point /*$s6*/, int *currkey /*$s7*/, struct _SVector *ret_dpoint /*stack 12*/)
void CAMERA_SplineGetNearestPoint(struct Spline *spline, struct _SVector *point, int *currkey, struct _SVector *ret_dpoint)
{ // line 3895, offset 0x8001ab6c
	///* begin block 1 */
	//	// Start line: 3896
	//	// Start offset: 0x8001AB6C
	//	// Variables:
	//		struct _SVector dpoint; // stack offset -96
	//		struct _SVector dpoint2; // stack offset -88
	//		struct _SVector dpoint3; // stack offset -80
	//		struct _SVector point0; // stack offset -72
	//		struct _SVector point1; // stack offset -64
	//		struct _SVector point2; // stack offset -56
	//		struct _SVector point3; // stack offset -48
	//		int current_keyframe; // $s0
	//		int dist; // $fp
	//		int ret; // $s5
	//		int ret2; // $s4
	//		int ret3; // $s0
	//		struct SplineKey *key; // $s1
	//		int circular_spline; // $s2
	//		int prev_key; // $s2
	//		int next_key; // $s3

	//	/* begin block 1.1 */
	//		// Start line: 3921
	//		// Start offset: 0x8001AC98
	//		// Variables:
	//			short _x1; // $v1
	//			short _y1; // $t0
	//			short _z1; // $a3
	//			struct _SVector *_v0; // $a1
	//			struct vecS *_v1; // $a3
	//	/* end block 1.1 */
	//	// End offset: 0x8001AC98
	//	// End Line: 3921

	//	/* begin block 1.2 */
	//		// Start line: 3921
	//		// Start offset: 0x8001AC98
	//		// Variables:
	//			short _x1; // $v0
	//			short _y1; // $t0
	//			short _z1; // $v1
	//			struct _SVector *_v0; // $a2
	//			struct vecS *_v1; // $v1
	//	/* end block 1.2 */
	//	// End offset: 0x8001AC98
	//	// End Line: 3921

	//	/* begin block 1.3 */
	//		// Start line: 3936
	//		// Start offset: 0x8001AD60
	//		// Variables:
	//			short _x1; // $v0
	//			short _y1; // $t0
	//			short _z1; // $v1
	//			struct _SVector *_v0; // $a2
	//			struct vecS *_v1; // $v1
	//	/* end block 1.3 */
	//	// End offset: 0x8001AD60
	//	// End Line: 3936

	//	/* begin block 1.4 */
	//		// Start line: 3949
	//		// Start offset: 0x8001ADC0
	//		// Variables:
	//			short _x1; // $v0
	//			short _y1; // $t0
	//			short _z1; // $v1
	//			struct _SVector *_v0; // $a1
	//			struct vecS *_v1; // $v1
	//	/* end block 1.4 */
	//	// End offset: 0x8001ADC0
	//	// End Line: 3949
	///* end block 1 */
	//// End offset: 0x8001AED4
	//// End Line: 3975

	///* begin block 2 */
	//	// Start line: 9304
	///* end block 2 */
	//// End Line: 9305
	UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ CAMERA_SplineHelpMove(struct Camera *camera /*$s1*/)
void CAMERA_SplineHelpMove(struct Camera *camera)
{ // line 3981, offset 0x8001af04
	/* begin block 1 */
		// Start line: 3982
		// Start offset: 0x8001AF04
		// Variables:
			struct _SVector camPos; // stack offset -48
			_Position pos; // stack offset -40
			struct _Rotation rotation; // stack offset -32
			struct _Instance *focusInstance; // $s3
			struct MultiSpline *posSpline; // $s2
	/* end block 1 */
	// End offset: 0x8001B058
	// End Line: 4026

	/* begin block 2 */
		// Start line: 9489
	/* end block 2 */
	// End Line: 9490
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ CAMERA_SplineProcess(struct Camera *camera /*$s1*/)
void CAMERA_SplineProcess(struct Camera *camera)
{ // line 4028, offset 0x8001b074
	/* begin block 1 */
		// Start line: 4029
		// Start offset: 0x8001B074
		// Variables:
			struct _SVector camPos; // stack offset -48
			struct _SVector sv; // stack offset -40
			short targetFocusDistance; // $s4
			struct MultiSpline *posSpline; // $s3
			short smooth; // $s0
			short dist_smooth; // $s2
			static short hold_flag; // offset 0x5c
			struct _Rotation targetFocusRotation; // stack offset -32

		/* begin block 1.1 */
			// Start line: 4114
			// Start offset: 0x8001B1C0
			// Variables:
				short _x0; // $v0
				short _y0; // $a1
				short _z0; // $a2
				short _x1; // $v1
				short _y1; // $v1
				short _z1; // $v0
				struct _SVector *_v; // $a0
				struct _SVector *_v1; // $v0
		/* end block 1.1 */
		// End offset: 0x8001B1C0
		// End Line: 4114
	/* end block 1 */
	// End offset: 0x8001B3A8
	// End Line: 4177

	/* begin block 2 */
		// Start line: 9602
	/* end block 2 */
	// End Line: 9603
				UNIMPLEMENTED();
}

void CAMERA_ShakeCamera(struct Camera* camera)
{
	if (camera->shake > 0)
	{
		camera->core.position.x += ((camera_shakeOffset[(camera->shakeFrame & 0xF)].x * camera->shakeScale) >> 12);
		camera->core.position.y += ((camera_shakeOffset[(camera->shakeFrame & 0xF)].y * camera->shakeScale) >> 12);
		camera->core.position.z += ((camera_shakeOffset[(camera->shakeFrame & 0xF)].z * camera->shakeScale) >> 12);

		camera->shake -= gameTrackerX.timeMult;

		if (camera->shake < 0)
		{
			camera->shake = 0;
		}

		camera->shakeFrame++;
	}
}

void CAMERA_Process(struct Camera* camera)
{
	struct _Instance* focusInstance;
	short _x0;
	short _y0;
	short _z0;
	short _x1;
	short _y1;
	short _z1;
	struct _SVector* _v;
	_Position* _v0;
	_Position* _v1;

	focusInstance = camera->focusInstance;
	
	camera->focuspoint_fallz -= camera->newFocusInstancePos.z - focusInstance->oldPos.z;

	camera->oldFocusInstancePos = camera->newFocusInstancePos;

	camera->newFocusInstancePos = focusInstance->position;

	camera->oldFocusInstanceRot = camera->newFocusInstanceRot;

	camera->newFocusInstanceRot = focusInstance->rotation;

	if (camera->signalPos.x == camera->core.position.x &&
		camera->signalPos.y == camera->core.position.y && 
		camera->signalPos.z == camera->core.position.z)
	{
		camera_still = 1;
	}
	else
	{
		camera_still = 0;
	}

	camera->signalPos.x = camera->core.position.x;
	camera->signalPos.y = camera->core.position.y;
	camera->signalPos.z = camera->core.position.z;
	
	camera->prev_instance_mode = camera->instance_mode;
	camera->x_rot_change = 0;

	camera->instance_mode = CAMERA_QueryMode(camera);

	_v0 = &camera->newFocusInstancePos;
	_v1 = &camera->oldFocusInstancePos;

	_x0 = _v0->x;
	_y0 = _v0->y;
	_z0 = _v0->z;

	_x1 = _v1->x;
	_y1 = _v1->y;
	_z1 = _v1->z;

	_v = &camera->focusInstanceVelVec;
	
	_v->x = _x0 - _x1;
	_v->y = _y0 - _y1;
	_v->z = _z0 - _z1;

	camera->instance_prev_xyvel = camera->instance_xyvel;

	camera->instance_xyvel = MATH3D_FastSqrt0((camera->focusInstanceVelVec.x * camera->focusInstanceVelVec.x) + (camera->focusInstanceVelVec.y * camera->focusInstanceVelVec.y));

	if (shorten_flag == 0)
	{
		shorten_count = 0;
	}

	shorten_flag = 0;

	if (camera->cuckooTimer > 0)
	{
		camera->cuckooTimer--;
	}

	if (camera->mode != 6)
	{
		CAMERA_HandleTransitions(camera);
	}

	switch (camera->mode)
	{
	case 0:
	case 12:
	case 13:
		CAMERA_GenericCameraProcess(camera);
		break;
	case 2:
	case 4:
		CAMERA_SplineProcess(camera);
		break;
	case 5:
		CAMERA_CinematicProcess(camera);
		break;
	case 6:
		CAMERA_LookProcess(camera);
		break;
	default:
		break;
	}

	camera->flags &= 0xFFFFF7FF;
	camera->flags &= 0xFFFFEFFF;

	CAMERA_ShakeCamera(camera);
}


// autogenerated function stub: 
// void /*$ra*/ CAMERA_CenterCamera(struct Camera *camera /*$s1*/)
void CAMERA_CenterCamera(struct Camera *camera)
{ // line 4404, offset 0x8001b6fc
	/* begin block 1 */
		// Start line: 4405
		// Start offset: 0x8001B6FC

		/* begin block 1.1 */
			// Start line: 4409
			// Start offset: 0x8001B724
			// Variables:
				int tmp1; // $s0
				int tmp2; // $v0
		/* end block 1.1 */
		// End offset: 0x8001B790
		// End Line: 4413
	/* end block 1 */
	// End offset: 0x8001B7BC
	// End Line: 4420

	/* begin block 2 */
		// Start line: 10388
	/* end block 2 */
	// End Line: 10389
				UNIMPLEMENTED();
}

void CAMERA_SetLookRot(struct Camera* camera, int x_rotation, int z_rotation)
{
	camera->lookRot.x = x_rotation;
	camera->lookRot.z = z_rotation;
}


// autogenerated function stub: 
// void /*$ra*/ CAMERA_StartLookaroundMode(struct Camera *camera /*$s0*/)
void CAMERA_StartLookaroundMode(struct Camera *camera)
{ // line 4442, offset 0x8001b7f0
	/* begin block 1 */
		// Start line: 10452
	/* end block 1 */
	// End Line: 10453
	UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ CAMERA_StartSwimThrowMode(struct Camera *camera /*$s0*/)
void CAMERA_StartSwimThrowMode(struct Camera *camera)
{ // line 4460, offset 0x8001b880
	/* begin block 1 */
		// Start line: 10498
	/* end block 1 */
	// End Line: 10499
	UNIMPLEMENTED();
}

void CAMERA_EndSwimThrowMode(struct Camera* camera)
{
	CameraLookStickyFlag = 0;

	CAMERA_EndLook(camera);
}

void CAMERA_ForceEndLookaroundMode(struct Camera* camera)
{
	CameraLookStickyFlag = 0;

	CAMERA_EndLook(camera);

	camera->flags &= 0xFFFDFFFF;
}


// autogenerated function stub: 
// void /*$ra*/ CAMERA_Control(struct Camera *camera /*$s0*/, struct _Instance *playerInstance /*$s5*/)
void CAMERA_Control(struct Camera *camera, struct _Instance *playerInstance)
{ // line 4483, offset 0x8001b920
	/* begin block 1 */
		// Start line: 4484
		// Start offset: 0x8001B920
		// Variables:
			long *controlCommand; // $s2
			int lookmode; // $s1
			struct _Instance *focusInstance; // $s4
	/* end block 1 */
	// End offset: 0x8001BE44
	// End Line: 4718

	/* begin block 2 */
		// Start line: 10545
	/* end block 2 */
	// End Line: 10546
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ CAMERA_EndLook(struct Camera *camera /*$s0*/)
void CAMERA_EndLook(struct Camera *camera)
{ // line 4721, offset 0x8001be68
	/* begin block 1 */
		// Start line: 4722
		// Start offset: 0x8001BE68
		// Variables:
			struct _Instance *focusInstance; // $s1
	/* end block 1 */
	// End offset: 0x8001BF44
	// End Line: 4782

	/* begin block 2 */
		// Start line: 11051
	/* end block 2 */
	// End Line: 11052
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ CAMERA_ChangeToUnderWater(struct Camera *camera /*$s0*/, struct _Instance *instance /*$a1*/)
void CAMERA_ChangeToUnderWater(struct Camera *camera, struct _Instance *instance)
{ // line 4786, offset 0x8001bf5c
	/* begin block 1 */
		// Start line: 11218
	/* end block 1 */
	// End Line: 11219
	UNIMPLEMENTED();
}

void CAMERA_ChangeToOutOfWater(struct Camera* camera, struct _Instance* instance)
{
	if (camera->focusInstance == instance)
	{
		if (camera->mode != 5)
		{
			CAMERA_SetMode(camera, 13);
			
			camera->rotationVel.z = 0;

			camera->targetTilt = 0;
		}
		else
		{
			CAMERA_SaveMode(camera, 13);
		}

		camera->flags &= 0xFFFEFFFF;
	}
}


// autogenerated function stub: 
// void /*$ra*/ CAMERA_UpdateFocusDistance(struct Camera *camera /*$a3*/)
void CAMERA_UpdateFocusDistance(struct Camera *camera)
{ // line 4929, offset 0x8001c07c
	/* begin block 1 */
		// Start line: 4930
		// Start offset: 0x8001C07C
		// Variables:
			int smooth; // $v1
			long dampMode; // $a0
	/* end block 1 */
	// End offset: 0x8001C13C
	// End Line: 4977

	/* begin block 2 */
		// Start line: 9858
	/* end block 2 */
	// End Line: 9859
			UNIMPLEMENTED();
}

void CAMERA_UpdateFocusTilt(struct Camera* camera)
{
	if ((camera->flags & 0x1800))
	{
		camera->x_rot_change = 0;
		camera->focusRotation.x = camera->tfaceTilt;
	}
	else
	{
		camera->x_rot_change = camera->focusRotation.x;

		if (camera->forced_movement == 3 || (camera->lock & 0x2))
		{
			if ((camera->flags & 0x10000))
			{
				CriticalDampAngle(1, &camera->focusRotation.x, camera->tfaceTilt, &camera->focusRotVel.x, &camera->focusRotAccl.x, 32);
			}
			else
			{
				camera->focusRotation.x = camera->targetFocusRotation.x;
			}

			camera->x_rot_change = CAMERA_SignedAngleDifference(camera->x_rot_change, camera->focusRotation.x);
		}
	}
}

void CAMERA_UpdateFocusRoll(struct Camera* camera)
{
	long tmp_inc; // $s0

	//s1 = camera
	//v1 = roll_inc

	if (roll_inc != 0)
	{
		//a0 = gameTrackerX.timeMult
		//v0 = 4096
		tmp_inc = roll_inc;

		if (gameTrackerX.timeMult != 4096 && roll_inc < 0)
		{
			///@FIXME some macro used here?
		}
		//loc_8001C628
	}
	//loc_8001C6C0
#if 0
		bgez    $v1, loc_8001C60C
		move    $v0, $v1
		addiu   $v0, $v1, 0x1F

		loc_8001C60C:
	sra     $v0, 5
		mult    $v0, $a0
		mflo    $v0
		bgez    $v0, loc_8001C628
		sra     $s0, $v0, 7
		addiu   $v0, 0x7F
		sra     $s0, $v0, 7

		loc_8001C628:
	lw      $v0, -0x71B0($gp)
		nop
		bgez    $v0, loc_8001C63C
		nop
		addiu   $v0, 0xFFF

		loc_8001C63C :
		lw      $a1, -0x71B4($gp)
		sll     $v0, 4
		bgez    $a1, loc_8001C650
		sra     $a0, $v0, 16
		addiu   $a1, 0xFFF

		loc_8001C650 :
		sll     $a1, 4
		jal     sub_800166F0
		sra     $a1, 16
		move    $v1, $s0
		sll     $v0, 16
		bgez    $s0, loc_8001C670
		sra     $a0, $v0, 16
		addiu   $v1, $s0, 0xFFF

		loc_8001C670:
	sra     $v0, $v1, 12
		bgez    $v0, loc_8001C680
		nop
		negu    $v0, $v0

		loc_8001C680 :
	slt     $v0, $a0
		bnez    $v0, loc_8001C69C
		nop
		lw      $v0, -0x71B4($gp)
		sw      $zero, -0x71AC($gp)
		j       loc_8001C6A8
		nop

		loc_8001C69C :
	lw      $v0, -0x71B0($gp)
		nop
		addu    $v0, $s0

		loc_8001C6A8 :
	sw      $v0, -0x71B0($gp)
		lui     $v1, 0xFF
		lw      $v0, -0x71B0($gp)
		li      $v1, 0xFFFFFF
		and $v0, $v1
		sw      $v0, -0x71B0($gp)

		loc_8001C6C0:
	lw      $v0, -0x71B0($gp)
		nop
		bgez    $v0, loc_8001C6D4
		nop
		addiu   $v0, 0xFFF

		loc_8001C6D4 :
		sra     $v0, 12
		sh      $v0, 0xB2($s1)
		lw      $ra, 0x10 + var_s8($sp)
		lw      $s1, 0x10 + var_s4($sp)
		lw      $s0, 0x10 + var_s0($sp)
		jr      $ra
		addiu   $sp, 0x20
#endif
}


// autogenerated function stub: 
// void /*$ra*/ CAMERA_UpdateFocusRotate(struct Camera *camera /*$s0*/)
void CAMERA_UpdateFocusRotate(struct Camera *camera)
{ // line 5037, offset 0x8001c334
	/* begin block 1 */
		// Start line: 5038
		// Start offset: 0x8001C334

		/* begin block 1.1 */
			// Start line: 5041
			// Start offset: 0x8001C368
			// Variables:
				int dampspeed; // $v1
				long dampmode; // $a0
		/* end block 1.1 */
		// End offset: 0x8001C3E8
		// End Line: 5066
	/* end block 1 */
	// End offset: 0x8001C410
	// End Line: 5073

	/* begin block 2 */
		// Start line: 11626
	/* end block 2 */
	// End Line: 11627
				UNIMPLEMENTED();
}

void CAMERA_UpdateFocusRotationX(struct Camera* camera, struct _Instance* focusInstance)
{
	short cameraPlayerRotX; // $a1
	short dist; // $s1
	short tfaceFlag; // $s2
	struct _Normal normal; // stack offset -24
	int mult; // $v1
	int tmpsmooth; // $t0

	//s0 = camera
	//a0 = camera->core.rotation.z
	dist = camera->targetFocusDistance;
	tfaceFlag = 0;

	//v0 = focusInstance->tface->textoff
	//v1 = ((char*)((struct _Terrain*)focusInstance->tfaceLevel)->StartTextureList) + focusInstance->tface->textoff;
	if (focusInstance->tface != NULL && focusInstance->tfaceLevel != NULL && focusInstance->tface->textoff != 0xFFFF)
	{
		if (((struct TextureFT3*)((char*)((struct _Terrain*)focusInstance->tfaceLevel)->StartTextureList) + focusInstance->tface->textoff)->attr & 0x80000)
		{
			if (dist < 2912)
			{
				//v0 = tfaceFlag
				COLLIDE_GetNormal(focusInstance->tface->normal, (short*)((struct _Terrain*)focusInstance->tfaceLevel)->normalList, (_SVector*)&normal);
			
				//v0 = tface_flag
				if (normal.y < 3950)
				{
					tfaceFlag = 1;

					//a1 = camera->focusRotation.z
					//a0 = &normal
					int x = CAMERA_CalcTilt(&normal, camera->focusRotation.z);
					int tilt = ((x * 8) + x);
					tilt < 0 ? ((tilt + 15) >> 4) : tilt >> 4;
					camera->targetTilt = tilt;

					//v0 = camera->targetTilt
					//continue this here
				}
				//loc_8001C93C
			}
			//loc_8001C93C
		}
		//loc_8001C938
	}
	//loc_8001C938
#if 0
		sh      $v0, 0x19E($s0)
		sll     $v0, 16
		sra     $v1, $v0, 16
		slti    $v0, $v1, -0x100
		bnez    $v0, loc_8001C8D0
		li      $v0, 0xFFFFFF00
		slti    $v0, $v1, 0x101
		bnez    $v0, loc_8001C8D8
		sll     $v0, $s1, 16
		li      $v0, 0x100

		loc_8001C8D0:
	sh      $v0, 0x19E($s0)
		sll     $v0, $s1, 16

		loc_8001C8D8 :
		sra     $v0, 16
		li      $v1, 0xB60
		subu    $v1, $v0
		slti    $v0, $v1, 0x200
		beqz    $v0, loc_8001C918
		li      $a0, 1
		lh      $v0, 0x19E($s0)
		nop
		mult    $v0, $v1
		mflo    $v0
		bgez    $v0, loc_8001C90C
		nop
		addiu   $v0, 0x1FF

		loc_8001C90C:
	sra     $v0, 9
		sh      $v0, 0x19E($s0)
		li      $a0, 1

		loc_8001C918 :
		addiu   $a1, $s0, 0xFE
		addiu   $a3, $s0, 0x144
		lh      $a2, 0x19E($s0)
		addiu   $v0, $s0, 0x146
		sw      $v0, 0x20 + var_10($sp)
		li      $v0, 8
		jal     sub_800179F8
		sw      $v0, 0x20 + var_C($sp)

		loc_8001C938:
	move    $v0, $s2

		loc_8001C93C :
	bnez    $v0, loc_8001C9B0
		nop
		lw      $v0, 0x49C($s0)
		nop
		andi    $v0, 0x38
		bnez    $v0, loc_8001C95C
		li      $t0, 0x18
		sh      $zero, 0x19E($s0)

		loc_8001C95C:
	lw      $v0, 0x49C($s0)
		nop
		andi    $v0, 0x2000
		beqz    $v0, loc_8001C994
		li      $a0, 1
		lh      $v0, 0x4AC($s0)
		lh      $v1, 0x4BA($s0)
		nop
		slt     $v0, $v1
		beqz    $v0, loc_8001C994
		li      $v0, 0xFFFFFE80
		sh      $v0, 0x19E($s0)
		li      $t0, 0xC
		li      $a0, 1

		loc_8001C994:
	addiu   $a1, $s0, 0xFE
		addiu   $a3, $s0, 0x144
		lh      $a2, 0x19E($s0)
		addiu   $v0, $s0, 0x146
		sw      $v0, 0x20 + var_10($sp)
		jal     sub_800179F8
		sw      $t0, 0x20 + var_C($sp)

		loc_8001C9B0:
	lhu     $v1, 0x1B2($s0)
		lhu     $a0, 0xFE($s0)
		lhu     $v0, 0x48C($s0)
		addu    $v1, $a0
		addu    $v0, $v1
		andi    $v1, $v0, 0xFFF
		addiu   $v0, $v1, -0x301
		sltiu   $v0, 0x4FF
		beqz    $v0, loc_8001C9E0
		move    $a1, $v1
		j       loc_8001C9F4
		li      $a1, 0x300

		loc_8001C9E0:
	addiu   $v0, $v1, -0x800
		sltiu   $v0, 0x500
		beqz    $v0, loc_8001C9F8
		andi    $a0, $a1, 0xFFF
		li      $a1, 0xFFFFFD00

		loc_8001C9F4 :
		andi    $a0, $a1, 0xFFF

		loc_8001C9F8 :
		move    $a1, $a0
		lw      $v0, 0x49C($s0)
		lui     $v1, 0x200
		and $v0, $v1
		beqz    $v0, loc_8001CA40
		sh      $a0, 0x1BA($s0)
		slti    $v0, $a0, 0x801
		bnez    $v0, loc_8001CA24
		sll     $v0, $a1, 16
		ori     $a1, $a0, 0xF000
		sll     $v0, $a1, 16

		loc_8001CA24:
	lh      $v1, -0x542A($gp)
		sra     $v0, 16
		slt     $v1, $v0
		lhu     $v0, -0x542A($gp)
		beqz    $v1, loc_8001CA40
		addiu   $v0, 0x1000
		sh      $v0, 0x1BA($s0)

		loc_8001CA40:
	lw      $ra, 0x20 + var_sC($sp)
		lw      $s2, 0x20 + var_s8($sp)
		lw      $s1, 0x20 + var_s4($sp)
		lw      $s0, 0x20 + var_s0($sp)
		jr      $ra
		addiu   $sp, 0x30
#endif


}


// autogenerated function stub: 
// void /*$ra*/ CAMERA_FollowPlayerTilt(struct Camera *camera /*$s1*/, struct _Instance *focusInstance /*$a1*/)
void CAMERA_FollowPlayerTilt(struct Camera *camera, struct _Instance *focusInstance)
{ // line 5178, offset 0x8001c6a0
	/* begin block 1 */
		// Start line: 5179
		// Start offset: 0x8001C6A0
		// Variables:
			int speed; // $s2
			int mode; // $s3
			long focusInstanceStatus; // $a0

		/* begin block 1.1 */
			// Start line: 5203
			// Start offset: 0x8001C724
			// Variables:
				struct _SVector offset; // stack offset -40
				struct _Normal normal; // stack offset -32

			/* begin block 1.1.1 */
				// Start line: 5227
				// Start offset: 0x8001C7DC
				// Variables:
					int waterZ; // $v0
					int target; // $v0
					int height; // $s0

				/* begin block 1.1.1.1 */
					// Start line: 5235
					// Start offset: 0x8001C81C
					// Variables:
						int fdsq; // $v0
				/* end block 1.1.1.1 */
				// End offset: 0x8001C85C
				// End Line: 5243
			/* end block 1.1.1 */
			// End offset: 0x8001C85C
			// End Line: 5244
		/* end block 1.1 */
		// End offset: 0x8001C85C
		// End Line: 5245
	/* end block 1 */
	// End offset: 0x8001C85C
	// End Line: 5250

	/* begin block 2 */
		// Start line: 11914
	/* end block 2 */
	// End Line: 11915
						UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ CAMERA_FollowGoBehindPlayerWithTimer(struct Camera *camera /*$s0*/)
void CAMERA_FollowGoBehindPlayerWithTimer(struct Camera *camera)
{ // line 5259, offset 0x8001c8b0
	/* begin block 1 */
		// Start line: 5260
		// Start offset: 0x8001C8B0
		// Variables:
			struct _Instance *focusInstance; // $s1
	/* end block 1 */
	// End offset: 0x8001C998
	// End Line: 5298

	/* begin block 2 */
		// Start line: 12087
	/* end block 2 */
	// End Line: 12088
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ CAMERA_FollowGoBehindPlayer(struct Camera *camera /*$v1*/)
void CAMERA_FollowGoBehindPlayer(struct Camera *camera)
{ // line 5301, offset 0x8001c9ac
	/* begin block 1 */
		// Start line: 5302
		// Start offset: 0x8001C9AC
		// Variables:
			struct _Instance *focusInstance; // $v0
	/* end block 1 */
	// End offset: 0x8001C9AC
	// End Line: 5302

	/* begin block 2 */
		// Start line: 12179
	/* end block 2 */
	// End Line: 12180
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ CAMERA_CalculateLead(struct Camera *camera /*$s1*/)
void CAMERA_CalculateLead(struct Camera *camera)
{ // line 5313, offset 0x8001c9e8
	/* begin block 1 */
		// Start line: 5314
		// Start offset: 0x8001C9E8
		// Variables:
			short lead_target; // $s0
			short lead_smooth; // $v1

		/* begin block 1.1 */
			// Start line: 5320
			// Start offset: 0x8001CA34
			// Variables:
				int speedxy; // $s0
				short angle; // $a0

			/* begin block 1.1.1 */
				// Start line: 5332
				// Start offset: 0x8001CABC
				// Variables:
					int calc; // $v1
			/* end block 1.1.1 */
			// End offset: 0x8001CB2C
			// End Line: 5349
		/* end block 1.1 */
		// End offset: 0x8001CB34
		// End Line: 5354
	/* end block 1 */
	// End offset: 0x8001CB40
	// End Line: 5368

	/* begin block 2 */
		// Start line: 12203
	/* end block 2 */
	// End Line: 12204
					UNIMPLEMENTED();
}

void CAMERA_CalcFollowPosition(struct Camera* camera, struct _Rotation* rotation)
{ 
	struct _Instance* focusInstance;
	short _x1;
	short _y1;
	short _z1;
	struct _Rotation* _v0;
	short target_rotx;
	int hypotXY;
	int smooth;
	int diff;
	struct _Vector dpv;
	int zdiff;
	int velz;
	int ground;
	int pos;

	focusInstance = camera->focusInstance;

#if 0
	eprinterr("[HACK]: Camera distance hack is enabled!\n");

	//The below is set by EVENT_* code however since it's largely unimplemented it's never set yet!
	camera->focusDistance = 1500;

	//The below is the first frame's camera rotation, something is unimplemented so it's not set yet!
	eprinterr("[HACK]: Camera default rotation hack is enabled!\n");

	rotation->x = 0xFC7;
	rotation->y = 0;
	rotation->z = 0;

	//The below is the first frame's camera rotation, something is unimplemented so it's not set yet!
	eprinterr("[HACK]: Camera default focus point hack is enabled!\n");

	camera->focusPoint.x = 0xFF63;
	camera->focusPoint.y = 0xFB3A;
	camera->focusPoint.z = 0xEE84;

#endif

	CAMERA_CalcPosition(&camera->targetPos, &camera->focusPoint, rotation, camera->focusDistance);

#if 0
	camera->core.position.x = camera->targetPos.x;
	camera->core.position.y = camera->targetPos.y;
	camera->core.position.z = camera->targetPos.z;

#else
	eprinterr("%x\n", gameTrackerX.controlCommand[0][1]);

	if ((gameTrackerX.controlCommand[0][1] & 0x10))
	{
		if ((gameTrackerX.controlCommand[0][1] & 0x1))
		{
			camera->core.position.z += 128*8;
		}

		if ((gameTrackerX.controlCommand[0][1] & 0x2))
		{
			camera->core.position.z -= 128*8;
		}
	}
	else
	{
		if ((gameTrackerX.controlCommand[0][1] & 0x1))
		{
			camera->core.position.y += 128;
		}

		if ((gameTrackerX.controlCommand[0][1] & 0x2))
		{
			camera->core.position.y -= 128;
		}
	}


	if ((gameTrackerX.controlCommand[0][1] & 0x4))
	{
		rotation->z += 0xFC7;
	}

	if ((gameTrackerX.controlCommand[0][1] & 0x8))
	{
		rotation->z += -0xFC7;
	}
#endif

	_x1 = rotation->x;
	_y1 = rotation->y;
	_z1 = rotation->z;

	_v0 = &camera->core.rotation;

	_v0->x = _x1;
	_v0->y = _y1;
	_v0->z = _z1;

	if (!(camera->flags & 0x10000))
	{
		camera->actual_x_rot -= camera->x_rot_change;

		dpv.x = camera->real_focuspoint.x - camera->targetPos.x;
		dpv.z = 0;
		dpv.y = camera->real_focuspoint.y - camera->targetPos.y;

		gte_ldlvl(dpv);

		gte_sqr0();

		gte_stlvnl(&dpv);

		hypotXY = MATH3D_FastSqrt0(dpv.x + dpv.y);

		diff = ratan2(camera->real_focuspoint.z - camera->targetPos.x, hypotXY);

		target_rotx = diff;

		if ((camera->instance_mode & 0x1038))
		{
			velz = camera->focusInstanceVelVec.z;

			if (focusInstance->shadowPosition.z != focusInstance->position.z)
			{
				if (velz < 0)
				{
					if (velz < -260)
					{
						if (-520 - velz > 0)
						{
							velz = 0;
						}
					}

					pos = camera->real_focuspoint.z + (velz * 2);

					ground = focusInstance->shadowPosition.z + 352;

					if (pos < ground)
					{
						ground -= camera->targetPos.z;
					}
					else
					{
						ground = pos - camera->targetPos.z;
					}

					target_rotx = ratan2(ground, hypotXY);

					if (CAMERA_SignedAngleDifference(target_rotx, camera->actual_x_rot) < 0)
					{
						target_rotx = camera->actual_x_rot;
					}
				}

				target_rotx = camera->core.rotation.x;
			}
		}
		else
		{
			if (CAMERA_AngleDifference(target_rotx, camera->core.rotation.x) < 4)
			{
				target_rotx = camera->core.rotation.x;
			}
		}

		if ((camera->flags & 0x1800))
		{
			camera->actual_x_rot = target_rotx;
			camera->x_rot_change = 0;
		}

		zdiff = CAMERA_SignedAngleDifference(target_rotx, camera->actual_x_rot);

		if ((camera->instance_mode & 0x2000))
		{
			if (zdiff >= 81)
			{
				smooth = zdiff - 80 / 3;

				if (smooth >= 4)
				{
					if (smooth >= 25)
					{
						smooth = 24;
					}
					else
					{
						smooth = 4;
					}
				}
				else
				{
					smooth = 4;
				}
			}
		}
		else
		{
			smooth = 24;
		}

		if (smooth != 0)
		{
			CriticalDampAngle(1, &camera->actual_x_rot, target_rotx, &camera->actual_vel_x, &camera->actual_acc_x, smooth);
		}
		else
		{
			camera->actual_acc_x = 0;
			camera->actual_vel_x = 0;
		}

		camera->core.rotation.x = camera->actual_x_rot;
	}
	else
	{
		camera->actual_x_rot = camera->core.rotation.x;
	}

	camera->lagZ = camera->core.rotation.z;
}


// autogenerated function stub: 
// void /*$ra*/ CAMERA_SetupColInfo(struct Camera *camera /*$a3*/, struct CameraCollisionInfo *colInfo /*$t0*/, _Position *targetCamPos /*$a2*/)
void CAMERA_SetupColInfo(struct Camera *camera, struct CameraCollisionInfo *colInfo, _Position *targetCamPos)
{ // line 5509, offset 0x8001ce8c
	///* begin block 1 */
	//	// Start line: 5510
	//	// Start offset: 0x8001CE8C
	//	// Variables:
	//		static short toggle; // offset 0x60

	//	/* begin block 1.1 */
	//		// Start line: 5515
	//		// Start offset: 0x8001CEA0
	//		// Variables:
	//			short _x1; // $v1
	//			short _y1; // $a0
	//			short _z1; // $a1
	//			_Position *_v0; // $v0
	//			_Position *_v1; // $v0
	//	/* end block 1.1 */
	//	// End offset: 0x8001CEA0
	//	// End Line: 5515

	//	/* begin block 1.2 */
	//		// Start line: 5519
	//		// Start offset: 0x8001CEAC
	//		// Variables:
	//			short _x1; // $v1
	//			short _y1; // $a0
	//			short _z1; // $a1
	//			_Position *_v0; // $v0
	//			_Position *_v1; // $v0
	//	/* end block 1.2 */
	//	// End offset: 0x8001CECC
	//	// End Line: 5519

	//	/* begin block 1.3 */
	//		// Start line: 5521
	//		// Start offset: 0x8001CECC
	//		// Variables:
	//			short _x1; // $v0
	//			short _y1; // $a0
	//			short _z1; // $a1
	//			_Position *_v0; // $v1
	//	/* end block 1.3 */
	//	// End offset: 0x8001CECC
	//	// End Line: 5521
	///* end block 1 */
	//// End offset: 0x8001CF44
	//// End Line: 5542

	///* begin block 2 */
	//	// Start line: 12616
	///* end block 2 */
	//// End Line: 12617
	UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ CAMERA_DoPanicCheck(struct Camera *camera /*$s0*/, struct CameraCollisionInfo *tmpcolInfo /*$s1*/, struct _Rotation *rotation /*$s3*/, short *best_z /*$s4*/, short *max_dist /*stack 16*/)
void CAMERA_DoPanicCheck(struct Camera *camera, struct CameraCollisionInfo *tmpcolInfo, struct _Rotation *rotation, short *best_z, short *max_dist)
{ // line 5550, offset 0x8001cf4c
	/* begin block 1 */
		// Start line: 5551
		// Start offset: 0x8001CF4C
		// Variables:
			_Position targetCamPos; // stack offset -32

		/* begin block 1.1 */
			// Start line: 5551
			// Start offset: 0x8001CF4C
			// Variables:
				short _x1; // $v1
				short _y1; // $a3
				short _z1; // $t0
				_Position *_v0; // $v0
				_Position *_v1; // $v0
		/* end block 1.1 */
		// End offset: 0x8001CF4C
		// End Line: 5551
	/* end block 1 */
	// End offset: 0x8001CFFC
	// End Line: 5563

	/* begin block 2 */
		// Start line: 12701
	/* end block 2 */
	// End Line: 12702
				UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ CAMERA_Panic(struct Camera *camera /*$s2*/, short min_dist /*$fp*/)
void CAMERA_Panic(struct Camera *camera, short min_dist)
{ // line 5565, offset 0x8001d01c
	/* begin block 1 */
		// Start line: 5566
		// Start offset: 0x8001D01C
		// Variables:
			_Position targetCamPos; // stack offset -160
			struct _Rotation rotation; // stack offset -152
			int n; // $s1
			short best_z; // stack offset -48
			short max_dist; // stack offset -46
			struct CameraCollisionInfo tmpcolInfo; // stack offset -144
			short free_count1; // $s7
			short free_count2; // $s6
	/* end block 1 */
	// End offset: 0x8001D19C
	// End Line: 5615

	/* begin block 2 */
		// Start line: 12739
	/* end block 2 */
	// End Line: 12740
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// long /*$ra*/ CAMERA_DoCameraCollision2(struct Camera *camera /*$s1*/, _Position *targetCamPos /*$v0*/, int simpleflag /*$s3*/)
long CAMERA_DoCameraCollision2(struct Camera *camera, _Position *targetCamPos, int simpleflag)
{ // line 5619, offset 0x8001d1cc
	/* begin block 1 */
		// Start line: 5620
		// Start offset: 0x8001D1CC
		// Variables:
			int secondcheck_flag; // $s0
			long hit; // $s2
			struct CameraCollisionInfo colInfo; // stack offset -120
			static long collisiontimeDown; // offset 0x64

		/* begin block 1.1 */
			// Start line: 5710
			// Start offset: 0x8001D40C
			// Variables:
				short _x1; // $v1
				short _y1; // $a3
				short _z1; // $t0
				_Position *_v0; // $v0
				_Position *_v1; // $v0
		/* end block 1.1 */
		// End offset: 0x8001D40C
		// End Line: 5710

		/* begin block 1.2 */
			// Start line: 5766
			// Start offset: 0x8001D558
			// Variables:
				int speed; // $s0
		/* end block 1.2 */
		// End offset: 0x8001D620
		// End Line: 5786

		/* begin block 1.3 */
			// Start line: 5816
			// Start offset: 0x8001D6A8
			// Variables:
				int angle1; // $s0
				int angle2; // $v0
		/* end block 1.3 */
		// End offset: 0x8001D754
		// End Line: 5832
	/* end block 1 */
	// End offset: 0x8001D7B4
	// End Line: 5871

	/* begin block 2 */
		// Start line: 12897
	/* end block 2 */
	// End Line: 12898
				UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ CAMERA_FocusInstanceMoved(struct Camera *camera /*$a0*/)
int CAMERA_FocusInstanceMoved(struct Camera *camera)
{ // line 5876, offset 0x8001d7d0
#if defined(PC_VERSION)
	return camera->newFocusInstancePos.x != camera->oldFocusInstancePos.x
		|| camera->newFocusInstancePos.y != camera->oldFocusInstancePos.y
		|| camera->newFocusInstancePos.z != camera->oldFocusInstancePos.z
		|| camera->newFocusInstanceRot.x != camera->oldFocusInstanceRot.x
		|| camera->newFocusInstanceRot.y != camera->oldFocusInstanceRot.y
		|| camera->newFocusInstanceRot.z != camera->oldFocusInstanceRot.z;
#else
	UNIMPLEMENTED();
	return 0;
#endif
}
