#include "CORE.H"

#include "REAVER.H"
#include "Game/GAMEPAD.H"
#include "Game/FX.H"
#include "Game/COLLIDE.H"
#include "Game/STATE.H"
#include "MEMPACK.H"
#include "MATH3D.H"

short FireReaverFlag;

void SoulReaverInit(struct _Instance* instance, struct GameTracker* gameTracker) // Matching - 100%
{
	struct __ReaverData* data;

	if ((instance->flags & 0x20000))
	{
		data = (struct __ReaverData*)instance->extraData;

		MEMPACK_Free((char*)data);
	}
	else
	{
		data = (struct __ReaverData*)MEMPACK_Malloc(sizeof(struct __ReaverData), 30);

		instance->extraData = (void*)data;

		FireReaverFlag = 0;

		data->CurrentReaver = 2;
		data->ReaverOn = 1;
		data->ReaverChargeTime = 0;
		data->ReaverShockAmount = 0;
		data->ReaverPickedUp = 0;
		data->ReaverSize = 4096;
		data->ReaverDeg = 0;
		data->ReaverScale = 4096;
		data->ReaverTargetScale = 4096;

		COLLIDE_SegmentCollisionOff(instance, 0);
	}

	FX_ReaverBladeInit();
}

void SoulReaverCollide(struct _Instance* instance, struct GameTracker* gameTracker) // Matching - 100%
{
	struct _CollideInfo* collideInfo;
	struct _HSphere* S;
	struct _Instance* target;
	struct __ReaverData* reaverData;
	long type;
	struct _Instance* inst;

	collideInfo = (struct _CollideInfo*)instance->collideInfo;
	if (collideInfo->type0 == 1 && collideInfo->type1 == 1)
	{
		S = (struct _HSphere*)collideInfo->prim0;
		if (S->id == 9)
		{
			S = (struct _HSphere*)collideInfo->prim1;
			if (S->id == 8)
			{
				type = 0;
				target = (struct _Instance*)collideInfo->inst1;
				COLLIDE_SegmentCollisionOff(instance, 0);
				reaverData = (struct __ReaverData*)instance->extraData;
				switch (reaverData->CurrentReaver)
				{
				case 1:
				case 2:
					type = 4096;
					break;
				case 6:
					type = 32;
					break;
				}
				if (instance->LinkParent != NULL)
				{
					COLLIDE_SegmentCollisionOff(instance, 0);
					INSTANCE_Post(gameTrackerX.playerInstance, 0x0100001F, SetMonsterHitData(instance->LinkParent, target, type, 0, 0));
					INSTANCE_Post(target, 0x400000, SetFXHitData(instance, (unsigned char)collideInfo->segment, 50, type));
				}
			}
		}
	}
	if (collideInfo->type1 != 3U)
	{
		inst = (struct _Instance*)collideInfo->inst1;
		inst->flags |= 4;
	}
	else
	{
		COLLIDE_SetBSPTreeFlag(collideInfo, 0x800);
	}
}

void SoulReaverProcess(struct _Instance* instance, struct GameTracker* gameTracker) // Matching - 100%
{
	struct __ReaverData* data;

	data = (struct __ReaverData*)instance->extraData;

	if ((unsigned char)data->ReaverPickedUp != 0)
	{
		instance->currentStreamUnitID = gameTrackerX.playerInstance->currentStreamUnitID;
	}

	_SoulReaverAnimate(instance);
}


// autogenerated function stub: 
// void /*$ra*/ CollideReaverProjectile(struct _Instance *instance /*$s2*/, struct GameTracker *gameTracker /*$s4*/)
void CollideReaverProjectile(struct _Instance *instance, struct GameTracker *gameTracker)
{ // line 256, offset 0x80079fa4
	UNIMPLEMENTED();
}

unsigned long SoulReaverQuery(struct _Instance* instance, unsigned long query) // Matching - 100%
{
	struct __ReaverData* reaverData;
	unsigned long retval;

	switch (query)
	{
	case 1:
		return 0x20000;
		break;
	case 4:
		return 0x1000;
		break;
	case 40:
		reaverData = (struct __ReaverData*)instance->extraData;
		if (reaverData->ReaverOn != 0)
		{
			if (reaverData->ReaverTargetScale != 0)
			{
				retval = 3;
			}
			else
			{
				retval = 1;
			}
			return retval;
		}
	default:
		retval = 0;
	}
	return retval;
}

void SoulReaverImbue(struct _Instance* instance, int number) // Matching - 100%
{
	long color;
	struct __ReaverTuneData* tuneData;

	tuneData = (struct __ReaverTuneData*)instance->data;
	color = ((long*)tuneData)[number - 1];
	FX_DoBlastRing(instance, (struct _SVector*)&instance->position, instance->matrix, 0, 0x140, 0, 0xF0, 0, 0, -0x10000, 0, 0, 0xA0, 0x140, color, 0, 0, 0x14, 1);
}

void SoulReaverCharge(struct _Instance* instance, struct __ReaverData* data) // Matching - 100%
{
	long color;
	long shock;
	struct __ReaverTuneData* tuneData; // $s1

	tuneData = (struct __ReaverTuneData*)instance->data;
	if (data->ReaverChargeTime != 0)
	{
		data->ReaverChargeTime = data->ReaverChargeTime - gameTrackerX.timeMult;
		if (data->ReaverShockAmount <= 245759)
		{
			data->ReaverShockAmount = data->ReaverShockAmount + gameTrackerX.timeMult;
			shock = (data->ReaverShockAmount / 4096) + 50;
		}
		else
		{
			shock = 110;
		}
		GAMEPAD_Shock1(shock, 20480);

		if (data->ReaverChargeTime <= 0)
		{
			data->ReaverChargeTime += 61440;
			color = ((long*)tuneData)[data->CurrentReaver - 1];
			FX_DoBlastRing(instance, (struct _SVector*)&instance->position, instance->matrix, 0, 360, 0, 0, 0, 0, 0xFFFF0000, 0, 320, 272, 224, color, 0, 0, -1, 1);
		}
	}
}

void StopSoulReaverCharge(struct __ReaverData* data, struct _Instance* instance) // Matching - 100%
{
	data->ReaverChargeTime = 0;
	
	data->ReaverShockAmount = 0;

	GAMEPAD_Shock1(0, 0);

	FX_EndInstanceEffects(instance);
}


void SoulReaverPost(struct _Instance* instance, unsigned long message, unsigned long data) // Matching - 100%
{
	struct __ReaverData* reaverData;

	reaverData = (struct __ReaverData*)instance->extraData;

	switch (message)
	{
	case 0x800002:
		if (instance->LinkParent == NULL)
		{
			INSTANCE_LinkToParent(instance, (struct _Instance*)data, 41);
		}

		reaverData->ReaverOn = 1;

		reaverData->ReaverPickedUp = 1;

		instance->flags &= ~0x800;
		break;
	case 0x800100:
		reaverData->ReaverOn = 1;

		if (reaverData->ReaverTargetScale == 0)
		{
			reaverData->ReaverTargetScale = 4096;
		}

		instance->flags &= ~0x800;
		break;
	case 0x800101:
		reaverData->ReaverOn = 0;

		StopSoulReaverCharge(reaverData, instance);

		instance->flags |= 0x800;
		break;
	case 0x800103:
		reaverData->CurrentReaver = (short)data;

		if ((short)data == 6)
		{
			FireReaverFlag = 1;
		}
		else
		{
			FireReaverFlag = 0;
		}

		SoulReaverImbue(instance, data);
		break;
	case 0x800104:
		reaverData->ReaverChargeTime = 61440;

		INSTANCE_Broadcast(instance, 32, 0x800028, SetObjectAbsorbData(instance, 0, 60));
		break;
	case 0x800107:
		reaverData->ReaverTargetScale = (short)data;
		break;
	case 0x800010:
	{
		SVECTOR oldVector;
		SVECTOR startPos;

		StopSoulReaverCharge(reaverData, instance);

		oldVector.vx = 0;
		oldVector.vy = 0;
		oldVector.vz = 400;

		ApplyMatrixSV(instance->matrix, &oldVector, &startPos);

		startPos.vx += instance->position.x;
		startPos.vy += instance->position.y;
		startPos.vz += instance->position.z;
		{
			struct __ReaverData* reaverData;
			struct evObjectBirthProjectileData* pData;

			reaverData = (struct __ReaverData*)instance->extraData;

			pData = PHYSOB_BirthProjectile(instance->LinkParent, 0, reaverData->CurrentReaver + 2);

			if (pData->birthInstance != NULL)
			{
				pData->birthInstance->collideFunc = CollideReaverProjectile;

				SET_VEC((struct _SVector*)&pData->birthInstance->position, (struct _Position*)&startPos);

				INSTANCE_Post(pData->birthInstance, 0x800010, data);

				SET_VEC((struct _SVector*)&pData->birthInstance->position, (struct _Position*)&startPos);
			}
		}
		break;
	}
	case 0x200002:
		COLLIDE_SegmentCollisionOn(instance, 0);
		break;
	case 0x200003:
		COLLIDE_SegmentCollisionOff(instance, 0);
		break;
	case 0x800105:
		StopSoulReaverCharge(reaverData, instance);
		break;
	case 0x800108:
		reaverData->ReaverTargetScale = 4096;

		instance->flags &= ~0x800;
		break;
	case 0x800109:
		StopSoulReaverCharge(reaverData, instance);

		reaverData->ReaverTargetScale = 0;
		break;
	}
}

unsigned long REAVER_GetGlowColor(struct _Instance* instance) // Matching - 100%
{
	struct __ReaverTuneData* tuneData;
	struct __ReaverData* data;

	data = (struct __ReaverData*)instance->extraData;

	tuneData = (struct __ReaverTuneData*)instance->data;

	return ((unsigned long*)tuneData)[data->CurrentReaver - 1];
}


void _SoulReaverAnimate(struct _Instance* instance) // Matching - 100%
{
	struct __ReaverData* data;
	struct __ReaverTuneData* tuneData;

	data = (struct __ReaverData*)instance->extraData;

	tuneData = (struct __ReaverTuneData*)instance->data;

	FX_SetReaverInstance(instance);

	data->ReaverDeg += 256 + (rand() & 31);

	data->ReaverDeg &= 0xFFF;

	if ((unsigned char)data->ReaverOn == 1)
	{
		if (data->ReaverSize < 4096)
		{
			data->ReaverSize += 256;
		}
	}
	else if (data->ReaverSize > 0)
	{
		data->ReaverSize -= 256;
	}

	if (data->CurrentReaver > 0)
	{
		unsigned long* temp;  // not from SYMDUMP

		temp = &tuneData->spectralInnerColor;

		data->ReaverBladeColor = temp[data->CurrentReaver - 1];

		temp = &tuneData->spectralInnerGlowColor;

		data->ReaverBladeGlowColor = temp[data->CurrentReaver - 1];

		temp = &tuneData->spectralGlowColor;

		data->ReaverGlowColor = temp[data->CurrentReaver - 1];
	}

	if (compare(data->ReaverTargetScale, data->ReaverScale) <= 128)
	{
		data->ReaverScale = data->ReaverTargetScale;
	}
	else
	{
		if (data->ReaverScale > data->ReaverTargetScale)
		{
			data->ReaverScale -= 128;
		}

		if (data->ReaverScale < data->ReaverTargetScale)
		{
			data->ReaverScale += 128;
		}
	}


	if (((unsigned char)data->ReaverOn == 1) && (data->ReaverScale > 0))
	{
		instance->flags &= ~0x800;
	}
	else
	{
		instance->flags |= 0x800;
	}

	SoulReaverCharge(instance, data);
}

int SoulReaverFire() // Matching - 100%
{
	return FireReaverFlag;
}