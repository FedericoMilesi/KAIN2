#include "Game/CORE.H"
#include "ANMCTRLR.H"
#include "POOLMMG2.H"
#include "ANIMG2.H"
#include "Game/PSX/COLLIDES.H"
#include "Game/G2/ANMINTRP.H"
#include "Game/G2/ANMCTRLR.H"
#include "Game/G2/TIMERG2.H"
#include "Game/PSX/PSX_G2/QUATVM.H"

void G2Anim_AttachControllerToSeg(struct _G2Anim_Type *anim, int segNumber, int type)
{
	_G2AnimController_InsertIntoList(_G2AnimController_Create(segNumber, type), &anim->controllerList);
}

void G2Anim_DetachControllerFromSeg(struct _G2Anim_Type* anim, int segNumber, int type) // Matching - 99.90%
{
	struct _G2AnimController_Type* controller;
	unsigned short* controllerNextPtr;

	controllerNextPtr = &anim->controllerList;
	controller = _G2AnimControllerST_FindPtrInList(segNumber, type, &controllerNextPtr);
	if (controller == NULL)
	{
		controllerNextPtr = &anim->disabledControllerList;
		controller = _G2AnimControllerST_FindPtrInList(segNumber, type, &controllerNextPtr);
		if (controller == NULL)
		{
			return;
		}
	}
	controller = _G2AnimController_Destroy(controller);
	*controllerNextPtr = controller - _controllerPool.blockPool;
}

void G2Anim_EnableController(struct _G2Anim_Type* anim, int segNumber, int type)
{
	struct _G2AnimController_Type* controller;
	struct _G2Matrix_Type* segMatrix;
	
	controller = _G2AnimControllerST_RemoveFromList(segNumber, type, &anim->disabledControllerList);

	if (controller != NULL)
	{
		controller->duration = 0;

		controller->elapsedTime = 0;

		controller->flags = (unsigned char)controller->flags;

		if (controller->type == 8)
		{
			G2EulerAngles_ToMatrix_S(&controller->data.quat.dest, &anim->segMatrices[segNumber]);

			_G2AnimController_InsertIntoList(controller, &anim->controllerList);
		}
		else if (controller->type == 0x20)
		{
			segMatrix = &anim->segMatrices[segNumber];

			controller->data.quat.src.x = (unsigned short)segMatrix->trans.x;
			controller->data.quat.src.y = (unsigned short)segMatrix->trans.y;
			controller->data.quat.src.z = (unsigned short)segMatrix->trans.z;

			_G2AnimController_InsertIntoList(controller, &anim->controllerList);
		}
		else
		{
			memset(&controller->data.quat.src, 0, sizeof(struct _G2Quat_Type) * 2);

			_G2AnimController_InsertIntoList(controller, &anim->controllerList);
		}
	}
}

void G2Anim_DisableController(struct _G2Anim_Type* anim, int segNumber, int type)
{ 
	struct _G2AnimController_Type* controller;

	controller = _G2AnimControllerST_RemoveFromList(segNumber, type, &anim->controllerList);

	if (controller != NULL)
	{
		_G2AnimController_InsertIntoList(controller, &anim->disabledControllerList);
	}
}

void G2Anim_InterpDisableController(struct _G2Anim_Type* anim, int segNumber, int type, short duration) { // Matching - 100%
	struct _G2SVector3_Type zeroVector;
	struct _G2Quat_Type targetQuat;
	struct _G2AnimController_Type* controller;

	memset(&zeroVector, 0, 6);
	if (duration == 0 || type == 32)
	{
		G2Anim_DisableController(anim, segNumber, type);
	}
	controller = _G2AnimControllerST_FindInList(segNumber, type, &anim->controllerList);
	if (controller != NULL)
	{
		if (controller->type == 8)
		{
			_G2AnimController_GetSimpleWorldRotQuat(controller, anim, &targetQuat);
			G2Anim_SetInterpController_Quat(anim, segNumber, type, &targetQuat, duration);
		}
		else
		{
			G2Anim_SetInterpController_Vector(anim, segNumber, type, &zeroVector, duration);
		}
		controller->flags |= 0x8000;
	}
}

enum _G2Bool_Enum G2Anim_IsControllerActive(struct _G2Anim_Type* anim, int segNumber, int type)//Matching - 99.74%
{
	struct _G2AnimController_Type* controller;

	controller = _G2AnimControllerST_FindInList(segNumber, type, &anim->controllerList);

	if (controller == NULL)
	{
		return (enum _G2Bool_Enum)0;
	}

	return (enum _G2Bool_Enum)((controller->flags & 0x8000) < 0x8000);
}

enum _G2Bool_Enum G2Anim_IsControllerInterpolating(struct _G2Anim_Type* anim, int segNumber, int type)//Matching - 99.76%
{
	struct _G2AnimController_Type* controller;

	controller = _G2AnimControllerST_FindInList(segNumber, type, &anim->controllerList);

	if (controller == NULL || !(controller->flags & 0x4000))
	{
		return G2FALSE;
	}
	else
	{
		return (enum _G2Bool_Enum)((controller->flags & 0x2000) < 0x2000);
	}
}


// autogenerated function stub: 
// void /*$ra*/ G2Anim_GetControllerCurrentInterpVector(struct _G2Anim_Type *anim /*$s1*/, int segNumber /*$a1*/, int type /*$a2*/, //struct _G2SVector3_Type *vector /*$s0*/)
void G2Anim_GetControllerCurrentInterpVector(struct _G2Anim_Type *anim, int segNumber, int type, struct _G2SVector3_Type *vector)
{ // line 558, offset 0x800906f4
	/* begin block 1 */
		// Start line: 559
		// Start offset: 0x800906F4
		// Variables:
			//struct _G2AnimController_Type *controller; // $v1
			//struct _G2SVector3_Type *base; // $a0
			//struct _G2SVector3_Type *offset; // $a1
			struct _G2Matrix_Type *segMatrix; // $v1

		/* begin block 1.1 */
			// Start line: 579
			// Start offset: 0x80090738
			// Variables:
				//struct _G2SVector3_Type *source; // $a0
				//struct _G2SVector3_Type *dest; // $s0

			/* begin block 1.1.1 */
				// Start line: 579
				// Start offset: 0x80090738
				// Variables:
					unsigned short z; // $v1
					unsigned long xy; // $v0
			/* end block 1.1.1 */
			// End offset: 0x80090738
			// End Line: 579
		/* end block 1.1 */
		// End offset: 0x80090738
		// End Line: 579

		/* begin block 1.2 */
			// Start line: 580
			// Start offset: 0x8009074C
			// Variables:
				//struct _G2SVector3_Type *dest; // $s0
				//struct _G2SVector3_Type *base; // $a0
				//struct _G2SVector3_Type *offset; // $a1
				long alpha; // $v0
		/* end block 1.2 */
		// End offset: 0x8009074C
		// End Line: 580
	/* end block 1 */
	// End offset: 0x80090840
	// End Line: 603

	/* begin block 2 */
		// Start line: 1116
	/* end block 2 */
	// End Line: 1117
				UNIMPLEMENTED();
}

void G2Anim_SetControllerCallbackData(struct _G2Anim_Type* anim, int segNumber, int type, void* callbackData)
{
	_G2Anim_FindController(anim, segNumber, type)->callbackData = callbackData;
}

void G2Anim_SetControllerAngleOrder(struct _G2Anim_Type* anim, int segNumber, int type, int order)
{
	struct _G2AnimController_Type* controller;

	controller = _G2Anim_FindController(anim, segNumber, type);

	controller->flags &= 0xFF00;
	controller->flags |= order;
}

void G2Anim_SetController_Vector(struct _G2Anim_Type* anim, int segNumber, int type, struct _G2SVector3_Type* vector)
{
	struct _G2AnimController_Type* controller;

	controller = _G2Anim_FindController(anim, segNumber, type);

	controller->data.vector.base.x = vector->x;
	controller->data.vector.base.y = vector->y;
	controller->data.vector.base.z = vector->z;

	controller->flags = (unsigned char)controller->flags;
}

void G2Anim_SetInterpController_Vector(struct _G2Anim_Type* anim, int segNumber, int type, struct _G2SVector3_Type* vector, int duration)  // Matching - 99.29%
{
	struct _G2EulerAngles_Type eulerVector;
	struct _G2Quat_Type quat;
	struct _G2AnimController_Type* controller;
	struct _G2SVector3_Type* base;
	struct _G2SVector3_Type* offset;

	controller = _G2Anim_FindController(anim, segNumber, type);

	if ((controller->type & 0x38) == 8)
	{
		_G2Anim_CopyVectorWithOrder(vector, &eulerVector, (unsigned char)controller->flags);

		G2Quat_FromEuler_S(&quat, &eulerVector);

		G2Anim_SetInterpController_Quat(anim, segNumber, type, &quat, (short)duration);
	}
	else
	{
		base = &controller->data.vector.base;

		offset = &controller->data.vector.offset;

		G2Anim_GetControllerCurrentInterpVector(anim, segNumber, type, base);

		offset->x = ((vector->x - base->x) * 4096) / ((short)duration + 1);
		offset->y = ((vector->y - base->y) * 4096) / ((short)duration + 1);
		offset->z = ((vector->z - base->z) * 4096) / ((short)duration + 1);

		controller->duration = duration;
		controller->elapsedTime = 0;
		controller->flags = (unsigned char)controller->flags | 0x4000;
	}
}

void G2Anim_SetInterpController_Quat(struct _G2Anim_Type* anim, int segNumber, int type, struct _G2Quat_Type* quat, int duration)
{
    struct _G2AnimController_Type* controller;
    struct _G2Quat_Type* source;
    unsigned long zw;
    unsigned long xy;

    source = quat;
    
    controller = _G2Anim_FindController(anim, segNumber, type);
    
    _G2AnimController_GetCurrentInterpQuat(controller, anim, &controller->data.quat.src);
    
    xy = *(unsigned long*)&source->x;
    zw = *(unsigned long*)&source->z;
    
    controller->elapsedTime = 0;
    
    *(unsigned int*)&controller->data.quat.dest.x = xy;
    *(unsigned int*)&controller->data.quat.dest.z = zw;

    controller->flags = (unsigned char)controller->flags | 0x4000;
    
    controller->duration = duration;
}

void _G2Anim_ApplyControllersToStoredFrame(struct _G2Anim_Type* anim)  // Matching - 100%
{
	int i;

	for (i = 0; i < anim->sectionCount; i++)
	{
		_G2AnimSection_ApplyControllersToStoredFrame(&anim->section[i]);
	}
}

void _G2Anim_BuildTransformsWithControllers(struct _G2Anim_Type* anim)
{
	struct _Segment* segment;
	struct _G2AnimController_Type* controller;
	struct _G2Matrix_Type* segMatrix;
	struct _G2Matrix_Type* parentMatrix;
	enum _G2Bool_Enum bRootTransUpdated;
	int segIndex;
	int segCount;
	unsigned long disabledBits[3];
	unsigned long disabledMask;
	unsigned long parentMask;
	unsigned long parentIndex;
	unsigned long* disabledBitsArray;///@FIXME not in original

	disabledMask = 1;
	
	segMatrix = anim->segMatrices;
	
	segment = anim->modelData->segmentList;

	disabledBits[0] = anim->disabledBits[0];
	disabledBits[1] = anim->disabledBits[1];
	disabledBits[2] = anim->disabledBits[2];

	bRootTransUpdated = (enum _G2Bool_Enum)(((anim->section[0].flags & 0x88) ^ 0x80) < 1);

	segCount = anim->modelData->numSegments;
	
	controller = &_controllerPool.blockPool[anim->controllerList];
	
	disabledBitsArray = &disabledBits[0];

	for (segIndex = 0; segIndex < segCount; segIndex++)
	{
		if (segment->parent != -1 && (disabledBits[segment->parent >> 5] & (1 << (segment->parent & 0x1F))))
		{
			disabledBitsArray[0] |= disabledMask;
		}

		if (!(disabledBitsArray[0] & disabledMask))
		{
			parentMatrix = &anim->segMatrices[segment->parent];

			if (segIndex == controller->segNumber)
			{
				_G2Anim_BuildSegTransformWithControllers(segMatrix, parentMatrix, controller, bRootTransUpdated, segIndex);

				bRootTransUpdated = G2FALSE;

				while (segIndex == controller->segNumber)
				{
					controller = &_controllerPool.blockPool[controller->next];
				}

				segment++;
			}
			else
			{
				_G2Anim_BuildSegTransformNoControllers(segMatrix, parentMatrix, bRootTransUpdated, segIndex);

				bRootTransUpdated = G2FALSE;

				segment++;
			}
		}
		else
		{
			segment++;
		}

		segMatrix++;

		if (disabledMask == 0)
		{
			disabledMask = 1;

			disabledBitsArray++;
		}
	}

	_G2Anim_UpdateControllers(anim);
}
void _G2Anim_BuildSegTransformWithControllers(struct _G2Matrix_Type* segMatrix, struct _G2Matrix_Type* parentMatrix, struct _G2AnimController_Type* controller, enum _G2Bool_Enum bRootTransUpdated, int segIndex)
{
	struct _G2AnimSegValue_Type* segValue;
	struct _G2LVector3_Type scale;
	unsigned long flags;
	struct _G2SVector3_Type* svector;
	struct _G2LVector3_Type* lvector;

	segValue = &_segValues[segIndex];

	_G2Anim_BuildSegLocalRotMatrix(segValue, segMatrix);

	flags = 0x7;

	while (controller->segNumber == segIndex)
	{
		flags &= _G2AnimController_ApplyToSegValue(controller, segValue, segMatrix, parentMatrix);

		controller = &_controllerPool.blockPool[controller->next];
	}

	gte_SetRotMatrix(parentMatrix);

	scale.x = segValue->scale.x;
	scale.y = segValue->scale.y;
	scale.z = segValue->scale.z;

	if ((scale.x | scale.y | scale.z) != ONE)
	{
		ScaleMatrix((MATRIX*)segMatrix, (VECTOR*)&scale);

		segMatrix->scaleFlag = 1;
	}

	if ((flags & 0x1))
	{
		gte_ldclmv(((short*)segMatrix) + 0);

		gte_rtir();

		gte_stclmv(((short*)segMatrix) + 0);

		gte_ldclmv(((short*)segMatrix) + 1);

		gte_rtir();

		gte_stclmv(((short*)segMatrix) + 1);

		gte_ldclmv(((short*)segMatrix) + 2);

		gte_rtir();

		gte_stclmv(((short*)segMatrix) + 2);
	}
	
	if ((flags & 0x4))
	{
		if (segIndex == 0)
		{
			gte_SetRotMatrix(segMatrix);
		}

		svector = &segValue->trans;
		lvector = &segMatrix->trans;

		gte_ldv0(svector);

		gte_rtv0();

		gte_stlvnl(lvector);
	}
	else
	{
		segMatrix->trans.x = segValue->trans.x;
		segMatrix->trans.y = segValue->trans.y;
		segMatrix->trans.z = segValue->trans.z;
	}

	if (bRootTransUpdated != G2FALSE)
	{
		parentMatrix->trans.x += segMatrix->trans.x;
		parentMatrix->trans.y += segMatrix->trans.y;
		parentMatrix->trans.z += segMatrix->trans.z;

		segMatrix->trans.x = 0;
		segMatrix->trans.y = 0;
		segMatrix->trans.z = 0;
	}

	segMatrix->trans.x += parentMatrix->trans.x;
	segMatrix->trans.y += parentMatrix->trans.y;
	segMatrix->trans.z += parentMatrix->trans.z;
}

unsigned long _G2AnimController_ApplyToSegValue(struct _G2AnimController_Type* controller, struct _G2AnimSegValue_Type* segValue, struct _G2Matrix_Type* segMatrix, struct _G2Matrix_Type* parentMatrix)
{
	struct _G2Matrix_Type tempMatrix;
	struct _G2SVector3_Type tempVector;
	unsigned long flags;
	unsigned short z;
	unsigned long xy;

	if (!(((unsigned int*)controller)[0] & 0xFF020000))
	{
		_G2AnimController_ApplyWorldToParentMatrix(controller, parentMatrix);
	}
	else
	{
		flags = 0x7;

		switch (controller->type)
		{
		case 1:
		{
			flags = controller->data.callback.function(controller, segValue, parentMatrix, segMatrix);
			break;
		}
		case 8:
		{
			flags &= 0xFFFFFFFE;
		}
		case 10:
		{
			_G2AnimController_GetMatrix(controller, segMatrix);

			break;
		}
		case 76:
		{
			flags &= 0xFFFFFFFE;

			gte_SetRotMatrix(parentMatrix);

			gte_ldclmv(((short*)segMatrix) + 0);

			gte_rtir();

			gte_stclmv(((short*)segMatrix) + 0);

			gte_ldclmv(((short*)segMatrix) + 1);

			gte_rtir();

			gte_stclmv(((short*)segMatrix) + 1);

			gte_ldclmv(((short*)segMatrix) + 2);

			gte_rtir();

			gte_stclmv(((short*)segMatrix) + 2);
		}
		case 14:
		{
			_G2AnimController_GetMatrix(controller, &tempMatrix);

			gte_SetRotMatrix(&tempMatrix);

			gte_ldclmv(((short*)&tempMatrix) + 0);

			gte_rtir();

			gte_stclmv(((short*)&tempMatrix) + 0);

			gte_ldclmv(((short*)&tempMatrix) + 1);

			gte_rtir();

			gte_stclmv(((short*)&tempMatrix) + 1);

			gte_ldclmv(((short*)&tempMatrix) + 2);

			gte_rtir();

			gte_stclmv(((short*)&tempMatrix) + 2);

			break;
		}
		case 16:
		{
			flags &= 0xFFFFFFFD;
		}
		case 18:
		{
			_G2AnimController_GetVector(controller, &tempVector);

			segValue->scale.x = tempVector.x;
			segValue->scale.y = tempVector.y;
			segValue->scale.z = tempVector.z;

			break;
		}
		case 22:
		{
			_G2AnimController_GetVector(controller, &tempVector);

			segValue->scale.x += tempVector.x;
			segValue->scale.y += tempVector.y;
			segValue->scale.z += tempVector.z;

			break;
		}
		case 32:
		{
			flags &= 0xFFFFFFFB;

			_G2AnimController_GetVector(controller, &tempVector);

			segValue->scale.x -= tempVector.x;
			segValue->scale.y -= tempVector.y;
			segValue->scale.z -= tempVector.z;

			break;
		}
		case 34:
		{
			_G2AnimController_GetVector(controller, &tempVector);

			segValue->trans.x = tempVector.x;
			segValue->trans.y = tempVector.y;
			segValue->trans.z = tempVector.z;
			break;
		}
		case 38:
		{
			_G2AnimController_GetVector(controller, &tempVector);

			segValue->trans.x += tempVector.x;
			segValue->trans.y += tempVector.y;
			segValue->trans.z += tempVector.z;
			break;
		}
		}
	}

	return flags;
}

void _G2Anim_UpdateControllers(struct _G2Anim_Type* anim)//Matching - 99.70%
{
	struct _G2AnimController_Type* controller;
	struct _G2AnimSection_Type* section;
	short elapsedTime;

	if (anim->controllerList)
	{
		elapsedTime = G2Timer_GetFrameTime();

		controller = _controllerPool.blockPool + anim->controllerList;

		while (_controllerPool.blockPool < controller)
		{
			if ((controller->flags & 0x4000))
			{
				if (controller->elapsedTime >= controller->duration)
				{
					if ((controller->flags & 0x8000))
					{
						controller->flags &= 0x7FFF;
						
						_G2AnimControllerST_RemoveFromList(controller->segNumber, controller->type, &anim->controllerList);

						_G2AnimController_InsertIntoList(controller, &anim->disabledControllerList);
					}
					else if ((controller->flags & 0x2000) == 0)
					{
						controller->flags |= 0x2000;
						
						section = G2Anim_GetSectionWithSeg(anim, controller->segNumber);

						if (section)
						{
							if (section->callback)
							{
								section->callback(anim, section->sectionID, G2ANIM_MSG_SEGCTRLR_INTERPDONE, controller->type, controller->segNumber, (struct _Instance*)controller->callbackData);
							}
						}
					}
				}
				else
				{
					controller->elapsedTime += elapsedTime;

					if (controller->duration < controller->elapsedTime)
					{
						controller->elapsedTime = controller->duration;
					}
				}
			}
			controller = _controllerPool.blockPool + controller->next;
		}
	}
}

void _G2Anim_CopyVectorWithOrder(struct _G2SVector3_Type* sourceVector, struct _G2EulerAngles_Type* destVector, int order)//Matching - 100%
{
    if (order != 1)
    {
        if (order == 21)
        {
            destVector->x = sourceVector->x;
            destVector->y = sourceVector->y;
            destVector->z = sourceVector->z;
            destVector->order = order;
        }
    }
    else
    {
        destVector->x = sourceVector->z;
        destVector->y = sourceVector->y;
        destVector->z = sourceVector->x;
        destVector->order = order;
    }
}


// autogenerated function stub: 
// void /*$ra*/ _G2AnimSection_ApplyControllersToStoredFrame(struct _G2AnimSection_Type *section /*$s3*/)
void _G2AnimSection_ApplyControllersToStoredFrame(struct _G2AnimSection_Type *section)
{ // line 1181, offset 0x800915c0
	/* begin block 1 */
		// Start line: 1182
		// Start offset: 0x800915C0
		// Variables:
			struct _G2Anim_Type *anim; // $s7
			//struct _G2AnimController_Type *controller; // $s0
			struct _G2AnimSegValue_Type *segValue; // $s1
			struct _Segment *segment; // $s6
			struct _G2Matrix_Type segMatrix; // stack offset -152
			struct _G2Matrix_Type parentMatrix; // stack offset -120
			struct _G2Matrix_Type invParentMatrix; // stack offset -88
			struct _G2EulerAngles_Type eulerAngles; // stack offset -56
			int segIndex; // $s2
			int segCount; // $fp

		/* begin block 1.1 */
			// Start line: 1237
			// Start offset: 0x80091760
			// Variables:
				struct _G2Quat_Type tempQuat; // stack offset -48

			/* begin block 1.1.1 */
				// Start line: 1239
				// Start offset: 0x80091760
				// Variables:
					struct _G2Quat_Type *dest; // $s1

				/* begin block 1.1.1.1 */
					// Start line: 1239
					// Start offset: 0x80091760
					// Variables:
						unsigned long zw; // $v1
						//unsigned long xy; // $v0
				/* end block 1.1.1.1 */
				// End offset: 0x80091760
				// End Line: 1239
			/* end block 1.1.1 */
			// End offset: 0x80091760
			// End Line: 1239
		/* end block 1.1 */
		// End offset: 0x80091760
// End Line: 1239

/* begin block 1.2 */
	// Start line: 1242
	// Start offset: 0x8009177C
	// Variables:
		//struct _G2SVector3_Type *dest; // $s1

	/* begin block 1.2.1 */
		// Start line: 1242
		// Start offset: 0x8009177C
		// Variables:
unsigned long mask; // $v0
unsigned short z; // $v1
unsigned long xy; // $a0
/* end block 1.2.1 */
// End offset: 0x8009177C
// End Line: 1242
/* end block 1.2 */
// End offset: 0x8009177C
// End Line: 1242
/* end block 1 */
// End offset: 0x80091804
// End Line: 1260

/* begin block 2 */
	// Start line: 2436
/* end block 2 */
// End Line: 2437
UNIMPLEMENTED();

}

unsigned long _G2AnimController_ApplyWorldToParentMatrix(struct _G2AnimController_Type* controller, struct _G2Matrix_Type* parentMatrix) // Matching - 100%
{
	struct _G2Matrix_Type tempMatrix;
	struct _G2SVector3_Type tempSVector;
	struct _G2LVector3_Type tempLVector;

	switch (controller->type)
	{
	case 8:
		_G2AnimController_GetMatrix(controller, parentMatrix);
		break;
	case 16:
		break;
	case 76:
		_G2AnimController_GetMatrix(controller, &tempMatrix);
		MulMatrix2((MATRIX*)&tempMatrix, (MATRIX*)parentMatrix);
		break;
	case 84:
		_G2AnimController_GetVector(controller, &tempSVector);
		tempLVector.x = tempSVector.x;
		tempLVector.y = tempSVector.y;
		tempLVector.z = tempSVector.z;
		ScaleMatrix((MATRIX*)parentMatrix, (VECTOR*)&tempLVector);
		break;
	case 32:
		_G2AnimController_GetVector(controller, &tempSVector);
		parentMatrix->trans.x = tempSVector.x;
		parentMatrix->trans.y = tempSVector.y;
		parentMatrix->trans.z = tempSVector.z;
		break;
	case 100:
		_G2AnimController_GetVector(controller, &tempSVector);
		parentMatrix->trans.x += tempSVector.x;
		parentMatrix->trans.y += tempSVector.y;
		parentMatrix->trans.z += tempSVector.z;
		break;
	}
	return 7;
}

void _G2AnimController_GetMatrix(struct _G2AnimController_Type* controller, struct _G2Matrix_Type* matrix)
{
	struct _G2Quat_Type tempQuat;

	if ((controller->flags & 0x4000))
	{
		if ((controller->flags & 0x2000))
		{
			G2Quat_ToMatrix_S(&controller->data.quat.dest, matrix);
		}
		else
		{
			G2Quat_Slerp_VM(_G2AnimAlphaTable_GetValue(controller->alphaTable, (controller->elapsedTime << 12) / controller->duration), &controller->data.quat.src, &controller->data.quat.dest, &tempQuat, 0);
			G2Quat_ToMatrix_S(&tempQuat, matrix);
		}
	}
	else
	{
		if ((controller->flags & 0xFF) != 1)
		{
			if ((controller->flags & 0xFF) == 21)
			{
				RotMatrix((SVECTOR*)&controller->data.vector.base, (MATRIX*)matrix);
			}
		}
		else
		{
			RotMatrixZYX((SVECTOR*)&controller->data.vector.base, (MATRIX*)matrix);
		}
	}
}

void _G2AnimController_GetVector(struct _G2AnimController_Type* controller, struct _G2SVector3_Type* vector)
{
	struct _G2SVector3_Type* dest;
	unsigned short z;
	unsigned long xy;
	struct _G2SVector3_Type* base;
	struct _G2SVector3_Type* offset;
	long alpha;

	base = &controller->data.vector.base;

	dest = vector;

	dest->x = base->x;
	dest->y = base->y;
	dest->z = base->z;

	offset = &controller->data.vector.offset;

	if ((controller->flags & 0x4000))
	{
		alpha = controller->elapsedTime;

		gte_ldlvnlsv(dest);

		gte_ldsv(offset);

		gte_lddp(alpha);

		gte_gpl12();

		gte_stlvnlsv(dest);
	}
}

struct _G2AnimController_Type* _G2Anim_FindController(struct _G2Anim_Type* anim, int segNumber, int type)//Matching - 100%
{
	struct _G2AnimController_Type* controller;
	
	controller = _G2AnimControllerST_FindInList(segNumber, type, &anim->controllerList);

	if (controller == NULL)
	{
		controller = _G2AnimControllerST_FindInList(segNumber, type, &anim->disabledControllerList);
	}

	return controller;
}

struct _G2AnimController_Type* _G2AnimController_Create(int segNumber, int type)
{
	struct _G2AnimController_Type* controller;
	
	controller = (struct _G2AnimController_Type*)G2PoolMem_Allocate(&_controllerPool);

	memset(controller, 0, sizeof(struct _G2AnimController_Type));

	controller->next = 0;
	controller->segNumber = segNumber;
	controller->type = type;
	controller->flags = 0x15;

	return controller;
}

struct _G2AnimController_Type* _G2AnimController_Destroy(struct _G2AnimController_Type* controller) // Matching - 95.20%
{
	int nextControllerIndex;

	do
	{
		nextControllerIndex = controller->next;
		G2PoolMem_Free(&_controllerPool, controller);
		controller = &_controllerPool.blockPool[nextControllerIndex];
		if (controller <= _controllerPool.blockPool)
		{
			break;
		}
	} while (controller->type == 0);

	return controller;
}

void _G2AnimController_InsertIntoList(struct _G2AnimController_Type* controller, unsigned short* listPtr)//Matching - 91.64%
{
	struct _G2AnimController_Type* testController;

	testController = &_controllerPool.blockPool[listPtr[0]];

	while (_controllerPool.blockPool < testController)
	{
		if ((controller->segNumber >= testController->segNumber) && ((testController->segNumber != controller->segNumber) || (controller->type >= testController->type)))
		{
			listPtr = (unsigned short*)testController;
			testController = &_controllerPool.blockPool[testController->next];
		}
		else
		{
			break;
		}
	}

	listPtr[0] = ((controller - _controllerPool.blockPool));

	do
	{
		listPtr = (unsigned short*)controller;
		controller = &_controllerPool.blockPool[listPtr[0]];

	} while (_controllerPool.blockPool < controller);

	listPtr[0] = ((testController - _controllerPool.blockPool));
}

void _G2AnimController_GetCurrentInterpQuat(struct _G2AnimController_Type* controller, _G2Anim_Type* anim, struct _G2Quat_Type* quat)//Matching - 88.61%
{
    struct _G2EulerAngles_Type eulerVector;

    if ((controller->flags & 0x4000))
    {
        if ((controller->flags & 0x2000))
        {
            *quat = controller->data.quat.dest;
        }
        else
        {
            G2Quat_Slerp_VM(_G2AnimAlphaTable_GetValue(controller->alphaTable, (controller->elapsedTime * 4096) / controller->duration), &controller->data.quat.src, &controller->data.quat.dest, quat, 0);
        }
    }
    else
    {
        if (controller->type == 8)
        {
            G2EulerAngles_ToMatrix_S(quat, &anim->segMatrices[controller->segNumber]);
        }
        else if (controller->type == 76)
        {
            *(unsigned int*)&quat->x = 0;
            *(unsigned int*)&quat->z = 4096 << 16;
        }
        else
        {
            if (controller->type == 14)
            {
                _G2Anim_CopyVectorWithOrder(&controller->data.vector.base, &eulerVector, controller->flags & 0xFF);
            }
            else
            {
                G2Anim_GetSegChannelValue(anim, controller->segNumber, (unsigned short*)&eulerVector, 7);
                eulerVector.order = 0;
            }
            G2Quat_FromEuler_S(quat, &eulerVector);

        }
    }
}

void _G2AnimController_GetSimpleWorldRotQuat(struct _G2AnimController_Type* controller, struct _G2Anim_Type* anim, struct _G2Quat_Type* quat) // Matching - 99.84%
{
	struct _Segment* segment;
	struct _G2Matrix_Type* parentMatrix;
	struct _G2Matrix_Type segMatrix;
	int segNumber;

	segNumber = controller->segNumber;
	segment = &anim->modelData->segmentList[segNumber];
	parentMatrix = &anim->segMatrices[segment->parent];
	_G2Anim_BuildSegLocalRotMatrix(&_segValues[segNumber], &segMatrix);
	MulMatrix2((MATRIX*)parentMatrix, (MATRIX*)&segMatrix);
	G2EulerAngles_ToMatrix_S(quat, &segMatrix);
}

struct _G2AnimController_Type* _G2AnimControllerST_FindInList(int segNumber, int type, unsigned short* listPtr)
{
    struct _G2AnimController_Type* controller;

    controller = (struct _G2AnimController_Type*)listPtr;

    while (_controllerPool.blockPool < (controller = &_controllerPool.blockPool[controller->next]))
    {
        if (controller->segNumber != segNumber || controller->type != type)
        {
            listPtr = (unsigned short*)controller;
        }
        else
        {
            break;
        }
    }

    if (controller == _controllerPool.blockPool)
    {
        return NULL;
    }

    return controller;
}

struct _G2AnimController_Type* _G2AnimControllerST_FindPtrInList(int segNumber, int type, unsigned short** listPtrPtr) // Matching - 99.63%
{
	struct _G2AnimController_Type* controller;

	controller = &_controllerPool.blockPool[**listPtrPtr];
	while (_controllerPool.blockPool < controller)
	{
		if (controller->segNumber == segNumber && controller->type == type)
		{
			break;
		}
		*listPtrPtr = (unsigned short*)controller;
		controller = &_controllerPool.blockPool[controller->next];
	}
	if (controller == _controllerPool.blockPool)
	{
		*listPtrPtr = NULL;
		return NULL;
	}
	return controller;
}

struct _G2AnimController_Type* _G2AnimControllerST_RemoveFromList(int segNumber, int type, unsigned short* listPtr)//Matching - 83.37%
{
	struct _G2AnimController_Type* controller;
	struct _G2AnimController_Type* stepController;
	struct _G2AnimController_Type* nextController;

	if ((controller = &_controllerPool.blockPool[listPtr[0]]) > _controllerPool.blockPool)
	{
		while ((controller = &_controllerPool.blockPool[listPtr[0]]) > _controllerPool.blockPool)
		{
			if (controller->segNumber != segNumber || controller->type != type)
			{
				nextController = controller;

				listPtr = (unsigned short*)controller;

				controller = &_controllerPool.blockPool[listPtr[0]];
			}
			else
			{
				break;
			}
		}

		nextController = controller;
		while (nextController > _controllerPool.blockPool)
		{
			stepController = nextController;
			nextController = &_controllerPool.blockPool[nextController->next];

			listPtr[0] = stepController->next;

			if (nextController <= _controllerPool.blockPool || nextController->type != 0)
			{
				stepController->next = 0;

				return controller;
			}
		}
	}
	return NULL;
}