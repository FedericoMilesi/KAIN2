#include "CORE.H"
#include "INSTNCG2.H"
#include "G2/ANIMG2.H"
#include "MATH3D.H"

void G2Instance_BuildTransformsForList(struct _Instance* listHead)//Matching - 99.74%
{
	struct _Instance* instance;

	instance = listHead;

	while (instance != NULL)
	{
		if (instance->LinkParent == NULL)
		{
			if ((instance->flags2 & 0x1) || ((instance->flags & 0x100000) &&
				(instance->oldPos.x == instance->position.x) &&
				(instance->oldPos.y == instance->position.y) &&
				(instance->oldPos.z == instance->position.z) &&
				(instance->oldRotation.x == instance->rotation.x) &&
				(instance->oldRotation.y == instance->rotation.y) &&
				(instance->oldRotation.z == instance->rotation.z) &&
				(instance->matrix != NULL) && (((instance->object->animList == NULL)) ||
				(instance->object->oflags2 & 0x40000000) || !(instance->anim.flags & 0x1))))
			{

				_G2Instance_BuildDeactivatedTransforms(instance);
			}
			else
			{
				G2Instance_BuildTransforms(instance);
			}
		}

		instance = instance->next;
	}

	instance = listHead;

	while (instance != NULL)
	{
		if (instance->rebuildCallback != NULL)
		{
			if (instance->rebuildCallback(instance) != FALSE)
			{
				G2Anim_UpdateStoredFrame(&instance->anim);

				G2Instance_RebuildTransforms(instance);
			}
		}

		instance = instance->next;
	}
}

void G2Instance_BuildTransforms(struct _Instance* instance)
{
	if (instance->object->animList != NULL && !(instance->object->oflags2 & 0x40000000))
	{
		_G2Instance_BuildAnimatedTransforms(instance);
	}
	else
	{
		_G2Instance_BuildNonAnimatedTransforms(instance);
	}
}


// autogenerated function stub: 
// void /*$ra*/ G2Instance_RebuildTransforms(struct _Instance *instance /*$a0*/)
void G2Instance_RebuildTransforms(struct _Instance *instance)
{ // line 169, offset 0x80094f68
	struct Object *object; // eax
#if defined(PC_VERSION)
  object = instance->object;
  if ( !object->animList || (object->oflags2 & 0x40000000) != 0 )
    G2Instance_RebuildNonAnimatedTransforms(instance);
  else
    G2Instance_RebuildAnimatedTransforms(instance);
#endif
}

struct _G2AnimKeylist_Type * G2Instance_GetKeylist(struct _Instance *instance, int id)
{
	return instance->object->animList[id];
}


// autogenerated function stub: 
// void /*$ra*/ _G2Instance_RebuildAnimatedTransforms(struct _Instance *instance /*$s3*/)
void _G2Instance_RebuildAnimatedTransforms(struct _Instance *instance)
{ // line 196, offset 0x80094fe4
	/* begin block 1 */
		// Start line: 197
		// Start offset: 0x80094FE4
		// Variables:
			struct _Model *model; // $s7
			struct _G2Matrix_Type *rootMatrix; // $s4
			struct _Rotation pre_facade_rot; // stack offset -120
			struct _G2Matrix_Type *segMatrix; // $a2
			struct _G2Matrix_Type seg1RotMatrix; // stack offset -112
			struct _G2Matrix_Type seg2RotMatrix; // stack offset -80
			struct _G2SVector3_Type rotVector; // stack offset -48
			long otx; // $s6
			long oty; // $s5
			long otz; // $s2
			long segIndex; // $s1

		/* begin block 1.1 */
			// Start line: 220
			// Start offset: 0x80095048
		/* end block 1.1 */
		// End offset: 0x80095094
		// End Line: 229

		/* begin block 1.2 */
			// Start line: 283
			// Start offset: 0x80095244
			// Variables:
				//struct VECTOR *ins_scale; // $v1
		/* end block 1.2 */
		// End offset: 0x80095278
		// End Line: 291
	/* end block 1 */
	// End offset: 0x800953EC
	// End Line: 346

	/* begin block 2 */
		// Start line: 415
	/* end block 2 */
	// End Line: 416
UNIMPLEMENTED();
}

void G2Instance_ClearMatrices(struct _Instance* instance)
{ 
	instance->oldMatrix = instance->matrix;

	instance->matrix = NULL;

	instance = instance->LinkChild;

	while (instance != NULL)
	{
		G2Instance_ClearMatrices(instance);

		instance = instance->LinkSibling;
	}
}

void _G2Instance_BuildAnimatedTransforms(struct _Instance* instance)
{
	MATRIX* rootMatrix;
	struct _Model* model;

	if ((instance->flags2 & 0x10000000) && (instance->flags2 & 0x4000000) || (instance->flags2 & 0x20000000) && (instance->flags & 0x800))
	{
		G2Instance_ClearMatrices(instance);
		
		return;
	}

	model = instance->object->modelList[instance->currentModel];

	rootMatrix = (MATRIX*)GAMELOOP_GetMatrices(model->numSegments + 1);

	if (rootMatrix == NULL)
	{
		instance->matrix = NULL;
		return;
	}

	instance->oldMatrix = instance->matrix;

	instance->matrix = rootMatrix + 1;

	_G2Instance_RebuildAnimatedTransforms(instance);
}

void _G2Instance_RebuildNonAnimatedTransforms(struct _Instance* instance)
{
	VECTOR* scale;
	MATRIX* introTransform;
	MATRIX* segMatrix;
	struct _Model* model;
	struct _Segment* segment;
	short scale_flag;
	long i;

	scale = (VECTOR*)getScratchAddr(10);
	segMatrix = instance->matrix;
	introTransform = (MATRIX*)getScratchAddr(14);
	scale_flag = 0;

	if (segMatrix != NULL)
	{
		model = instance->object->modelList[instance->currentModel];
		
		segment = model->segmentList;

		if (instance->scale.x != 4096 || instance->scale.y != 4096 || instance->scale.z != 4096)
		{
			scale->vx = instance->scale.x;
			scale->vy = instance->scale.y;
			scale->vz = instance->scale.z;

			scale_flag = 1;
		}
		
		for (i = 0; i < model->numSegments; i++, segMatrix++, segment++)
		{
			if (segment->lastTri != -1)
			{
				if ((segment->flags & 0x3))
				{
					RotMatrix((SVECTOR*)&instance->rotation, introTransform);

					if (scale_flag != 0)
					{
						ScaleMatrix(introTransform, scale);
					}

					_G2Instance_BuildFacadeTransforms(instance, segment, segMatrix, introTransform, scale_flag);
				}
				else
				{
					if ((instance->flags & 0x1) && instance->intro != NULL)
					{
						((long*)segMatrix)[0] = (long)instance->intro->data;
						((long*)segMatrix)[1] = (long)instance->intro->instance;
						((long*)segMatrix)[2] = (long)instance->intro->multiSpline;
						((long*)segMatrix)[3] = (long)instance->intro->dsignal;

						((long*)segMatrix)[4] = (long)((long*)&instance->intro->multiSpline->curRotMatrix)[4];
						((long*)segMatrix)[5] = (long)instance->intro->multiSpline->curRotMatrix.t[0];
						((long*)segMatrix)[6] = (long)instance->intro->multiSpline->curRotMatrix.t[1];
						((long*)segMatrix)[7] = (long)instance->intro->multiSpline->curRotMatrix.t[2];
					}
					else
					{
						if (instance->rotation.z != 0 || instance->rotation.x != 0 || instance->rotation.y != 0)
						{
							RotMatrix((SVECTOR*)&instance->rotation, segMatrix);
						}
						else
						{
							MATH3D_SetUnityMatrix(segMatrix);
						}
					}

					if (scale_flag != 0)
					{
						ScaleMatrix(segMatrix, scale);
					}
					
					segMatrix->t[0] = instance->position.x;
					segMatrix->t[1] = instance->position.y;
					segMatrix->t[2] = instance->position.z;
				}
			}

			((short*)segMatrix)[9] = scale_flag;
		}

		instance = instance->LinkChild;

		while (instance != NULL)
		{
			G2Instance_BuildTransforms(instance);
			instance = instance->LinkSibling;
		}
	}
}

void _G2Instance_BuildDeactivatedTransforms(struct _Instance* instance)
{ 
	MATRIX* segMatrix;
	MATRIX* startOldMatrix;
	int numMatrices;
	struct _Model* model;

	if ((instance->flags2 & 0x10000000) && ((instance->flags2 & 0x04000000) || ((instance->flags2 & 0x20000000) && (instance->flags & 0x800))))
	{
		G2Instance_ClearMatrices(instance);
		return;
	}

	if (instance->matrix == NULL)
	{
		G2Instance_BuildTransforms(instance);
		return;
	}
	
	model = instance->object->modelList[instance->currentModel];
	
	if (instance->object->animList != NULL && !(instance->object->oflags2 & 0x40000000))
	{
		numMatrices = model->numSegments + 1;
	}
	else
	{
		numMatrices = model->numSegments;
	}

	segMatrix = GAMELOOP_GetMatrices(numMatrices);

	if (segMatrix == NULL)
	{
		instance->matrix = NULL;
		return;
	}

	startOldMatrix = instance->matrix;

	instance->oldMatrix = startOldMatrix;

	if (instance->object->animList != NULL)
	{
		startOldMatrix--;
		
		if (!(instance->object->oflags2 & 0x40000000))
		{
			instance->matrix = segMatrix + 1;
		}
		else
		{
			startOldMatrix = instance->oldMatrix;

			instance->matrix = segMatrix;
		}
	}
	else
	{
		startOldMatrix = instance->oldMatrix;

		instance->matrix = segMatrix;
	}

	if (instance->oldMatrix != NULL)
	{
		memcpy(segMatrix, startOldMatrix, numMatrices + 5);///@FIXME bug/size error?
	}
	
	instance = instance->LinkChild;

	while (instance != NULL)
	{
		G2Instance_BuildTransforms(instance);

		instance = instance->LinkSibling;
	}
}

void _G2Instance_BuildNonAnimatedTransforms(struct _Instance* instance)
{
	MATRIX* segMatrix;
	struct _Model* model;

	if ((instance->flags2 & 0x10000000) && (instance->flags2 & 0x4000000) && (instance->flags2 & 0x20000000) && (instance->flags & 0x800))
	{
		G2Instance_ClearMatrices(instance);
	}
	else
	{
		model = instance->object->modelList[instance->currentModel];

		segMatrix = GAMELOOP_GetMatrices(model->numSegments);

		if (segMatrix == NULL)
		{
			instance->matrix = NULL;
		}
		else
		{
			instance->oldMatrix = instance->matrix;
			instance->matrix = segMatrix;

			_G2Instance_RebuildNonAnimatedTransforms(instance);
		}
	}
}


// autogenerated function stub: 
// void /*$ra*/ _G2Instance_BuildFacadeTransforms(struct _Instance *instance /*$s0*/, struct _Segment *segment /*$s1*/, MATRIX *segMatrix /*$s5*/, MATRIX *matrixPool /*$s6*/, long scale_flag /*stack 16*/)
void _G2Instance_BuildFacadeTransforms(struct _Instance *instance, struct _Segment *segment, MATRIX *segMatrix, MATRIX *matrixPool, long scale_flag)
{ // line 619, offset 0x800959f0
	/* begin block 1 */
		// Start line: 620
		// Start offset: 0x800959F0
		// Variables:
			_Position *cameraPos; // $s7
			SVECTOR*segmentPos; // $s3
			SVECTOR*segmentRot; // $s4
			//struct VECTOR *scale; // $fp

		/* begin block 1.1 */
			// Start line: 644
			// Start offset: 0x80095B1C
			// Variables:
				SVECTOR*zvec; // $s1
				SVECTOR*camWorldPos; // $s2
				SVECTOR*camLocPos; // $s6
				long sqrt; // $s0
		/* end block 1.1 */
		// End offset: 0x80095C38
		// End Line: 676

		/* begin block 1.2 */
			// Start line: 683
			// Start offset: 0x80095C98
			// Variables:
				//struct VECTOR *xy; // $s0
		/* end block 1.2 */
		// End offset: 0x80095D5C
		// End Line: 702
	/* end block 1 */
	// End offset: 0x80095D5C
	// End Line: 703

	/* begin block 2 */
		// Start line: 1488
	/* end block 2 */
	// End Line: 1489
				UNIMPLEMENTED();
}




