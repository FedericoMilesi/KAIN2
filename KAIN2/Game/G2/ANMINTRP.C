#include "CORE.H"
#include "ANMINTRP.H"
#include "ANIMG2.H"
#include "ANMG2ILF.H"
#include "PSX/PSX_G2/QUATVM.H"
#include "POOLMMG2.H"

void G2AnimSection_InterpToKeylistAtTime(struct _G2AnimSection_Type *section, struct _G2AnimKeylist_Type *keylist, int keylistID, short targetTime, int duration)
{
	struct _G2Anim_Type *anim;
	struct _G2AnimInterpInfo_Type *interpInfo;
	struct _G2AnimInterpStateBlock_Type *stateBlockList;
	struct _G2AnimQuatInfo_Type *quatInfo;
	unsigned long alarmFlags;
	short elapsedTime;
	int quatInfoChunkCount;
	int segCount;
	
	if (duration != 0)
	{
		anim = _G2AnimSection_GetAnim(section);

		interpInfo = section->interpInfo;

		segCount = section->segCount;

		if (interpInfo->stateBlockList != NULL)
		{
			_G2AnimSection_InterpStateToQuat(section);
		}
		else
		{
			if (_G2Anim_AllocateInterpStateBlockList(section) == NULL)
			{
				G2AnimSection_SwitchToKeylistAtTime(section, keylist, keylistID, targetTime);
				return;
			}
			else
			{
				section->interpInfo = NULL;

				_G2AnimSection_UpdateStoredFrameFromData(section, anim);
				
				section->interpInfo = interpInfo;

				_G2AnimSection_SegValueToQuat(section, 0);
			}
		}

		elapsedTime = section->elapsedTime;

		alarmFlags = section->alarmFlags;

		section->interpInfo = NULL;

		G2AnimSection_SwitchToKeylistAtTime(section, keylist, keylistID, targetTime);

		_G2AnimSection_UpdateStoredFrameFromData(section, anim);

		section->interpInfo = interpInfo;
		section->alarmFlags = alarmFlags;
		section->elapsedTime = elapsedTime;

		_G2AnimSection_SegValueToQuat(section, 1);

		stateBlockList = interpInfo->stateBlockList;

		quatInfoChunkCount = 4;

		quatInfo = &stateBlockList->quatInfo[0];

		if (quatInfo->destTrans.x == 0 &&
			quatInfo->destTrans.y == 0 &&
			quatInfo->destTrans.z == 0)
		{
			quatInfo->srcTrans.x = 0;
			quatInfo->srcTrans.y = 0;
			quatInfo->srcTrans.z = 0;

		}

		while (--segCount > 0)
		{
			quatInfoChunkCount--;

			quatInfo->destScale.x -= quatInfo->srcScale.x;
			quatInfo->destScale.y -= quatInfo->srcScale.y;
			quatInfo->destScale.z -= quatInfo->srcScale.z;

			quatInfo->destTrans.x -= quatInfo->srcTrans.x;
			quatInfo->destTrans.y -= quatInfo->srcTrans.y;
			quatInfo->destTrans.z -= quatInfo->srcTrans.z;

			if (quatInfoChunkCount == 0)
			{
				stateBlockList = stateBlockList->next;
				quatInfoChunkCount = 4;
				quatInfo = &stateBlockList->quatInfo[0];
			}

			quatInfo++;
		}

		segCount++;

		interpInfo ->targetTime = targetTime;
		interpInfo->duration = duration;

		if (!(section->flags & 0x2) && (alarmFlags & 0x3))
		{
			if (duration < (elapsedTime % section->keylist->s0TailTime) + 1)
			{
				elapsedTime = duration;
			}
			else
			{
				elapsedTime = (elapsedTime % section->keylist->s0TailTime) + 1;
			}

			section->elapsedTime = elapsedTime;
		}
		else
		{
			section->elapsedTime = 0;
		}

		section->keylist = keylist;
		section->keylistID = keylistID;

		keylist->timePerKey = -keylist->timePerKey;

		if ((section->flags & 0x2))
		{
			G2AnimSection_SetLoopRangeAll(section);
		}

		G2AnimSection_ClearAlarm(section, 0x3);
		
		section->flags &= 0x7F;

		G2AnimSection_SetUnpaused(section);

		section->swAlarmTable = NULL;
		section->interpInfo = interpInfo;

		anim->flags |= 0x1;
	}
	else
	{
		G2AnimSection_SwitchToKeylistAtTime(section, keylist, keylistID, targetTime);
		return;
	}
}


// autogenerated function stub: 
// void /*$ra*/ _G2AnimSection_UpdateStoredFrameFromQuat(struct _G2AnimSection_Type *section /*$s7*/)
void _G2AnimSection_UpdateStoredFrameFromQuat(struct _G2AnimSection_Type *section)
{ // line 193, offset 0x800923c0
	/* begin block 1 */
		// Start line: 194
		// Start offset: 0x800923C0
		// Variables:
			struct _G2AnimSegValue_Type *segValue; // $s1
			struct _G2AnimInterpInfo_Type *interpInfo; // $s0
			struct _G2AnimInterpStateBlock_Type *stateBlockList; // $s3
			struct _G2AnimQuatInfo_Type *quatInfo; // $s0
			long alpha; // $s5
			struct _G2Quat_Type newQuat; // stack offset -48
			int quatInfoChunkCount; // $s4
			int segCount; // $s6

		/* begin block 1.1 */
			// Start line: 223
			// Start offset: 0x8009244C
			// Variables:
				struct _G2Quat_Type *source; // $fp
				struct _G2Quat_Type *dest; // $s1

			/* begin block 1.1.1 */
				// Start line: 223
				// Start offset: 0x8009244C
				// Variables:
					unsigned long zw; // $v1
					unsigned long xy; // $v0
			/* end block 1.1.1 */
			// End offset: 0x8009244C
			// End Line: 223
		/* end block 1.1 */
		// End offset: 0x8009244C
		// End Line: 223

		/* begin block 1.2 */
			// Start line: 223
			// Start offset: 0x8009244C
			// Variables:
				//struct _G2SVector3_Type *dest; // $a0
				//struct _G2SVector3_Type *base; // $v0
				//struct _G2SVector3_Type *offset; // $v1
				//long alpha; // $s5
		/* end block 1.2 */
		// End offset: 0x8009244C
		// End Line: 223

		/* begin block 1.3 */
			// Start line: 223
			// Start offset: 0x8009244C
			// Variables:
				//struct _G2SVector3_Type *dest; // $a0
				//struct _G2SVector3_Type *base; // $v0
				//struct _G2SVector3_Type *offset; // $v1
				//long alpha; // $s5
		/* end block 1.3 */
		// End offset: 0x8009244C
		// End Line: 223
	/* end block 1 */
	// End offset: 0x8009256C
	// End Line: 252

	/* begin block 2 */
		// Start line: 434
	/* end block 2 */
	// End Line: 435

}

void _G2AnimSection_InterpStateToQuat(struct _G2AnimSection_Type *section)
{
	struct _G2AnimInterpInfo_Type *interpInfo;
	struct _G2AnimInterpStateBlock_Type *stateBlockList;
	struct _G2AnimQuatInfo_Type *quatInfo;
	long alpha;
	struct _G2Quat_Type newQuat;
	int quatInfoChunkCount;
	int segCount;
	struct _G2Quat_Type *source;
	struct _G2Quat_Type *dest;
	unsigned long zw;
	unsigned long xy;

#define GET_XY(a) *(long*)(&a.x);
#define SET_XY(a, c) *(long*)(&a.x) = c;
#define GET_ZW(b) *(long*)(&b->z);
#define SET_ZW(b, c) *(long*)(&b.z) = c;

	interpInfo = section->interpInfo;
	alpha = (section->elapsedTime * 4096) / interpInfo->duration;
	quatInfoChunkCount = 4;
	segCount = section->segCount;

	alpha = _G2AnimAlphaTable_GetValue(interpInfo->alphaTable, alpha);
	stateBlockList = interpInfo->stateBlockList;

	quatInfo = &stateBlockList->quatInfo[0];

	if (segCount > 0)
	{
		source = &newQuat;
		
		do
		{
			struct _G2SVector3_Type* dest;
			struct _G2SVector3_Type* offset;

			G2Quat_Slerp_VM(alpha, &quatInfo->srcQuat, &quatInfo->destQuat, &newQuat, 0);

			zw = GET_ZW(source);
			SET_ZW(quatInfo->srcQuat, zw);

			xy = GET_XY(newQuat);
			SET_XY(quatInfo->srcQuat, xy);

			dest = &quatInfo->srcScale;
			offset = &quatInfo->destScale;

			MAC0 = dest->x;
			MAC1 = dest->y;
			MAC2 = dest->z;

			gte_ldsv(dest);

			IR0 = alpha;

			gte_gpl12();

			dest->x = MAC1;
			dest->y = MAC2;
			dest->z = MAC3;

			dest = &quatInfo->srcTrans;
			offset = &quatInfo->destTrans;

			MAC0 = dest->x;
			MAC1 = dest->y;
			MAC2 = dest->z;

			gte_ldsv(dest);

			IR0 = alpha;

			gte_gpl12();

			dest->x = MAC1;
			dest->y = MAC2;
			dest->z = MAC3;

			segCount--;
			
			quatInfoChunkCount--;
			
			quatInfo++;

			if (quatInfoChunkCount == 0)
			{
				stateBlockList = stateBlockList->next;
				
				quatInfoChunkCount = 4;
			}

		} while (segCount > 0);
	}
}


// autogenerated function stub: 
// void /*$ra*/ _G2AnimSection_SegValueToQuat(struct _G2AnimSection_Type *section /*$a0*/, int zeroOne /*$s6*/)
void _G2AnimSection_SegValueToQuat(struct _G2AnimSection_Type *section, int zeroOne)
{ // line 318, offset 0x80092740
	/* begin block 1 */
		// Start line: 319
		// Start offset: 0x80092740
		// Variables:
			struct _G2AnimSegValue_Type *segValue; // $s2
			struct _G2AnimInterpInfo_Type *interpInfo; // $v0
			struct _G2AnimInterpStateBlock_Type *stateBlockList; // $s4
			struct _G2AnimQuatInfo_Type *quatInfo; // $s0
			struct _G2EulerAngles_Type preQuat; // stack offset -40
			int quatInfoChunkCount; // $s3
			int segCount; // $s5
	/* end block 1 */
	// End offset: 0x800928A4
	// End Line: 384

	/* begin block 2 */
		// Start line: 716
	/* end block 2 */
	// End Line: 717

}

struct _G2AnimInterpStateBlock_Type* _G2Anim_AllocateInterpStateBlockList(struct _G2AnimSection_Type *section)
{
	struct _G2AnimInterpInfo_Type* interpInfo;
	struct _G2AnimInterpStateBlock_Type* newBlock;
	int segCount;

	segCount = section->segCount;
	interpInfo = section->interpInfo;

	newBlock = (struct _G2AnimInterpStateBlock_Type*)G2PoolMem_Allocate(&_interpStateBlockPool);
	interpInfo->stateBlockList = newBlock;

	if (newBlock == NULL)
	{
		return interpInfo->stateBlockList;
	}
	else
	{
		segCount -= 4;
		
		while (segCount > 0)
		{
			newBlock->next = (struct _G2AnimInterpStateBlock_Type*)G2PoolMem_Allocate(&_interpStateBlockPool);

			if (newBlock->next == NULL)
			{
				_G2Anim_FreeInterpStateBlockList(interpInfo->stateBlockList);

				interpInfo->stateBlockList = NULL;

				return NULL;
			}
			
			newBlock = newBlock->next;

			segCount -= 4;
		}

		newBlock->next = NULL;
	}

	return interpInfo->stateBlockList;
}

void _G2Anim_FreeInterpStateBlockList(struct _G2AnimInterpStateBlock_Type *block)
{
	struct _G2AnimInterpStateBlock_Type *nextBlock;
	
	while (block != NULL)
	{
		nextBlock = block->next;
		
		G2PoolMem_Free(& _interpStateBlockPool, block);

		block = nextBlock;
	}
}




