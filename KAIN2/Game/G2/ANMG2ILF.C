#include "CORE.H"
#include "ANMG2ILF.H"


short G2Anim_GetElapsedTime(struct _G2Anim_Type* anim)
{
#if defined(PSX_VERSION)
	struct _G2AnimSection_Type* section;
	section = &anim->section[anim->masterSection];
	return section->elapsedTime;
#elif defined(PC_VERSION)
	return anim->section[anim->masterSection].elapsedTime;
#endif
}

struct _G2AnimKeylist_Type* G2Anim_GetKeylist(struct _G2Anim_Type* anim)
{
#if defined(PSX_VERSION)
	struct _G2AnimSection_Type* section;
	section = &anim->section[anim->masterSection];
	return section->keylist;
#elif defined(PC_VERSION)
	return anim->section[anim->masterSection].keylist;
#endif
}


// autogenerated function stub: 
// void /*$ra*/ G2Anim_GetRootMotionOverInterval(struct _G2Anim_Type *anim /*$a0*/, short intervalStart /*$a1*/, short intervalEnd /*$a2*/, struct _G2SVector3_Type *motionVector /*$a3*/)
void G2Anim_GetRootMotionOverInterval(struct _G2Anim_Type *anim, short intervalStart, short intervalEnd, struct _G2SVector3_Type *motionVector)
{ // line 165, offset 0x8008fa58
#if defined(PC_VERSION)
	G2Anim_GetRootMotionFromTimeForDuration(anim, intervalStart, intervalEnd - intervalStart, motionVector);
#endif
}


// autogenerated function stub: 
// void /*$ra*/ G2Anim_InterpToKeylistFrame(struct _G2Anim_Type *anim /*$s2*/, struct _G2AnimKeylist_Type *keylist /*$s4*/, int keylistID /*$s5*/, int targetFrame /*$s6*/, int duration /*stack 16*/)
void G2Anim_InterpToKeylistFrame(struct _G2Anim_Type *anim, struct _G2AnimKeylist_Type *keylist, int keylistID, int targetFrame, int duration)
{ // line 292, offset 0x8008fa88
#if defined(PC_VERSION)
	int sectionCount; // ecx
	int v6; // edi
	struct _G2AnimSection_Type* section; // esi

	v6 = 0;
	if (anim->sectionCount)
	{
		section = anim->section;
		do
		{
			G2AnimSection_InterpToKeylistAtTime(section, keylist, keylistID, keylist->s0TailTime * targetFrame, duration);
			sectionCount = anim->sectionCount;
			++v6;
			++section;
		} while (v6 < sectionCount);
	}
#endif
}


// autogenerated function stub: 
// void /*$ra*/ G2Anim_SetAlphaTable(struct _G2Anim_Type *anim /*$s2*/, struct _G2AnimAlphaTable_Type *table /*$s3*/)
void G2Anim_SetAlphaTable(struct _G2Anim_Type *anim, struct _G2AnimAlphaTable_Type *table)
{ // line 412, offset 0x8008fb2c
#if defined(PC_VERSION)
	int v2; // edx
	struct _G2AnimInterpInfo_Type** p_interpInfo; // ecx

	v2 = 0;
	if (anim->sectionCount)
	{
		p_interpInfo = &anim->section[0].interpInfo;
		do
		{
			if (*p_interpInfo)
				(*p_interpInfo)->alphaTable = table;
			++v2;
			p_interpInfo += 12;
		} while (v2 < anim->sectionCount);
	}
#endif
}

void G2Anim_SetCallback(struct _G2Anim_Type *anim, unsigned long (*func)(struct _G2Anim_Type*, int, enum _G2AnimCallbackMsg_Enum, long, long, struct _Instance*), void *data)
{
#if defined(PSX_VERSION)
	int i;

	if (anim->sectionCount != 0)
	{
		for (i = 0; i < anim->sectionCount; i++)
		{
			anim->section[i].callback = func;
			anim->section[i].callbackData = data;
		}
	}

#elif defined(PC_VERSION)
	int v3; // ecx
	void** p_callbackData; // eax

	v3 = 0;
	if (anim->sectionCount)
	{
		p_callbackData = &anim->section[0].callbackData;
		do
		{
			*(p_callbackData - 1) = callback;
			*p_callbackData = data;
			++v3;
			p_callbackData += 12;
		} while (v3 < anim->sectionCount);
	}
#endif
}


// autogenerated function stub: 
// void /*$ra*/ G2Anim_SetLooping(struct _G2Anim_Type *anim /*$s2*/)
void G2Anim_SetLooping(struct _G2Anim_Type *anim)
{ // line 518, offset 0x8008fbd8
#if defined(PC_VERSION)
	int v1; // edx
	unsigned int* p_alarmFlags; // eax
	unsigned int v3; // ecx
	unsigned int v4; // ecx
	__int16 v5; // di

	v1 = 0;
	if (anim->sectionCount)
	{
		p_alarmFlags = &anim->section[0].alarmFlags;
		do
		{
			v3 = *p_alarmFlags;
			*((WORD*)p_alarmFlags - 8) = 0;
			*p_alarmFlags = v3 & 0xFFFFFFFC;
			v4 = p_alarmFlags[3];
			p_alarmFlags += 12;
			v5 = *(unsigned __int8*)(v4 + 1) + *(WORD*)(v4 + 6) * (*(WORD*)(v4 + 4) - 1);
			v4 = *((BYTE*)p_alarmFlags - 72) | 2;
			*((WORD*)p_alarmFlags - 31) = v5;
			*((BYTE*)p_alarmFlags - 72) = v4;
			++v1;
		} while (v1 < anim->sectionCount);
	}
#endif
}


// autogenerated function stub: 
// void /*$ra*/ G2Anim_SetNoLooping(struct _G2Anim_Type *anim /*$s2*/)
void G2Anim_SetNoLooping(struct _G2Anim_Type *anim)
{ // line 565, offset 0x8008fc38
#if defined(PC_VERSION)
	int v1; // ecx
	struct _G2AnimSection_Type* section; // eax
	unsigned __int8 flags; // dl

	v1 = 0;
	if (anim->sectionCount)
	{
		section = anim->section;
		do
		{
			flags = section->flags;
			++section;
			++v1;
			section[-1].flags = flags & 0xFD;
		} while (v1 < anim->sectionCount);
	}
#endif
}


// autogenerated function stub: 
// void /*$ra*/ G2Anim_SetPaused(struct _G2Anim_Type *anim /*$s2*/)
void G2Anim_SetPaused(struct _G2Anim_Type *anim)
{ // line 591, offset 0x8008fc98
#if defined(PC_VERSION)
	int v1; // ecx
	struct _G2AnimSection_Type* section; // eax
	unsigned __int8 flags; // dl

	v1 = 0;
	if (anim->sectionCount)
	{
		section = anim->section;
		do
		{
			flags = section->flags;
			++section;
			++v1;
			section[-1].flags = flags | 1;
		} while (v1 < anim->sectionCount);
	}
#endif
}


// autogenerated function stub: 
// void /*$ra*/ G2Anim_SetSpeedAdjustment(struct _G2Anim_Type *anim /*$a0*/, long adjustment /*$a1*/)
void G2Anim_SetSpeedAdjustment(struct _G2Anim_Type *anim, long adjustment)
{ // line 618, offset 0x8008fcf8
#if defined(PC_VERSION)
	int v2; // eax
	int* p_speedAdjustment; // ecx

	v2 = 0;
	if (anim->sectionCount)
	{
		p_speedAdjustment = &anim->section[0].speedAdjustment;
		do
		{
			*p_speedAdjustment = adjustment;
			++v2;
			p_speedAdjustment += 12;
		} while (v2 < anim->sectionCount);
	}
#endif
}


// autogenerated function stub: 
// void /*$ra*/ G2Anim_SetUnpaused(struct _G2Anim_Type *anim /*$s2*/)
void G2Anim_SetUnpaused(struct _G2Anim_Type *anim)
{ // line 649, offset 0x8008fd2c
#if defined(PC_VERSION)
	int v1; // ecx
	struct _G2AnimSection_Type* section; // eax
	unsigned __int8 flags; // dl

	v1 = 0;
	if (anim->sectionCount)
	{
		section = anim->section;
		do
		{
			flags = section->flags;
			++section;
			++v1;
			section[-1].flags = flags & 0xFE;
		} while (v1 < anim->sectionCount);
	}
#endif
}

void G2Anim_SwitchToKeylist(struct _G2Anim_Type *anim, struct _G2AnimKeylist_Type *keylist, int keylistID)
{
#if defined(PSX_VERSION)
	int i;

	if (anim->sectionCount != 0)
	{
		for (i = 0; i < anim->sectionCount; i++)
		{
			G2AnimSection_SwitchToKeylist(&anim->section[i], keylist, keylistID);
		}
	}

#elif defined(PC_VERSION)
	int v3; // esi
	struct _G2AnimSection_Type* section; // edi

	v3 = 0;
	if (anim->sectionCount)
	{
		section = anim->section;
		do
		{
			G2AnimSection_SwitchToKeylistAtTime(section, keylist, keylistID, 0);
			++v3;
			++section;
		} while (v3 < anim->sectionCount);
	}
#endif
}


// autogenerated function stub: 
// short /*$ra*/ G2AnimKeylist_GetDuration(struct _G2AnimKeylist_Type *keylist /*$a0*/)
short G2AnimKeylist_GetDuration(struct _G2AnimKeylist_Type *keylist)
{ // line 797, offset 0x8008fe0c
#if defined(PC_VERSION)
	return keylist->s0TailTime + (keylist->keyCount - 1) * keylist->timePerKey;
#else
	return 0;
#endif
}


// autogenerated function stub: 
// int /*$ra*/ G2AnimKeylist_GetKeyframeCount(struct _G2AnimKeylist_Type *keylist /*$a0*/)
int G2AnimKeylist_GetKeyframeCount(struct _G2AnimKeylist_Type *keylist)
{ // line 811, offset 0x8008fe34
#if defined(PC_VERSION)
	return ((keylist->keyCount - 1) * keylist->timePerKey + 2 * keylist->s0TailTime - 1) / keylist->s0TailTime;
#else
	return 0;
#endif
}


// autogenerated function stub: 
// void /*$ra*/ G2AnimSection_ClearAlarm(struct _G2AnimSection_Type *section /*$a0*/, unsigned long clut /*$a1*/)
void G2AnimSection_ClearAlarm(struct _G2AnimSection_Type *section, unsigned long flag)
{ // line 840, offset 0x8008fe6c
#if defined(PC_VERSION)
	section->alarmFlags &= ~flag;
#endif
}


// autogenerated function stub: 
// int /*$ra*/ G2AnimSection_GetKeyframeNumber(struct _G2AnimSection_Type *section /*$s0*/)
int G2AnimSection_GetKeyframeNumber(struct _G2AnimSection_Type *section)
{ // line 870, offset 0x8008fe80
#if defined(PC_VERSION)
	struct _G2AnimInterpInfo_Type* interpInfo; // eax

	interpInfo = section->interpInfo;
	if (interpInfo && interpInfo->stateBlockList)
		return interpInfo->targetTime / (int)section->keylist->s0TailTime;
	else
		return section->elapsedTime / (int)section->keylist->s0TailTime;
#else
	return 0;
#endif
}


// autogenerated function stub: 
// int /*$ra*/ G2AnimSection_GetStoredKeyframeNumber(struct _G2AnimSection_Type *section /*$a0*/)
int G2AnimSection_GetStoredKeyframeNumber(struct _G2AnimSection_Type *section)
{ // line 974, offset 0x8008fedc
#if defined(PC_VERSION)
	return section->storedTime / (int)section->keylist->s0TailTime;
#else
	return 0;
#endif
}


// autogenerated function stub: 
// void /*$ra*/ G2AnimSection_InterpToKeylistFrame(struct _G2AnimSection_Type *section /*$a0*/, struct _G2AnimKeylist_Type *keylist /*$a1*/, int keylistID /*$a2*/, int targetFrame /*$a3*/, int duration /*stack 16*/)
void G2AnimSection_InterpToKeylistFrame(struct _G2AnimSection_Type *section, struct _G2AnimKeylist_Type *keylist, int keylistID, int targetFrame, int duration)
{ // line 1005, offset 0x8008fefc
#if defined(PC_VERSION)
	G2AnimSection_InterpToKeylistAtTime(section, keylist, keylistID, targetFrame * keylist->s0TailTime, duration);
#endif
}


// autogenerated function stub: 
// enum _G2Bool_Enum /*$ra*/ G2AnimSection_IsInInterpolation(struct _G2AnimSection_Type *section /*$a0*/)
enum _G2Bool_Enum G2AnimSection_IsInInterpolation(struct _G2AnimSection_Type *section)
{ // line 1023, offset 0x8008ff3c
#if defined(PC_VERSION)
	struct _G2AnimInterpInfo_Type* interpInfo; // eax

	interpInfo = section->interpInfo;
	return interpInfo && interpInfo->stateBlockList;
#else
	return (_G2Bool_Enum)0;
#endif
}


// autogenerated function stub: 
// short /*$ra*/ G2AnimSection_NextKeyframe(struct _G2AnimSection_Type *section /*$s0*/)
short G2AnimSection_NextKeyframe(struct _G2AnimSection_Type *section)
{ // line 1081, offset 0x8008ff6c
#if defined(PC_VERSION)
	int FrameTime; // eax

	if ((section->flags & 1) != 0)
		return 0;
	section->flags &= ~4;
	FrameTime = G2Timer_GetFrameTime();
	return G2AnimSection_UpdateOverInterval(section, FrameTime);
#else
	return 0;
#endif
}


// autogenerated function stub: 
// void /*$ra*/ G2AnimSection_SetAlphaTable(struct _G2AnimSection_Type *section /*$a0*/, struct _G2AnimAlphaTable_Type *table /*$a1*/)
void G2AnimSection_SetAlphaTable(struct _G2AnimSection_Type *section, struct _G2AnimAlphaTable_Type *table)
{ // line 1112, offset 0x8008ffc8
#if defined(PC_VERSION)
	struct _G2AnimInterpInfo_Type* interpInfo; // eax

	interpInfo = section->interpInfo;
	if (interpInfo)
		interpInfo->alphaTable = table;
#endif
}


// autogenerated function stub: 
// void /*$ra*/ G2AnimSection_SetInterpInfo(struct _G2AnimSection_Type *section /*$a0*/, struct _G2AnimInterpInfo_Type *newInfoPtr /*$a1*/)
void G2AnimSection_SetInterpInfo(struct _G2AnimSection_Type *section, struct _G2AnimInterpInfo_Type *newInfoPtr)
{ // line 1162, offset 0x8008ffe4
#if defined(PC_VERSION)
	section->interpInfo = newInfoPtr;
	if (newInfoPtr)
	{
		*(DWORD*)&newInfoPtr->duration = 0;
		newInfoPtr->alphaTable = 0;
		newInfoPtr->stateBlockList = 0;
	}
#endif
}


// autogenerated function stub: 
// void /*$ra*/ G2AnimSection_SetLooping(struct _G2AnimSection_Type *section /*$s0*/)
void G2AnimSection_SetLooping(struct _G2AnimSection_Type *section)
{ // line 1208, offset 0x80090014
#if defined(PC_VERSION)
	unsigned int alarmFlags; // ecx

	alarmFlags = section->alarmFlags;
	section->loopStartTime = 0;
	section->alarmFlags = alarmFlags & ~3u;
	alarmFlags = section->flags | 2;
	section->loopEndTime = section->keylist->s0TailTime + (section->keylist->keyCount - 1) * section->keylist->timePerKey;
	section->flags = alarmFlags;
#endif
}


// autogenerated function stub: 
// void /*$ra*/ G2AnimSection_SetLoopRangeAll(struct _G2AnimSection_Type *section /*$s0*/)
void G2AnimSection_SetLoopRangeAll(struct _G2AnimSection_Type *section)
{ // line 1220, offset 0x80090054
#if defined(PC_VERSION)
	struct _G2AnimKeylist_Type* keylist; // eax

	keylist = section->keylist;
	section->loopStartTime = 0;
	section->loopEndTime = keylist->s0TailTime + (keylist->keyCount - 1) * keylist->timePerKey;
#endif
}


// autogenerated function stub: 
// void /*$ra*/ G2AnimSection_SetNoLooping(struct _G2AnimSection_Type *section /*$a0*/)
void G2AnimSection_SetNoLooping(struct _G2AnimSection_Type *section)
{ // line 1261, offset 0x80090084
#if defined(PC_VERSION)
	section->flags &= ~2u;
#endif
}


// autogenerated function stub: 
// void /*$ra*/ G2AnimSection_SetNotRewinding(struct _G2AnimSection_Type *section /*$a0*/)
void G2AnimSection_SetNotRewinding(struct _G2AnimSection_Type *section)
{ // line 1270, offset 0x80090098
#if defined(PC_VERSION)
	section->flags &= ~4u;
#endif
}


// autogenerated function stub: 
// void /*$ra*/ G2AnimSection_SetPaused(struct _G2AnimSection_Type *section /*$a0*/)
void G2AnimSection_SetPaused(struct _G2AnimSection_Type *section)
{ // line 1279, offset 0x800900ac
#if defined(PC_VERSION)
	section->flags |= 1u;
#endif
}


// autogenerated function stub: 
// void /*$ra*/ G2AnimSection_SetUnpaused(struct _G2AnimSection_Type *section /*$a0*/)
void G2AnimSection_SetUnpaused(struct _G2AnimSection_Type *section)
{ // line 1333, offset 0x800900c0
#if defined(PC_VERSION)
	section->flags &= ~1u;
#endif
}


// autogenerated function stub: 
// void /*$ra*/ G2AnimSection_SwitchToKeylist(struct _G2AnimSection_Type *section /*$a0*/, struct _G2AnimKeylist_Type *keylist /*$a1*/, int keylistID /*$a2*/)
void G2AnimSection_SwitchToKeylist(struct _G2AnimSection_Type *section, struct _G2AnimKeylist_Type *keylist, int keylistID)
{ // line 1344, offset 0x800900d4
#if defined(PC_VERSION)
	G2AnimSection_SwitchToKeylistAtTime(section, keylist, keylistID, 0);
#endif
}
