#include "Game/CORE.H"
#include "ANIMG2.H"
#include "POOLMMG2.H"
#include "ANMG2ILF.H"
#include "ANMINTRP.H"
#include "ANMCTRLR.H"
#include "Game/PSX/COLLIDES.H"

enum _G2Bool_Enum G2Anim_Install()
{
	struct _G2AnimController_Type *dummyController;

	G2PoolMem_InitPool(&_chanStatusBlockPool, 180, 36);
	G2PoolMem_InitPool(&_interpStateBlockPool, 96, 164);
	G2PoolMem_InitPool(&_controllerPool, 122, 164);

	dummyController = (struct _G2AnimController_Type*)G2PoolMem_Allocate(&_controllerPool);

	dummyController->next = 0;
	dummyController->segNumber = 255;
	dummyController->type = 0;

	return (_G2Bool_Enum)1;
}

#if defined(PC_VERSION)
struct _G2PoolMemPool_Type stru_B08B60,
	stru_B08B70,
	stru_B08B80;
#elif defined(PSX_VERSION)
struct _G2AnimChanStatusBlockPool_Type _chanStatusBlockPool;
struct _G2AnimInterpStateBlockPool_Type _interpStateBlockPool;
struct _G2AnimControllerPool_Type _controllerPool;
#endif

void G2Anim_ResetInternalState()
{
#if defined(PSX_VERSION)
	struct _G2AnimController_Type* dummyController;

	G2PoolMem_ResetPool(&_chanStatusBlockPool);
	G2PoolMem_ResetPool(&_interpStateBlockPool);
	G2PoolMem_ResetPool(&_controllerPool);

	dummyController = (struct _G2AnimController_Type*)G2PoolMem_Allocate(&_controllerPool);
	dummyController->next = 0;
	dummyController->segNumber = 255;
	dummyController->type = 0;

#elif defined(PC_VERSION)
	struct _G2AnimController_Type* dummyController; // eax

	G2PoolMem_ResetPool(&stru_B08B70);
	G2PoolMem_ResetPool(&stru_B08B60);
	G2PoolMem_ResetPool(&stru_B08B80);
	dummyController = (struct _G2AnimController_Type*)G2PoolMem_Allocate(&stru_B08B80);
	dummyController->next = 0;
	dummyController->segNumber = -1;
	dummyController->type = 0;
#endif
}

void G2Anim_Init(struct _G2Anim_Type* anim, struct _Model *modelData)
{
#if defined(PSX_VERSION)
	struct _G2AnimSection_Type* section;
	int sectionID;

	anim->sectionCount = 1;
	anim->masterSection = 0;
	anim->controllerList = 0;
	anim->disabledControllerList = 0;
	anim->segMatrices = NULL;
	anim->modelData = modelData;

	memset(&anim->disabledBits[0], 0, sizeof(anim->disabledBits) + sizeof(anim->section));

	section = &anim->section[0];

	for (sectionID = 0; sectionID < 3; sectionID++, section++)
	{
		section->storedTime = -1;
		section->swAlarmTable = NULL;
		section->speedAdjustment = 4096;
	}

	anim->section[0].segCount = modelData->numSegments;

#elif defined(PC_VERSION)
	__int16** p_swAlarmTable; // eax
	int v3; // ecx

	anim->sectionCount = 1;
	anim->masterSection = 0;
	anim->controllerList = 0;
	anim->disabledControllerList = 0;
	anim->segMatrices = 0;
	anim->modelData = modelData;
	memset(anim->disabledBits, 0, 0x9Cu);
	p_swAlarmTable = &anim->section[0].swAlarmTable;
	v3 = 3;
	do
	{
		*((WORD*)p_swAlarmTable - 3) = -1;
		*p_swAlarmTable = 0;
		p_swAlarmTable[1] = (__int16*)4096;
		p_swAlarmTable += 12;
		--v3;
	} while (v3);
	anim->section[0].segCount = modelData->numSegments;
#endif
}

struct _G2AnimSection_Type * G2Anim_AddSection(struct _G2Anim_Type *anim, int firstSegID, int segCount)
{ 
	struct _G2AnimSection_Type* section;

	section = &anim->section[anim->sectionCount];

	memset(section, 0, sizeof(struct _G2AnimSection_Type));

	section->storedTime = -1;
	section->firstSeg = firstSegID;
	section->segCount = segCount;
	section->swAlarmTable = NULL;
	section->speedAdjustment = 4096;
	section->sectionID = anim->sectionCount;

	anim->sectionCount++;

	return section;
}


// autogenerated function stub: 
// void /*$ra*/ G2Anim_Free(struct _G2Anim_Type *anim /*$s4*/)
void G2Anim_Free(struct _G2Anim_Type *anim)
{ // line 487, offset 0x80092b94
	/* begin block 1 */
		// Start line: 488
		// Start offset: 0x80092B94
		// Variables:
			struct _G2AnimSection_Type *animSection; // $s1
			int sectionID; // $s2
			struct _G2AnimInterpInfo_Type *interpInfo; // $s0
	/* end block 1 */
	// End offset: 0x80092C30
	// End Line: 527

	/* begin block 2 */
		// Start line: 1048
	/* end block 2 */
	// End Line: 1049
	UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ G2Anim_Restore(struct _G2Anim_Type *anim /*$s2*/)
void G2Anim_Restore(struct _G2Anim_Type *anim)
{ // line 531, offset 0x80092c50
	/* begin block 1 */
		// Start line: 532
		// Start offset: 0x80092C50
		// Variables:
			struct _G2AnimSection_Type *animSection; // $a0
			int sectionID; // $s0
	/* end block 1 */
	// End offset: 0x80092CB8
	// End Line: 553

	/* begin block 2 */
		// Start line: 1162
	/* end block 2 */
	// End Line: 1163
	UNIMPLEMENTED();
}

void G2Anim_BuildTransforms(struct _G2Anim_Type* anim)
{
	unsigned short z;
	unsigned long xy;
	
	G2Anim_UpdateStoredFrame(anim);

	if ((anim->section[0].flags & 0x88) != 0x80)
	{
		anim->rootTrans.x = 0;
		anim->rootTrans.y = 0;
		anim->rootTrans.z = 0;
	}

	if ((anim->section[0].flags & 0x4))
	{
		anim->rootTrans.x = -anim->rootTrans.x;
		anim->rootTrans.y = -anim->rootTrans.y;
		anim->rootTrans.z = -anim->rootTrans.z;
	}

	z = anim->rootTrans.z;
	xy = ((unsigned long*)&anim->rootTrans.x)[0];

	_segValues[0].trans.z = z;
	((unsigned long*)&_segValues[0].trans.x)[0] = xy;

	if (anim->controllerList != 0)
	{
		_G2Anim_BuildTransformsWithControllers(anim);
	}
	else
	{
		_G2Anim_BuildTransformsNoControllers(anim);
	}

	anim->rootTrans.x = 0;
	anim->rootTrans.y = 0;
	anim->rootTrans.z = 0;

	anim->section[0].flags &= 0x7F;
	anim->flags &= 0xFFFE;
}

void G2Anim_UpdateStoredFrame(struct _G2Anim_Type* anim)
{
	struct _G2AnimSection_Type* section;
	short storedTime;
	short elapsedTime;
	struct _G2SVector3_Type motionVector;
	int sectionCount;
	struct _G2AnimInterpInfo_Type* interpInfo;
	struct _G2SVector3_Type* vector;

	section = &anim->section[0];
	sectionCount = anim->sectionCount;
	storedTime = section->storedTime;
	elapsedTime = section->elapsedTime;

	while (sectionCount-- > 0)
	{
		interpInfo = section->interpInfo;

		if (interpInfo != NULL && interpInfo->stateBlockList != NULL)
		{
			_G2AnimSection_UpdateStoredFrameFromQuat(section);
			section++;
		}
		else
		{
			_G2AnimSection_UpdateStoredFrameFromData(section, anim);
			section++;
		}
	}

	vector = &motionVector;

	if (storedTime < 0)
	{
		storedTime = 0;
	}

	vector->x = 0;
	vector->y = 0;
	vector->z = 0;

	if (storedTime < elapsedTime)
	{
		G2Anim_GetRootMotionOverInterval(anim, storedTime, elapsedTime, vector);
	}
	else if (elapsedTime < storedTime)
	{
		G2Anim_GetRootMotionOverInterval(anim, elapsedTime, storedTime, vector);
	}

	if((anim->section[0].flags & 0x4))
	{
		anim->rootTrans.x -= motionVector.x;
		anim->rootTrans.y -= motionVector.y;
		anim->rootTrans.z -= motionVector.z;
	}
	else
	{
		anim->rootTrans.x += motionVector.x;
		anim->rootTrans.y += motionVector.y;
		anim->rootTrans.z += motionVector.z;
	}
}


// autogenerated function stub: 
// struct _G2AnimSection_Type * /*$ra*/ G2Anim_GetSectionWithSeg(struct _G2Anim_Type *anim /*$a0*/, int segNumber /*$a1*/)
struct _G2AnimSection_Type * G2Anim_GetSectionWithSeg(struct _G2Anim_Type *anim, int segNumber)
{ // line 712, offset 0x80092f18
	/* begin block 1 */
		// Start line: 715
		// Start offset: 0x80092F18
		// Variables:
			struct _G2AnimSection_Type *section; // $a3
			struct _G2AnimSection_Type *tempSection; // $a2
			struct _G2AnimSection_Type *endSection; // $a0
			int firstSeg; // $v1
			int lastSeg; // $v0
	/* end block 1 */
	// End offset: 0x80092F7C
	// End Line: 747

	/* begin block 2 */
		// Start line: 1557
	/* end block 2 */
	// End Line: 1558

	/* begin block 3 */
		// Start line: 1559
	/* end block 3 */
	// End Line: 1560

	/* begin block 4 */
		// Start line: 1570
	/* end block 4 */
	// End Line: 1571

	/* begin block 5 */
		// Start line: 1574
	/* end block 5 */
	// End Line: 1575
	UNIMPLEMENTED();
	return null;
}

enum _G2Bool_Enum G2Anim_SegmentHasActiveChannels(struct _G2Anim_Type* anim, int segNumber, unsigned short chanMask)
{
	struct _G2AnimSection_Type* section;
	unsigned char* segChanFlagStream;
	unsigned char activeChanBits;
	unsigned short dataFlagBits;
	unsigned short segFlagBits;
	int flagBytesPerSeg;
	int a0;//?
	
	section = G2Anim_GetSectionWithSeg(anim, segNumber);

	a0 = ((anim->modelData->numSegments << 1) + anim->modelData->numSegments) + 7;

	if (a0 < 0)
	{
		a0 = ((anim->modelData->numSegments << 1) + anim->modelData->numSegments) + 14;
	}

	segNumber += (segNumber << 1);

	segFlagBits = segNumber;
	flagBytesPerSeg = a0 >> 3;

	segChanFlagStream = &((unsigned char*)(section->keylist + 1))[section->keylist->sectionCount << 2];
	
	if (segNumber < 0)
	{
		segFlagBits = segNumber + 7;
	}

	segChanFlagStream = &segChanFlagStream[segFlagBits >> 3] + 1;

	segNumber -= segFlagBits;

	activeChanBits = ((unsigned char*)(section->keylist + 1))[section->keylist->sectionCount << 2];

	if ((activeChanBits & 0x1))
	{
		segFlagBits = 0;

		segChanFlagStream += flagBytesPerSeg;

		segFlagBits = ((segChanFlagStream[segFlagBits >> 3] | (segChanFlagStream[0] << 8)) >> segNumber) & 0x7;
	}

	if ((activeChanBits & 0x2))
	{
		segFlagBits |= (((segChanFlagStream[0] | (segChanFlagStream[0] << 8)) >> segNumber) & 0x7) << 4;
	}

	if ((activeChanBits & 0x4))
	{
		segFlagBits |= (((segChanFlagStream[0] | (segChanFlagStream[1] << 8)) >> segNumber) & 0x7) << 8;
	}

	return (_G2Bool_Enum)(0 < (segFlagBits & chanMask));
}


// autogenerated function stub: 
// void /*$ra*/ G2Anim_GetSegChannelValue(struct _G2Anim_Type *anim /*$s0*/, int segIndex /*$s1*/, unsigned short *valueTable /*$s3*/, unsigned short channelMask /*$s2*/)
void G2Anim_GetSegChannelValue(struct _G2Anim_Type *anim, int segIndex, unsigned short *valueTable, unsigned short channelMask)
{ // line 866, offset 0x800930c4
	/* begin block 1 */
		// Start line: 867
		// Start offset: 0x800930C4
		// Variables:
			unsigned short *chanFinalValue; // $v1

		/* begin block 1.1 */
			// Start line: 867
			// Start offset: 0x800930C4

			/* begin block 1.1.1 */
				// Start line: 867
				// Start offset: 0x800930C4
				// Variables:
					unsigned short z; // $v1
					unsigned long xy; // $v0
			/* end block 1.1.1 */
			// End offset: 0x800930C4
			// End Line: 867
		/* end block 1.1 */
		// End offset: 0x800930C4
		// End Line: 867
	/* end block 1 */
	// End offset: 0x80093154
	// End Line: 905

	/* begin block 2 */
		// Start line: 1902
	/* end block 2 */
	// End Line: 1903
	UNIMPLEMENTED();
}

void G2Anim_GetRootMotionFromTimeForDuration(struct _G2Anim_Type *anim, short durationStart, short duration, struct _G2SVector3_Type *motionVector)
{ 
	struct _G2Anim_Type dummyAnim; // stack offset -216
	struct _G2AnimSection_Type* section; // $s2
	struct _G2AnimKeylist_Type* keylist; // $s4
	short storedKeyEndTime; // $s2
	short timePerKey; // $s0
	short keyTime; // $a0
	long alpha; // $a1
	struct _G2AnimInterpInfo_Type* interpInfo; // $a0

	struct _G2SVector3_Type* dest; // $s5
	struct _G2SVector3_Type* base; // $v0
	struct _G2SVector3_Type* offset; // $v1
	//long alpha; // $a1
	struct _G2SVector3_Type* vector; // $s5
	//struct _G2SVector3_Type* dest; // $s5
	//struct _G2SVector3_Type* base; // $s5

#if 0
	sub_800932B0:

	var_B8 = -0xB8
		var_A8 = -0xA8
		var_94 = -0x94
		var_93 = -0x93
		var_92 = -0x92
		var_91 = -0x91
		var_90 = -0x90
		var_8E = -0x8E
		var_70 = -0x70
		var_6C = -0x6C
		var_s0 = 0
		var_s4 = 4
		var_s8 = 8
		var_sC = 0xC
		var_s10 = 0x10
		var_s14 = 0x14
		var_s18 = 0x18
		var_s1C = 0x1C

		addiu   $sp, -0xE8
		move    $t0, $a0
		sw      $s6, 0xC8 + var_s18($sp)
		move    $s6, $a2
		sw      $s5, 0xC8 + var_s14($sp)
		move    $s5, $a3
		sw      $s1, 0xC8 + var_s4($sp)
		move    $s1, $a1
		sw      $s2, 0xC8 + var_s8($sp)
		addiu   $s2, $t0, 0x24  # '$'
		sw      $ra, 0xC8 + var_s1C($sp)
		sw      $s4, 0xC8 + var_s10($sp)
		sw      $s3, 0xC8 + var_sC($sp)
		sw      $s0, 0xC8 + var_s0($sp)
		lw      $a0, 0x2C($s2)
		nop
		beqz    $a0, loc_800933EC
		move    $s3, $s6
		lw      $s0, 8($a0)
		nop
		beqz    $s0, loc_800933EC
		sll     $v0, $a1, 16
		lh      $v1, 0($a0)
		sra     $v0, 4
		div     $v0, $v1
		mflo    $a1
		lw      $a0, 4($a0)
		jal     sub_80094E6C
		nop
		move    $a1, $v0
		addiu   $v0, $s0, 0x20  # ' '
		addiu   $v1, $s0, 0x26  # '&'
		lhu     $t4, 0($v0)
		lhu     $t5, 2($v0)
		lhu     $t6, 4($v0)
		mtc2    $t4, $25
		mtc2    $t5, $26
		mtc2    $t6, $27
		lhu     $t4, 0($v1)
		lhu     $t5, 2($v1)
		lhu     $t6, 4($v1)
		mtc2    $t4, $9
		mtc2    $t5, $10
		mtc2    $t6, $11
		mtc2    $a1, $8
		nop
		nop
		cop2    0x1A8003E
		mfc2    $t4, $25
		mfc2    $t5, $26
		mfc2    $t6, $27
		sh      $t4, 0($s5)
		sh      $t5, 2($s5)
		sh      $t6, 4($s5)
		lw      $s4, 0x24($s2)
		sll     $v0, $s6, 16
		lh      $v1, 6($s4)
		sra     $v0, 4
		div     $v0, $v1
		mflo    $a1
		lh      $v0, 0($s5)
		nop
		mult    $v0, $a1
		mflo    $t0
		lh      $v0, 2($s5)
		nop
		mult    $v0, $a1
		mflo    $v1
		lh      $v0, 4($s5)
		nop
		mult    $v0, $a1
		sra     $v0, $t0, 12
		sh      $v0, 0($s5)
		sra     $v0, $v1, 12
		sh      $v0, 2($s5)
		mflo    $a0
		sra     $v0, $a0, 12
		j       loc_80093560
		sh      $v0, 4($s5)

		loc_800933EC:
	lw      $s4, 0x24($s2)
		sll     $v0, $s1, 16
		lh      $a1, 6($s4)
		sra     $v0, 16
		div     $v0, $a1
		mflo    $v0
		lhu     $s0, 6($s4)
		addiu   $v0, 1
		mult    $s0, $v0
		li      $a0, 1
		lhu     $v1, 4($s4)
		sb      $a0, 0xC8 + var_B8($sp)
		mflo    $s2
		lw      $a2, 0x10($t0)
		addiu   $v1, -1
		mult    $a1, $v1
		sb      $zero, 0xC8 + var_93($sp)
		sb      $zero, 0xC8 + var_92($sp)
		sb      $a0, 0xC8 + var_91($sp)
		sw      $s4, 0xC8 + var_70($sp)
		sw      $zero, 0xC8 + var_6C($sp)
		sw      $a2, 0xC8 + var_A8($sp)
		negu    $v0, $s0
		sh      $v0, 0xC8 + var_8E($sp)
		sll     $v0, $s3, 16
		sw      $zero, 0($s5)
		mflo    $v1
		beqz    $v0, loc_80093554
		sh      $zero, 4($s5)
		sll     $v0, $v1, 16
		sra     $s6, $v0, 16

		loc_80093468:
	sll     $v0, $s1, 16
		sra     $v0, 16
		slt     $v0, $s6
		bnez    $v0, loc_80093480
		nop
		lbu     $s0, 1($s4)

		loc_80093480:
	sh      $s1, 0xC8 + var_90($sp)
		addiu   $a0, $sp, 0xC8 + var_94
		jal     sub_80094C10
		addiu   $a1, $sp, 0xC8 + var_B8
		subu    $v1, $s2, $s1
		move    $a0, $v1
		sll     $v1, 16
		sll     $v0, $s3, 16
		slt     $v0, $v1
		beqz    $v0, loc_800934B4
		sll     $v0, $a0, 16
		move    $a0, $s3
		sll     $v0, $a0, 16

		loc_800934B4:
	sra     $v1, $v0, 16
		sll     $v0, $s0, 16
		sra     $a1, $v0, 16
		slt     $v0, $v1, $a1
		beqz    $v0, loc_800934DC
		sll     $v0, $v1, 12
		div     $v0, $a1
		mflo    $a1
		j       loc_800934E0
		nop

		loc_800934DC :
	li      $a1, 0x1000

		loc_800934E0 :
		lhu     $t4, 0($s5)
		lhu     $t5, 2($s5)
		lhu     $t6, 4($s5)
		mtc2    $t4, $25
		mtc2    $t5, $26
		mtc2    $t6, $27
		addiu   $t1, $gp, -0x11F8
		lhu     $t4, 0($t1)
		lhu     $t5, 2($t1)
		lhu     $t6, 4($t1)
		mtc2    $t4, $9
		mtc2    $t5, $10
		mtc2    $t6, $11
		mtc2    $a1, $8
		nop
		nop
		cop2    0x1A8003E
		mfc2    $t4, $25
		mfc2    $t5, $26
		mfc2    $t6, $27
		sh      $t4, 0($s5)
		sh      $t5, 2($s5)
		sh      $t6, 4($s5)
		move    $s1, $s2
		subu    $v0, $s3, $a0
		move    $s3, $v0
		sll     $v0, 16
		bnez    $v0, loc_80093468
		addu    $s2, $s0

		loc_80093554 :
	lw      $a0, 0xC8 + var_6C($sp)
		jal     sub_80094E2C
		nop

		loc_80093560 :
	lw      $ra, 0xC8 + var_s1C($sp)
		lw      $s6, 0xC8 + var_s18($sp)
		lw      $s5, 0xC8 + var_s14($sp)
		lw      $s4, 0xC8 + var_s10($sp)
		lw      $s3, 0xC8 + var_sC($sp)
		lw      $s2, 0xC8 + var_s8($sp)
		lw      $s1, 0xC8 + var_s4($sp)
		lw      $s0, 0xC8 + var_s0($sp)
		jr      $ra
		addiu   $sp, 0xE8
#endif
		UNIMPLEMENTED();
}

void G2AnimSection_SwitchToKeylistAtTime(struct _G2AnimSection_Type *section, struct _G2AnimKeylist_Type *keylist, int keylistID, short targetTime)
{
	struct _G2Anim_Type *anim;
	struct _G2SVector3_Type rootMotion;
	struct _G2AnimInterpInfo_Type *interpInfo;
	unsigned short z;
	unsigned long xy;

	anim = _G2AnimSection_GetAnim(section);

	if (section->firstSeg == 0)
	{
		anim->flags |= 0x1;

		if (section->keylist != NULL && section->storedTime >= 0)
		{
			G2Anim_GetRootMotionOverInterval(anim, section->storedTime, section->elapsedTime, &rootMotion);
		}
		else
		{
			rootMotion.x = 0;
			rootMotion.y = 0;
			rootMotion.z = 0;
		}

		rootMotion.x += anim->rootTrans.x;
		rootMotion.y += anim->rootTrans.y;
		rootMotion.z += anim->rootTrans.z;
	}

	interpInfo = section->interpInfo;

	if (interpInfo != NULL)
	{
		if (interpInfo->stateBlockList != NULL)
		{
			_G2Anim_FreeInterpStateBlockList(interpInfo->stateBlockList);

			interpInfo->stateBlockList = NULL;
		}
	}
	
	G2AnimSection_ClearAlarm(section, 0x3);

	if (keylist != section->keylist)
	{
		section->keylist = keylist;
		section->keylistID = keylistID;
		section->storedTime = -keylist->timePerKey;
	}
	
	G2AnimSection_JumpToTime(section, targetTime);
	
	if (section->firstSeg == 0)
	{
		section->flags |= 0x80;
		xy = ((unsigned long*)&rootMotion)[0];
		z = rootMotion.z;
		
		((unsigned long*)&anim->rootTrans)[0] = xy;
		anim->rootTrans.z = z;
	}

	if ((section->flags & 0x2))
	{
		G2AnimSection_SetLoopRangeAll(section);
	}

	G2AnimSection_SetUnpaused(section);

	section->swAlarmTable = NULL;
}

void G2AnimSection_JumpToTime(struct _G2AnimSection_Type *section, short targetTime)
{
	struct _G2Anim_Type *anim;

	anim = _G2AnimSection_GetAnim(section);

	if (targetTime < section->elapsedTime)
	{
		section->keylist->timePerKey = -section->keylist->timePerKey;
	}

	section->elapsedTime = targetTime;
	
	_G2AnimSection_UpdateStoredFrameFromData(section, anim);
	
	G2AnimSection_ClearAlarm(section, 0x3);

	section->flags &= 0x7F;

	if (section->firstSeg == 0)
	{
		anim->rootTrans.x = 0;
		anim->rootTrans.y = 0;
		anim->rootTrans.z = 0;
	}
}


// autogenerated function stub: 
// short /*$ra*/ G2AnimSection_UpdateOverInterval(struct _G2AnimSection_Type *section /*$s0*/, short interval /*$a1*/)
short G2AnimSection_UpdateOverInterval(struct _G2AnimSection_Type *section, short interval)
{ // line 1273, offset 0x800936a0
	/* begin block 1 */
		// Start line: 1274
		// Start offset: 0x800936A0
		// Variables:
			struct _G2Anim_Type *anim; // $s2
			struct _G2SVector3_Type motionVector; // stack offset -32
			struct _G2AnimInterpInfo_Type *interpInfo; // $s1
			short elapsedTime; // $s3

		/* begin block 1.1 */
			// Start line: 1324
			// Start offset: 0x80093788

			/* begin block 1.1.1 */
				// Start line: 1324
				// Start offset: 0x80093788
				// Variables:
					unsigned short z; // $v1
					unsigned long xy; // $v0
			/* end block 1.1.1 */
			// End offset: 0x80093788
			// End Line: 1324
		/* end block 1.1 */
		// End offset: 0x80093788
		// End Line: 1324
	/* end block 1 */
	// End offset: 0x80093874
	// End Line: 1361

	/* begin block 2 */
		// Start line: 2725
	/* end block 2 */
	// End Line: 2726
	UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// short /*$ra*/ G2AnimSection_AdvanceOverInterval(struct _G2AnimSection_Type *section /*$s1*/, short interval /*$s0*/)
short G2AnimSection_AdvanceOverInterval(struct _G2AnimSection_Type *section, short interval)
{ // line 1381, offset 0x80093894
	/* begin block 1 */
		// Start line: 1382
		// Start offset: 0x80093894
		// Variables:
			struct _G2AnimKeylist_Type *keylist; // $a0
			short newTime; // $s6
			short extraTime; // $s2
			short elapsedTime; // $fp
			short endTime; // $s4
			short loopExtraTime; // stack offset -48
			short *swAlarmTable; // $s0
			short swAlarmTime; // $v1
			struct _G2Anim_Type *anim; // $s7
			struct _G2SVector3_Type motionVector; // stack offset -56
			unsigned long message; // $s3

		/* begin block 1.1 */
			// Start line: 1614
			// Start offset: 0x80093BD0
		/* end block 1.1 */
		// End offset: 0x80093BD8
		// End Line: 1614

		/* begin block 1.2 */
			// Start line: 1624
			// Start offset: 0x80093BE8

			/* begin block 1.2.1 */
				// Start line: 1624
				// Start offset: 0x80093BE8
				// Variables:
					unsigned short z; // $v1
					unsigned long xy; // $v0
			/* end block 1.2.1 */
			// End offset: 0x80093BE8
			// End Line: 1624
		/* end block 1.2 */
		// End offset: 0x80093BE8
		// End Line: 1624
	/* end block 1 */
	// End offset: 0x80093C3C
	// End Line: 1658

	/* begin block 2 */
		// Start line: 2959
	/* end block 2 */
	// End Line: 2960
					UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// short /*$ra*/ G2AnimSection_RewindOverInterval(struct _G2AnimSection_Type *section /*$s1*/, short interval /*$a1*/)
short G2AnimSection_RewindOverInterval(struct _G2AnimSection_Type *section, short interval)
{ // line 1671, offset 0x80093c6c
	/* begin block 1 */
		// Start line: 1672
		// Start offset: 0x80093C6C
		// Variables:
			short newTime; // $s3
			short extraTime; // $s6
			short elapsedTime; // $s7
			short endTime; // $s2
			struct _G2Anim_Type *anim; // $s4
			struct _G2SVector3_Type motionVector; // stack offset -48
			unsigned long message; // $s5

		/* begin block 1.1 */
			// Start line: 1832
			// Start offset: 0x80093E34
		/* end block 1.1 */
		// End offset: 0x80093E3C
		// End Line: 1832

		/* begin block 1.2 */
			// Start line: 1841
			// Start offset: 0x80093E4C

			/* begin block 1.2.1 */
				// Start line: 1841
				// Start offset: 0x80093E4C
				// Variables:
					unsigned short z; // $v1
					unsigned long xy; // $v0
			/* end block 1.2.1 */
			// End offset: 0x80093E4C
			// End Line: 1841
		/* end block 1.2 */
		// End offset: 0x80093E4C
		// End Line: 1841
	/* end block 1 */
	// End offset: 0x80093E80
	// End Line: 1867

	/* begin block 2 */
		// Start line: 3631
	/* end block 2 */
	// End Line: 3632
					UNIMPLEMENTED();
	return 0;
}

void _G2Anim_BuildTransformsNoControllers(struct _G2Anim_Type* anim)
{
	struct _Segment* segment;
	struct _G2Matrix_Type* segMatrix;
	enum _G2Bool_Enum bRootTransUpdated;
	int segIndex;
	int segCount;
	unsigned long disabledBits[3];
	unsigned long disabledMask;
	unsigned long parentMask;
	unsigned long parentIndex;
	unsigned long* disabledBitsArray;///@FIXME Not really here on original?

	segMatrix = anim->segMatrices;

	segment = anim->modelData->segmentList;
	
	disabledMask = 1;
	
	disabledBits[0] = anim->disabledBits[0];

	disabledBits[1] = anim->disabledBits[1];
	
	disabledBits[2] = anim->disabledBits[2];

	segCount = anim->modelData->numSegments;

	bRootTransUpdated = (_G2Bool_Enum)(((anim->section[0].flags & 0x88) ^ 0x80) < 1);
	
	if (segCount > 0)
	{
		disabledBitsArray = &disabledBits[0];
		
		for (segIndex = 0; segIndex < segCount; segIndex++)
		{
			if (segment[segIndex].parent != -1 && (disabledBitsArray[segment[segIndex].parent >> 5] & (1 << (segment[segIndex].parent & 0x1F))))
			{
				disabledBitsArray[0] |= disabledMask;
			}

			if (!(disabledBitsArray[0] & disabledMask))
			{
				_G2Anim_BuildSegTransformNoControllers(&segMatrix[segIndex], &anim->segMatrices[segment[segIndex].parent], bRootTransUpdated, segIndex);
			}

			bRootTransUpdated = (_G2Bool_Enum)0;

			disabledMask <<= 1;

			if (disabledMask == 0)
			{
				disabledBitsArray++;
				
				disabledMask = 1;
			}
		}
	}
}

void _G2Anim_BuildSegTransformNoControllers(struct _G2Matrix_Type* segMatrix, struct _G2Matrix_Type* parentMatrix, enum _G2Bool_Enum bRootTransUpdated, int segIndex)
{
	struct _G2AnimSegValue_Type* segValue;
	struct _G2LVector3_Type scale;
	struct _G2SVector3_Type* svector;
	struct _G2LVector3_Type* lvector;

	segValue = &_segValues[segIndex];

	scale.x = segValue->scale.x;
	scale.y = segValue->scale.y;
	scale.z = segValue->scale.z;

	_G2Anim_BuildSegLocalRotMatrix(segValue, segMatrix);

	if (0 < ((scale.x | scale.y | scale.z) ^ 4096))
	{
		ScaleMatrix((MATRIX*)segMatrix, (VECTOR*)&scale);

		segMatrix->scaleFlag = 1;
	}

	gte_SetRotMatrix(parentMatrix);

	gte_ldclmv((((short*)segMatrix) + 0));
	gte_rtir();
	gte_stclmv((((short*)segMatrix) + 0));

	gte_ldclmv((((short*)segMatrix) + 1));
	gte_rtir();
	gte_stclmv((((short*)segMatrix) + 1));

	gte_ldclmv((((short*)segMatrix) + 2));
	gte_rtir();
	gte_stclmv((((short*)segMatrix) + 2));

	svector = &segValue->trans;
	lvector = &segMatrix->trans;

	gte_ldv0(svector);
	gte_rtv0();
	gte_stlvnl(lvector);

	if (bRootTransUpdated != 0)
	{
		parentMatrix->trans.x += segMatrix->trans.x;
		parentMatrix->trans.y += segMatrix->trans.y;
		parentMatrix->trans.z += segMatrix->trans.z;
		
		segMatrix->trans.x = 0;
		segMatrix->trans.y = 0;
		segMatrix->trans.z = 0;
	}

	segMatrix->trans.x += parentMatrix->trans.x;
	segMatrix->trans.y += parentMatrix->trans.y;
	segMatrix->trans.z += parentMatrix->trans.z;
}


void _G2Anim_BuildSegLocalRotMatrix(struct _G2AnimSegValue_Type* segValue, struct _G2Matrix_Type* segMatrix)
{
	struct _G2SVector3_Type rot;
	struct _G2SVector3_Type* source;
	struct _G2SVector3_Type* dest;
	unsigned long mask;
	unsigned short z;
	unsigned long xy;

	source = &segValue->rotQuat.rot;
	
	if (source[3].y != 0)
	{
		G2Quat_ToMatrix_S(&segValue->rotQuat.quat, segMatrix);
	}
	else
	{
		mask = 0xFFF0FFF;

		dest = &rot;
		z = source->z & 0xFFF;
		xy = ((unsigned long*)&source->x)[0] & mask;

		rot.z = z;
		((unsigned long*)rot.x)[0] = xy;

		RotMatrixZYX((SVECTOR*)dest, (MATRIX*)segMatrix);
	}
}

void wombat(unsigned char* segKeyList, int flagBitOffset, struct _G2AnimSegKeyflagInfo_Type* kfInfo)
{
#if defined(PSX_VERSION)
	int flagDWordOffset;
	int flagBitShift;

	flagDWordOffset = flagBitOffset >> 5;
	
	flagDWordOffset <<= 5;

	kfInfo->stream = (unsigned long*)segKeyList + flagDWordOffset;
	
	flagBitShift = flagBitOffset - flagDWordOffset;
	
	kfInfo->flags = kfInfo->stream[0] >> flagBitShift;

#elif defined(PC_VERSION)
	ulong* v3; // esi
	ulong v4; // eax

	v3 = (ulong*)&segKeyList[4 * (flagBitOffset >> 5)];
	kfInfo->stream = v3;
	v4 = *v3 >> (flagBitOffset - 32 * (flagBitOffset >> 5));
	kfInfo->bitCount = 32 - (flagBitOffset & 0x1F);
	kfInfo->flags = v4;
#endif
}


// autogenerated function stub: 
// unsigned long /*$ra*/ kangaroo(struct _G2AnimSegKeyflagInfo_Type *kfInfo /*$a0*/)
unsigned long kangaroo(struct _G2AnimSegKeyflagInfo_Type *kfInfo)
{ // line 2129, offset 0x800942c0

#if defined(PSX_VERSION)
	UNIMPLEMENTED();

	return 0;

#elif defined(PC_VERSION)

	ulong* stream; // esi
	ulong flags; // ecx
	int v3; // edi
	unsigned int result; // eax
	ulong v5; // esi

	stream = kfInfo->stream;
	if (!kfInfo->stream)
		return 0;
	flags = kfInfo->flags;
	v3 = kfInfo->bitCount - 3;
	result = flags & 7;
	kfInfo->bitCount = v3;
	kfInfo->flags = flags >> 3;
	if (v3 <= 0)
	{
		kfInfo->stream = stream + 1;
		v5 = stream[1];
		kfInfo->flags = v5;
		if (v3 < 0)
		{
			result |= (v5 << (v3 + 3)) & 7;
			kfInfo->flags = v5 >> -(char)v3;
		}
		kfInfo->bitCount = v3 + 32;
	}
	return result;
#endif
}


// autogenerated function stub: 
// void /*$ra*/ _G2Anim_InitializeSegValue(struct _G2Anim_Type *anim /*$a0*/, struct _G2AnimSegValue_Type *segValue /*$a1*/, int segIndex /*$a2*/)
void _G2Anim_InitializeSegValue(struct _G2Anim_Type *anim, struct _G2AnimSegValue_Type *segValue, int segIndex)
{ // line 2167, offset 0x80094348
	/* begin block 1 */
		// Start line: 2170
		// Start offset: 0x80094348
		// Variables:
			struct _Segment *segment; // $v0

		/* begin block 1.1 */
			// Start line: 2170
			// Start offset: 0x80094348
			// Variables:
				struct _G2Quat_Type *quat; // $a1
		/* end block 1.1 */
		// End offset: 0x80094348
		// End Line: 2170

		/* begin block 1.2 */
			// Start line: 2170
			// Start offset: 0x80094348
		/* end block 1.2 */
		// End offset: 0x80094348
		// End Line: 2170

		/* begin block 1.3 */
			// Start line: 2170
			// Start offset: 0x80094348

			/* begin block 1.3.1 */
				// Start line: 2170
				// Start offset: 0x80094348
				// Variables:
					unsigned long zpad; // $v0
					unsigned long xy; // $v1
			/* end block 1.3.1 */
			// End offset: 0x80094348
			// End Line: 2170
		/* end block 1.3 */
		// End offset: 0x80094348
		// End Line: 2170
	/* end block 1 */
	// End offset: 0x80094348
	// End Line: 2170

	/* begin block 2 */
		// Start line: 4838
	/* end block 2 */
	// End Line: 4839

	/* begin block 3 */
		// Start line: 4840
	/* end block 3 */
	// End Line: 4841

	UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ _G2AnimSection_InitStatus(struct _G2AnimSection_Type *section /*$s7*/, struct _G2Anim_Type *anim /*stack 4*/)
void _G2AnimSection_InitStatus(struct _G2AnimSection_Type *section, struct _G2Anim_Type *anim)
{ // line 2224, offset 0x8009439c
	/* begin block 1 */
		// Start line: 2225
		// Start offset: 0x8009439C
		// Variables:
			struct _G2AnimDecompressChannelInfo_Type dcInfo; // stack offset -104
			struct _G2AnimSegValue_Type *segValue; // $s6
			struct _G2AnimChanStatusBlock_Type **chanStatusNextBlockPtr; // $s5
			struct _G2AnimChanStatusBlock_Type *chanStatusBlock; // $v0
			struct _G2AnimChanStatus_Type *chanStatus; // $s2
			int chanStatusChunkCount; // $s3
			struct _G2AnimSegKeyflagInfo_Type rotKfInfo; // stack offset -88
			struct _G2AnimSegKeyflagInfo_Type scaleKfInfo; // stack offset -72
			struct _G2AnimSegKeyflagInfo_Type transKfInfo; // stack offset -56
			int type; // $s0
			unsigned long segChanFlags; // $s1
			int segIndex; // $s4
			int lastSeg; // $fp

		/* begin block 1.1 */
			// Start line: 2225
			// Start offset: 0x8009439C
			// Variables:
				//struct _G2Anim_Type *anim; // stack offset 4
				//struct _G2AnimSection_Type *section; // $s7

			/* begin block 1.1.1 */
				// Start line: 2225
				// Start offset: 0x8009439C
				// Variables:
					int bitsPerFlagType; // $s2
					int flagBitOffset; // $s0
					unsigned long activeChanBits; // $s3
					unsigned char *segKeyList; // $s1
			/* end block 1.1.1 */
			// End offset: 0x80094470
			// End Line: 2225
		/* end block 1.1 */
		// End offset: 0x80094470
		// End Line: 2225
	/* end block 1 */
	// End offset: 0x80094600
	// End Line: 2336

	/* begin block 2 */
		// Start line: 4952
	/* end block 2 */
	// End Line: 4953
	UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ FooBar(struct _G2AnimSection_Type *section /*$s6*/, struct _G2Anim_Type *anim /*stack 4*/, int decompressedKey /*$s4*/, int targetKey /*stack 12*/, long timeOffset /*stack 16*/)
void FooBar(struct _G2AnimSection_Type *section, struct _G2Anim_Type *anim, int decompressedKey, int targetKey, long timeOffset)
{ // line 2346, offset 0x80094648
	/* begin block 1 */
		// Start line: 2347
		// Start offset: 0x80094648
		// Variables:
			struct _G2AnimDecompressChannelInfo_Type dcInfo; // stack offset -152
			struct _G2AnimSegValue_Type *segValue; // $s6
			short *chanValue; // $s1
			struct _G2AnimChanStatusBlock_Type *chanStatusBlock; // $s7
			struct _G2AnimChanStatus_Type *chanStatus; // $s3
			int chanStatusChunkCount; // $s5
			struct _G2AnimSegKeyflagInfo_Type rotKfInfo; // stack offset -136
			struct _G2AnimSegKeyflagInfo_Type scaleKfInfo; // stack offset -120
			struct _G2AnimSegKeyflagInfo_Type transKfInfo; // stack offset -104
			int type; // $s0
			unsigned long segChanFlags; // $s2
			int segIndex; // $s4
			int lastSeg; // stack offset -48
			struct _G2AnimDecompressChannelInfo_Type nextDCInfo; // stack offset -88
			struct _G2AnimDecompressChannelInfo_Type initDCInfo; // stack offset -72
			struct _G2AnimChanStatus_Type nextChanStatus; // stack offset -56

		/* begin block 1.1 */
			// Start line: 2347
			// Start offset: 0x80094648
			// Variables:
				//struct _G2Anim_Type *anim; // stack offset 4
				//struct _G2AnimSection_Type *section; // $s6

			/* begin block 1.1.1 */
				// Start line: 2347
				// Start offset: 0x80094648
				// Variables:
					int bitsPerFlagType; // $s2
					int flagBitOffset; // $s0
					unsigned long activeChanBits; // $s3
					unsigned char *segKeyList; // $s1
			/* end block 1.1.1 */
			// End offset: 0x80094728
			// End Line: 2347
		/* end block 1.1 */
		// End offset: 0x80094728
		// End Line: 2347
	/* end block 1 */
	// End offset: 0x80094AA0
	// End Line: 2508

	/* begin block 2 */
		// Start line: 5213
	/* end block 2 */
	// End Line: 5214
	UNIMPLEMENTED();
}

void _G2AnimSection_UpdateStoredFrameFromData(struct _G2AnimSection_Type *section, struct _G2Anim_Type *anim)
{
	short timePerKey;
	long storedKey;
	long targetKey;
	long timeOffset;

	storedKey = section->storedTime / section->keylist->timePerKey;
	timePerKey = section->keylist->timePerKey;
	targetKey = section->elapsedTime / timePerKey;

	if (storedKey >= 0)
	{
		if (targetKey < storedKey)
		{
			_G2AnimSection_InitStatus(section, anim);
			storedKey = -1;
		}

		timeOffset = ((section->elapsedTime - (targetKey * timePerKey)) >> 12) / timePerKey;

		FooBar(section, anim, storedKey, targetKey, timeOffset);

		section->flags |= 0x80;

		section->storedTime = section->elapsedTime;
	}
}

struct _G2Anim_Type* _G2AnimSection_GetAnim(struct _G2AnimSection_Type* section)
{
	return (struct _G2Anim_Type*)((char*)(section) - (section->sectionID * sizeof(struct _G2AnimSection_Type) + 0x24));
}


// autogenerated function stub: 
// void /*$ra*/ _G2AnimSection_TriggerEffects(struct _G2AnimSection_Type *section /*$s1*/, short startTime /*$a1*/, short endTime /*$a2*/)
void _G2AnimSection_TriggerEffects(struct _G2AnimSection_Type *section, short startTime, short endTime)
{ // line 2576, offset 0x80094bc0
#if defined(PSX_VERSION)
	UNIMPLEMENTED();
#elif defined(PC_VERSION)
	struct _G2AnimFxHeader_Type* fxHeader; // esi
	signed __int8 i; // dl
	int sectionID; // ecx
	unsigned int sizeAndSection; // edi
	int v8; // eax
	int v9; // edi
	__int16 v10; // ax
	int(__stdcall * callback)(); // ebp
	struct _G2AnimKeylist_Type* keylist; // [esp+Ch] [ebp+4h]

	keylist = section->keylist;
	fxHeader = keylist->fxList;
	if (fxHeader)
	{
		for (i = fxHeader->type; i != -1; fxHeader = (struct _G2AnimFxHeader_Type*)((char*)fxHeader + v9))
		{
			sectionID = section->sectionID;
			sizeAndSection = fxHeader->sizeAndSection;
			v8 = sizeAndSection & 0xF;
			v9 = (sizeAndSection >> 2) & 0x3C;
			if (v8 == sectionID)
			{
				if ((v10 = fxHeader->keyframeID * keylist->s0TailTime, startTime < v10) && endTime >= v10
					|| !v10 && startTime <= 0 && endTime >= 0)
				{
					callback = section->callback;
					if (callback)
						((void(__cdecl*)(__int16**, int, int, DWORD, struct _G2AnimFxHeader_Type*, void*))callback)(
							&section[-sectionID - 1].swAlarmTable,
							sectionID,
							6,
							i,
							&fxHeader[1],
							section->callbackData);
				}
			}
			i = *(&fxHeader->type + v9);
		}
	}
#endif
}


// autogenerated function stub: 
// void /*$ra*/ _G2Anim_FreeChanStatusBlockList(struct _G2AnimChanStatusBlock_Type *block /*$a1*/)
void _G2Anim_FreeChanStatusBlockList(struct _G2AnimChanStatusBlock_Type *block)
{ // line 2621, offset 0x80094cec
	/* begin block 1 */
		// Start line: 2622
		// Start offset: 0x80094CEC
		// Variables:
			struct _G2AnimChanStatusBlock_Type *nextBlock; // $s0
	/* end block 1 */
	// End offset: 0x80094D1C
	// End Line: 2633

	/* begin block 2 */
		// Start line: 5825
	/* end block 2 */
	// End Line: 5826
			UNIMPLEMENTED();
}

long _G2AnimAlphaTable_GetValue(struct _G2AnimAlphaTable_Type *table, long trueAlpha)
{
	long position;
	long positionInt;
	long positionFrac;
	long value;

	if (table != NULL)
	{
		position = (table->size - 1) * trueAlpha;
		positionInt = position >> 12;

		value = table->data[positionInt++];
		positionFrac = position & 0xFFF;

		return value + ((table->data[positionInt] - value) * positionFrac) >> 12;
	}
	
	return trueAlpha;
}




