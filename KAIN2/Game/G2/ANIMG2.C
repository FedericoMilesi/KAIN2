#include "CORE.H"
#include "ANIMG2.H"
#include "POOLMMG2.H"
#include "ANMG2ILF.H"
#include "ANMINTRP.H"

enum _G2Bool_Enum G2Anim_Install()
{
	struct _G2AnimController_Type *dummyController;

	G2PoolMem_InitPool(&_chanStatusBlockPool, 180, 36);
	G2PoolMem_InitPool(&_interpStateBlockPool, 96, 164);
	G2PoolMem_InitPool(&_controllerPool, 122, 164);

	dummyController = (struct _G2AnimController_Type*)G2PoolMem_Allocate(&_controllerPool);

	dummyController->next = 0;
	dummyController->segNumber = 255;
	dummyController->type = 0;

	return (_G2Bool_Enum)1;
}

#if defined(PC_VERSION)
struct _G2PoolMemPool_Type stru_B08B60,
	stru_B08B70,
	stru_B08B80;
#elif defined(PSX_VERSION)
struct _G2AnimChanStatusBlockPool_Type _chanStatusBlockPool;
struct _G2AnimInterpStateBlockPool_Type _interpStateBlockPool;
struct _G2AnimControllerPool_Type _controllerPool;
#endif

void G2Anim_ResetInternalState()
{
#if defined(PSX_VERSION)
	struct _G2AnimController_Type* dummyController;

	G2PoolMem_ResetPool(&_chanStatusBlockPool);
	G2PoolMem_ResetPool(&_interpStateBlockPool);
	G2PoolMem_ResetPool(&_controllerPool);

	dummyController = (struct _G2AnimController_Type*)G2PoolMem_Allocate(&_controllerPool);
	dummyController->next = 0;
	dummyController->segNumber = 255;
	dummyController->type = 0;

#elif defined(PC_VERSION)
	struct _G2AnimController_Type* dummyController; // eax

	G2PoolMem_ResetPool(&stru_B08B70);
	G2PoolMem_ResetPool(&stru_B08B60);
	G2PoolMem_ResetPool(&stru_B08B80);
	dummyController = (struct _G2AnimController_Type*)G2PoolMem_Allocate(&stru_B08B80);
	dummyController->next = 0;
	dummyController->segNumber = -1;
	dummyController->type = 0;
#endif
}

void G2Anim_Init(struct _G2Anim_Type *anim, struct _Model *modelData)
{
#if defined(PSX_VERSION)
	struct _G2AnimSection_Type* section;
	int sectionID;

	anim->sectionCount = 1;
	anim->masterSection = 0;
	anim->controllerList = 0;
	anim->disabledControllerList = 0;
	anim->segMatrices = NULL;
	anim->modelData = modelData;

	memset(anim->disabledBits, 0, sizeof(anim->disabledBits) + sizeof(anim->section));

	section = &anim->section[0];

	for (sectionID = 0; sectionID < 3; sectionID++, section++)
	{
		section->storedTime = -1;
		section->swAlarmTable = NULL;
		section->speedAdjustment = 4096;
	}

	anim->section[0].segCount = modelData->numSegments;

#elif defined(PC_VERSION)
	__int16** p_swAlarmTable; // eax
	int v3; // ecx

	anim->sectionCount = 1;
	anim->masterSection = 0;
	anim->controllerList = 0;
	anim->disabledControllerList = 0;
	anim->segMatrices = 0;
	anim->modelData = modelData;
	memset(anim->disabledBits, 0, 0x9Cu);
	p_swAlarmTable = &anim->section[0].swAlarmTable;
	v3 = 3;
	do
	{
		*((WORD*)p_swAlarmTable - 3) = -1;
		*p_swAlarmTable = 0;
		p_swAlarmTable[1] = (__int16*)4096;
		p_swAlarmTable += 12;
		--v3;
	} while (v3);
	anim->section[0].segCount = modelData->numSegments;
#endif
}

struct _G2AnimSection_Type * G2Anim_AddSection(struct _G2Anim_Type *anim, int firstSegID, int segCount)
{ 
	struct _G2AnimSection_Type* section;

	section = &anim->section[anim->sectionCount];

	memset(section, 0, sizeof(_G2AnimSection_Type));

	section->storedTime = -1;
	section->firstSeg = firstSegID;
	section->segCount = segCount;
	section->swAlarmTable = NULL;
	section->speedAdjustment = 4096;
	section->sectionID = anim->sectionCount;

	anim->sectionCount++;

	return section;
}


// autogenerated function stub: 
// void /*$ra*/ G2Anim_Free(struct _G2Anim_Type *anim /*$s4*/)
void G2Anim_Free(struct _G2Anim_Type *anim)
{ // line 487, offset 0x80092b94
	/* begin block 1 */
		// Start line: 488
		// Start offset: 0x80092B94
		// Variables:
			struct _G2AnimSection_Type *animSection; // $s1
			int sectionID; // $s2
			struct _G2AnimInterpInfo_Type *interpInfo; // $s0
	/* end block 1 */
	// End offset: 0x80092C30
	// End Line: 527

	/* begin block 2 */
		// Start line: 1048
	/* end block 2 */
	// End Line: 1049

}


// autogenerated function stub: 
// void /*$ra*/ G2Anim_Restore(struct _G2Anim_Type *anim /*$s2*/)
void G2Anim_Restore(struct _G2Anim_Type *anim)
{ // line 531, offset 0x80092c50
	/* begin block 1 */
		// Start line: 532
		// Start offset: 0x80092C50
		// Variables:
			struct _G2AnimSection_Type *animSection; // $a0
			int sectionID; // $s0
	/* end block 1 */
	// End offset: 0x80092CB8
	// End Line: 553

	/* begin block 2 */
		// Start line: 1162
	/* end block 2 */
	// End Line: 1163

}


// autogenerated function stub: 
// void /*$ra*/ G2Anim_BuildTransforms(struct _G2Anim_Type *anim /*$s0*/)
void G2Anim_BuildTransforms(struct _G2Anim_Type *anim)
{ // line 562, offset 0x80092cd0
	/* begin block 1 */
		// Start line: 563
		// Start offset: 0x80092CD0

		/* begin block 1.1 */
			// Start line: 574
			// Start offset: 0x80092CF8
		/* end block 1.1 */
		// End offset: 0x80092D00
		// End Line: 574

		/* begin block 1.2 */
			// Start line: 586
			// Start offset: 0x80092D38

			/* begin block 1.2.1 */
				// Start line: 586
				// Start offset: 0x80092D38
				// Variables:
					unsigned short z; // $v0
					unsigned long xy; // $v1
			/* end block 1.2.1 */
			// End offset: 0x80092D38
			// End Line: 586
		/* end block 1.2 */
		// End offset: 0x80092D38
		// End Line: 586

		/* begin block 1.3 */
			// Start line: 598
			// Start offset: 0x80092D6C
		/* end block 1.3 */
		// End offset: 0x80092D6C
		// End Line: 598
	/* end block 1 */
	// End offset: 0x80092D6C
	// End Line: 598

	/* begin block 2 */
		// Start line: 1238
	/* end block 2 */
	// End Line: 1239

}


// autogenerated function stub: 
// void /*$ra*/ G2Anim_UpdateStoredFrame(struct _G2Anim_Type *anim /*$s2*/)
void G2Anim_UpdateStoredFrame(struct _G2Anim_Type *anim)
{ // line 617, offset 0x80092d9c
	/* begin block 1 */
		// Start line: 618
		// Start offset: 0x80092D9C
		// Variables:
			struct _G2AnimSection_Type *section; // $s0
			short storedTime; // $s3
			short elapsedTime; // $s4
			struct _G2SVector3_Type motionVector; // stack offset -32
			int sectionCount; // $s1
			struct _G2AnimInterpInfo_Type *interpInfo; // $v0

		/* begin block 1.1 */
			// Start line: 669
			// Start offset: 0x80092E28
			// Variables:
				struct _G2SVector3_Type *vector; // $a3
		/* end block 1.1 */
		// End offset: 0x80092E28
		// End Line: 669
	/* end block 1 */
	// End offset: 0x80092EF8
	// End Line: 703

	/* begin block 2 */
		// Start line: 1353
	/* end block 2 */
	// End Line: 1354

}


// autogenerated function stub: 
// struct _G2AnimSection_Type * /*$ra*/ G2Anim_GetSectionWithSeg(struct _G2Anim_Type *anim /*$a0*/, int segNumber /*$a1*/)
struct _G2AnimSection_Type * G2Anim_GetSectionWithSeg(struct _G2Anim_Type *anim, int segNumber)
{ // line 712, offset 0x80092f18
	/* begin block 1 */
		// Start line: 715
		// Start offset: 0x80092F18
		// Variables:
			struct _G2AnimSection_Type *section; // $a3
			struct _G2AnimSection_Type *tempSection; // $a2
			struct _G2AnimSection_Type *endSection; // $a0
			int firstSeg; // $v1
			int lastSeg; // $v0
	/* end block 1 */
	// End offset: 0x80092F7C
	// End Line: 747

	/* begin block 2 */
		// Start line: 1557
	/* end block 2 */
	// End Line: 1558

	/* begin block 3 */
		// Start line: 1559
	/* end block 3 */
	// End Line: 1560

	/* begin block 4 */
		// Start line: 1570
	/* end block 4 */
	// End Line: 1571

	/* begin block 5 */
		// Start line: 1574
	/* end block 5 */
	// End Line: 1575

	return null;
}


// autogenerated function stub: 
// enum _G2Bool_Enum /*$ra*/ G2Anim_SegmentHasActiveChannels(struct _G2Anim_Type *anim /*$s0*/, int segNumber /*$s1*/, unsigned short chanMask /*$a2*/)
enum _G2Bool_Enum G2Anim_SegmentHasActiveChannels(struct _G2Anim_Type *anim, int segNumber, unsigned short chanMask)
{ // line 758, offset 0x80092f84
	/* begin block 1 */
		// Start line: 759
		// Start offset: 0x80092F84
		// Variables:
			struct _G2AnimSection_Type *section; // $a1
			unsigned char *segChanFlagStream; // $a0
			unsigned char activeChanBits; // $a2
			unsigned short dataFlagBits; // $v1
			unsigned short segFlagBits; // $a1
			int flagBytesPerSeg; // $t0
	/* end block 1 */
	// End offset: 0x800930A0
	// End Line: 848

	/* begin block 2 */
		// Start line: 1650
	/* end block 2 */
	// End Line: 1651

	return (_G2Bool_Enum)0;
}


// autogenerated function stub: 
// void /*$ra*/ G2Anim_GetSegChannelValue(struct _G2Anim_Type *anim /*$s0*/, int segIndex /*$s1*/, unsigned short *valueTable /*$s3*/, unsigned short channelMask /*$s2*/)
void G2Anim_GetSegChannelValue(struct _G2Anim_Type *anim, int segIndex, unsigned short *valueTable, unsigned short channelMask)
{ // line 866, offset 0x800930c4
	/* begin block 1 */
		// Start line: 867
		// Start offset: 0x800930C4
		// Variables:
			unsigned short *chanFinalValue; // $v1

		/* begin block 1.1 */
			// Start line: 867
			// Start offset: 0x800930C4

			/* begin block 1.1.1 */
				// Start line: 867
				// Start offset: 0x800930C4
				// Variables:
					unsigned short z; // $v1
					unsigned long xy; // $v0
			/* end block 1.1.1 */
			// End offset: 0x800930C4
			// End Line: 867
		/* end block 1.1 */
		// End offset: 0x800930C4
		// End Line: 867
	/* end block 1 */
	// End offset: 0x80093154
	// End Line: 905

	/* begin block 2 */
		// Start line: 1902
	/* end block 2 */
	// End Line: 1903

}

void G2Anim_GetRootMotionFromTimeForDuration(struct _G2Anim_Type *anim, short durationStart, short duration, struct _G2SVector3_Type *motionVector)
{ 
	struct _G2Anim_Type dummyAnim; // stack offset -216
	struct _G2AnimSection_Type* section; // $s2
	struct _G2AnimKeylist_Type* keylist; // $s4
	short storedKeyEndTime; // $s2
	short timePerKey; // $s0
	short keyTime; // $a0
	long alpha; // $a1
	struct _G2AnimInterpInfo_Type* interpInfo; // $a0

	struct _G2SVector3_Type* dest; // $s5
	struct _G2SVector3_Type* base; // $v0
	struct _G2SVector3_Type* offset; // $v1
	//long alpha; // $a1
	struct _G2SVector3_Type* vector; // $s5
	//struct _G2SVector3_Type* dest; // $s5
	//struct _G2SVector3_Type* base; // $s5

#if 0
	sub_800932B0:

	var_B8 = -0xB8
		var_A8 = -0xA8
		var_94 = -0x94
		var_93 = -0x93
		var_92 = -0x92
		var_91 = -0x91
		var_90 = -0x90
		var_8E = -0x8E
		var_70 = -0x70
		var_6C = -0x6C
		var_s0 = 0
		var_s4 = 4
		var_s8 = 8
		var_sC = 0xC
		var_s10 = 0x10
		var_s14 = 0x14
		var_s18 = 0x18
		var_s1C = 0x1C

		addiu   $sp, -0xE8
		move    $t0, $a0
		sw      $s6, 0xC8 + var_s18($sp)
		move    $s6, $a2
		sw      $s5, 0xC8 + var_s14($sp)
		move    $s5, $a3
		sw      $s1, 0xC8 + var_s4($sp)
		move    $s1, $a1
		sw      $s2, 0xC8 + var_s8($sp)
		addiu   $s2, $t0, 0x24  # '$'
		sw      $ra, 0xC8 + var_s1C($sp)
		sw      $s4, 0xC8 + var_s10($sp)
		sw      $s3, 0xC8 + var_sC($sp)
		sw      $s0, 0xC8 + var_s0($sp)
		lw      $a0, 0x2C($s2)
		nop
		beqz    $a0, loc_800933EC
		move    $s3, $s6
		lw      $s0, 8($a0)
		nop
		beqz    $s0, loc_800933EC
		sll     $v0, $a1, 16
		lh      $v1, 0($a0)
		sra     $v0, 4
		div     $v0, $v1
		mflo    $a1
		lw      $a0, 4($a0)
		jal     sub_80094E6C
		nop
		move    $a1, $v0
		addiu   $v0, $s0, 0x20  # ' '
		addiu   $v1, $s0, 0x26  # '&'
		lhu     $t4, 0($v0)
		lhu     $t5, 2($v0)
		lhu     $t6, 4($v0)
		mtc2    $t4, $25
		mtc2    $t5, $26
		mtc2    $t6, $27
		lhu     $t4, 0($v1)
		lhu     $t5, 2($v1)
		lhu     $t6, 4($v1)
		mtc2    $t4, $9
		mtc2    $t5, $10
		mtc2    $t6, $11
		mtc2    $a1, $8
		nop
		nop
		cop2    0x1A8003E
		mfc2    $t4, $25
		mfc2    $t5, $26
		mfc2    $t6, $27
		sh      $t4, 0($s5)
		sh      $t5, 2($s5)
		sh      $t6, 4($s5)
		lw      $s4, 0x24($s2)
		sll     $v0, $s6, 16
		lh      $v1, 6($s4)
		sra     $v0, 4
		div     $v0, $v1
		mflo    $a1
		lh      $v0, 0($s5)
		nop
		mult    $v0, $a1
		mflo    $t0
		lh      $v0, 2($s5)
		nop
		mult    $v0, $a1
		mflo    $v1
		lh      $v0, 4($s5)
		nop
		mult    $v0, $a1
		sra     $v0, $t0, 12
		sh      $v0, 0($s5)
		sra     $v0, $v1, 12
		sh      $v0, 2($s5)
		mflo    $a0
		sra     $v0, $a0, 12
		j       loc_80093560
		sh      $v0, 4($s5)

		loc_800933EC:
	lw      $s4, 0x24($s2)
		sll     $v0, $s1, 16
		lh      $a1, 6($s4)
		sra     $v0, 16
		div     $v0, $a1
		mflo    $v0
		lhu     $s0, 6($s4)
		addiu   $v0, 1
		mult    $s0, $v0
		li      $a0, 1
		lhu     $v1, 4($s4)
		sb      $a0, 0xC8 + var_B8($sp)
		mflo    $s2
		lw      $a2, 0x10($t0)
		addiu   $v1, -1
		mult    $a1, $v1
		sb      $zero, 0xC8 + var_93($sp)
		sb      $zero, 0xC8 + var_92($sp)
		sb      $a0, 0xC8 + var_91($sp)
		sw      $s4, 0xC8 + var_70($sp)
		sw      $zero, 0xC8 + var_6C($sp)
		sw      $a2, 0xC8 + var_A8($sp)
		negu    $v0, $s0
		sh      $v0, 0xC8 + var_8E($sp)
		sll     $v0, $s3, 16
		sw      $zero, 0($s5)
		mflo    $v1
		beqz    $v0, loc_80093554
		sh      $zero, 4($s5)
		sll     $v0, $v1, 16
		sra     $s6, $v0, 16

		loc_80093468:
	sll     $v0, $s1, 16
		sra     $v0, 16
		slt     $v0, $s6
		bnez    $v0, loc_80093480
		nop
		lbu     $s0, 1($s4)

		loc_80093480:
	sh      $s1, 0xC8 + var_90($sp)
		addiu   $a0, $sp, 0xC8 + var_94
		jal     sub_80094C10
		addiu   $a1, $sp, 0xC8 + var_B8
		subu    $v1, $s2, $s1
		move    $a0, $v1
		sll     $v1, 16
		sll     $v0, $s3, 16
		slt     $v0, $v1
		beqz    $v0, loc_800934B4
		sll     $v0, $a0, 16
		move    $a0, $s3
		sll     $v0, $a0, 16

		loc_800934B4:
	sra     $v1, $v0, 16
		sll     $v0, $s0, 16
		sra     $a1, $v0, 16
		slt     $v0, $v1, $a1
		beqz    $v0, loc_800934DC
		sll     $v0, $v1, 12
		div     $v0, $a1
		mflo    $a1
		j       loc_800934E0
		nop

		loc_800934DC :
	li      $a1, 0x1000

		loc_800934E0 :
		lhu     $t4, 0($s5)
		lhu     $t5, 2($s5)
		lhu     $t6, 4($s5)
		mtc2    $t4, $25
		mtc2    $t5, $26
		mtc2    $t6, $27
		addiu   $t1, $gp, -0x11F8
		lhu     $t4, 0($t1)
		lhu     $t5, 2($t1)
		lhu     $t6, 4($t1)
		mtc2    $t4, $9
		mtc2    $t5, $10
		mtc2    $t6, $11
		mtc2    $a1, $8
		nop
		nop
		cop2    0x1A8003E
		mfc2    $t4, $25
		mfc2    $t5, $26
		mfc2    $t6, $27
		sh      $t4, 0($s5)
		sh      $t5, 2($s5)
		sh      $t6, 4($s5)
		move    $s1, $s2
		subu    $v0, $s3, $a0
		move    $s3, $v0
		sll     $v0, 16
		bnez    $v0, loc_80093468
		addu    $s2, $s0

		loc_80093554 :
	lw      $a0, 0xC8 + var_6C($sp)
		jal     sub_80094E2C
		nop

		loc_80093560 :
	lw      $ra, 0xC8 + var_s1C($sp)
		lw      $s6, 0xC8 + var_s18($sp)
		lw      $s5, 0xC8 + var_s14($sp)
		lw      $s4, 0xC8 + var_s10($sp)
		lw      $s3, 0xC8 + var_sC($sp)
		lw      $s2, 0xC8 + var_s8($sp)
		lw      $s1, 0xC8 + var_s4($sp)
		lw      $s0, 0xC8 + var_s0($sp)
		jr      $ra
		addiu   $sp, 0xE8
#endif
}

void G2AnimSection_SwitchToKeylistAtTime(struct _G2AnimSection_Type *section, struct _G2AnimKeylist_Type *keylist, int keylistID, short targetTime)
{
	struct _G2Anim_Type *anim;
	struct _G2SVector3_Type rootMotion;
	struct _G2AnimInterpInfo_Type *interpInfo;
	unsigned short z;
	unsigned long xy;

	anim = _G2AnimSection_GetAnim(section);

	if (section->firstSeg == 0)
	{
		anim->flags |= 0x1;

		if (section->keylist != NULL && section->storedTime >= 0)
		{
			G2Anim_GetRootMotionOverInterval(anim, section->storedTime, section->elapsedTime, &rootMotion);
		}
		else
		{
			rootMotion.x = 0;
			rootMotion.y = 0;
			rootMotion.z = 0;
		}

		rootMotion.x += anim->rootTrans.x;
		rootMotion.y += anim->rootTrans.y;
		rootMotion.z += anim->rootTrans.z;
	}

	interpInfo = section->interpInfo;

	if (interpInfo != NULL)
	{
		if (interpInfo->stateBlockList != NULL)
		{
			_G2Anim_FreeInterpStateBlockList(interpInfo->stateBlockList);

			interpInfo->stateBlockList = NULL;
		}
	}
	
	G2AnimSection_ClearAlarm(section, 0x3);

	if (keylist != section->keylist)
	{
		section->keylist = keylist;
		section->keylistID = keylistID;
		section->storedTime = -keylist->timePerKey;
	}
	
	G2AnimSection_JumpToTime(section, targetTime);
	
	if (section->firstSeg == 0)
	{
		section->flags |= 0x80;
		xy = ((unsigned long*)&rootMotion)[0];
		z = rootMotion.z;
		
		((unsigned long*)&anim->rootTrans)[0] = xy;
		anim->rootTrans.z = z;
	}

	if ((section->flags & 0x2))
	{
		G2AnimSection_SetLoopRangeAll(section);
	}

	G2AnimSection_SetUnpaused(section);

	section->swAlarmTable = NULL;
}

void G2AnimSection_JumpToTime(struct _G2AnimSection_Type *section, short targetTime)
{
	struct _G2Anim_Type *anim;

	anim = _G2AnimSection_GetAnim(section);

	if (targetTime < section->elapsedTime)
	{
		section->keylist->timePerKey = -section->keylist->timePerKey;
	}

	section->elapsedTime = targetTime;
	
	_G2AnimSection_UpdateStoredFrameFromData(section, anim);
	
	G2AnimSection_ClearAlarm(section, 0x3);

	section->flags &= 0x7F;

	if (section->firstSeg == 0)
	{
		anim->rootTrans.x = 0;
		anim->rootTrans.y = 0;
		anim->rootTrans.z = 0;
	}
}


// autogenerated function stub: 
// short /*$ra*/ G2AnimSection_UpdateOverInterval(struct _G2AnimSection_Type *section /*$s0*/, short interval /*$a1*/)
short G2AnimSection_UpdateOverInterval(struct _G2AnimSection_Type *section, short interval)
{ // line 1273, offset 0x800936a0
	/* begin block 1 */
		// Start line: 1274
		// Start offset: 0x800936A0
		// Variables:
			struct _G2Anim_Type *anim; // $s2
			struct _G2SVector3_Type motionVector; // stack offset -32
			struct _G2AnimInterpInfo_Type *interpInfo; // $s1
			short elapsedTime; // $s3

		/* begin block 1.1 */
			// Start line: 1324
			// Start offset: 0x80093788

			/* begin block 1.1.1 */
				// Start line: 1324
				// Start offset: 0x80093788
				// Variables:
					unsigned short z; // $v1
					unsigned long xy; // $v0
			/* end block 1.1.1 */
			// End offset: 0x80093788
			// End Line: 1324
		/* end block 1.1 */
		// End offset: 0x80093788
		// End Line: 1324
	/* end block 1 */
	// End offset: 0x80093874
	// End Line: 1361

	/* begin block 2 */
		// Start line: 2725
	/* end block 2 */
	// End Line: 2726

	return 0;
}


// autogenerated function stub: 
// short /*$ra*/ G2AnimSection_AdvanceOverInterval(struct _G2AnimSection_Type *section /*$s1*/, short interval /*$s0*/)
short G2AnimSection_AdvanceOverInterval(struct _G2AnimSection_Type *section, short interval)
{ // line 1381, offset 0x80093894
	/* begin block 1 */
		// Start line: 1382
		// Start offset: 0x80093894
		// Variables:
			struct _G2AnimKeylist_Type *keylist; // $a0
			short newTime; // $s6
			short extraTime; // $s2
			short elapsedTime; // $fp
			short endTime; // $s4
			short loopExtraTime; // stack offset -48
			short *swAlarmTable; // $s0
			short swAlarmTime; // $v1
			struct _G2Anim_Type *anim; // $s7
			struct _G2SVector3_Type motionVector; // stack offset -56
			unsigned long message; // $s3

		/* begin block 1.1 */
			// Start line: 1614
			// Start offset: 0x80093BD0
		/* end block 1.1 */
		// End offset: 0x80093BD8
		// End Line: 1614

		/* begin block 1.2 */
			// Start line: 1624
			// Start offset: 0x80093BE8

			/* begin block 1.2.1 */
				// Start line: 1624
				// Start offset: 0x80093BE8
				// Variables:
					unsigned short z; // $v1
					unsigned long xy; // $v0
			/* end block 1.2.1 */
			// End offset: 0x80093BE8
			// End Line: 1624
		/* end block 1.2 */
		// End offset: 0x80093BE8
		// End Line: 1624
	/* end block 1 */
	// End offset: 0x80093C3C
	// End Line: 1658

	/* begin block 2 */
		// Start line: 2959
	/* end block 2 */
	// End Line: 2960

	return 0;
}


// autogenerated function stub: 
// short /*$ra*/ G2AnimSection_RewindOverInterval(struct _G2AnimSection_Type *section /*$s1*/, short interval /*$a1*/)
short G2AnimSection_RewindOverInterval(struct _G2AnimSection_Type *section, short interval)
{ // line 1671, offset 0x80093c6c
	/* begin block 1 */
		// Start line: 1672
		// Start offset: 0x80093C6C
		// Variables:
			short newTime; // $s3
			short extraTime; // $s6
			short elapsedTime; // $s7
			short endTime; // $s2
			struct _G2Anim_Type *anim; // $s4
			struct _G2SVector3_Type motionVector; // stack offset -48
			unsigned long message; // $s5

		/* begin block 1.1 */
			// Start line: 1832
			// Start offset: 0x80093E34
		/* end block 1.1 */
		// End offset: 0x80093E3C
		// End Line: 1832

		/* begin block 1.2 */
			// Start line: 1841
			// Start offset: 0x80093E4C

			/* begin block 1.2.1 */
				// Start line: 1841
				// Start offset: 0x80093E4C
				// Variables:
					unsigned short z; // $v1
					unsigned long xy; // $v0
			/* end block 1.2.1 */
			// End offset: 0x80093E4C
			// End Line: 1841
		/* end block 1.2 */
		// End offset: 0x80093E4C
		// End Line: 1841
	/* end block 1 */
	// End offset: 0x80093E80
	// End Line: 1867

	/* begin block 2 */
		// Start line: 3631
	/* end block 2 */
	// End Line: 3632

	return 0;
}


// autogenerated function stub: 
// void /*$ra*/ _G2Anim_BuildTransformsNoControllers(struct _G2Anim_Type *anim /*$s4*/)
void _G2Anim_BuildTransformsNoControllers(struct _G2Anim_Type *anim)
{ // line 1876, offset 0x80093eac
	/* begin block 1 */
		// Start line: 1877
		// Start offset: 0x80093EAC
		// Variables:
			struct _Segment *segment; // $a1
			struct _G2Matrix_Type *segMatrix; // $s5
			enum _G2Bool_Enum bRootTransUpdated; // $a2
			int segIndex; // $s3
			int segCount; // $s6
			unsigned long disabledBits[3]; // stack offset -56
			unsigned long disabledMask; // $s1
			unsigned long parentMask; // $v1
			unsigned long parentIndex; // $v0
	/* end block 1 */
	// End offset: 0x80093FD4
	// End Line: 1949

	/* begin block 2 */
		// Start line: 4114
	/* end block 2 */
	// End Line: 4115

}


// autogenerated function stub: 
// void /*$ra*/ _G2Anim_BuildSegTransformNoControllers(struct _G2Matrix_Type *segMatrix /*$s0*/, struct _G2Matrix_Type *parentMatrix /*$s3*/, enum _G2Bool_Enum bRootTransUpdated /*$s4*/, int segIndex /*$a3*/)
void _G2Anim_BuildSegTransformNoControllers(struct _G2Matrix_Type *segMatrix, struct _G2Matrix_Type *parentMatrix, enum _G2Bool_Enum bRootTransUpdated, int segIndex)
{ // line 1959, offset 0x80094000
	/* begin block 1 */
		// Start line: 1960
		// Start offset: 0x80094000
		// Variables:
			struct _G2AnimSegValue_Type *segValue; // $s1
			struct _G2LVector3_Type scale; // stack offset -40

		/* begin block 1.1 */
			// Start line: 2009
			// Start offset: 0x80094084
			// Variables:
				struct _G2SVector3_Type *svector; // $v0
				struct _G2LVector3_Type *lvector; // $v1
		/* end block 1.1 */
		// End offset: 0x80094084
		// End Line: 2009
	/* end block 1 */
	// End offset: 0x800941CC
	// End Line: 2055

	/* begin block 2 */
		// Start line: 4369
	/* end block 2 */
	// End Line: 4370

}


// autogenerated function stub: 
// void /*$ra*/ _G2Anim_BuildSegLocalRotMatrix(struct _G2AnimSegValue_Type *segValue /*$v1*/, struct _G2Matrix_Type *segMatrix /*$a1*/)
void _G2Anim_BuildSegLocalRotMatrix(struct _G2AnimSegValue_Type *segValue, struct _G2Matrix_Type *segMatrix)
{ // line 2063, offset 0x80094228
	/* begin block 1 */
		// Start line: 2064
		// Start offset: 0x80094228
		// Variables:
			struct _G2SVector3_Type rot; // stack offset -16

		/* begin block 1.1 */
			// Start line: 2070
			// Start offset: 0x80094254
			// Variables:
				struct _G2SVector3_Type *source; // $v1
				struct _G2SVector3_Type *dest; // $a0

			/* begin block 1.1.1 */
				// Start line: 2070
				// Start offset: 0x80094254
				// Variables:
					unsigned long mask; // $a2
					unsigned short z; // $v0
					unsigned long xy; // $v1
			/* end block 1.1.1 */
			// End offset: 0x80094254
			// End Line: 2070
		/* end block 1.1 */
		// End offset: 0x80094254
		// End Line: 2070
	/* end block 1 */
	// End offset: 0x80094278
	// End Line: 2074

	/* begin block 2 */
		// Start line: 4616
	/* end block 2 */
	// End Line: 4617

}


// autogenerated function stub: 
// void /*$ra*/ wombat(unsigned char *segKeyList /*$a0*/, int flagBitOffset /*$a1*/, struct _G2AnimSegKeyflagInfo_Type *kfInfo /*$a2*/)
void wombat(unsigned char *segKeyList, int flagBitOffset, struct _G2AnimSegKeyflagInfo_Type *kfInfo)
{ // line 2113, offset 0x80094288
	ulong* v3; // esi
	ulong v4; // eax

	v3 = (ulong*)&segKeyList[4 * (flagBitOffset >> 5)];
	kfInfo->stream = v3;
	v4 = *v3 >> (flagBitOffset - 32 * (flagBitOffset >> 5));
	kfInfo->bitCount = 32 - (flagBitOffset & 0x1F);
	kfInfo->flags = v4;
}


// autogenerated function stub: 
// unsigned long /*$ra*/ kangaroo(struct _G2AnimSegKeyflagInfo_Type *kfInfo /*$a0*/)
unsigned long kangaroo(struct _G2AnimSegKeyflagInfo_Type *kfInfo)
{ // line 2129, offset 0x800942c0
	ulong* stream; // esi
	ulong flags; // ecx
	int v3; // edi
	unsigned int result; // eax
	ulong v5; // esi

	stream = kfInfo->stream;
	if (!kfInfo->stream)
		return 0;
	flags = kfInfo->flags;
	v3 = kfInfo->bitCount - 3;
	result = flags & 7;
	kfInfo->bitCount = v3;
	kfInfo->flags = flags >> 3;
	if (v3 <= 0)
	{
		kfInfo->stream = stream + 1;
		v5 = stream[1];
		kfInfo->flags = v5;
		if (v3 < 0)
		{
			result |= (v5 << (v3 + 3)) & 7;
			kfInfo->flags = v5 >> -(char)v3;
		}
		kfInfo->bitCount = v3 + 32;
	}
	return result;
}


// autogenerated function stub: 
// void /*$ra*/ _G2Anim_InitializeSegValue(struct _G2Anim_Type *anim /*$a0*/, struct _G2AnimSegValue_Type *segValue /*$a1*/, int segIndex /*$a2*/)
void _G2Anim_InitializeSegValue(struct _G2Anim_Type *anim, struct _G2AnimSegValue_Type *segValue, int segIndex)
{ // line 2167, offset 0x80094348
	/* begin block 1 */
		// Start line: 2170
		// Start offset: 0x80094348
		// Variables:
			struct _Segment *segment; // $v0

		/* begin block 1.1 */
			// Start line: 2170
			// Start offset: 0x80094348
			// Variables:
				struct _G2Quat_Type *quat; // $a1
		/* end block 1.1 */
		// End offset: 0x80094348
		// End Line: 2170

		/* begin block 1.2 */
			// Start line: 2170
			// Start offset: 0x80094348
		/* end block 1.2 */
		// End offset: 0x80094348
		// End Line: 2170

		/* begin block 1.3 */
			// Start line: 2170
			// Start offset: 0x80094348

			/* begin block 1.3.1 */
				// Start line: 2170
				// Start offset: 0x80094348
				// Variables:
					unsigned long zpad; // $v0
					unsigned long xy; // $v1
			/* end block 1.3.1 */
			// End offset: 0x80094348
			// End Line: 2170
		/* end block 1.3 */
		// End offset: 0x80094348
		// End Line: 2170
	/* end block 1 */
	// End offset: 0x80094348
	// End Line: 2170

	/* begin block 2 */
		// Start line: 4838
	/* end block 2 */
	// End Line: 4839

	/* begin block 3 */
		// Start line: 4840
	/* end block 3 */
	// End Line: 4841

}


// autogenerated function stub: 
// void /*$ra*/ _G2AnimSection_InitStatus(struct _G2AnimSection_Type *section /*$s7*/, struct _G2Anim_Type *anim /*stack 4*/)
void _G2AnimSection_InitStatus(struct _G2AnimSection_Type *section, struct _G2Anim_Type *anim)
{ // line 2224, offset 0x8009439c
	/* begin block 1 */
		// Start line: 2225
		// Start offset: 0x8009439C
		// Variables:
			struct _G2AnimDecompressChannelInfo_Type dcInfo; // stack offset -104
			struct _G2AnimSegValue_Type *segValue; // $s6
			struct _G2AnimChanStatusBlock_Type **chanStatusNextBlockPtr; // $s5
			struct _G2AnimChanStatusBlock_Type *chanStatusBlock; // $v0
			struct _G2AnimChanStatus_Type *chanStatus; // $s2
			int chanStatusChunkCount; // $s3
			struct _G2AnimSegKeyflagInfo_Type rotKfInfo; // stack offset -88
			struct _G2AnimSegKeyflagInfo_Type scaleKfInfo; // stack offset -72
			struct _G2AnimSegKeyflagInfo_Type transKfInfo; // stack offset -56
			int type; // $s0
			unsigned long segChanFlags; // $s1
			int segIndex; // $s4
			int lastSeg; // $fp

		/* begin block 1.1 */
			// Start line: 2225
			// Start offset: 0x8009439C
			// Variables:
				//struct _G2Anim_Type *anim; // stack offset 4
				//struct _G2AnimSection_Type *section; // $s7

			/* begin block 1.1.1 */
				// Start line: 2225
				// Start offset: 0x8009439C
				// Variables:
					int bitsPerFlagType; // $s2
					int flagBitOffset; // $s0
					unsigned long activeChanBits; // $s3
					unsigned char *segKeyList; // $s1
			/* end block 1.1.1 */
			// End offset: 0x80094470
			// End Line: 2225
		/* end block 1.1 */
		// End offset: 0x80094470
		// End Line: 2225
	/* end block 1 */
	// End offset: 0x80094600
	// End Line: 2336

	/* begin block 2 */
		// Start line: 4952
	/* end block 2 */
	// End Line: 4953

}


// autogenerated function stub: 
// void /*$ra*/ FooBar(struct _G2AnimSection_Type *section /*$s6*/, struct _G2Anim_Type *anim /*stack 4*/, int decompressedKey /*$s4*/, int targetKey /*stack 12*/, long timeOffset /*stack 16*/)
void FooBar(struct _G2AnimSection_Type *section, struct _G2Anim_Type *anim, int decompressedKey, int targetKey, long timeOffset)
{ // line 2346, offset 0x80094648
	/* begin block 1 */
		// Start line: 2347
		// Start offset: 0x80094648
		// Variables:
			struct _G2AnimDecompressChannelInfo_Type dcInfo; // stack offset -152
			struct _G2AnimSegValue_Type *segValue; // $s6
			short *chanValue; // $s1
			struct _G2AnimChanStatusBlock_Type *chanStatusBlock; // $s7
			struct _G2AnimChanStatus_Type *chanStatus; // $s3
			int chanStatusChunkCount; // $s5
			struct _G2AnimSegKeyflagInfo_Type rotKfInfo; // stack offset -136
			struct _G2AnimSegKeyflagInfo_Type scaleKfInfo; // stack offset -120
			struct _G2AnimSegKeyflagInfo_Type transKfInfo; // stack offset -104
			int type; // $s0
			unsigned long segChanFlags; // $s2
			int segIndex; // $s4
			int lastSeg; // stack offset -48
			struct _G2AnimDecompressChannelInfo_Type nextDCInfo; // stack offset -88
			struct _G2AnimDecompressChannelInfo_Type initDCInfo; // stack offset -72
			struct _G2AnimChanStatus_Type nextChanStatus; // stack offset -56

		/* begin block 1.1 */
			// Start line: 2347
			// Start offset: 0x80094648
			// Variables:
				//struct _G2Anim_Type *anim; // stack offset 4
				//struct _G2AnimSection_Type *section; // $s6

			/* begin block 1.1.1 */
				// Start line: 2347
				// Start offset: 0x80094648
				// Variables:
					int bitsPerFlagType; // $s2
					int flagBitOffset; // $s0
					unsigned long activeChanBits; // $s3
					unsigned char *segKeyList; // $s1
			/* end block 1.1.1 */
			// End offset: 0x80094728
			// End Line: 2347
		/* end block 1.1 */
		// End offset: 0x80094728
		// End Line: 2347
	/* end block 1 */
	// End offset: 0x80094AA0
	// End Line: 2508

	/* begin block 2 */
		// Start line: 5213
	/* end block 2 */
	// End Line: 5214

}

void _G2AnimSection_UpdateStoredFrameFromData(struct _G2AnimSection_Type *section, struct _G2Anim_Type *anim)
{
	short timePerKey;
	long storedKey;
	long targetKey;
	long timeOffset;

	storedKey = section->storedTime / section->keylist->timePerKey;
	timePerKey = section->keylist->timePerKey;
	targetKey = section->elapsedTime / timePerKey;

	if (storedKey >= 0)
	{
		if (targetKey < storedKey)
		{
			_G2AnimSection_InitStatus(section, anim);
			storedKey = -1;
		}

		timeOffset = ((section->elapsedTime - (targetKey * timePerKey)) >> 12) / timePerKey;

		FooBar(section, anim, storedKey, targetKey, timeOffset);

		section->flags |= 0x80;

		section->storedTime = section->elapsedTime;
	}
}

struct _G2Anim_Type* _G2AnimSection_GetAnim(struct _G2AnimSection_Type *section)
{
	return (struct _G2Anim_Type*)((char*)(section) - (section->sectionID * sizeof(struct _G2AnimSection_Type) + 0x24));
}


// autogenerated function stub: 
// void /*$ra*/ _G2AnimSection_TriggerEffects(struct _G2AnimSection_Type *section /*$s1*/, short startTime /*$a1*/, short endTime /*$a2*/)
void _G2AnimSection_TriggerEffects(struct _G2AnimSection_Type *section, short startTime, short endTime)
{ // line 2576, offset 0x80094bc0
#if defined(PC_VERSION)
	struct _G2AnimFxHeader_Type* fxHeader; // esi
	signed __int8 i; // dl
	int sectionID; // ecx
	unsigned int sizeAndSection; // edi
	int v8; // eax
	int v9; // edi
	__int16 v10; // ax
	int(__stdcall * callback)(); // ebp
	struct _G2AnimKeylist_Type* keylist; // [esp+Ch] [ebp+4h]

	keylist = section->keylist;
	fxHeader = keylist->fxList;
	if (fxHeader)
	{
		for (i = fxHeader->type; i != -1; fxHeader = (struct _G2AnimFxHeader_Type*)((char*)fxHeader + v9))
		{
			sectionID = section->sectionID;
			sizeAndSection = fxHeader->sizeAndSection;
			v8 = sizeAndSection & 0xF;
			v9 = (sizeAndSection >> 2) & 0x3C;
			if (v8 == sectionID)
			{
				if ((v10 = fxHeader->keyframeID * keylist->s0TailTime, startTime < v10) && endTime >= v10
					|| !v10 && startTime <= 0 && endTime >= 0)
				{
					callback = section->callback;
					if (callback)
						((void(__cdecl*)(__int16**, int, int, DWORD, struct _G2AnimFxHeader_Type*, void*))callback)(
							&section[-sectionID - 1].swAlarmTable,
							sectionID,
							6,
							i,
							&fxHeader[1],
							section->callbackData);
				}
			}
			i = *(&fxHeader->type + v9);
		}
	}
#endif
}


// autogenerated function stub: 
// void /*$ra*/ _G2Anim_FreeChanStatusBlockList(struct _G2AnimChanStatusBlock_Type *block /*$a1*/)
void _G2Anim_FreeChanStatusBlockList(struct _G2AnimChanStatusBlock_Type *block)
{ // line 2621, offset 0x80094cec
	/* begin block 1 */
		// Start line: 2622
		// Start offset: 0x80094CEC
		// Variables:
			struct _G2AnimChanStatusBlock_Type *nextBlock; // $s0
	/* end block 1 */
	// End offset: 0x80094D1C
	// End Line: 2633

	/* begin block 2 */
		// Start line: 5825
	/* end block 2 */
	// End Line: 5826

}

long _G2AnimAlphaTable_GetValue(struct _G2AnimAlphaTable_Type *table, long trueAlpha)
{
	long position;
	long positionInt;
	long positionFrac;
	long value;

	if (table != NULL)
	{
		position = (table->size - 1) * trueAlpha;
		positionInt = position >> 12;

		value = table->data[positionInt++];
		positionFrac = position & 0xFFF;

		return value + ((table->data[positionInt] - value) * positionFrac) >> 12;
	}
	
	return trueAlpha;
}




