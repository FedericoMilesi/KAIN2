#include "CORE.H"
#include "EVENT.H"
#include "CINEMA/CINEPSX.H"
#include "Game/SCRIPT.H"
#include "Game/LOCAL/LOCALSTR.H"
#include "Game/FONT.H"
#include "Game/MENU/MENU.H"
#include "Game/COLLIDE.H"
#include "Game/PIPE3D.H"
#include "Game/SOUND.H"
#include "PSX/MAIN.H"
#include "GAMEPAD.H"
#include "STRMLOAD.H"
#include "STATE.H"
#include "Game/PSX/COLLIDES.H"

struct HintSystemStruct gHintSystem; // offset 0x800D2AFC
struct WaterLevelProcess WaterLevelArray[5]; // offset 0x800D2744
long WaterInUse; // offset 0x800CF544
struct EventTimer eventTimerArray[24]; // offset 0x800D27D4
long numActiveEventTimers; // offset 0x800D2A14
long WaitingForVoiceNumber; // offset 0x800D2AF8
long WaitingToLoadSFX; // offset 0x800D2AF4
long WaitingToLoadSound; // offset 0x800D2A18
short MoviePlayed; // offset 0x800D2A6C
short MovieToPlay; // offset 0x800D2A70
struct _Instance* eventListArray[20][10]; // offset 0x800D44C0
long eventListNumInstances[20]; // offset 0x800D43D0
struct Level* CurrentPuzzleLevel; // offset 0x800D27D0
long NumSignalsToReset;
struct SignalResetStruct ResetSignalArray[16];
struct Event* currentEventInstance;
long EventCurrentEventIndex;
short EventAbortLine;
long CurrentEventLine;
struct ScriptPCode* currentActionScript;
short EventJustRecievedTimer;
short* EventAbortedPosition;
long MoveCodeStreamExtra;

#define OPERATION_ADD 1
#define OPERATION_SUB 2
#define OPERATION_MUL 3
#define OPERATION_DIV 4
#define OPERATION_MOD 5
#define OPERATION_GREATER_THAN 6
#define OPERATION_LESS_THAN 7
#define OPERATION_GREATER_THAN_OR_EQUAL 8
#define OPERATION_LESS_THAN_OR_EQUAL 9
#define OPERATION_EQU 10
#define OPERATION_NEQ 11
#define OPERATION_AND 12
#define OPERAND_VECTOR3D 9
#define OPERAND_ROTATION3D 14
#define OPERAND_LIST 18
#define OPERAND_SUBLIST 22

static inline int EVENT_check_flag_set(int flags, int flag)
{
	return (flags & flag) != 0;
}
static inline int EVENT_check_flag_unset(int flags, int flag)
{
	return (flags & flag) == 0;
}

// autogenerated function stub: 
// void /*$ra*/ EVENT_UpdateResetSignalArrayAndWaterMovement(struct Level *oldLevel /*$a0*/, struct Level *newLevel /*$a1*/, long sizeOfLevel /*$a2*/)
void EVENT_UpdateResetSignalArrayAndWaterMovement(struct Level *oldLevel, struct Level *newLevel, long sizeOfLevel)
{ // line 151, offset 0x800605d0
	/* begin block 1 */
		// Start line: 152
		// Start offset: 0x800605D0
		// Variables:
			long offset; // $a1
			long i; // $t0

		/* begin block 1.1 */
			// Start line: 173
			// Start offset: 0x80060648
			// Variables:
				struct WaterLevelProcess *curWater; // $t1
		/* end block 1.1 */
		// End offset: 0x800606A4
		// End Line: 186
	/* end block 1 */
	// End offset: 0x800606A4
	// End Line: 188

	/* begin block 2 */
		// Start line: 302
	/* end block 2 */
	// End Line: 303

	/* begin block 3 */
		// Start line: 307
	/* end block 3 */
	// End Line: 308
				UNIMPLEMENTED();
}

void EVENT_ResetAllOneTimeVariables()  // Matching - 100%
{
	int i;

	if (NumSignalsToReset != 0)
	{
		for (i = 0; i < 16; i++)
		{
			if (ResetSignalArray[i].timeLeft > 0 && --ResetSignalArray[i].timeLeft == 0)
			{
				NumSignalsToReset--;

				ResetSignalArray[i].mSignal->flags &= ~0x1;
				ResetSignalArray[i].timeLeft = 0;
			}
		}
	}
}

void EVENT_AddSignalToReset(struct _MultiSignal *mSignal)  // Matching - 100%
{
	int i;
	
	if (NumSignalsToReset < 16)
	{
		for (i = 0; i < 16; i++)
		{
			if (ResetSignalArray[i].timeLeft == 0)
			{
				ResetSignalArray[i].timeLeft = 1;

				ResetSignalArray[i].mSignal = mSignal;

				NumSignalsToReset++;

				return;
			}
		}
	}
}

void HINT_ResetHint()  // Matching - 100%
{
	memset(&gHintSystem, 0, sizeof(struct HintSystemStruct));
}

void HINT_StartHint(short hintNumber)  // Matching - 100%
{
	unsigned int h;  // changed type in regards to SYMDUMP
	unsigned int temp;  // not from SYMDUMP

	h = hintNumber + 55;

	gHintSystem.flags = 0x2 | 0x1;

	temp = gHintSystem.hintNumber = hintNumber;

	if (temp >= 54)
	{
		h = 108;
	}

	gHintSystem.stringNumber = h;

	gHintSystem.fadeTimer = 61440;

	gHintSystem.spawningUnitID = gameTrackerX.playerInstance->currentStreamUnitID;
}


void HINT_StopHint()  // Matching - 100%
{
	if (!(gHintSystem.flags & 0x1))
	{
		return;
	}

	if (!(gHintSystem.flags & 0x2) && !(gHintSystem.flags & 0x4))
	{
		gHintSystem.flags |= 0x4;

		if (gHintSystem.flags & 0x2)
		{
			gHintSystem.flags &= ~0x2;
			gHintSystem.fadeTimer = (61440 - gHintSystem.fadeTimer);
		}
		else
		{
			gHintSystem.fadeTimer = 61440;
		}
	}
}

void HINT_KillSpecificHint(short hintNumber)  // Matching - 100%
{
	if (gHintSystem.hintNumber == hintNumber)
	{
		HINT_StopHint();
	}
}

long HINT_GetCurrentHint()  // Matching - 100%
{
	if ((gHintSystem.flags & 0x1))
	{
		return gHintSystem.hintNumber;
	}

	return -1;
}

void EVENT_ProcessTimers()  // Matching - 100%
{
	int i;
	struct EventTimer* eventTimer;

	if (numActiveEventTimers != 0)
	{
		for (i = 0; i < 24; i++)
		{
			eventTimer = &eventTimerArray[i];

			if (eventTimer->flags & 1)
			{
				if ((unsigned long)eventTimer->time < gameTrackerX.timeMult)
				{
					eventTimer->time = 0;
				}
				else
				{
					eventTimer->time = (eventTimer->time - gameTrackerX.timeMult);
				}

				if (eventTimer->time <= 0)
				{
					eventTimer->time = 0;
					currentEventInstance = eventTimer->event;
					eventTimer->actionScript->conditionBits &= 0xFFFE;
					EVENT_RemoveTimer(eventTimer);
					EventAbortLine = 0;
					CurrentPuzzleLevel = eventTimer->level;
					EventCurrentEventIndex = eventTimer->nextEventIndex;

					if ((EVENT_DoAction(eventTimer->event, eventTimer->actionScript, eventTimer->scriptPos) != 0) && (EventCurrentEventIndex != -1))
					{
						EVENT_Process(eventTimer->event, EventCurrentEventIndex);
					}
				}
			}
		}
	}
}

void EVENT_ProcessHints()  // Matching - 100%
{
	char string[128];
	long y;

	if ((gHintSystem.flags & 0x1))
	{
		sprintf(string, "%s\n", localstr_get((enum localstr_t)gHintSystem.stringNumber));

		if ((gHintSystem.flags & 0x2))
		{
			y = ((gHintSystem.fadeTimer * 52) / 61440) + 200;
		}
		else
		{
			y = 200;
			if ((gHintSystem.flags & 0x4))
			{
				y = 252 - ((gHintSystem.fadeTimer * 52) / 61440);
			}
		}

		FONT_FontPrintCentered(string, y);

		FONT_FontPrintCentered("$\n", y);

		DisplayHintBox(FONT_GetStringWidth(string), y);

		if (gHintSystem.fadeTimer != 0)
		{
			if (gameTrackerX.timeMult >= (unsigned long)gHintSystem.fadeTimer)
			{
				gHintSystem.fadeTimer = 0;

				if ((gHintSystem.flags & 0x2))
				{
					gHintSystem.flags &= 0xFFFD;
				}
				else if ((gHintSystem.flags & 0x4))
				{
					gHintSystem.flags = 0;

					gHintSystem.hintNumber = -1;

					gHintSystem.stringNumber = -1;
				}
			}
			else
			{
				gHintSystem.fadeTimer -= gameTrackerX.timeMult;
			}
		}

		if (gHintSystem.spawningUnitID != gameTrackerX.playerInstance->currentStreamUnitID)
		{
			HINT_StopHint();
		}

		if ((gameTrackerX.gameFlags & 0x10))
		{
			HINT_StopHint();
		}
	}
}

struct EventTimer* EVENT_GetNextTimer()  // Matching - 100%
{
	int i;
	struct EventTimer* eventTimer;

	if (numActiveEventTimers < 24)
	{
		for (eventTimer = (struct EventTimer*)&eventTimerArray, i = 24; i > 0; i--, eventTimer++)
		{
			if (!(eventTimer->flags & 0x1))
			{
				numActiveEventTimers++;

				eventTimer->flags |= 0x1;

				return eventTimer;
			}
		}
	}
	return NULL;
}

void EVENT_RemoveTimer(struct EventTimer* timer)  // Matching - 100%
{
	if (timer != NULL)
	{
		numActiveEventTimers--;

		timer->flags &= 0xFFFFFFFE;
	}
}

void EVENT_InitTimers()  // Matching - 100%
{
	numActiveEventTimers = 0;
	memset(&eventTimerArray[0], 0, sizeof(struct EventTimer) * 24);
}

void EVENT_InitTerrainMovement()  // Matching - 100%
{
	long i;
	
	for (i = 0; i < 5; i++)
	{
		memset(&WaterLevelArray[i], sizeof(struct WaterLevelProcess), 0);///@FIXME bug in original code, wrong order of last two arguments.
	}

	WaterInUse = 0;
}

void EVENT_Init()  // Matching - 100%
{
	EVENT_InitTerrainMovement();
	EVENT_InitTimers();
	HINT_ResetHint();

	WaitingForVoiceNumber = -1;
	WaitingToLoadSound = 614400;
	WaitingToLoadSFX = 614400;
	MoviePlayed = 0;
	MovieToPlay = -1;
}

struct WaterLevelProcess* EVENT_GetNextTerrainMove()  // Matching - 100%
{
	int i;
	
	for (i = 0; i < 5; i++)
	{
		if (!(WaterLevelArray[i].flags & 0x1))
		{
			return &WaterLevelArray[i];
		}
	}

	return NULL;
}

void EVENT_ProcessMovingWater()  // Matching - 100%
{
	int i;
	int inUse;
	struct WaterLevelProcess* curWater;
	int delta;

	inUse = 0;

	if (WaterInUse != 0)
	{
		curWater = &WaterLevelArray[0];

		for (i = 5; i > 0; i--, curWater++)
		{
			if ((curWater->flags & 0x00000001) != 0)
			{
				inUse = 1;
				curWater->curStep += gameTrackerX.timeMult;

				if (curWater->maxSteps < curWater->curStep)
				{
					curWater->curStep = curWater->maxSteps;
				}

				delta = ((curWater->zValueTo - curWater->zValueFrom) * (curWater->curStep >> 12)) / (curWater->maxSteps >> 12);
				curWater->bspTree->globalOffset.z = curWater->oldGlobalOffset + delta;
				curWater->bspTree->localOffset.z = curWater->zValueFrom + delta;

				if ((curWater->flags & 0x00000002) != 0)
				{
					curWater->streamUnit->level->waterZLevel = curWater->oldWaterZ + delta;
					curWater->streamUnit->level->terrain->UnitChangeFlags |= 1;
				}

				if (curWater->curStep == curWater->maxSteps)
				{
					curWater->flags = 0;
				}
			}
		}
	}

	if (!inUse)
	{
		WaterInUse = 0;
	}
}

void EVENT_DoProcess()  // Matching - 100%
{
	EVENT_ProcessMovingWater();

	EVENT_ProcessTimers();
}


void EVENT_BSPProcess(struct _StreamUnit* streamUnit)  // Matching - 100%
{
	struct _Terrain* terrain;
	int curTree;
	struct BSPTree* bspTree;
	struct _Instance* instance;
	short z;
	int dx;
	int dy;
	int dz;
	short y;
	short z2;
	short x;
	short y2;
	struct _Instance* attachedInstance;
	SVECTOR offset;
	struct Level* level;

	level = streamUnit->level;
	terrain = level->terrain;
	for (curTree = 0; curTree < terrain->numBSPTrees; curTree++)
	{
		bspTree = &terrain->BSPTreeArray[curTree];
		if (bspTree->ID >= 0)
		{
			instance = bspTree->instanceSpline;
			if (instance)
			{
				if (instance->matrix != NULL && instance->oldMatrix != NULL)
				{
					dx = (unsigned short)instance->matrix->t[0] - (unsigned short)instance->oldMatrix->t[0];
					dy = (unsigned short)instance->matrix->t[1] - (unsigned short)instance->oldMatrix->t[1];
					dz = (unsigned short)instance->matrix->t[2] - (unsigned short)instance->oldMatrix->t[2];
				}
				else
				{
					dx = (unsigned short)instance->position.x - (unsigned short)instance->oldPos.x;
					dy = (unsigned short)instance->position.y - (unsigned short)instance->oldPos.y;
					dz = (unsigned short)instance->position.z - (unsigned short)instance->oldPos.z;
				}

				if (dx << 16 || dy << 16 || dz << 16)
				{
					y = bspTree->globalOffset.y;
					bspTree->globalOffset.x += dx;
					z = bspTree->globalOffset.z;
					bspTree->globalOffset.y = y + dy;
					x = bspTree->localOffset.x;
					bspTree->globalOffset.z = z + dz;
					y2 = bspTree->localOffset.y;
					bspTree->localOffset.x = x + dx;
					z2 = bspTree->localOffset.z + dz;
					bspTree->localOffset.y = y2 + dy;
					bspTree->localOffset.z = z2;
					terrain->UnitChangeFlags |= 2u;
					offset.vx = dx;
					offset.vy = dy;
					offset.vz = dz;
					for (attachedInstance = gameTrackerX.instanceList->first;
						attachedInstance;
						attachedInstance = attachedInstance->next)
					{
						if (!instance->attachedID
							&& attachedInstance->tface
							&& attachedInstance->currentStreamUnitID == streamUnit->StreamUnitID
							&& attachedInstance->bspTree == curTree)
						{
							attachedInstance->position.x += dx;
							attachedInstance->position.y += dy;
							attachedInstance->position.z += dz;

							COLLIDE_UpdateAllTransforms(attachedInstance, &offset);
						}
					}
				}
			}
		}
	}
}

void EVENT_Process(struct Event* eventInstance, long startIndex)  // Matching - 100%
{
	long i;

	currentEventInstance = eventInstance;

	for (i = startIndex; i < eventInstance->numActions; i++)
	{
		EventCurrentEventIndex = i + 1;

		if (EventCurrentEventIndex == eventInstance->numActions)
		{
			EventCurrentEventIndex = -1;
		}

		if (eventInstance->conditionalList[i] != NULL)
		{
			EventAbortLine = 0;
			CurrentEventLine = 0;

			if (EVENT_IsConditionTrue(eventInstance, eventInstance->conditionalList[i]) != 0)
			{
				while (eventInstance->actionList[i] == NULL)
				{
					if (i >= eventInstance->numActions)
					{
						break;
					}
					i++;
				}

				if (i < eventInstance->numActions)
				{
					if (!(eventInstance->actionList[i]->conditionBits & 0x2))
					{
						EventAbortLine = 0;
						EVENT_DoAction(eventInstance, eventInstance->actionList[i], eventInstance->actionList[i]->data);
					}
				}
			}
		}
		else
		{
			if (!(eventInstance->actionList[i]->conditionBits & 0x2))
			{
				EventAbortLine = 0;
				EVENT_DoAction(eventInstance, eventInstance->actionList[i], eventInstance->actionList[i]->data);
			}
		}
	}
}

// autogenerated function stub: 
// void /*$ra*/ EVENT_ProcessPuppetShow(struct Event *eventInstance /*$s1*/, long startIndex /*$a1*/)
void EVENT_ProcessPuppetShow(struct Event *eventInstance, long startIndex)
{ // line 795, offset 0x80061220
	/* begin block 1 */
		// Start line: 796
		// Start offset: 0x80061220
		// Variables:
			long i; // $s0
			long conditionIsStatisfied; // $s3
	/* end block 1 */
	// End offset: 0x800613DC
	// End Line: 859

	/* begin block 2 */
		// Start line: 1888
	/* end block 2 */
	// End Line: 1889
			UNIMPLEMENTED();
}

void EVENT_ProcessEvents(struct EventPointers* eventPointers, struct Level* level)  // Matching - 100%
{ 
	long i;

	CurrentPuzzleLevel = level;

	for (i = 0; i < eventPointers->numPuzzles; i++)
	{
		if (eventPointers->eventInstances[i]->eventNumber >= 0)
		{
			EVENT_Process(eventPointers->eventInstances[i], 0);
		}
		else
		{
			if (eventPointers->eventInstances[i]->processingPuppetShow != 0)
			{
				EVENT_ProcessPuppetShow(eventPointers->eventInstances[i], eventPointers->eventInstances[i]->processingPuppetShow - 1);
			}
		}
	}

	if (MovieToPlay != -1)
	{
		CINE_PlayIngame(MovieToPlay);
		MovieToPlay = -1;
		MoviePlayed = 1;
	}
}

long EVENT_DoAction(struct Event* eventInstance, struct ScriptPCode* actionScript, short* scriptData)  // Matching - 100%
{
	long retValue;
	long operateOnStack;
	struct _PCodeStack stack;
	struct EventTimer* timer;

	stack.topOfStack = 0;

	retValue = 1;

	currentActionScript = actionScript;
	EventJustRecievedTimer = 0;
	EventAbortedPosition = scriptData;

	if (!(actionScript->conditionBits & 0x1))
	{
		if (scriptData != NULL)
		{
			while (EventAbortLine == NULL)
			{
				scriptData = EVENT_ParseOpcode(&stack, scriptData, &operateOnStack);

				if (EventAbortLine != NULL && EventJustRecievedTimer == NULL)
				{
					timer = EVENT_GetNextTimer();

					if (timer != NULL)
					{
						retValue = 0;
						timer->event = eventInstance;
						timer->actionScript = actionScript;

						timer->time = 0;
						timer->scriptPos = EventAbortedPosition;

						actionScript->conditionBits |= 0x1;

						timer->level = CurrentPuzzleLevel;
						timer->nextEventIndex = EventCurrentEventIndex;
					}
				}

				if (operateOnStack != 0 && EventAbortLine == NULL && stack.topOfStack > 0)
				{
					stack.topOfStack--;

					EVENT_ExecuteActionCommand(&stack.stack[stack.topOfStack], NULL, &stack, scriptData);
				}

				if (scriptData == NULL)
				{
					break;
				}
			}
		}
	}

	return retValue;
}

long EVENT_IsConditionTrue(struct Event* eventInstance, struct ScriptPCode* conditionScript)  // Matching - 100%
{
	long retValue;
	long error;
	long operateOnStack;
	short flags;
	struct _PCodeStack stack;
	short* scriptData;
	
	stack.topOfStack = 0;
	scriptData = conditionScript->data;
	currentActionScript = NULL;
	retValue = 0;

	while (scriptData != NULL && EventAbortLine == NULL)
	{
		scriptData = EVENT_ParseOpcode(&stack, scriptData, &operateOnStack);

		if (operateOnStack != 0 && EventAbortLine == NULL)
		{
			CurrentEventLine++;

			if (stack.topOfStack > 0)
			{
				retValue = EVENT_GetScalerValueFromOperand(&stack.stack[--stack.topOfStack], &error, &flags);

				if (error != 0)
				{
					retValue = 0;
					break;
				}
				else
				{
					if (retValue == 0)
					{
						break;
					}
				}
			}
		}
	}

	if (EventAbortLine == 1)
	{
		retValue = 0;
	}

	return retValue;
}


long EVENT_WriteEventObject(struct StackType* stackEntry, long areaID, struct Event* event, long number)  // Matching - 100%
{
	long retValue;

	retValue = 0;

	if (event != NULL)
	{
		stackEntry->id = 16;
		stackEntry->data.savedEventObject.savedEvent = (struct SavedBasic*)event;
		stackEntry->data.savedEventObject.attribute = -1;
	}
	else
	{
		struct SavedBasic* savedEvent;

		savedEvent = SAVE_GetSavedEvent(areaID, number);

		if (savedEvent != NULL)
		{
			stackEntry->id = 21;
			stackEntry->data.savedEventObject.savedEvent = savedEvent;
			stackEntry->data.savedEventObject.areaID = areaID;
			stackEntry->data.savedEventObject.eventNumber = number;
			stackEntry->data.savedEventObject.attribute = -1;
			retValue = 1;
		}
		else
		{
			stackEntry->id = 21;

			stackEntry->data.savedEventObject.savedEvent = EVENT_CreateSaveEvent(areaID, number);

			stackEntry->data.savedEventObject.areaID = areaID;
			stackEntry->data.savedEventObject.eventNumber = number;
			stackEntry->data.savedEventObject.attribute = -1;
			retValue = 1;
		}
	}

	return retValue;
}


struct _MultiSignal* EVENT_ResolveObjectSignal(struct _StreamUnit* stream, long signalNumber)  // Matching - 100%
{
	struct _MultiSignal* retValue;
	struct Level* level;

	level = stream->level;
	retValue = NULL;
	if (signalNumber < 0)
	{
		switch (signalNumber)
		{
		case -1:
			retValue = level->startSignal;
			break;
		case -2:
			retValue = level->spectralSignal;
			break;
		case -3:
			retValue = level->materialSignal;
			break;
		case -4:
			retValue = level->startUnitLoadedSignal;
			break;
		case -5:
			retValue = level->startUnitMainSignal;
			break;
		}
	}
	else
	{
		retValue = SIGNAL_FindSignal(level, signalNumber);
	}

	return retValue;
}

struct Intro* EVENT_ResolveObjectIntro(struct EventInstanceObject* instanceObject)  // Matching - 100%
{
	return INSTANCE_FindIntro(instanceObject->unitID, instanceObject->introUniqueID);
}


struct _SFXMkr* EVENT_ResolveSFXMarker(struct _StreamUnit* stream, struct EventInstanceObject* instanceObject)  // Matching - 100%
{
	int i;
	struct Level* level;
	struct _SFXMkr* result;

	level = stream->level;
	result = NULL;
	if (level->NumberOfSFXMarkers != NULL)
	{
		for (i = 0; i < level->NumberOfSFXMarkers; i++)
		{
			if (instanceObject->introUniqueID == level->SFXMarkerList[i].uniqueID)
			{
				result = &level->SFXMarkerList[i];
				break;
			}
		}
	}
	return result;
}

void EVENT_AddGameObjectToStack(struct _PCodeStack* stack)  // Matching - 100%
{
	struct StackType* stackEntry;

	if (stack->topOfStack < 32)
	{
		stackEntry = &stack->stack[stack->topOfStack];
		stackEntry->id = 3;
		stackEntry->data.gameObject.attribute = -1;
		stack->topOfStack++;
	}
}

void EVENT_AddPlayerObjectToStack(struct _PCodeStack* stack)  // Matching - 100%
{
	struct StackType* stackEntry;

	if (stack->topOfStack < 32)
	{
		stackEntry = &stack->stack[stack->topOfStack];
		stackEntry->id = 2;
		stackEntry->data.instanceObject.instance = gameTrackerX.playerInstance;
		stackEntry->data.instanceObject.attribute = -1;
		stack->topOfStack++;
	}
}

// autogenerated function stub: 
// void /*$ra*/ EVENT_AddObjectToStack(struct _PCodeStack *stack /*$s2*/, long item /*$a1*/)
void EVENT_AddObjectToStack(struct _PCodeStack *stack, long item)
{ // line 1179, offset 0x8006199c
	/* begin block 1 */
		// Start line: 1180
		// Start offset: 0x8006199C
		// Variables:
			struct EventBasicObject *basicObject; // $a0
			int topOfStack; // $s1

		/* begin block 1.1 */
			// Start line: 1192
			// Start offset: 0x800619C8
			// Variables:
				struct StackType *stackEntry; // $s0

			/* begin block 1.1.1 */
				// Start line: 1198
				// Start offset: 0x80061A24
			/* end block 1.1.1 */
			// End offset: 0x80061A44
			// End Line: 1214

			/* begin block 1.1.2 */
				// Start line: 1222
				// Start offset: 0x80061A44
			/* end block 1.1.2 */
			// End offset: 0x80061A78
			// End Line: 1239

			/* begin block 1.1.3 */
				// Start line: 1254
				// Start offset: 0x80061A94
			/* end block 1.1.3 */
			// End offset: 0x80061A94
			// End Line: 1256

			/* begin block 1.1.4 */
				// Start line: 1264
				// Start offset: 0x80061AB0
			/* end block 1.1.4 */
			// End offset: 0x80061AB0
			// End Line: 1266

			/* begin block 1.1.5 */
				// Start line: 1274
				// Start offset: 0x80061AD4
			/* end block 1.1.5 */
			// End offset: 0x80061B60
			// End Line: 1324

			/* begin block 1.1.6 */
				// Start line: 1336
				// Start offset: 0x80061B60
			/* end block 1.1.6 */
			// End offset: 0x80061BB0
			// End Line: 1358
		/* end block 1.1 */
		// End offset: 0x80061BB4
		// End Line: 1366
	/* end block 1 */
	// End offset: 0x80061BB4
	// End Line: 1372

	/* begin block 2 */
		// Start line: 2740
	/* end block 2 */
	// End Line: 2741
				UNIMPLEMENTED();
}

void EVENT_AddCharPointerToStack(struct _PCodeStack* stack, char* pointer) // Matching - 100%
{
	struct StackType* stackEntry;

	if (stack->topOfStack < 32)
	{
		stackEntry = &stack->stack[stack->topOfStack];
		stackEntry->id = 28;
		stackEntry->data.CharPointer.pointer = pointer;
		stack->topOfStack++;
	}
}

void EVENT_AddShortPointerToStack(struct _PCodeStack* stack, short* pointer) // Matching - 100%
{
	struct StackType* stackEntry;

	if (stack->topOfStack < 32)
	{
		stackEntry = &stack->stack[stack->topOfStack];
		stackEntry->id = 10;
		stackEntry->data.ShortPointer.pointer = pointer;
		stack->topOfStack++;
	}
}

void EVENT_AddNumberToStack(struct _PCodeStack* stack, long item, long flags) // Matching - 100%
{
	struct StackType* stackEntry;

	if (stack->topOfStack < 32)
	{
		stackEntry = &stack->stack[stack->topOfStack];
		stackEntry->id = 7;
		stackEntry->data.Number.currentNumber = item;
		stackEntry->data.Number.error = 0;
		stackEntry->data.Number.flags = (short) flags;
		stack->topOfStack++;
	}
}

void EVENT_ChangeOperandToNumber(struct StackType* operand, long item, long flags)  // Matching - 100%
{
	operand->id = 7;

	operand->data.Number.currentNumber = item;
	operand->data.Number.error = 0;
	operand->data.Number.flags = (short)flags;
}

void EVENT_ChangeOperandVector3d(struct StackType* operand, short x, short y, short z, long streamUnitID)//Matching - 100%
{
	operand->id = 9;

	operand->data.vector3d.vx = x;
	operand->data.vector3d.vy = y;
	operand->data.vector3d.vz = z;

	operand->data.vector3d.errorx = 160;
	operand->data.vector3d.errory = 160;
	operand->data.vector3d.errorz = 160;

	operand->data.vector3d.streamUnitID = streamUnitID;
}

void EVENT_Addvector3dToStack(struct _PCodeStack* stack, short x, short y, short z, long streamUnitID) // Matching - 100%
{
	if (stack->topOfStack < 32)
	{
		EVENT_ChangeOperandVector3d(&stack->stack[stack->topOfStack], x, y, z, streamUnitID);
		stack->topOfStack++;
	}
}

void EVENT_ChangeOperandRotation3d(struct StackType* operand, struct Rotation3d* rotation) // Matching - 100%
{
	operand->id = 14;
	operand->data.rotation3d.vx = rotation->vx;
	operand->data.rotation3d.vy = rotation->vy;
	operand->data.rotation3d.vz = rotation->vz;
	operand->data.rotation3d.errorx = rotation->errorx;
	operand->data.rotation3d.errory = rotation->errory;
	operand->data.rotation3d.errorz = rotation->errorz;
	operand->data.rotation3d.attribute = -1;
}

long EVENT_AddSubListObjectToStack(struct _PCodeStack* stack, long listNumber)  // Matching - 100%
{
	struct StackType* stackEntry;

	if (stack->topOfStack < 32)
	{
		stackEntry = &stack->stack[stack->topOfStack];
		stackEntry->id = 22;
		if (eventListNumInstances[listNumber] >= 1)
		{
			stackEntry->data.subListObject.instanceList = eventListArray[listNumber];
			stackEntry->data.subListObject.numberOfInstances = eventListNumInstances[listNumber];
		}
		else
		{
			stackEntry->data.subListObject.instanceList = NULL;
			stackEntry->data.subListObject.numberOfInstances = eventListNumInstances[listNumber];
		}
		stackEntry->data.subListObject.numberOfAttributes = 0;
		stack->topOfStack++;
	}
	return 0;
}

void EVENT_StackDuplicate(struct _PCodeStack* stack) // Matching - 100%
{
	if (stack->topOfStack < 32 && stack->topOfStack != 0)
	{
		stack->stack[stack->topOfStack] = stack->stack[stack->topOfStack - 1];
		stack->topOfStack++;
	}
}

long EVENT_TransformTGroupAttribute(struct _PCodeStack* stack, struct StackType* stackObject, long item, short* codeStream) // Matching - 100%
{
	long retValue;

	retValue = 0;
	if (stackObject->data.terrainGroup.attribute == -1)
	{
		stackObject->data.terrainGroup.attribute = item;
		retValue = 1;
		switch (item)
		{
		case 5:
		case 6:
		case 7:
		case 8:
		case 9:
		case 10:
		case 11:
		case 12:
		case 13:
		case 14:
		case 15:
		case 16:
		case 17:
		case 18:
		case 19:
		case 20:
		case 21:
		case 22:
		case 23:
		case 24:
		case 25:
		case 26:
		case 27:
		case 28:
		case 29:
		case 30:
		case 31:
		case 32:
		case 33:
		case 34:
		case 35:
		case 36:
		case 37:
		case 38:
		case 39:
		case 40:
		case 41:
		case 42:
		case 43:
			break;
		case 44:
			if (codeStream)
			{
				codeStream++;
				MoveCodeStreamExtra = 2;
				stackObject->data.terrainGroup.arg[0] = codeStream[0];
				stackObject->data.terrainGroup.arg[1] = codeStream[1];
			}
			retValue = 1;
			break;
		case 45:
			if (codeStream)
			{
				codeStream++;
				MoveCodeStreamExtra = 1;
				stackObject->data.terrainGroup.arg[0] = codeStream[0];
			}
			retValue = 1;
			break;
		case 46:
			if (codeStream)
			{
				codeStream++;
				MoveCodeStreamExtra = 2;
				stackObject->data.terrainGroup.arg[0] = codeStream[0];
				stackObject->data.terrainGroup.arg[1] = codeStream[1];
			}
			retValue = 1;
			break;
		case 47:
			if (codeStream)
			{
				codeStream++;
				MoveCodeStreamExtra = 1;
				stackObject->data.terrainGroup.arg[0] = codeStream[0];
			}
			retValue = 1;
			break;
		}
	}
	return retValue;
}

long EVENT_TransformConstrictAttribute(struct _PCodeStack* stack, struct StackType* stackObject, long item) // Matching - 100%
{
	long retValue;
	struct _Instance* instance;

	instance = stackObject->data.constrictInfo.instance;
	retValue = 0;
	switch (item)
	{
	case 58:
		EVENT_ChangeOperandToNumber(stackObject, instance->constrictAngle < -1, 0);
		retValue = 1;
		break;
	case 59:
		EVENT_ChangeOperandToNumber(stackObject, (instance->constrictAngle < 2) ^ 1, 0);
		retValue = 1;
		break;
	}
	return retValue;
}

long EVENT_TransformInstanceAttribute(struct _PCodeStack* stack, struct StackType* stackObject, long item, short* codeStream)  // Matching - 99.03%
{
	long retValue;
	long x;
	long y;
	long z;
	struct _Instance* instance;

	instance = stackObject->data.instanceObject.instance;

	retValue = 0;

	switch (item)
	{
	case 5:
	{
		struct evPositionData* position;

		position = (struct evPositionData*)INSTANCE_Query(instance, 6);

		if (position == NULL)
		{
			x = instance->position.x;
			y = instance->position.y;
			z = instance->position.z;
		}
		else
		{
			x = position->x;
			y = position->y;
			z = position->z;
		}

		EVENT_ChangeOperandVector3d(stackObject, (short)x, (short)y, (short)z, instance->currentStreamUnitID);

		retValue = 1;
		break;
	}
	case 9:
	{
		struct evPositionData* rotation;
		struct Rotation3d vector;
		struct _SVector pad;  // not from SYMDUMP

		rotation = (struct evPositionData*)INSTANCE_Query(instance, 7);

		if (rotation == NULL)
		{
			vector.vx = instance->rotation.x;
			vector.vy = instance->rotation.y;
			vector.vz = instance->rotation.z;
		}
		else
		{
			vector.vx = rotation->x;
			vector.vy = rotation->y;
			vector.vz = rotation->z;
		}

		pad.x = 512;
		pad.y = 512;
		pad.z = 512;

		EVENT_ChangeOperandRotation3d(stackObject, &vector);

		retValue = 1;
		break;
	}
	case 12:
		stackObject->id = 15;

		stackObject->data.instanceSpline.instance = instance;

		stackObject->data.instanceSpline.spline = SCRIPT_GetMultiSpline(instance, (unsigned long*)&stackObject->data.instanceSpline.isParent, (unsigned long*)&stackObject->data.instanceSpline.isClass);

		stackObject->data.instanceSpline.splineFlags = 0;
		stackObject->data.instanceSpline.attribute = -1;

		retValue = 1;
		break;
	case 126:
	{
		int status;

		stackObject->id = 27;
		stackObject->data.soundObject.data.instance = instance;
		stackObject->data.soundObject.attribute = -1;

		if (codeStream != NULL)
		{
			MoveCodeStreamExtra = 1;
			stackObject->data.soundObject.soundNumber = codeStream[1];
		}

		status = SOUND_IsInstanceSoundLoaded(instance->object->soundData, stackObject->data.soundObject.soundNumber);

		if (status == 0)
		{
			WaitingToLoadSound = WaitingToLoadSound - gameTrackerX.timeMult;

			if (WaitingToLoadSound > 0)
			{
				EventAbortLine = 1;
				retValue = 1;
			}
			else
			{
				WaitingToLoadSound = 0x96000;
			}
		}
		else
		{
			if (status != -1)
			{
				WaitingToLoadSound = 0x96000;

			}
		}

		retValue = 1;
		break;
	}
	case 29:
		if (instance->object->animList != NULL)
		{
			retValue = 1;

			stackObject->id = 19;
			stackObject->data.instanceAnimate.instance = instance;
			stackObject->data.instanceAnimate.attribute = -1;
		}

		break;
	case 19:
		EVENT_ChangeOperandToNumber(stackObject, INSTANCE_Query(instance, 10), 3);

		retValue = 1;
		break;
	case 159:
		EVENT_ChangeOperandToNumber(stackObject, INSTANCE_Query(instance, 43), 0);

		retValue = 1;
		break;
	case 169:
		EVENT_ChangeOperandToNumber(stackObject, INSTANCE_Query(instance, 31), 0);

		retValue = 1;
		break;
	case 170:
		EVENT_ChangeOperandToNumber(stackObject, INSTANCE_Query(instance, 32), 0);

		retValue = 1;
		break;
	case 161:
	{
		struct _Instance* tmpI;
		long value;

		tmpI = (struct _Instance*)INSTANCE_Query(instance, 44);

		if (tmpI == NULL)
		{
			value = 0;
		}
		else
		{
			if ((INSTANCE_Query(tmpI, 1) & 32))
			{
				if ((INSTANCE_Query(tmpI, 4) & 3))
				{
					return 1;
				}

				return 2;
			}

			value = 3;
		}

		EVENT_ChangeOperandToNumber(stackObject, value, 0);

		retValue = 1;
		break;
	}
	case 139:
	case 166:
		EVENT_ChangeOperandToNumber(stackObject, ((INSTANCE_Query(instance, 0) >> 30) & 1), 0);

		retValue = 1;
		break;
	case 167:
		EVENT_ChangeOperandToNumber(stackObject, ((INSTANCE_Query(instance, 0) >> 26) & 1), 0);

		retValue = 1;
		break;
	case 160:
	{
		unsigned long r;  // not from SYMDUMP

		r = (INSTANCE_Query(instance, 1) & 4);

		EVENT_ChangeOperandToNumber(stackObject, (r > 0), 0);

		retValue = 1;
		break;
	}
	case 18:
		EVENT_ChangeOperandToNumber(stackObject, INSTANCE_Query(instance, 9), 1);

		retValue = 1;
		break;
	case 56:
		EVENT_ChangeOperandToNumber(stackObject, INSTANCE_Query(instance, 30), 0);

		retValue = 1;
		break;
	case 63:
		EVENT_ChangeOperandToNumber(stackObject, 1, 0);

		retValue = 1;
		break;
	case 33:
		stackObject->id = 20;
		stackObject->data.instanceAniTexture.instance = instance;

		retValue = 1;

		stackObject->data.instanceAniTexture.aniTextures = instance->object->modelList[instance->currentModel]->aniTextures;
		stackObject->data.instanceAniTexture.attribute = -1;
		break;
	case 43:
	{
		struct StreamUnit* temp;  // not from SYMDUMP
		int temp2;  // not from SYMDUMP

		temp2 = 0;

		if (instance->attachedID == 0)
		{
			temp = (struct StreamUnit*)STREAM_GetStreamUnitWithID(instance->currentStreamUnitID);

			if (temp != NULL)
			{
				if (instance->bspTree < ((struct _StreamUnit*)(temp))->level->terrain->numBSPTrees)
				{
					temp2 = -((instance->currentStreamUnitID * 256) + ((struct _StreamUnit*)(temp))->level->terrain->BSPTreeArray[instance->bspTree].ID);
				}
			}
		}
		else
		{
			temp2 = instance->attachedID;
		}

		EVENT_ChangeOperandToNumber(stackObject, temp2, 0);

		retValue = 1;
		break;
	}
	case 146:
		EVENT_ChangeOperandToNumber(stackObject, 0, 0);

		retValue = 1;
		break;
	case 151:
		EVENT_ChangeOperandToNumber(stackObject, instance->currentStreamUnitID, 0);

		retValue = 1;
		break;
	case 153:
		EVENT_ChangeOperandToNumber(stackObject, (instance->tface != NULL), 0);

		retValue = 1;
		break;
	case 57:
		retValue = 1;

		stackObject->id = 24;
		stackObject->data.instanceAnimate.instance = instance;
		stackObject->data.instanceAnimate.attribute = -1;
		break;
	case 60:
	{
		long value;

		value = 0;

		if ((instance->flags & 4))
		{
			value = 1;
			instance->flags &= ~4;
		}

		EVENT_ChangeOperandToNumber(stackObject, value, 0);

		retValue = 1;
		break;
	}
	case 121:
	{
		long value;

		value = 0;

		if ((instance->flags & 8))
		{
			value = 1;
			instance->flags &= ~8;
		}

		EVENT_ChangeOperandToNumber(stackObject, value, 0);

		retValue = 1;
		break;
	}
	case 122:
	{
		long value;

		value = 0;

		if ((instance->flags & 0x10))
		{
			value = 1;
			instance->flags &= ~0x10;
		}

		EVENT_ChangeOperandToNumber(stackObject, value, 0);

		retValue = 1;
		break;
	}
	case 106:
	{
		long value;

		value = 0;

		if (instance->flags < 0)
		{
			value = 1;
			instance->flags &= 0x7FFFFFFF;
		}

		EVENT_ChangeOperandToNumber(stackObject, value, 0);

		retValue = 1;
		break;
	}
	case 125:
	{
		long value;

		value = 0;

		if ((instance->flags2 & 0x10000))
		{
			value = 1;
			instance->flags2 &= 0xFFFEFFFF;
		}

		EVENT_ChangeOperandToNumber(stackObject, value, 0);

		retValue = 1;
		break;
	}
	case 137:
		EVENT_ChangeOperandToNumber(stackObject, INSTANCE_Query(instance, 36), 3);

		retValue = 1;
		break;
	case 4:
	case 10:
	case 11:
	case 20:
	case 21:
	case 32:
	case 36:
	case 37:
	case 38:
	case 39:
	case 51:
	case 52:
	case 53:
	case 54:
	case 55:
	case 62:
	case 64:
	case 75:
	case 76:
	case 77:
	case 78:
	case 79:
	case 80:
	case 83:
	case 84:
	case 85:
	case 91:
	case 92:
	case 94:
	case 95:
	case 103:
	case 108:
	case 109:
	case 110:
	case 111:
	case 114:
	case 116:
	case 123:
	case 124:
	case 138:
	case 140:
	case 141:
	case 143:
	case 144:
	case 163:
	case 164:
	case 165:
		stackObject->data.instanceObject.attribute = item;
		retValue = 1;
	}

	return retValue;
}


long EVENT_TransformSoundObjectAttribute(struct _PCodeStack* stack, struct SoundObject* soundObject, long item, short* codeStream) // Matching - 100%
{
	long retValue;
	int status;

	retValue = 0;
	switch (item)
	{
	case 126:
		if (codeStream != NULL)
		{
			codeStream++;
			MoveCodeStreamExtra = 1;
			soundObject->soundNumber = codeStream[0];
		}
		status = SOUND_IsInstanceSoundLoaded(soundObject->data.sfxMarker->soundData, soundObject->soundNumber);
		if (status == 0)
		{
			WaitingToLoadSFX = WaitingToLoadSFX - gameTrackerX.timeMult;
			if (WaitingToLoadSFX > 0)
			{
				EventAbortLine = 1;
			}
			else
			{
				WaitingToLoadSFX = 0x96000;
			}
		}
		else if (status != -1)
		{
			WaitingToLoadSFX = 0x96000;
		}
		retValue = 1;
		break;
	case 127:
		soundObject->attribute = (short)item;
		if (codeStream != NULL)
		{
			codeStream++;
			MoveCodeStreamExtra = 2;
			soundObject->value = codeStream[0];
			soundObject->duration = codeStream[1];
		}
		retValue = 1;
		break;
	case 13:
	case 14:
		soundObject->attribute = (short)item;
		retValue = 1;
		break;
	case 128:
		soundObject->attribute = (short)item;
		if (codeStream != NULL)
		{
			codeStream++;
			MoveCodeStreamExtra = 2;
			soundObject->value = codeStream[0];
			soundObject->duration = codeStream[1];
		}
		retValue = 1;
		break;
	}
	return retValue;
}

// autogenerated function stub: 
// long /*$ra*/ EVENT_GetGameValue(struct GameObject *gameObject /*$a0*/)
long EVENT_GetGameValue(struct GameObject *gameObject)
{ // line 2260, offset 0x80062764
	/* begin block 1 */
		// Start line: 2261
		// Start offset: 0x80062764
		// Variables:
			long value; // $v1
	/* end block 1 */
	// End offset: 0x800627F0
	// End Line: 2293

	/* begin block 2 */
		// Start line: 4907
	/* end block 2 */
	// End Line: 4908
			UNIMPLEMENTED();
	return 0;
}


long EVENT_TransformGameAttribute(struct _PCodeStack* stack, struct StackType* stackObject, long item, short* codeStream)  // Matching - 99.48%
{
	long value;
	long retValue;

	retValue = 0;

	switch (item)
	{
	case 1:
		EVENT_ChangeOperandToNumber(stackObject, (long)((gameTrackerX.currentTime * 30) / 1000), 0);

		retValue = 1;
		break;
	case 61:
		EVENT_ChangeOperandToNumber(stackObject, gameTrackerX.timeOfDay, 0);

		retValue = 1;
		break;
	case 27:
		value = gameTrackerX.controlCommand[0][0];

		if ((value & 0x90) == 0x90)  // error in original code?
		{
			value &= ~0x90;
		}

		EVENT_ChangeOperandToNumber(stackObject, value, 1);

		retValue = 1;
		break;
	case 157:
		EVENT_ChangeOperandToNumber(stackObject, HINT_GetCurrentHint(), 0);

		retValue = 1;
		break;
	case 158:
		EVENT_ChangeOperandToNumber(stackObject, gameTrackerX.streamFlags & 0x100000, 0);

		retValue = 1;
		break;
	case 20:
		value = (INSTANCE_Query(gameTrackerX.playerInstance, 11) >> 1) & 1;

		if (STREAM_IsMorphInProgress() != 0)
		{
			value = 0;
		}

		EVENT_ChangeOperandToNumber(stackObject, value, 0);

		retValue = 1;
		break;
	case 21:
		value = INSTANCE_Query(gameTrackerX.playerInstance, 11) & 1;

		if (STREAM_IsMorphInProgress() != 0)
		{
			value = 0;
		}

		EVENT_ChangeOperandToNumber(stackObject, value, 0);

		retValue = 1;
		break;
	case 49:
	{
		struct EventTimer* timer;
		short time;

		timer = EVENT_GetNextTimer();

		if (timer != NULL)
		{
			if (codeStream != NULL)
			{
				codeStream++;
				MoveCodeStreamExtra = 1;
				time = *codeStream++;
				EventAbortLine = 1;
				EventJustRecievedTimer = 1;
				timer->flags &= 1;
				timer->time = time << 12;
				timer->event = currentEventInstance;
				timer->actionScript = currentActionScript;
				timer->scriptPos = codeStream;
				currentActionScript->conditionBits |= 1;
				timer->level = CurrentPuzzleLevel;
				timer->nextEventIndex = EventCurrentEventIndex;
			}
		}

		retValue = 1;
		break;
	}
	case 66:
		stackObject->id = 25;
		stackObject->data.cameraObject.camera = &theCamera;
		stackObject->data.cameraObject.attribute = -1;

		retValue = 1;
		break;
	case 145:
		stack->topOfStack -= 1;

		EVENT_AddShortPointerToStack(stack, &gEndGameNow);

		retValue = 1;
		break;
	case 74:
	{
		long wipeType;
		long wipeTime;

		if (codeStream != NULL)
		{
			codeStream++;
			MoveCodeStreamExtra = 2;
			wipeType = codeStream[0];
			wipeTime = codeStream[1];

			gameTrackerX.maxWipeTime = (codeStream[1] < 0) ? -codeStream[1] : codeStream[1];

			gameTrackerX.wipeTime = (int)wipeTime;
			gameTrackerX.wipeType = (int)wipeType;

			if (wipeType == 11)
			{
				if (wipeTime < 0)
				{
					gameTrackerX.streamFlags |= 0x2000000;
				}
				else
				{
					gameTrackerX.streamFlags &= ~0x2000000;
				}
			}

			stack->topOfStack -= 1;
		}

		retValue = 1;
		break;
	}
	case 162:
	{
		long motor0Time;
		long motor0Speed;
		long motor1Time;
		long motor1Speed;

		if (codeStream != NULL)
		{
			MoveCodeStreamExtra = 4;
			codeStream++;
			motor0Speed = codeStream[0];
			codeStream++;
			motor0Time = codeStream[0];
			codeStream++;
			motor1Speed = codeStream[0];
			codeStream++;
			motor1Time = codeStream[0];
			stack->topOfStack -= 1;

			GAMEPAD_Shock(motor0Speed, motor0Time << 12, motor1Speed, motor1Time << 12);
		}

		retValue = 1;
		break;
	}
	case 82:
		INSTANCE_Broadcast(0, 42, 0x4000E, 1);

		stack->topOfStack -= 1;
		retValue = 1;
		break;
	case 81:
		INSTANCE_Broadcast(0, 10, 0x4000E, 0);

		stack->topOfStack -= 1;
		retValue = 1;
		break;
	case 90:
	{
		short rand1;
		short rand2;

		if (codeStream != NULL)
		{
			codeStream++;
			MoveCodeStreamExtra = 2;
			rand1 = codeStream[0];
			rand2 = codeStream[1];

			EVENT_ChangeOperandToNumber(stackObject, rand() % (rand2 - rand1) + rand1, 0);
		}

		retValue = 1;
		break;
	}
	case 120:
		EVENT_ChangeOperandToNumber(stackObject, LOAD_IsXAInQueue() == 0, 0);

		retValue = 1;
		break;
	case 134:
	{
		int number;

		number = ((unsigned long)gameTrackerX.streamFlags >> 23) & 1;

		EVENT_ChangeOperandToNumber(stackObject, number, 0);

		retValue = 1;
		break;
	}
	case 154:
		EVENT_ChangeOperandToNumber(stackObject, INSTANCE_Query(gameTrackerX.playerInstance, 41), 3);

		retValue = 1;
		break;
	case 155:
		EVENT_ChangeOperandToNumber(stackObject, INSTANCE_Query(gameTrackerX.playerInstance, 42), 3);

		retValue = 1;
		break;
	case 168:
		stack->topOfStack -= 1;

		if (gameTrackerX.debugFlags & 0x80000)
		{
			if (LOAD_IsXAInQueue() != 0)
			{
				EventAbortLine = 1;
			}
		}

		retValue = 1;
		break;
	case 2:
	case 88:
	case 89:
	case 108:
	case 109:
	case 110:
	case 111:
	case 118:
	case 119:
	case 135:
	case 136:
	case 137:
	case 140:
	case 142:
	case 147:
	case 150:
	case 156:
		stackObject->data.gameObject.attribute = item;
		retValue = 1;
		break;
	}

	return retValue;
}


long EVENT_TransformAreaAttribute(struct _PCodeStack* stack, struct StackType* stackObject, long item, short* codeStream)  // Matching - 100%
{
	long retValue;
	long offset;
	struct _StreamUnit* streamUnit;

	streamUnit = stackObject->data.areaObject.streamUnit;
	retValue = 0;

	if (streamUnit == NULL)
	{
		EventAbortLine = 1;
		retValue = 1;
	}
	else
	{
		switch (item)
		{
		case 3:
			MoveCodeStreamExtra = 1;

			do
			{

			} while (0);  // garbage code for reordering

			offset = codeStream[1];

			if ((offset >= 0) && (offset <= 5))
			{
				stack->topOfStack -= 1;

				EVENT_AddShortPointerToStack(stack, &streamUnit->eventVariables[offset]);

				retValue = 1;
			}

			break;
		case 65:
			stack->topOfStack -= 1;

			EVENT_AddShortPointerToStack(stack, (short*)&streamUnit->level->waterZLevel);

			retValue = 1;
			break;
		case 113:
		case 112:
			stackObject->data.areaObject.attribute = item;
			retValue = 1;
			break;
		}
	}

	return retValue;
}


// autogenerated function stub: 
// long /*$ra*/ EVENT_TransformEventAttribute(struct _PCodeStack *stack /*$a0*/, struct StackType *stackObject /*$a1*/, long item /*$a2*/, short *codeStream /*$a3*/)
long EVENT_TransformEventAttribute(struct _PCodeStack *stack, struct StackType *stackObject, long item, short *codeStream)
{ // line 2639, offset 0x80062d5c
	/* begin block 1 */
		// Start line: 2640
		// Start offset: 0x80062D5C
		// Variables:
			long retValue; // $v1
			long offset; // $a1
			struct Event *event; // $t0
	/* end block 1 */
	// End offset: 0x80062DDC
	// End Line: 2691

	/* begin block 2 */
		// Start line: 5722
	/* end block 2 */
	// End Line: 5723
			UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// long /*$ra*/ EVENT_TransformSavedEventAttribute(struct _PCodeStack *stack /*$t0*/, struct StackType *stackObject /*$a0*/, long item /*$a2*/, short *codeStream /*$a3*/)
long EVENT_TransformSavedEventAttribute(struct _PCodeStack *stack, struct StackType *stackObject, long item, short *codeStream)
{ // line 2694, offset 0x80062dec
	/* begin block 1 */
		// Start line: 2695
		// Start offset: 0x80062DEC
		// Variables:
			long retValue; // $v1
			long offset; // $a1

		/* begin block 1.1 */
			// Start line: 2713
			// Start offset: 0x80062E44
		/* end block 1.1 */
		// End offset: 0x80062E44
		// End Line: 2715

		/* begin block 1.2 */
			// Start line: 2722
			// Start offset: 0x80062E68
		/* end block 1.2 */
		// End offset: 0x80062E68
		// End Line: 2724
	/* end block 1 */
	// End offset: 0x80062E98
	// End Line: 2753

	/* begin block 2 */
		// Start line: 5843
	/* end block 2 */
	// End Line: 5844
			UNIMPLEMENTED();
	return 0;
}

long EVENT_TransformSubListObjectAttribute(struct _PCodeStack* stack, struct StackType* stackObject, long item)
{
	long retValue; // $a0
	
	UNIMPLEMENTED();//Unions messy here!
	return 0;
}


// autogenerated function stub: 
// long /*$ra*/ EVENT_TransformListObjectAttribute(struct _PCodeStack *stack /*$a0*/, struct StackType *stackObject /*$a1*/, long item /*$a2*/)
long EVENT_TransformListObjectAttribute(struct _PCodeStack *stack, struct StackType *stackObject, long item)
{ // line 2780, offset 0x80062edc
	/* begin block 1 */
		// Start line: 2782
		// Start offset: 0x80062EDC
		// Variables:
			long retValue; // $a0
	/* end block 1 */
	// End offset: 0x80062F08
	// End Line: 2801

	/* begin block 2 */
		// Start line: 6019
	/* end block 2 */
	// End Line: 6020

	/* begin block 3 */
		// Start line: 6020
	/* end block 3 */
	// End Line: 6021

	/* begin block 4 */
		// Start line: 6026
	/* end block 4 */
	// End Line: 6027
			UNIMPLEMENTED();
	return 0;
}


long EVENT_TransformCameraObjectAttribute(struct _PCodeStack* stack, struct StackType* stackObject, long item, short* codeStream)  // Matching - 100%
{
	long retValue;
	struct Camera* camera;

	camera = stackObject->data.cameraObject.camera;

	retValue = 0;

	switch (item)
	{
	case 67:
	case 68:
	case 69:
	case 70:
	case 71:
	case 72:
	case 73:
		stackObject->data.cameraObject.attribute = item;

		retValue = 1;
		break;
	case 93:
	{
		short time;

		if (codeStream != NULL)
		{
			codeStream++;
			MoveCodeStreamExtra = 2;
			time = *codeStream++;

			CAMERA_SetShake(camera, time, (*codeStream++ << 12) / 100);

			stack->topOfStack -= 1;
		}

		retValue = 1;
		break;
	}
	case 104:
		stackObject->data.cameraObject.attribute = item;

		retValue = 1;
		break;
	case 105:
		if (codeStream != NULL)
		{
			codeStream++;
			MoveCodeStreamExtra = 1;
			stackObject->data.cameraObject.frames = *codeStream++;
		}

		stackObject->data.cameraObject.attribute = item;

		retValue = 1;
		break;
	case 117:
		EVENT_ChangeOperandToNumber(stackObject, camera->data.Cinematic.cinema_done != 0, 0);

		retValue = 1;
		break;
	case 9:
	case 16:
		stackObject->data.cameraObject.attribute = item;

		retValue = 1;
		break;
	}

	return retValue;
}


// autogenerated function stub: 
// long /*$ra*/ EVENT_TransformSplineAttribute(struct _PCodeStack *stack /*$a0*/, struct StackType *stackObject /*$a1*/, long item /*$a2*/, short *codeStream /*$a3*/)
long EVENT_TransformSplineAttribute(struct _PCodeStack *stack, struct StackType *stackObject, long item, short *codeStream)
{ // line 2880, offset 0x8006303c
	/* begin block 1 */
		// Start line: 2881
		// Start offset: 0x8006303C
		// Variables:
			long retValue; // $v1
			struct _Instance *instance; // $s0

		/* begin block 1.1 */
			// Start line: 2903
			// Start offset: 0x800630C4
			// Variables:
				long maxKeyFrames; // $v0
		/* end block 1.1 */
		// End offset: 0x800630F8
		// End Line: 2914
	/* end block 1 */
	// End offset: 0x8006312C
	// End Line: 2932

	/* begin block 2 */
		// Start line: 6240
	/* end block 2 */
	// End Line: 6241
				UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// long /*$ra*/ EVENT_TransformIntroAttribute(struct _PCodeStack *stack /*$a0*/, struct StackType *stackObject /*$s3*/, long item /*$a2*/)
long EVENT_TransformIntroAttribute(struct _PCodeStack *stack, struct StackType *stackObject, long item)
{ // line 2935, offset 0x80063140
	/* begin block 1 */
		// Start line: 2936
		// Start offset: 0x80063140
		// Variables:
			long retValue; // $v0
			long x; // $s0
			long y; // $s1
			long z; // $s2
			struct Intro *intro; // $a3

		/* begin block 1.1 */
			// Start line: 2947
			// Start offset: 0x8006318C
		/* end block 1.1 */
		// End offset: 0x800631D8
		// End Line: 2962

		/* begin block 1.2 */
			// Start line: 2969
			// Start offset: 0x800631D8
			// Variables:
				//struct Rotation3d vector; // stack offset -48
		/* end block 1.2 */
		// End offset: 0x800631D8
		// End Line: 2972
	/* end block 1 */
	// End offset: 0x80063240
	// End Line: 3039

	/* begin block 2 */
		// Start line: 6363
	/* end block 2 */
	// End Line: 6364
			UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// long /*$ra*/ EVENT_ParseOperand2(struct StackType *operand2 /*$a0*/, long *error /*$s0*/, long *trueValue /*$s1*/)
long EVENT_ParseOperand2(struct StackType *operand2, long *error, long *trueValue)
{ // line 3041, offset 0x8006325c
	/* begin block 1 */
		// Start line: 3042
		// Start offset: 0x8006325C
		// Variables:
			long number; // $v0

		/* begin block 1.1 */
			// Start line: 3047
			// Start offset: 0x8006327C
			// Variables:
				short flags; // stack offset -24
		/* end block 1.1 */
		// End offset: 0x800632A0
		// End Line: 3055
	/* end block 1 */
	// End offset: 0x800632A0
	// End Line: 3057

	/* begin block 2 */
		// Start line: 6616
	/* end block 2 */
	// End Line: 6617
				UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// long /*$ra*/ EVENT_DoVMObjectAction(struct EventVmObject *vmobject /*$s0*/, struct StackType *operand2 /*$a0*/)
long EVENT_DoVMObjectAction(struct EventVmObject *vmobject, struct StackType *operand2)
{ // line 3059, offset 0x800632b4
	/* begin block 1 */
		// Start line: 3060
		// Start offset: 0x800632B4
		// Variables:
			long result; // $s1
			long trueValue; // stack offset -20
			long number; // $a2
			long error; // stack offset -24
	/* end block 1 */
	// End offset: 0x80063458
	// End Line: 3134

	/* begin block 2 */
		// Start line: 6653
	/* end block 2 */
	// End Line: 6654
			UNIMPLEMENTED();
	return 0;
}


long EVENT_GetVMObjectValue(struct EventVmObject* vmobject)  // Matching - 97.70%
{
	long value;
	long trueValue;

	value = 0;
	trueValue = 1;

	switch (vmobject->attribute)
	{
	case -1:
		value = 1;
		break;
	case 14:
		trueValue = 0;
	case 13:
		value = trueValue;

		if (vmobject->vmObjectPtr->flags & 2)
		{
			value = value == 0;
		}

		break;
	case 99:
		value = vmobject->vmObjectPtr->currentIdx;
		break;
	case 100:
		value = vmobject->vmObjectPtr->timer % vmobject->vmObjectPtr->curVMOffsetTable->numVMOffsets;
		break;
	}

	return value;
}


// autogenerated function stub: 
// long /*$ra*/ EVENT_DoGameAction(struct GameObject *gameObject /*$s2*/, struct StackType *operand2 /*$a0*/)
long EVENT_DoGameAction(struct GameObject *gameObject, struct StackType *operand2)
{ // line 3170, offset 0x8006353c
	/* begin block 1 */
		// Start line: 3171
		// Start offset: 0x8006353C
		// Variables:
			long error; // stack offset -32
			long number; // $s0
			long trueValue; // stack offset -28
	/* end block 1 */
	// End offset: 0x80063810
	// End Line: 3303

	/* begin block 2 */
		// Start line: 6877
	/* end block 2 */
	// End Line: 6878
			UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// long /*$ra*/ EVENT_DoSignalAction(struct SignalObject *signalObject /*$s0*/, struct StackType *operand2 /*$a0*/)
long EVENT_DoSignalAction(struct SignalObject *signalObject, struct StackType *operand2)
{ // line 3306, offset 0x80063830
	/* begin block 1 */
		// Start line: 3307
		// Start offset: 0x80063830
		// Variables:
		long trueValue; // stack offset -12
		long number; // $v1
		long error; // stack offset -16
		/* end block 1 */
		// End offset: 0x80063898
		// End Line: 3339

		/* begin block 2 */
			// Start line: 7151
		/* end block 2 */
		// End Line: 7152
		UNIMPLEMENTED();
		return 0;
}


// autogenerated function stub: 
// long /*$ra*/ EVENT_TransformSignalAttribute(struct _PCodeStack *stack /*$a0*/, struct StackType *stackObject /*$a0*/, long item /*$a2*/)
long EVENT_TransformSignalAttribute(struct _PCodeStack* stack, struct StackType* stackObject, long item)
{ // line 3342, offset 0x800638ac
	/* begin block 1 */
		// Start line: 3343
		// Start offset: 0x800638AC
		// Variables:
	long retValue; // $v1
	struct _MultiSignal* msignal; // $a1
	/* end block 1 */
	// End offset: 0x800638F4
	// End Line: 3371

	/* begin block 2 */
		// Start line: 7228
	/* end block 2 */
	// End Line: 7229
	UNIMPLEMENTED();
	return 0;
}

long EVENT_TransformRotation3dAttribute(struct _PCodeStack* stack, struct StackType* stackObject, long item, short* codeStream)  // Matching - 100%
{
	long retValue;

	switch (item)
	{
	case 6:
	case 7:
	case 8:
	case 96:
	case 97:
	case 98:
		stackObject->data.rotation3d.attribute = item;
		return 1;

	default:
		return 0;
	}
}


// autogenerated function stub: 
// long /*$ra*/ EVENT_TransformVector3dAttribute(struct _PCodeStack *stack /*$a0*/, struct StackType *stackObject /*$a0*/, long item /*$a2*/, short *codeStream /*$a3*/)
long EVENT_TransformVector3dAttribute(struct _PCodeStack* stack, struct StackType* stackObject, long item, short* codeStream)
{ // line 3399, offset 0x8006393c
	/* begin block 1 */
		// Start line: 3400
		// Start offset: 0x8006393C
		// Variables:
	long retValue; // $a2
	/* end block 1 */
	// End offset: 0x80063A28
	// End Line: 3452

	/* begin block 2 */
		// Start line: 7350
	/* end block 2 */
	// End Line: 7351
	UNIMPLEMENTED();
	return 0;
}

void EVENT_ModifyObjectToStackWithAttribute(struct _PCodeStack* stack, long item, short* codeStream)  // Matching - 100%
{
	if(stack->topOfStack != 0)
	{
		EVENT_TransformObjectOnStack(stack, item, codeStream);
	}
}


// autogenerated function stub: 
// long /*$ra*/ EVENT_DoInstanceAnimateTextureAction(struct InstanceAnimateTexture *instanceAniTexture /*$s1*/, struct StackType *operand2 /*$a0*/)
long EVENT_DoInstanceAnimateTextureAction(struct InstanceAnimateTexture *instanceAniTexture, struct StackType *operand2)
{ // line 3478, offset 0x80063a68
	/* begin block 1 */
		// Start line: 3479
		// Start offset: 0x80063A68
		// Variables:
			long trueValue; // stack offset -20
			long number; // $a2
			long result; // $s0
			long error; // stack offset -24
	/* end block 1 */
	// End offset: 0x80063B58
	// End Line: 3532

	/* begin block 2 */
		// Start line: 7525
	/* end block 2 */
	// End Line: 7526
			UNIMPLEMENTED();
	return 0;
}

void EVENT_ResetAllSplineFlags(struct MultiSpline* spline) // Matching - 100%
{
	if (spline->positional)
	{
		spline->positional->flags &= 0xF8;
	}
	if (spline->rotational)
	{
		spline->rotational->flags &= 0xF8;
	}
	if (spline->scaling)
	{
		spline->scaling->flags &= 0xF8;
	}
	if (spline->color)
	{
		spline->color->flags &= 0xF8;
	}
}

void EVENT_SetSplineLoop(struct MultiSpline* spline) // Matching - 100%
{
	if (spline->positional)
	{
		spline->positional->flags |= 2;
	}
	if (spline->rotational)
	{
		spline->rotational->flags |= 2;
	}
	if (spline->scaling)
	{
		spline->scaling->flags |= 2;
	}
	if (spline->color)
	{
		spline->color->flags |= 2;
	}
}


// autogenerated function stub: 
// long /*$ra*/ EVENT_DoSplineAction(struct InstanceSpline *instanceSpline /*$s3*/, struct StackType *operand2 /*$a0*/)
long EVENT_DoSplineAction(struct InstanceSpline *instanceSpline, struct StackType *operand2)
{ // line 3551, offset 0x80063c80
	/* begin block 1 */
		// Start line: 3552
		// Start offset: 0x80063C80
		// Variables:
			long trueValue; // stack offset -28
			long number; // $s0
			long result; // $s4
			long error; // stack offset -32

		/* begin block 1.1 */
			// Start line: 3563
			// Start offset: 0x80063CC4
			// Variables:
				struct _Instance *instance; // $s1
				struct MultiSpline *spline; // $s2

			/* begin block 1.1.1 */
				// Start line: 3615
				// Start offset: 0x80063D84
				// Variables:
					long curKeyFrame; // $a0

				/* begin block 1.1.1.1 */
					// Start line: 3623
					// Start offset: 0x80063D94
					// Variables:
						long maxKeyFrames; // $v1
				/* end block 1.1.1.1 */
				// End offset: 0x80063DB4
				// End Line: 3631
			/* end block 1.1.1 */
			// End offset: 0x80063EA8
			// End Line: 3675
		/* end block 1.1 */
		// End offset: 0x80064028
		// End Line: 3715
	/* end block 1 */
	// End offset: 0x80064028
	// End Line: 3717

	/* begin block 2 */
		// Start line: 7682
	/* end block 2 */
	// End Line: 7683
						UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// long /*$ra*/ EVENT_DoAnimateAction(struct InstanceAnimate *instanceAnimate /*$s1*/, struct StackType *operand2 /*$s3*/)
long EVENT_DoAnimateAction(struct InstanceAnimate *instanceAnimate, struct StackType *operand2)
{ // line 3720, offset 0x8006404c
	/* begin block 1 */
		// Start line: 3721
		// Start offset: 0x8006404C
		// Variables:
			long trueValue; // stack offset -28
			long number; // $a0
			long result; // $s2
			long error; // stack offset -32
			struct _Instance *instance; // $s0

		/* begin block 1.1 */
			// Start line: 3786
			// Start offset: 0x80064128
			// Variables:
				struct _Instance *hostInstance; // $v0
		/* end block 1.1 */
		// End offset: 0x80064128
		// End Line: 3787
	/* end block 1 */
	// End offset: 0x80064300
	// End Line: 3941

	/* begin block 2 */
		// Start line: 8043
	/* end block 2 */
	// End Line: 8044
				UNIMPLEMENTED();
	return 0;
}


long EVENT_DoInstanceAction(struct InstanceObject* instanceObject, struct StackType* operand2, short* codeStream)  // Matching - 99.77%
{
	long trueValue;
	long number;
	long error;
	long result;
	struct _Instance* instance;
	int temp;  // not from SYMDUMP

	trueValue = 1;

	instance = instanceObject->instance;

	number = -1;
	result = 0;

	if (instanceObject->attribute != -1)
	{
		number = EVENT_ParseOperand2(operand2, &error, &trueValue);

		switch (instanceObject->attribute)
		{
		case 38:
			trueValue ^= 1;
		case 39:
			if (trueValue != 0)
			{
				INSTANCE_Post(instance, 0x800021, 0);
			}
			else
			{
				INSTANCE_Post(instance, 0x800022, 0);
			}

			break;
		case 37:
			trueValue ^= 1;
		case 36:
			if (trueValue != 0)
			{
				if (!(INSTANCE_Query(instanceObject->instance, 5) & 0x1))
				{
					INSTANCE_Post(instance, 0x800020, 0);
				}

				break;
			}

			if (INSTANCE_Query(instanceObject->instance, 5) & 0x1)
			{
				INSTANCE_Post(instance, 0x800020, 0);
			}

			break;
		case 20:
			trueValue ^= 1;
		case 21:
			if (trueValue != 0)
			{
				INSTANCE_Post(instance, 0x10002002, 0);

				result = 1;
				break;
			}
			else
			{
				INSTANCE_Post(instance, 0x10002001, 0);
			}

			result = 1;
			break;
		case 52:
			if (trueValue != 0)
			{
				instance->flags |= 0x800;
			}
			else
			{
				instance->flags &= ~0x800;
			}

			result = 1;
			break;
		case 53:
			if (trueValue != 0)
			{
				instance->flags2 |= 0x20000000;
				instance->flags |= 0x40000;
			}
			else
			{
				instance->flags2 &= 0xDFFFFFFF;
				instance->flags &= 0xFFFBFFFF;
			}

			result = 1;
			break;
		case 11:
			trueValue ^= 1;
		case 10:
			if (trueValue != 0)
			{
				instance->flags |= 0x800;
				instance->flags2 |= 0x20000000;
				instance->flags |= 0x40000;

				if (instance->object->oflags2 & 0x80000)
				{
					instance->flags2 |= 0x10000000;
				}
			}
			else
			{
				instance->flags &= ~0x800;
				instance->flags2 &= 0xDFFFFFFF;
				instance->flags &= 0xFFFBFFFF;

				if (instance->object->oflags2 & 0x80000)
				{
					instance->flags2 &= 0xEFFFFFFF;
				}
			}

			if (INSTANCE_Query(instance, 1) & 0xE)
			{
				INSTANCE_Post(instance, 0x40013, trueValue);
			}

			result = 1;
			break;
		case 32:
			switch (number)
			{
			case 1:
				INSTANCE_Post(instance, 0x40000, 0);
				break;
			case 2:
				INSTANCE_Post(instance, 0x40012, 0);
				break;
			case 3:
				INSTANCE_Post(instance, 0x40014, 0);
				break;
			case 4:
				INSTANCE_Post(instance, 0x40005, 0xA000);
			}

			break;
		case 54:
		{
			int x;
			int y;

			x = 0;

			if (number < 4U)
			{
				y = 0;

				switch (number)
				{
				case 0:
					y = 1;
					break;
				case 1:
					x = 1;
					break;
				case 2:
					x = 0;
					y = -1;
					break;
				case 3:
					x = -1;
					break;
				}

				INSTANCE_Post(instance, 0x800000, SetObjectData(x, y, 6, NULL, 0));
			}

			break;
		}
		case 55:
		{
			struct Object* object;
			int i;

			object = instance->object;

			if (object->numberOfEffects != 0)
			{
				if (number == -1)
				{
					for (i = 0; i < object->numberOfEffects; i++)
					{
						FX_StartInstanceEffect(instance, &object->effectList[i], 0);
					}

					break;
				}
				else
				{
					if (number < object->numberOfEffects)
					{
						FX_StartInstanceEffect(instance, &object->effectList[number], 0);
					}
				}
			}

			break;
		}
		case 51:
			if (number == -1)
			{
				number = 0;
			}

			INSTANCE_Post(instance, 0x01000017, number);
			break;
		case 64:
			if (number != 0)
			{
				number = 1;
			}

			INSTANCE_Post(instance, 0x0100001A, number);
			break;
		case 138:
		{
			struct Intro* intro;

			intro = instance->intro;

			if (intro != NULL)
			{
				if (trueValue != 0)
				{
					intro->flags |= 0x400;
				}
				else
				{
					intro->flags &= ~0x400;
				}
			}

			break;
		}
		case 4:
			if (number >= 256)
			{
				INSTANCE_Post(instance, 0x40017, number - 256);
				break;
			}

			if ((number - 1) < 7U)
			{
				ScriptKillInstance(instance, number);
				break;
			}

			if (number == 0)
			{
				SAVE_UndestroyInstance(instance);
			}

			break;
		case 76:
		{
			struct Vector3d* vector3d;

			if (operand2 != NULL)
			{
				if (operand2->id == 9)
				{
					vector3d = &operand2->data.vector3d;

					INSTANCE_Post(instance, 0x4000A, SetPositionData(vector3d->vx, vector3d->vy, vector3d->vz));

					instance->currentStreamUnitID = vector3d->streamUnitID;
				}
			}
			break;
		}
		case 77:
			if (operand2 != NULL)
			{
				if (operand2->id == 14)
				{
					INSTANCE_Post(instance, 0x4000B, SetPositionData(operand2->data.rotation3d.vx, operand2->data.rotation3d.vy, operand2->data.rotation3d.vz));
				}
			}

			break;
		case 80:
			if (operand2 != NULL)
			{
				if (operand2->id == 14)
				{
					INSTANCE_Post(instance, 0x4000D, SetPositionData(operand2->data.rotation3d.vx, operand2->data.rotation3d.vy, operand2->data.rotation3d.vz));
				}
			}

			break;
		case 133:
			INSTANCE_Post(instance, 0x40021, number);
			break;
		case 123:
			if (operand2 != NULL)
			{
				if (operand2->id == 9)
				{
					INSTANCE_Post(instance, 0x40018, SetPositionData(operand2->data.vector3d.vx, operand2->data.vector3d.vy, operand2->data.vector3d.vz));
				}
			}

			break;
		case 75:
			if (operand2 != NULL)
			{
				if (operand2->id == 9)
				{
					INSTANCE_Post(instance, 0x40016, SetPositionData(operand2->data.vector3d.vx, operand2->data.vector3d.vy, operand2->data.vector3d.vz));
				}
			}

			break;
		case 114:
			if (operand2 != NULL)
			{
				if (operand2->id == 9)
				{
					INSTANCE_Post(instance, 0x4000C, SetPositionData(operand2->data.vector3d.vx, operand2->data.vector3d.vy, operand2->data.vector3d.vz));
				}
			}

			break;
		case 79:
			trueValue = trueValue == 0;
		case 78:
			if (instance == gameTrackerX.playerInstance)
			{
				INSTANCE_Post(instance, 0x4000E, trueValue);

				if (trueValue != 0)
				{
					gameTrackerX.gameFlags |= 0x90;
				}
				else
				{
					gameTrackerX.gameFlags &= ~0x80;
					gameTrackerX.gameFlags &= ~0x10;
				}

				if (trueValue != 0)
				{
					struct EventTimer* timer;

					timer = EVENT_GetNextTimer();

					if (timer != NULL)
					{
						EventAbortLine = 1;
						EventJustRecievedTimer = 1;

						timer->scriptPos = codeStream;
						timer->flags &= 1;
						timer->time = 0x1000;
						timer->event = currentEventInstance;
						timer->actionScript = currentActionScript;

						currentActionScript->conditionBits |= 1;

						timer->level = CurrentPuzzleLevel;
						timer->nextEventIndex = EventCurrentEventIndex;
					}
				}

				break;
			}

			INSTANCE_Post(instance, 0x4000E, trueValue);
			break;
		case 141:
			if (number >= 0)
			{
				INSTANCE_Broadcast(NULL, 10, 0x01000011, SetMonsterAlarmData(instance, NULL, number));
			}

			break;
		case 83:
			if (operand2 != NULL)
			{
				if (operand2->id == 9)
				{
					INSTANCE_Post(instance, 0x4000F, SetPositionData(operand2->data.vector3d.vx, operand2->data.vector3d.vy, operand2->data.vector3d.vz));
				}
			}

			break;
		case 84:
			if (trueValue != 0)
			{
				INSTANCE_Post(instance, 0x40010, 0);
			}

			break;
		case 85:
			INSTANCE_Post(instance, 0x800027, trueValue);
			break;
		case 91:
			if (number >= 0)
			{
				instance->lightGroup = (unsigned char)number;
			}

			break;
		case 92:
			if (number >= 0)
			{
				instance->spectralLightGroup = (unsigned char)number;
			}

			break;
		case 95:
			trueValue = 0;
		case 94:
			INSTANCE_Post(instance, 0x800029, trueValue);
			break;
		case 103:
			if (trueValue != 0)
			{
				instance->flags &= 0xFFBFFFFF;
				break;
			}

			instance->flags |= 0x400000;
			break;
		case 140:
			INSTANCE_Post(instance, 0x40022, number);
			break;
		case 108:
			temp = number % 360 << 12;

			if (number < 0)
			{
				temp = (number + 360) << 12;
			}

			INSTANCE_Post(instance, 0x04000005, rcos(temp / 360));
			break;
		case 109:
			INSTANCE_Post(instance, 0x04000006, 0);
			break;
		case 110:
			INSTANCE_Post(instance, 0x40015, 1 << number);
			break;
		case 111:
			INSTANCE_Post(instance, 0x40011, 0);
			break;
		case 116:
			INSTANCE_Post(instance, 0x40006, number << 12);
			break;
		case 124:
			number <<= 12;
			INSTANCE_Post(instance, 0x40019, number);
		case 163:
			INSTANCE_Post(instance, 0x1000022, number);
			break;
		case 164:
			INSTANCE_Post(instance, 0x1000022, 0);
			break;
		case 165:
			if (instance == gameTrackerX.playerInstance)
			{
				if (trueValue != 0)
				{
					gameTrackerX.gameFlags |= 0x90;
				}
				else
				{
					gameTrackerX.gameFlags &= ~0x80;
					gameTrackerX.gameFlags &= ~0x10;
				}
			}
		}
	}

	return result;
}


// autogenerated function stub: 
// long /*$ra*/ EVENT_GetTGroupValue(struct TGroupObject *terrainGroup /*$a0*/)
long EVENT_GetTGroupValue(struct TGroupObject *terrainGroup)
{ // line 4434, offset 0x80064dc4
	/* begin block 1 */
		// Start line: 4436
		// Start offset: 0x80064DC4
		// Variables:
			long value; // $a2
			long trueValue; // $a3
			struct BSPTree *bspTree; // $a1
	/* end block 1 */
	// End offset: 0x80064F24
	// End Line: 4543

	/* begin block 2 */
		// Start line: 9517
	/* end block 2 */
	// End Line: 9518

	/* begin block 3 */
		// Start line: 9518
	/* end block 3 */
	// End Line: 9519
			UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// long /*$ra*/ EVENT_DoTGroupAction(struct TGroupObject *terrainGroup /*$s1*/, struct StackType *operand2 /*$a0*/)
long EVENT_DoTGroupAction(struct TGroupObject *terrainGroup, struct StackType *operand2)
{ // line 4546, offset 0x80064f30
	/* begin block 1 */
		// Start line: 4547
		// Start offset: 0x80064F30
		// Variables:
			long trueValue; // stack offset -20
			long number; // $v0
			long error; // stack offset -24
			long result; // $s2

		/* begin block 1.1 */
			// Start line: 4558
			// Start offset: 0x80064F64
			// Variables:
				struct BSPTree *bspTree; // $s0

			/* begin block 1.1.1 */
				// Start line: 4566
				// Start offset: 0x80065010
				// Variables:
					struct WaterLevelProcess *curWater; // $a0
			/* end block 1.1.1 */
			// End offset: 0x8006509C
			// End Line: 4582

			/* begin block 1.1.2 */
				// Start line: 4590
				// Start offset: 0x800650B0
				// Variables:
					long offsetz; // $a0
			/* end block 1.1.2 */
			// End offset: 0x80065134
			// End Line: 4603
		/* end block 1.1 */
		// End offset: 0x8006521C
		// End Line: 4673
	/* end block 1 */
	// End offset: 0x8006521C
	// End Line: 4675

	/* begin block 2 */
		// Start line: 9745
	/* end block 2 */
	// End Line: 9746
					UNIMPLEMENTED();
	return 0;
}


long EVENT_DoCameraAction(struct CameraObject* cameraObject, struct StackType* operand2, short* codeStream)  // Matching - 99.91%
{
	long trueValue;
	long number;
	long error;
	struct Camera* camera;

	trueValue = 1;

	error = 1;

	number = -1;

	camera = cameraObject->camera;

	if (cameraObject->attribute != -1)
	{
		number = EVENT_ParseOperand2(operand2, &error, &trueValue);

		switch (cameraObject->attribute)
		{
		case 67:
			if (error == 0)
			{
				CAMERA_SetSmoothValue(camera, number);
			}

			break;
		case 68:
		case 69:
		{
			struct Intro* intro;

			intro = NULL;

			if (operand2 != NULL)
			{
				switch (operand2->id)
				{
				case 2:
					intro = operand2->data.instanceObject.instance->intro;
					break;
				case 4:
					intro = operand2->data.introObject.intro;
					break;
				}
			}

			if (intro != NULL)
			{
				if (cameraObject->attribute == 68)
				{
					camera->Spline00 = intro->multiSpline;
				}
				else
				{
					camera->Spline01 = intro->multiSpline;
				}
			}

			break;
		}
		case 9:
		case 70:
		{
			long angle;

			if (error == 0)
			{
				if (cameraObject->attribute == 70)
				{
					angle = -number;

					if ((angle % 360) < 0)
					{
						angle += 360;
					}

					CAMERA_Adjust_tilt(cameraObject->camera, (angle * 4096) / 360);
				}
				else
				{
					angle = -number;

					if ((angle % 360) < 0)
					{
						angle += 360;
					}

					CAMERA_Adjust_rotation(cameraObject->camera, (angle * 4096) / 360);
				}
			}
			break;
		}
		case 105:
		{
			long angle;

			if (error == 0)
			{
				angle = number % 360;

				if (angle < 0)
				{
					angle += 360;
				}

				CAMERA_Adjust_roll(((angle * 4096) / 360), cameraObject->frames);
			}

			break;
		}
		case 104:
		{
			long angle;

			if (error == 0)
			{
				angle = number % 360;

				if (angle < 0)
				{
					angle += 360;
				}

				CAMERA_Adjust_roll(((angle * 4096) / 360), 0);
			}
			break;
		}
		case 71:
			if (error == 0)
			{
				CAMERA_Adjust_distance(cameraObject->camera, number);
			}

			break;
		case 72:
			CAMERA_RestoreMode(camera);
			break;
		case 73:
			if ((operand2 != NULL) && (operand2->id == 2))
			{
				CAMERA_SetInstanceFocus(camera, operand2->data.instanceObject.instance);
			}

			break;
		case 16:
			if (error == 0)
			{
				CAMERA_SetMode(camera, number);
			}

			break;
		}
	}

	return 0;
}


// autogenerated function stub: 
// long /*$ra*/ EVENT_DoObjectSoundAction(struct SoundObject *soundObject /*$s0*/, struct StackType *operand2 /*$a0*/)
long EVENT_DoObjectSoundAction(struct SoundObject *soundObject, struct StackType *operand2)
{ // line 4882, offset 0x800655b8
	/* begin block 1 */
		// Start line: 4883
		// Start offset: 0x800655B8
		// Variables:
			long trueValue; // stack offset -20
			long number; // $v1
			long error; // stack offset -24
			long result; // $s2
			struct _Instance *instance; // $a3

		/* begin block 1.1 */
			// Start line: 4898
			// Start offset: 0x800655F0
			// Variables:
				struct SoundInstance *soundInstance; // $s1
		/* end block 1.1 */
		// End offset: 0x800656D0
		// End Line: 4936
	/* end block 1 */
	// End offset: 0x800656D0
	// End Line: 4937

	/* begin block 2 */
		// Start line: 10435
	/* end block 2 */
	// End Line: 10436
				UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// long /*$ra*/ EVENT_DoSoundMarkerAction(struct SoundObject *soundObject /*$s0*/, struct StackType *operand2 /*$a0*/)
long EVENT_DoSoundMarkerAction(struct SoundObject *soundObject, struct StackType *operand2)
{ // line 4940, offset 0x800656ec
	/* begin block 1 */
		// Start line: 4941
		// Start offset: 0x800656EC
		// Variables:
			long trueValue; // stack offset -20
			long number; // $v1
			long error; // stack offset -24
			long result; // $s2
			struct _SFXMkr *sfxMarker; // $a3

		/* begin block 1.1 */
			// Start line: 4956
			// Start offset: 0x80065724
			// Variables:
				struct SoundInstance *soundInstance; // $s1
		/* end block 1.1 */
		// End offset: 0x80065804
		// End Line: 4994
	/* end block 1 */
	// End offset: 0x80065804
	// End Line: 4995

	/* begin block 2 */
		// Start line: 10560
	/* end block 2 */
	// End Line: 10561
				UNIMPLEMENTED();
	return 0;
}

long EVENT_GetSoundValue(struct SoundObject* soundObject)  // Matching - 100%
{
	return 0;
}

long EVENT_DoAreaAction(struct AreaObject* areaObject, struct StackType* operand2) // Matching - 100%
{
	long trueValue;
	long number;
	long error;
	struct _StreamUnit* streamUnit;

	trueValue = 1;
	number = -1;
	streamUnit = areaObject->streamUnit;
	if (areaObject->attribute != -1)
	{
		number = EVENT_ParseOperand2(operand2, &error, &trueValue);
		if (areaObject->attribute != 0x70)
		{
			if ((areaObject->attribute == 0x71) && (error == 0))
			{
				streamUnit->TargetFogNear = (short)number;
				streamUnit->level->fogNear = (short)number;
			}
		}
		else if (error == 0)
		{
			streamUnit->TargetFogFar = (short)number;
			streamUnit->level->fogFar = (short)number;
		}
	}
	return 0;
}


// autogenerated function stub: 
// long /*$ra*/ EVENT_DoIntroAction(struct IntroObject *introObject /*$s1*/, struct StackType *operand2 /*$a0*/)
long EVENT_DoIntroAction(struct IntroObject *introObject, struct StackType *operand2)
{ // line 5082, offset 0x800658d4
	/* begin block 1 */
		// Start line: 5083
		// Start offset: 0x800658D4
		// Variables:
			long trueValue; // stack offset -20
			long number; // $a2
			long error; // stack offset -24
			long result; // $s2

		/* begin block 1.1 */
			// Start line: 5094
			// Start offset: 0x80065908
			// Variables:
				struct Intro *intro; // $s0

			/* begin block 1.1.1 */
				// Start line: 5144
				// Start offset: 0x80065A3C
				// Variables:
					int i; // $a2
					int j; // $v1
					int id; // $a1

				/* begin block 1.1.1.1 */
					// Start line: 5147
					// Start offset: 0x80065A4C

					/* begin block 1.1.1.1.1 */
						// Start line: 5150
						// Start offset: 0x80065A5C
						// Variables:
							struct Intro *intro1; // $v0
					/* end block 1.1.1.1.1 */
					// End offset: 0x80065A94
					// End Line: 5159
				/* end block 1.1.1.1 */
				// End offset: 0x80065A94
				// End Line: 5160
			/* end block 1.1.1 */
			// End offset: 0x80065AC8
			// End Line: 5163
		/* end block 1.1 */
		// End offset: 0x80065AC8
		// End Line: 5170
	/* end block 1 */
	// End offset: 0x80065AC8
	// End Line: 5172

	/* begin block 2 */
		// Start line: 10861
	/* end block 2 */
	// End Line: 10862
							UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// void /*$ra*/ EVENT_DoStackOperationEquals(struct _PCodeStack *stack /*$a2*/, short *codeStream /*$a3*/)
void EVENT_DoStackOperationEquals(struct _PCodeStack *stack, short *codeStream)
{ // line 5189, offset 0x80065ae4
	/* begin block 1 */
		// Start line: 5190
		// Start offset: 0x80065AE4
		// Variables:
			//struct StackType operand1; // stack offset -88
			//struct StackType operand2; // stack offset -48
	/* end block 1 */
	// End offset: 0x80065BA8
	// End Line: 5204

	/* begin block 2 */
		// Start line: 10378
	/* end block 2 */
	// End Line: 10379
	UNIMPLEMENTED();
}


// autogenerated function stub: 
// long /*$ra*/ EVENT_CompareVector3d(struct Vector3d *vector1 /*$a0*/, struct Vector3d *vector2 /*$a1*/)
long EVENT_CompareVector3d(struct Vector3d *vector1, struct Vector3d *vector2)
{ // line 5209, offset 0x80065bd0
	/* begin block 1 */
		// Start line: 5211
		// Start offset: 0x80065BD0
		// Variables:
			long retValue; // $t2

		/* begin block 1.1 */
			// Start line: 5240
			// Start offset: 0x80065C88
			// Variables:
				long dist; // $v0
		/* end block 1.1 */
		// End offset: 0x80065D08
		// End Line: 5250

		/* begin block 1.2 */
			// Start line: 5256
			// Start offset: 0x80065D10
			// Variables:
				//long dist; // $v0
		/* end block 1.2 */
		// End offset: 0x80065D80
		// End Line: 5266
	/* end block 1 */
	// End offset: 0x80065D80
	// End Line: 5270

	/* begin block 2 */
		// Start line: 11134
	/* end block 2 */
	// End Line: 11135

	/* begin block 3 */
		// Start line: 11135
	/* end block 3 */
	// End Line: 11136

	/* begin block 4 */
		// Start line: 11137
	/* end block 4 */
	// End Line: 11138
				UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// long /*$ra*/ EVENT_CompareRotationVectors(struct Rotation3d *rot1 /*$a0*/, struct Rotation3d *rot2 /*$s1*/, long trueValue /*$s6*/)
long EVENT_CompareRotationVectors(struct Rotation3d *rot1, struct Rotation3d *rot2, long trueValue)
{ // line 5279, offset 0x80065d8c
	/* begin block 1 */
		// Start line: 5280
		// Start offset: 0x80065D8C
		// Variables:
			//MATRIX matrix1; // stack offset -104
			//MATRIX matrix2; // stack offset -72
			long result; // $s2
			long c1; // $v1
			long attribute; // $s0
			struct _SVector axis; // stack offset -40
			long doSoft; // $s4
	/* end block 1 */
	// End offset: 0x80065F58
	// End Line: 5377

	/* begin block 2 */
		// Start line: 11280
	/* end block 2 */
	// End Line: 11281
			UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// long /*$ra*/ EVENT_CompareListWithOperation(struct _PCodeStack *stack /*$s7*/, struct ListObject *listObject /*$s3*/, struct StackType *operand2 /*stack 8*/, long operation /*$fp*/)
long EVENT_CompareListWithOperation(struct _PCodeStack *stack, struct ListObject *listObject, struct StackType *operand2, long operation)
{ // line 5394, offset 0x80065f84
	/* begin block 1 */
		// Start line: 5395
		// Start offset: 0x80065F84
		// Variables:
			long retValue; // $s4
			long d; // $s0
			//struct StackType operand1; // stack offset -96
			char objectName[16]; // stack offset -56
			char *temp; // $v0
			struct _Instance *instance; // $s2
			long areaID; // $s5
	/* end block 1 */
	// End offset: 0x80066144
	// End Line: 5460

	/* begin block 2 */
		// Start line: 11514
	/* end block 2 */
	// End Line: 11515

	/* begin block 3 */
		// Start line: 11521
	/* end block 3 */
	// End Line: 11522
			UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// long /*$ra*/ EVENT_CompareSubListWithOperation(struct _PCodeStack *stack /*$s6*/, struct SubListObject *subListObject /*$s3*/, struct StackType *operand2 /*$s7*/, long operation /*$fp*/)
long EVENT_CompareSubListWithOperation(struct _PCodeStack *stack, struct SubListObject *subListObject, struct StackType *operand2, long operation)
{ // line 5464, offset 0x80066178
	/* begin block 1 */
		// Start line: 5465
		// Start offset: 0x80066178
		// Variables:
			long i; // $s4
			long retValue; // $s5
			long d; // $s0
			//struct StackType operand1; // stack offset -80
	/* end block 1 */
	// End offset: 0x800662E0
	// End Line: 5498

	/* begin block 2 */
		// Start line: 11665
	/* end block 2 */
	// End Line: 11666

	/* begin block 3 */
		// Start line: 11669
	/* end block 3 */
	// End Line: 11670
			UNIMPLEMENTED();
	return 0;
}


long EVENT_CompareOperandsWithOperation(struct _PCodeStack* stack, struct StackType* operand1, struct StackType* operand2, long operation)  // Matching - 100%
{
	long number;
	long number1;
	long number2;
	long error;
	long trueValue;
	short flags1;
	short flags2;
	short x;  // not from SYMDUMP
	short y;  // not from SYMDUMP
	short z;  // not from SYMDUMP
	int cmp_result;  // not from SYMDUMP

	number = 0;
	trueValue = 1;

	switch (operand1->id)
	{
	case 8:
		break;
	case OPERAND_VECTOR3D:
		if (operand2->id != OPERAND_VECTOR3D)
		{
			break;
		}

		switch (operation)
		{
		case OPERATION_ADD:
			x = operand1->data.vector3d.vx + operand2->data.vector3d.vx;
			y = operand1->data.vector3d.vy + operand2->data.vector3d.vy;
			z = operand1->data.vector3d.vz + operand2->data.vector3d.vz;

			EVENT_Addvector3dToStack(stack, x, y, z, 0);

			number = -1;
			break;
		case OPERATION_SUB:
			x = operand1->data.vector3d.vx - operand2->data.vector3d.vx;
			y = operand1->data.vector3d.vy - operand2->data.vector3d.vy;
			z = operand1->data.vector3d.vz - operand2->data.vector3d.vz;

			EVENT_Addvector3dToStack(stack, x, y, z, 0);

			number = -1;
			break;
		case OPERATION_NEQ:
			trueValue = 0;
		case OPERATION_EQU:
			cmp_result = EVENT_CompareVector3d(&operand1->data.vector3d, &operand2->data.vector3d);

			number = trueValue;

			if (cmp_result == 0)
			{
				number ^= 1;
			}

			break;
		}

		break;
	case OPERAND_ROTATION3D:
		if (operand2->id != OPERAND_ROTATION3D)
		{
			break;
		}

		switch (operation)
		{
		case OPERATION_NEQ:
			trueValue = 0;
		case OPERATION_EQU:
			number = EVENT_CompareRotationVectors(&operand1->data.rotation3d, &operand2->data.rotation3d, trueValue);
			break;
		}

		break;
	case OPERAND_SUBLIST:
		cmp_result = EVENT_CompareSubListWithOperation(stack, &operand1->data.subListObject, operand2, operation);

		number = trueValue;

		if (cmp_result == 0)
		{
			number ^= 1;
		}

		break;
	case OPERAND_LIST:
		cmp_result = EVENT_CompareListWithOperation(stack, &operand1->data.listObject, operand2, operation);

		number = trueValue;

		if (cmp_result == 0)
		{
			number ^= 1;
		}

		break;
	default:
		number1 = EVENT_GetScalerValueFromOperand(operand1, &error, &flags1);

		number2 = EVENT_GetScalerValueFromOperand(operand2, &error, &flags2);

		switch (operation)
		{
		case OPERATION_ADD:
			number = number1 + number2;
			break;
		case OPERATION_SUB:
			number = number1 - number2;
			break;
		case OPERATION_MUL:
			number = number1 * number2;
			break;
		case OPERATION_DIV:
			number = 0;

			if (number2 != 0)
			{
				number = number1 / number2;
			}

			break;
		case 5:
			number = number1 % number2;

			if (number < 0)
			{
				number += number2;
			}

			break;
		case OPERATION_LESS_THAN_OR_EQUAL:
			trueValue = 0;
		case OPERATION_GREATER_THAN:
			number = trueValue;
			cmp_result = number1 > number2;

			if (cmp_result == 0)
			{
				number ^= 1;
			}

			break;
		case OPERATION_GREATER_THAN_OR_EQUAL:
			trueValue = 0;
		case OPERATION_LESS_THAN:
			number = trueValue;
			cmp_result = number1 < number2;

			if (cmp_result == 0)
			{
				number ^= 1;
			}

			break;
		case OPERATION_NEQ:
			trueValue = 0;
		case OPERATION_EQU:
			if ((!(flags1 & 1)) && (!(flags2 & 1)))
			{
				number = trueValue;

				if (number1 != number2)
				{
					number ^= 1;
				}
			}
			else
			{
				if (flags1 & 2)
				{
					number2 = 1 << number2;
				}

				number = trueValue;

				if ((number1 & number2) != number2)
				{
					number ^= 1;
				}
			}

			break;
		case OPERATION_AND:
			number = (number1 & number2) != 0;
			break;
		}

		break;
	}

	return number;
}


// autogenerated function stub: 
// void /*$ra*/ EVENT_DoStackMathOperation(struct _PCodeStack *stack /*$s0*/, long operation /*$a3*/)
void EVENT_DoStackMathOperation(struct _PCodeStack *stack, long operation)
{ // line 5713, offset 0x8006664c
	/* begin block 1 */
		// Start line: 5714
		// Start offset: 0x8006664C
		// Variables:
			//struct StackType operand1; // stack offset -128
			//struct StackType operand2; // stack offset -88

		/* begin block 1.1 */
			// Start line: 5732
			// Start offset: 0x80066738
			// Variables:
				//struct StackType holdOperand; // stack offset -48
		/* end block 1.1 */
		// End offset: 0x80066804
		// End Line: 5737
	/* end block 1 */
	// End offset: 0x80066804
	// End Line: 5739

	/* begin block 2 */
		// Start line: 12207
	/* end block 2 */
	// End Line: 12208
	UNIMPLEMENTED();
}

short* EVENT_ParseOpcode(struct _PCodeStack* stack, short* codeStream, long* operateOnStack)  // Matching - 100%
{
	short pcode;

	pcode = *codeStream++ - 1;

	MoveCodeStreamExtra = 0;
	*operateOnStack = 0;

	switch (pcode)
	{
	case 0:
	{
		EVENT_AddObjectToStack(stack, *codeStream);

		codeStream++;
		break;
	}
	case 11:
	{
		EVENT_AddNumberToStack(stack, *codeStream, 0);

		codeStream++;
		break;
	}
	case 1:
	{
		EVENT_ModifyObjectToStackWithAttribute(stack, *codeStream, codeStream);

		codeStream++;
		break;
	}
	case 3:
	{
		EVENT_DoStackMathOperation(stack, 10);
		break;
	}
	case 22:
	{
		EVENT_DoStackMathOperation(stack, 11);
		break;
	}
	case 4:
	{
		EventAbortedPosition = codeStream;
		*operateOnStack = 1;
		break;
	}
	case 31:
	{
		EVENT_DoStackMathOperation(stack, 12);
		break;
	}
	case 12:
	{
		EVENT_DoStackMathOperation(stack, 1);
		break;
	}
	case 13:
	{
		EVENT_DoStackMathOperation(stack, 2);
		break;
	}
	case 14:
	{
		EVENT_DoStackMathOperation(stack, 3);
		break;
	}
	case 15:
	{
		EVENT_DoStackMathOperation(stack, 4);
		break;
	}
	case 23:
	{
		EVENT_DoStackMathOperation(stack, 5);
		break;
	}

	case 16:
	{
		EVENT_StackDuplicate(stack);

		EVENT_AddNumberToStack(stack, 1, 0);

		EVENT_DoStackMathOperation(stack, 1);

		EVENT_DoStackOperationEquals(stack, codeStream);
		break;
	}
	case 17:
	{
		EVENT_StackDuplicate(stack);

		EVENT_AddNumberToStack(stack, 1, 0);

		EVENT_DoStackMathOperation(stack, 2);

		EVENT_DoStackOperationEquals(stack, codeStream);
		break;
	}
	case 2:
	{
		EVENT_DoStackOperationEquals(stack, codeStream);
		break;
	}
	case 18:
	{
		EVENT_DoStackMathOperation(stack, 6);
		break;
	}
	case 19:
	{
		EVENT_DoStackMathOperation(stack, 8);
		break;
	}
	case 20:
	{
		EVENT_DoStackMathOperation(stack, 7);
		break;
	}
	case 21:
	{
		EVENT_DoStackMathOperation(stack, 9);
		break;
	}
	case 6:
	case 8:
	case 9:
	{
		codeStream = NULL;
		break;
	}
	case 27:
	{
		EVENT_AddGameObjectToStack(stack);
		break;
	}
	case 28:
	{
		EVENT_AddPlayerObjectToStack(stack);
		break;
	}
	case 29:
	{
		EVENT_AddSubListObjectToStack(stack, *codeStream);

		codeStream++;
		break;
	}
	case 30:
	{
		if (currentActionScript != NULL)
		{
			currentActionScript->conditionBits |= 0x2;
		}
	}
	}

	return &codeStream[MoveCodeStreamExtra];
}


long EVENT_GetIntroValue(struct IntroObject* introObject) // Matching - 100%
{
	long value;
	long trueValue;

	value = 0;
	trueValue = 1;
	switch (introObject->attribute)
	{
	case -1:
		value = 1;
		break;
	case 20:
	case 21:
		value = -1;
		break;
	case 11:
		trueValue = trueValue ^ 1;
	case 10:
		value = trueValue;
		if (!(introObject->intro->flags & 0x80))
		{
			value ^= 1;
		}
		break;
	case 146:
	case 166:
		value = trueValue;
		if (!(introObject->intro->flags & 0x8))
		{
			value ^= 1;
		}
		break;
	case 5:
	case 9:
	case 12:
	case 16:
	case 36:
	case 37:
	case 43:
	case 126:
	case 143:
	case 144:
	case 160:
		value = 0;
		break;
	}
	return value;
}

// autogenerated function stub: 
// void /*$ra*/ EVENT_DoSubListAction(struct SubListObject *subListObject /*$s3*/, struct StackType *operand2 /*$s5*/, struct _PCodeStack *stack /*$s4*/, short *codeStream /*$s6*/)
void EVENT_DoSubListAction(struct SubListObject *subListObject, struct StackType *operand2, struct _PCodeStack *stack, short *codeStream)
{ // line 5946, offset 0x80066b44
	/* begin block 1 */
		// Start line: 5947
		// Start offset: 0x80066B44
		// Variables:
			long i; // $s2
			long d; // $s0
			//struct StackType operand1; // stack offset -72
	/* end block 1 */
	// End offset: 0x80066C14
	// End Line: 5966

	/* begin block 2 */
		// Start line: 12691
	/* end block 2 */
	// End Line: 12692
			UNIMPLEMENTED();
}


long EVENT_GetInstanceValue(struct InstanceObject* instanceObject) // Matching - 99.95%
{
	long value;
	struct _Instance* instance;

	instance = instanceObject->instance;
	value = 0;
	switch (instanceObject->attribute)
	{
	case -1:
		value = instance->introUniqueID;
		break;
	case 20:
		value = INSTANCE_Query(instance, 11) >> 1;
		value &= 1;
		if (STREAM_IsMorphInProgress())
		{
			value = 0;
		}
		break;
	case 21:
		value = INSTANCE_Query(instance, 11) & 1;
		if (STREAM_IsMorphInProgress())
		{
			value = 0;
		}
		break;
	case 5:
	case 9:
	case 12:
	case 32:
	case 54:
	case 55:
	case 94:
	case 95:
	case 126:
		value = 0;
		break;
	case 16:
		value = INSTANCE_Query(instance, 10);
		break;
	case 53:
		value = EVENT_check_flag_set(instance->flags2, 0x20000000);
		break;
	case 10:
	case 52:
		value = EVENT_check_flag_set(instance->flags, 0x800);
		break;
	case 11:
		value = EVENT_check_flag_unset(instance->flags, 0x800);
		break;
	case 36:
		value = (INSTANCE_Query(instance, 5) & 5) == 1;
		break;
	case 37:
		value = (INSTANCE_Query(instance, 5) & 9) == 0;
		break;
	case 143:
		value = INSTANCE_Query(instance, 5) >> 2;
		value &= 1;
		break;
	case 144:
		value = INSTANCE_Query(instance, 5) >> 3;
		value &= 1;
		break;
	case 38:
		value = INSTANCE_Query(instance, 27);
		break;
	case 39:
		value = INSTANCE_Query(instance, 26);
		break;
	case 91:
		value = instance->lightGroup;
		break;
	case 103:
		value = EVENT_check_flag_unset(instance->flags, 0x400000);
		break;
	case 92:
		value = instance->spectralLightGroup;
		break;
	}
	return value;
}

long EVENT_GetSplineFrameNumber(struct InstanceSpline* instanceSpline)  // Matching - 100%
{
	return SCRIPT_GetSplineFrameNumber(instanceSpline->instance, SCRIPT_GetPosSplineDef(instanceSpline->instance, instanceSpline->spline, instanceSpline->isParent, instanceSpline->isClass));
}


long EVENT_GetSplineValue(struct InstanceSpline* instanceSpline)  // Matching - 100%
{
	long value;
	struct _Instance* instance;

	instance = instanceSpline->instance;

	value = 0;

	switch (instanceSpline->attribute)
	{
	case 14:
		if (instance->flags & 0x2000000)
		{
			value = 0;
		}
		else
		{
			value = 1;
		}

		break;
	case 13:
	case 41:
		if (instance->flags & 0x2000000)
		{
			value = 1;
		}
		else
		{
			value = 0;
		}

		break;
	case 15:
	case 40:
		value = EVENT_GetSplineFrameNumber(instanceSpline);

		break;
	case 22:
		value = SCRIPTCountFramesInSpline(instance);

		break;
	case 17:
		if (instance->flags & 0x01000000)
		{
			value = -1;
		}
		else
		{
			value = 1;
		}

		break;
	case 16:
		value = 0;

		if (instanceSpline->spline->positional != NULL)
		{
			struct MultiSpline* spline;

			spline = instanceSpline->spline;

			if (spline->positional->flags & 1)
			{
				value = 1;
			}

			if (spline->positional->flags & 2)
			{
				value = 2;
			}

			if (spline->positional->flags & 4)
			{
				value = 1;
			}
		}

		break;
	case -1:
		value = 1;

		break;
	}

	return value;
}


long EVENT_GetAnimateTextureValue(struct InstanceAnimateTexture* instanceAniTexture)  // Matching - 100%
{
	long value;
	long trueValue;
	struct _Instance* instance;

	trueValue = 1;

	instance = instanceAniTexture->instance;

	value = 0;

	switch (instanceAniTexture->attribute)
	{
	case 13:
	case 41:
		trueValue = trueValue != 1;
	case 14:
		value = trueValue;

		if (!(instance->flags & 0x80))
		{
			value ^= 1;
		}

		break;
	case 15:
	case 40:
	{
		struct AniTexInfo* ani_tex_info;

		if (instanceAniTexture->aniTextures != NULL)
		{
			ani_tex_info = &instanceAniTexture->aniTextures->aniTexInfo;
			value = (instance->currentTextureAnimFrame / ani_tex_info->speed) % ani_tex_info->numFrames;
		}
		else
		{
			value = 0;
		}

		break;
	}
	case -1:
	case 17:
		value = 1;

		break;
	}

	return value;
}


long EVENT_GetAnimateValue(struct InstanceAnimate* instanceAnimate)  // Matching - 100%
{
	long value;
	struct _Instance* instance;

	value = 0;

	instance = instanceAnimate->instance;

	switch (instanceAnimate->attribute)
	{
	case -1:
	case 14:
		value = 1;

		break;
	case 13:
	case 41:
		value = 0;

		break;
	case 15:
	case 40:
		value = INSTANCE_Query(instance, 18);

		break;
	case 30:
		value = INSTANCE_Query(instance, 17);

		break;
	}

	return value;
}

long EVENT_TransformObjectOnStack(struct _PCodeStack* stack, long item, short* codeStream) // Matching - 100%
{
	long retValue;

	retValue = 0;
	if (stack->topOfStack != 0) {
		retValue = EVENT_TransformOperand(&stack->stack[stack->topOfStack - 1], stack, item, codeStream);
	}
	return retValue;
}

// autogenerated function stub: 
// void /*$ra*/ EVENT_UpdatePuzzlePointers(struct EventPointers *events /*$a0*/, long offset /*$a1*/)
void EVENT_UpdatePuzzlePointers(struct EventPointers *events, long offset)
{ // line 6318, offset 0x80067070
	/* begin block 1 */
		// Start line: 6320
		// Start offset: 0x80067070
		// Variables:
			long d; // $t3
			long d2; // $t1
			struct Event *curEvent; // $a3
	/* end block 1 */
	// End offset: 0x80067244
	// End Line: 6359

	/* begin block 2 */
		// Start line: 13463
	/* end block 2 */
	// End Line: 13464

	/* begin block 3 */
		// Start line: 13464
	/* end block 3 */
	// End Line: 13465

	/* begin block 4 */
		// Start line: 13467
	/* end block 4 */
	// End Line: 13468
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ EVENT_SaveEventsFromLevel(long levelID /*$s5*/, struct Level *level /*$a1*/)
void EVENT_SaveEventsFromLevel(long levelID, struct Level *level)
{ // line 6363, offset 0x8006724c
	/* begin block 1 */
		// Start line: 6364
		// Start offset: 0x8006724C
		// Variables:
			struct EventPointers *eventPointers; // $s4
			struct Event *eventInstance; // $s0
			long i; // $s3
			long d; // $a1
			long saveEvent; // $s1

		/* begin block 1.1 */
			// Start line: 6377
			// Start offset: 0x8006728C
			// Variables:
				long useBigSave; // $s2

			/* begin block 1.1.1 */
				// Start line: 6403
				// Start offset: 0x800672F8
				// Variables:
					struct SavedEvent *savedEvent; // $v0
			/* end block 1.1.1 */
			// End offset: 0x80067340
			// End Line: 6413

			/* begin block 1.1.2 */
				// Start line: 6416
				// Start offset: 0x80067348
				// Variables:
					//struct SavedEventSmallVars *savedEvent; // $a2
			/* end block 1.1.2 */
			// End offset: 0x80067390
			// End Line: 6426
		/* end block 1.1 */
		// End offset: 0x80067390
		// End Line: 6428
	/* end block 1 */
	// End offset: 0x800673A4
	// End Line: 6430

	/* begin block 2 */
		// Start line: 13588
	/* end block 2 */
	// End Line: 13589
					UNIMPLEMENTED();
}

void EVENT_LoadEventsForLevel(long levelID, struct Level* level)  // Matching - 100%
{
	long d;
	struct EventPointers* eventPointers;
	struct Event* eventInstance;
	struct SavedBasic* savedEvent;
	long eventNumber;

	eventPointers = level->PuzzleInstances;

	if (eventPointers != NULL)
	{
		savedEvent = SAVE_GetSavedNextEvent(levelID, NULL);

		while (savedEvent != NULL)
		{
			if (eventPointers->numPuzzles != 0)
			{
				eventInstance = NULL;

				if (savedEvent->savedID == 2)
				{
					eventNumber = ((struct SavedEvent*)savedEvent)->eventNumber;
				}
				else
				{
					eventNumber = (unsigned char)((struct SavedEventSmallVars*)savedEvent)->eventNumber;
				}

				for (d = 0; d < eventPointers->numPuzzles; d++)
				{
					if (eventPointers->eventInstances[d]->eventNumber == eventNumber)
					{
						eventInstance = eventPointers->eventInstances[d];
						break;
					}
				}

				if (eventInstance != NULL)
				{
					if (savedEvent->savedID == 2)
					{
						for (d = 0; d < 5; d++)
						{
							eventInstance->eventVariables[d] = ((struct SavedEvent*)savedEvent)->eventVariables[d];
						}
					}
					else
					{
						for (d = 0; d < 5; d++)
						{
							eventInstance->eventVariables[d] = (unsigned char)((struct SavedEventSmallVars*)savedEvent)->eventVariables[d];
						}
					}
				}
			}

			savedEvent = SAVE_GetSavedNextEvent(levelID, savedEvent);
		}
	}
}


struct SavedBasic* EVENT_CreateSaveEvent(long levelID, long eventNumber)  // Matching - 100%
{
	struct SavedEventSmallVars* savedEvent;
	long d;
	char* temp; // not in SYMDUMP

	savedEvent = (struct SavedEventSmallVars*)SAVE_GetSavedBlock(9, 0);
	if (savedEvent != NULL)
	{
		savedEvent->savedID = 9;
		savedEvent->areaID = (short)levelID;
		savedEvent->eventNumber = (char)eventNumber;
		d = 4;
		temp = &savedEvent->eventNumber;
		for (; d >= 0; d--)
		{
			temp[5] = 0;
			temp--;
		}
	}
	return (struct SavedBasic*)savedEvent;
}


void EVENT_RemoveInstanceFromInstanceList(struct _Instance* instance)  // Matching - 100%
{
	int d;
	int i;
	int i2;
	struct EventPointers* puzzle;
	struct EventBasicObject** basicEventObject;

	for (d = 0; d < 16; d++)
	{
		if ((StreamTracker.StreamList[d].used == 2) && (puzzle = StreamTracker.StreamList[d].level->PuzzleInstances, puzzle != NULL))
		{
			for (i = 0; i < puzzle->numPuzzles; i++)
			{
				basicEventObject = puzzle->eventInstances[i]->instanceList;
				for (i2 = 0; i2 < puzzle->eventInstances[i]->numInstances; i2++)
				{
					if (basicEventObject[i2]->id == 1)
					{
						if (((struct EventInstanceObject*)basicEventObject[i2])->instance == instance)
						{
							((struct EventInstanceObject*)basicEventObject[i2])->instance = NULL;
							break;
						}
					}
				}
			}
		}
	}
}


void EVENT_UpdatePuzzleWithInstance(struct EventPointers* puzzle, struct _Instance* instance) // Matching - 100%
{
	int i;
	int i2;
	struct EventBasicObject** basicEventObject;

	for (i = 0; i < puzzle->numPuzzles; i++)
	{
		basicEventObject = puzzle->eventInstances[i]->instanceList;

		for (i2 = 0; i2 < puzzle->eventInstances[i]->numInstances; i2++)
		{
			if (basicEventObject[i2]->id == 1 && instance->introUniqueID == ((struct EventInstanceObject*)basicEventObject[i2])->introUniqueID)
			{
				((struct EventInstanceObject*)basicEventObject[i2])->instance = instance;
				break;
			}
		}
	}
}

void EVENT_AddInstanceToInstanceList(struct _Instance* instance)  // Matching - 100%
{
	int d;
	int curTree;
	struct EventPointers* puzzle;
	struct Level* level;
	struct BSPTree* bspTree;

	for(d = 0; d < 16; d++)
	{
		if (StreamTracker.StreamList[d].used == 2)
		{
			level = StreamTracker.StreamList[d].level;
			puzzle = level->PuzzleInstances;

			if (puzzle != NULL)
			{
				EVENT_UpdatePuzzleWithInstance(puzzle, instance);
			}

			if (level->terrain->numBSPTrees > 0)
			{
				for (curTree = 0; curTree < level->terrain->numBSPTrees; curTree++)
				{
					bspTree = &level->terrain->BSPTreeArray[curTree];

					if (bspTree->ID >= 0)
					{
						if (bspTree->splineID == instance->introUniqueID)
						{
							bspTree->instanceSpline = instance;
						}
					}
				}
			}
		}
	}
}



struct _VMObject* EVENT_FindVMObject(struct _StreamUnit* stream, char* vmoName)  // Matching - 100%
{
	int i;
	struct _VMObject* vmObject;
	struct Level* level;

	level = stream->level;
	vmObject = NULL;
	for (i = 0; i < level->numVMObjects; i++)
	{
		if (strcmpi(level->vmobjectList[i].name, vmoName) == 0)
		{
			vmObject = &level->vmobjectList[i];
			break;
		}
	}

	return vmObject;
}


// autogenerated function stub: 
// void /*$ra*/ EVENT_FixPuzzlesForStream(struct _StreamUnit *stream /*$s7*/)
void EVENT_FixPuzzlesForStream(struct _StreamUnit *stream)
{ // line 6646, offset 0x80067888
	/* begin block 1 */
		// Start line: 6647
		// Start offset: 0x80067888
		// Variables:
			struct EventPointers *puzzle; // $s5
			struct EventBasicObject **basicEventObject; // $s6
			struct _Instance *instance; // $a1
			struct _Instance *next; // $s0
			int i; // $s4
			int i2; // $s2
			int p; // $a2

		/* begin block 1.1 */
			// Start line: 6674
			// Start offset: 0x80067938
			// Variables:
				struct _StreamUnit *newStream; // $v0
		/* end block 1.1 */
		// End offset: 0x8006794C
		// End Line: 6682

		/* begin block 1.2 */
			// Start line: 6689
			// Start offset: 0x8006795C
			// Variables:
				struct EventEventObject *eventEventObject; // $s1
				//struct _StreamUnit *newStream; // $v0

			/* begin block 1.2.1 */
				// Start line: 6696
				// Start offset: 0x80067970
				// Variables:
					struct EventPointers *puzzleInstances; // $v1
			/* end block 1.2.1 */
			// End offset: 0x800679C8
			// End Line: 6713
		/* end block 1.2 */
		// End offset: 0x800679C8
		// End Line: 6714

		/* begin block 1.3 */
			// Start line: 6719
			// Start offset: 0x800679D8
			// Variables:
				struct EventTGroupObject *tgroupEventObject; // $s1
				//struct _StreamUnit *newStream; // $v0

			/* begin block 1.3.1 */
				// Start line: 6724
				// Start offset: 0x800679EC
				// Variables:
					struct _Terrain *terrain; // $v0
			/* end block 1.3.1 */
			// End offset: 0x80067A3C
			// End Line: 6746
		/* end block 1.3 */
		// End offset: 0x80067A3C
		// End Line: 6747

		/* begin block 1.4 */
			// Start line: 6752
			// Start offset: 0x80067A4C
			// Variables:
				//struct _StreamUnit *newStream; // $v0
		/* end block 1.4 */
		// End offset: 0x80067A60
		// End Line: 6760

		/* begin block 1.5 */
			// Start line: 6769
			// Start offset: 0x80067A7C
			// Variables:
				void *pointer; // $v1

			/* begin block 1.5.1 */
				// Start line: 6779
				// Start offset: 0x80067A98
				// Variables:
					struct _StreamUnit *stream2; // $v0
			/* end block 1.5.1 */
			// End offset: 0x80067AC0
			// End Line: 6787
		/* end block 1.5 */
		// End offset: 0x80067AC0
		// End Line: 6787

		/* begin block 1.6 */
			// Start line: 6797
			// Start offset: 0x80067AF0
			// Variables:
				//struct _StreamUnit *newStream; // $v0
		/* end block 1.6 */
		// End offset: 0x80067B10
		// End Line: 6808
	/* end block 1 */
	// End offset: 0x80067B40
	// End Line: 6817

	/* begin block 2 */
		// Start line: 14341
	/* end block 2 */
	// End Line: 14342
					UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ EVENT_AddStreamToInstanceList(struct _StreamUnit *stream /*$s1*/)
void EVENT_AddStreamToInstanceList(struct _StreamUnit *stream)
{ // line 6819, offset 0x80067b6c
	/* begin block 1 */
		// Start line: 6820
		// Start offset: 0x80067B6C
		// Variables:
			int d; // $s6
			int i; // $s4
			int i2; // $s2
			int p; // $a2
			struct EventPointers *puzzle; // $s5
			struct EventBasicObject **basicEventObject; // $s7
			struct EventEventObject *eventEventObject; // $a1
			struct EventTGroupObject *tgroupEventObject; // $t0

		/* begin block 1.1 */
			// Start line: 6857
			// Start offset: 0x80067C54
			// Variables:
				struct EventPointers *puzzleInstances; // $v1
		/* end block 1.1 */
		// End offset: 0x80067CAC
		// End Line: 6875

		/* begin block 1.2 */
			// Start line: 6882
			// Start offset: 0x80067CD0
			// Variables:
				struct _Terrain *terrain; // $v0
		/* end block 1.2 */
		// End offset: 0x80067D20
		// End Line: 6906

		/* begin block 1.3 */
			// Start line: 6912
			// Start offset: 0x80067D30
		/* end block 1.3 */
		// End offset: 0x80067D44
		// End Line: 6917

		/* begin block 1.4 */
			// Start line: 6926
			// Start offset: 0x80067D60
			// Variables:
				void *pointer; // $v1
		/* end block 1.4 */
		// End offset: 0x80067D90
		// End Line: 6940

		/* begin block 1.5 */
			// Start line: 6949
			// Start offset: 0x80067DC0
		/* end block 1.5 */
		// End offset: 0x80067DE0
		// End Line: 6958
	/* end block 1 */
	// End offset: 0x80067E20
	// End Line: 6970

	/* begin block 2 */
		// Start line: 14936
	/* end block 2 */
	// End Line: 14937
				UNIMPLEMENTED();
}


void EVENT_RemoveStreamToInstanceList(struct _StreamUnit* stream)  // Matching - 100%
{
	int d;
	int i;
	int i2;
	struct EventPointers* puzzle;
	struct EventBasicObject** basicEventObject;
	struct EventEventObject* eventEventObject;  // not from SYMDUMP
	struct EventTGroupObject* tgroupEventObject;  // not from SYMDUMP
	struct EventWildCardObject* wildcardEventObject;  // not from SYMDUMP
	struct EventInstanceObject* instanceEventObject;  // not from SYMDUMP

	for (d = 0; d < 16; d++)
	{
		if ((StreamTracker.StreamList[d].used != 2) || (&StreamTracker.StreamList[d] == stream))
		{
			continue;
		}

		puzzle = StreamTracker.StreamList[d].level->PuzzleInstances;

		if (puzzle == NULL)
		{
			continue;
		}

		for (i = 0; i < puzzle->numPuzzles; i++)
		{
			basicEventObject = puzzle->eventInstances[i]->instanceList;

			for (i2 = 0; i2 < puzzle->eventInstances[i]->numInstances; i2++)
			{
				if (basicEventObject[i2]->id == 5)
				{
					wildcardEventObject = (struct EventWildCardObject*)basicEventObject[i2];

					if (wildcardEventObject->unitID == stream->StreamUnitID)
					{
						wildcardEventObject->objectName = NULL;
					}
				}
				else if (basicEventObject[i2]->id == 3)
				{
					eventEventObject = (struct EventEventObject*)basicEventObject[i2];

					if (eventEventObject->unitID == stream->StreamUnitID)
					{
						eventEventObject->event = NULL;
					}
				}
				else if (basicEventObject[i2]->id == 4)
				{
					tgroupEventObject = (struct EventTGroupObject*)basicEventObject[i2];

					if (tgroupEventObject->unitID == stream->StreamUnitID)
					{
						tgroupEventObject->bspTree = NULL;
						tgroupEventObject->stream = NULL;
					}
				}
				else if (basicEventObject[i2]->id == 6)
				{
					wildcardEventObject = (struct EventWildCardObject*)basicEventObject[i2];

					if (wildcardEventObject->unitID == stream->StreamUnitID)
					{
						wildcardEventObject->objectName = NULL;
					}
				}
				else if (basicEventObject[i2]->id == 1)
				{
					instanceEventObject = (struct EventInstanceObject*)basicEventObject[i2];

					if (instanceEventObject->unitID == stream->StreamUnitID)
					{
						instanceEventObject->data.intro = NULL;
					}
				}
			}
		}
	}

	for (i = 0; i < 24; i++)
	{
		if ((eventTimerArray[i].flags & 0x1) && (eventTimerArray[i].level == stream->level))
		{
			EVENT_RemoveTimer(&eventTimerArray[i]);
		}
	}
}


// autogenerated function stub: 
// void /*$ra*/ EVENT_RelocateInstanceList(struct Level *oldLevel /*$a0*/, struct Level *newLevel /*$a1*/, long sizeOfLevel /*$a2*/)
void EVENT_RelocateInstanceList(struct Level *oldLevel, struct Level *newLevel, long sizeOfLevel)
{ // line 7076, offset 0x80068018
	/* begin block 1 */
		// Start line: 7078
		// Start offset: 0x80068018
		// Variables:
			int d; // $t6
			int i; // $t4
			int i2; // $a3
			struct EventPointers *puzzle; // $t5
			struct EventBasicObject **basicEventObject; // $v0
			long offset; // $t0

		/* begin block 1.1 */
			// Start line: 7098
			// Start offset: 0x800680A4
		/* end block 1.1 */
		// End offset: 0x800680A4
		// End Line: 7103

		/* begin block 1.2 */
			// Start line: 7110
			// Start offset: 0x800680AC
		/* end block 1.2 */
		// End offset: 0x800680AC
		// End Line: 7115

		/* begin block 1.3 */
			// Start line: 7122
			// Start offset: 0x800680B4
		/* end block 1.3 */
		// End offset: 0x800680DC
		// End Line: 7127

		/* begin block 1.4 */
			// Start line: 7134
			// Start offset: 0x800680EC
		/* end block 1.4 */
		// End offset: 0x80068114
		// End Line: 7140

		/* begin block 1.5 */
			// Start line: 7147
			// Start offset: 0x80068124
		/* end block 1.5 */
		// End offset: 0x80068150
		// End Line: 7155
	/* end block 1 */
	// End offset: 0x80068210
	// End Line: 7177

	/* begin block 2 */
		// Start line: 15754
	/* end block 2 */
	// End Line: 15755

	/* begin block 3 */
		// Start line: 15755
	/* end block 3 */
	// End Line: 15756

	/* begin block 4 */
		// Start line: 15760
	/* end block 4 */
	// End Line: 15761
			UNIMPLEMENTED();
}

void EVENT_PrintVars()
{
}


void EVENT_ExecuteActionCommand(struct StackType* operand1, struct StackType* operand2, struct _PCodeStack* stack, short* codeStream)  // Matching - 100%
{
	long error;
	long value;
	short flags;

	switch (operand1->id)
	{
	case 27:
		if (operand1->data.soundObject.flags == 1)
		{
			EVENT_DoSoundMarkerAction(&operand1->data.soundObject, operand2);
			break;
		}

		EVENT_DoObjectSoundAction(&operand1->data.soundObject, operand2);
		break;
	case 1:
		EVENT_DoAreaAction(&operand1->data.areaObject, operand2);
		break;
	case 4:
		EVENT_DoIntroAction(&operand1->data.introObject, operand2);
		break;
	case 10:
		value = EVENT_GetScalerValueFromOperand(operand2, &error, &flags);

		if (error == 0)
		{
			operand1->data.ShortPointer.pointer[0] = (int)value;
		}

		break;
	default:
		break;
	case 28:
		value = EVENT_GetScalerValueFromOperand(operand2, &error, &flags);

		if (error == 0)
		{
			operand1->data.CharPointer.pointer[0] = (int)value;
			break;
		}

		break;
	case 11:
		value = EVENT_GetScalerValueFromOperand(operand2, &error, &flags);

		if (error == 0)
		{
			operand1->data.LongPointer.pointer[0] = value;
		}

		break;
	case 15:
		EVENT_DoSplineAction(&operand1->data.instanceSpline, operand2);
		break;
	case 2:
		EVENT_DoInstanceAction(&operand1->data.instanceObject, operand2, codeStream);
		break;
	case 17:
		EVENT_DoSignalAction(&operand1->data.signalObject, operand2);
		break;
	case 19:
		EVENT_DoAnimateAction(&operand1->data.instanceAnimate, operand2);
		break;
	case 20:
		EVENT_DoInstanceAnimateTextureAction(&operand1->data.instanceAniTexture, operand2);
		break;
	case 23:
		EVENT_DoTGroupAction(&operand1->data.terrainGroup, operand2);
		break;
	case 25:
		EVENT_DoCameraAction(&operand1->data.cameraObject, operand2, codeStream);
		break;
	case 26:
		EVENT_DoVMObjectAction(&operand1->data.vmObject, operand2);
		break;
	case 3:
		EVENT_DoGameAction(&operand1->data.gameObject, operand2);
		break;
	case 22:
		EVENT_DoSubListAction(&operand1->data.subListObject, operand2, stack, codeStream);
		break;
	}
}


long EVENT_GetScalerValueFromOperand(struct StackType* operand, long* error, short* flags)  // Matching - 99.82%
{
	long value;

	error[0] = 0;
	flags[0] = 0;
	value = 32767;

	switch (operand->id)
	{
	case 2:
		value = EVENT_GetInstanceValue(&operand->data.instanceObject);
		break;
	case 21:
		value = 0;
		break;
	case 27:
		if (operand->data.soundObject.flags == 1)
		{
			value = 0;
		}
		else
		{
			value = EVENT_GetSoundValue(&operand->data.soundObject);
		}

		break;
	case 10:
		value = operand->data.ShortPointer.pointer[0];
		break;
	case 28:
		value = (unsigned char)operand->data.CharPointer.pointer[0];
		break;
	case 11:
		value = operand->data.LongPointer.pointer[0];
		break;
	case 15:
		value = EVENT_GetSplineValue(&operand->data.instanceSpline);
		break;
	case 7:
		value = operand->data.Number.currentNumber;
		flags[0] = operand->data.Number.flags;
		break;
	case 4:
		value = EVENT_GetIntroValue(&operand->data.introObject);
		break;
	case 19:
		value = EVENT_GetAnimateValue(&operand->data.instanceAnimate);
		break;
	case 20:
		value = EVENT_GetAnimateTextureValue(&operand->data.instanceAniTexture);
		break;
	case 23:
		value = EVENT_GetTGroupValue(&operand->data.terrainGroup);
		break;
	case 24:
		value = (operand->data.constrictInfo.instance->constrictAngle + 1U < 3) ^ 1;
		break;
	case 26:
		value = EVENT_GetVMObjectValue(&operand->data.vmObject);
		break;
	case 3:
		value = EVENT_GetGameValue(&operand->data.gameObject);
		break;
	case 1:
		value = operand->data.areaObject.unitID;
		break;
	}

	return value;
}

long EVENT_TransformOperand(struct StackType* stackObject, struct _PCodeStack* stack, long item, short* codeStream) // Matching - 100%
{
	long retValue;

	switch (stackObject->id)
	{
	case 2:
		retValue = EVENT_TransformInstanceAttribute(stack, stackObject, item, codeStream);
		break;
	case 24:
		retValue = EVENT_TransformConstrictAttribute(stack, stackObject, item);
		break;
	case 15:
		retValue = EVENT_TransformSplineAttribute(stack, stackObject, item, codeStream);
		break;
	case 4:
		retValue = EVENT_TransformIntroAttribute(stack, stackObject, item);
		break;
	case 9:
		retValue = EVENT_TransformVector3dAttribute(stack, stackObject, item, codeStream);
		break;
	case 14:
		retValue = EVENT_TransformRotation3dAttribute(stack, stackObject, item, codeStream);
		break;
	case 16:
		retValue = EVENT_TransformEventAttribute(stack, stackObject, item, codeStream);
		break;
	case 17:
		retValue = EVENT_TransformSignalAttribute(stack, stackObject, item);
		break;
	case 1:
		retValue = EVENT_TransformAreaAttribute(stack, stackObject, item, codeStream);
		break;
	case 6:
		EventAbortLine = 1;
		retValue = 1;
		break;
	case 3:
		retValue = EVENT_TransformGameAttribute(stack, stackObject, item, codeStream);
		break;
	case 18:
		retValue = EVENT_TransformListObjectAttribute(stack, stackObject, item);
		break;
	case 19:
		if (stackObject->data.subListObject.numberOfInstances == -1)
		{
			stackObject->data.subListObject.numberOfInstances = item;
			retValue = 1;
			break;
		}
		retValue = 0;
		break;
	case 27:
		retValue = EVENT_TransformSoundObjectAttribute(stack, &stackObject->data.soundObject, item, codeStream);
		break;
	case 20:
		if (stackObject->data.subListObject.numberOfAttributes == -1)
		{
			stackObject->data.subListObject.numberOfAttributes = item;
			retValue = 1;
			break;
		}
		retValue = 0;
		break;
	case 21:
		retValue = EVENT_TransformSavedEventAttribute(stack, stackObject, item, codeStream);
		break;
	case 22:
		retValue = EVENT_TransformSubListObjectAttribute(stack, stackObject, item);
		break;
	case 23:
		retValue = EVENT_TransformTGroupAttribute(stack, stackObject, item, codeStream);
		break;
	case 25:
		retValue = EVENT_TransformCameraObjectAttribute(stack, stackObject, item, codeStream);
		break;
	case 26:
		stackObject->data.subListObject.numberOfAttributes = item;
		retValue = 1;
		break;
	case 28:
	default:
		retValue = 0;
		break;
	}
	return retValue;
}