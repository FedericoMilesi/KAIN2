#include "CORE.H"
#include "COLLIDE.H"

#include "MEMPACK.H"
#include "Game/STREAM.H"
#include "Game/BSP.H"
#include "Game/CAMERA.H"

#ifdef PC_VERSION
#pragma warning(disable: 4101)
#endif

void G2Quat_ToMatrix(struct _G2EulerAngles_Type* a1, struct _G2Matrix_Type* a2)
{
#if defined(PC_VERSION)
	int x; // ecx
	int y; // ebp
	int z; // ebx
	int order; // esi
	int v6; // edx
	int v7; // eax
	int v8; // ebx
	int v9; // edi
	int v10; // esi
	int v11; // [esp+10h] [ebp-Ch]
	int v12; // [esp+14h] [ebp-8h]
	int v13; // [esp+18h] [ebp-4h]
	int a1a; // [esp+20h] [ebp+4h]

	x = a1->x;
	y = a1->y;
	z = a1->z;
	order = a1->order;
	v6 = x * order;
	v11 = (z * order) >> 11;
	v12 = (x * x) >> 11;
	v7 = x * z;
	v13 = (y * z) >> 11;
	v8 = (y * y) >> 11;
	a1a = (a1->z * a1->z) >> 11;
	v9 = (x * y) >> 11;
	a2->rotScale[0][0] = 4096 - v8 - a1a;
	v10 = (y * order) >> 11;
	v7 >>= 11;
	a2->rotScale[0][1] = v9 - v11;
	a2->rotScale[0][2] = v7 + v10;
	a2->rotScale[1][0] = v11 + v9;
	a2->rotScale[1][1] = 4096 - v12 - a1a;
	v6 >>= 11;
	a2->rotScale[2][0] = v7 - v10;
	a2->rotScale[2][1] = v6 + v13;
	a2->rotScale[1][2] = v13 - v6;
	a2->rotScale[2][2] = 4096 - v12 - v8;
#else
	UNIMPLEMENTED();
#endif
}

// autogenerated function stub: 
// int /*$ra*/ COLLIDE_PointInTriangle(struct _SVector *v0 /*$a0*/, struct _SVector *v1 /*$a1*/, struct _SVector *v2 /*$a2*/, struct _SVector *point /*$a3*/, struct _SVector *normal /*stack 16*/)
int COLLIDE_PointInTriangle(struct _SVector* v0, struct _SVector* v1, struct _SVector* v2, struct _SVector* point, struct _SVector* normal)
{ // line 243, offset 0x8001e460
#if defined(PC_VERSION)
	struct _Triangle2D* triangle; // eax
	int x; // edi
	__int16 y; // cx
	int v8; // edx
	int v9; // ecx
	__int16* p_x; // ecx
	__int16 v11; // si
	__int16 z; // dx
	__int16 v13; // bx
	int v14; // edi
	__int16 v15; // bp
	int v16; // edx
	__int16 v17; // bx
	int v18; // eax
	int v19; // ecx
	int v20; // eax
	int v21; // zf
	int v23; // [esp+10h] [ebp-8h]
	__int16 v0a; // [esp+1Ch] [ebp+4h]
	int v1a; // [esp+20h] [ebp+8h]
	struct _SVector* v2a; // [esp+24h] [ebp+Ch]
	int normala; // [esp+2Ch] [ebp+14h]

	triangle = (struct _Triangle2D*)getScratchAddr(0);
	x = normal->x;
	if (normal->x < 0)
		x = -x;
	y = normal->y;
	v8 = y;
	if (y < 0)
		v8 = -y;
	v9 = normal->z;
	if (x <= v8)
	{
		v9 = (__int16)v9;
		if ((v9 & 0x8000u) != 0)
			v9 = -(__int16)v9;
		if (v8 > v9)
		{
			*(DWORD*)&triangle->x0 = (unsigned __int16)v0->x | (v0->z << 16);
			p_x = &triangle->x2;
			*(DWORD*)&triangle->x1 = (unsigned __int16)v1->x | (v1->z << 16);
			*(DWORD*)&triangle->x2 = (unsigned __int16)v2->x | (v2->z << 16);
			v11 = point->x;
			z = point->z;
			goto LABEL_15;
		}
	LABEL_14:
		*(DWORD*)&triangle->x0 = (unsigned __int16)v0->x | (v0->y << 16);
		p_x = &triangle->x2;
		*(DWORD*)&triangle->x1 = (unsigned __int16)v1->x | (v1->y << 16);
		*(DWORD*)&triangle->x2 = (unsigned __int16)v2->x | (v2->y << 16);
		v11 = point->x;
		z = point->y;
		goto LABEL_15;
	}
	v9 = (__int16)v9;
	if ((v9 & 0x8000u) != 0)
		v9 = -(__int16)v9;
	if (x <= v9)
		goto LABEL_14;
	*(DWORD*)&triangle->x0 = (v0->z << 16) | (unsigned __int16)v0->y;
	p_x = &triangle->x2;
	*(DWORD*)&triangle->x1 = (v1->z << 16) | (unsigned __int16)v1->y;
	*(DWORD*)&triangle->x2 = (v2->z << 16) | (unsigned __int16)v2->y;
	v11 = point->y;
	z = point->z;
LABEL_15:
	v0a = z;
	v13 = z;
	v2a = (struct _SVector*)triangle;
	v1a = 0;
	normala = 0;
	v23 = 3;
	v14 = p_x[1] >= z;
	do
	{
		v15 = triangle->y0;
		v16 = v15 >= v13;
		if (v14 == v16)
		{
			if (v14 && v13 == p_x[1])
			{
				if (v13 == v15)
				{
					if (v11 > *p_x != v11 > triangle->x0 || v11 == *p_x || v11 == triangle->x0)
						return 1;
					v13 = v0a;
				}
				else if (v11 == *p_x)
				{
					return 1;
				}
			}
			goto LABEL_36;
		}
		v17 = triangle->x0;
		if (*p_x >= v11 == triangle->x0 >= (unsigned __int16)v11)
		{
			if (*p_x >= v11)
				v1a = v1a == 0;
		}
		else
		{
			v18 = p_x[1] - v15;
			v19 = v18 * (v17 - v11) - (*p_x - v17) * (v15 - v0a);
			if (v18 < 0)
			{
				v18 = -v18;
				v19 = -v19;
			}
			v20 = v18 / 2;
			if (v19 <= v20)
			{
				if (v19 >= -v20)
					return 1;
			}
			else
			{
				v1a = v1a == 0;
			}
			triangle = (struct _Triangle2D*)v2a;
		}
		if (normala)
			break;
		v13 = v0a;
		normala = 1;
	LABEL_36:
		v14 = v16;
		p_x = &triangle->x0;
		triangle = (struct _Triangle2D*)((char*)triangle + 4);
		v21 = v23 == 1;
		v2a = (struct _SVector*)triangle;
		--v23;
	} while (!v21);
	return v1a;
#else
UNIMPLEMENTED();
	return 0;
#endif
}

int COLLIDE_PointInTriangle2DPub(short* v0, short* v1, short* v2, short* point)
{
#if defined(PSX_VERSION)
	struct _SVector normal;

	normal.x = 0;
	normal.y = 0;
	normal.z = 4096;

	return COLLIDE_PointInTriangle((struct _SVector*)v0, (struct _SVector*)v1, (struct _SVector*)v2, (struct _SVector*)point, (struct _SVector*)&normal);

#elif defined(PC_VERSION)
	struct _SVector normal; // [esp+0h] [ebp-8h] BYREF

	normal.z = 4096;
	normal.x = 0;
	normal.y = 0;
	normal.pad = 0;
	return COLLIDE_PointInTriangle(
		(struct _SVector*)v0,
		(struct _SVector*)v1,
		(struct _SVector*)v2,
		(struct _SVector*)point,
		&normal);
#endif
}

long COLLIDE_GetNormal(short nNum, short* nrmlArray, struct _SVector* nrml)//Matching - 99.87%
{
#if defined(PSX_VERSION)
	short* sPtr;
	long bitMask;

	if (nNum >= 0)
	{
		sPtr = &nrmlArray[nNum * 3];

		bitMask = *sPtr++;

		nrml->x = bitMask & 0x1FFF;
		nrml->y = *sPtr++;
		nrml->z = *sPtr;

		bitMask >>= 13;
	}
	else
	{
		sPtr = &nrmlArray[-nNum * 3];
		bitMask = *sPtr++;

		nrml->x = -(bitMask & 0x1FFF);
		nrml->y = -(*sPtr++);
		nrml->z = -(*sPtr);

		bitMask >>= 13;
	}

	return bitMask;

#elif defined(PC_VERSION)
	__int16 v3; // dx
	int result; // eax
	__int16* v5; // ecx
	__int16 v6; // dx

	if (nNum < 0)
	{
		v5 = &nrmlArray[-3 * nNum];
		v6 = *v5++;
		nrml->x = -(v6 & 0x1FFF);
		nrml->y = -*v5;
		nrml->z = -v5[1];
		return v6 >> 13;
	}
	else
	{
		v3 = nrmlArray[3 * nNum];
		result = v3 >> 13;
		nrml->x = v3 & 0x1FFF;
		nrml->y = nrmlArray[3 * nNum + 1];
		nrml->z = nrmlArray[3 * nNum + 2];
	}
	return result;
#endif
}

void COLLIDE_MakeNormal(struct _Terrain* terrain, struct _TFace* tface, struct _SVector* normal)
{
#if defined(PSX_VERSION)
	UNIMPLEMENTED();
#elif defined(PC_VERSION)
	struct _Vector* ScratchAddr; // esi
	DWORD* v4; // edi
	int* v5; // ebx
	struct _TVertex* vertexList; // edx
	struct _TVertex* v7; // ecx
	struct _TVertex* v8; // edx
	int z; // eax
	int v10; // edx
	int v11; // eax
	int v12; // eax
	int v13; // ecx
	int v14; // sf
	int v15; // edi
	int v16; // esi
	int v17; // edx
	int v18; // edx
	struct _Terrain* terraina; // [esp+14h] [ebp+4h]

	ScratchAddr = (struct _Vector*)getScratchAddr(0);
	v4 = (DWORD*)getScratchAddr(4);
	v5 = (int*)getScratchAddr(8);
	vertexList = terrain->vertexList;
	v7 = &vertexList[tface->face.v0];
	terraina = (struct _Terrain*)&vertexList[tface->face.v1];
	v8 = &vertexList[tface->face.v2];
	ScratchAddr->x = terraina->UnitChangeFlags - v7->vertex.x;
	ScratchAddr->y = terraina->spad - v7->vertex.y;
	ScratchAddr->z = terraina->lpad2 - v7->vertex.z;
	*v4 = v8->vertex.x - v7->vertex.x;
	v4[1] = v8->vertex.y - v7->vertex.y;
	z = v8->vertex.z;
	v10 = v4[1];
	v11 = z - v7->vertex.z;
	v4[2] = v11;
	*v5 = (__int16)((ScratchAddr->y * v11 - ScratchAddr->z * v10) >> 12);
	v5[1] = -(__int16)((v4[2] * ScratchAddr->x - ScratchAddr->z * *v4) >> 12);
	v12 = *v5;
	v13 = (__int16)((v4[1] * ScratchAddr->x - ScratchAddr->y * *v4) >> 12);
	v14 = *v5 < 0;
	v5[2] = v13;
	v15 = v12;
	if (v14)
		v15 = -v12;
	v16 = v5[1];
	v17 = v16;
	if (v16 < 0)
		v17 = -v16;
	if (v15 <= v17)
	{
		if (v16 >= 0)
			goto LABEL_10;
	}
	else
	{
		v16 = v12;
		if (v12 >= 0)
			goto LABEL_10;
	}
	v16 = -v16;
LABEL_10:
	v18 = v13;
	if (v13 < 0)
		v18 = -v13;
	if (v18 > v16)
	{
		if (v13 < 0)
			v13 = -v13;
		v16 = v13;
	}
	if (v16)
	{
		normal->x = (v12 << 12) / v16;
		normal->y = (v5[1] << 12) / v16;
		normal->z = (v5[2] << 12) / v16;
	}
#endif
}


// autogenerated function stub: 
// void /*$ra*/ COLLIDE_UpdateAllTransforms(struct _Instance *instance /*$a0*/, SVECTOR*offset /*$a1*/)
void COLLIDE_UpdateAllTransforms(struct _Instance *instance, SVECTOR*offset)
{ // line 415, offset 0x8001e9c0
#if defined(PC_VERSION)
#ifndef PC_VERSION
	MATRIX* matrix; // ebx
	int vx; // edx
	int vy; // esi
	int vz; // edi
	struct Object* object; // eax
	struct _Model* v7; // ecx
	MATRIX* v8; // eax
	int numSegments; // ecx
	struct _Model* v10; // ecx
	__int32* v11; // eax
	__int32 v12; // ebp
	__int32 v13; // ebx

	matrix = instance->matrix;
	if (matrix)
	{
		vx = offset->vx;
		vy = offset->vy;
		vz = offset->vz;
		object = instance->object;
		if (!object->animList || (object->oflags2 & 0x40000000) != 0)
		{
			v10 = object->modelList[instance->currentModel];
			v8 = instance->matrix;
			numSegments = v10->numSegments;
		}
		else
		{
			v7 = object->modelList[instance->currentModel];
			v8 = matrix - 1;
			numSegments = v7->numSegments + 1;
		}
		if (numSegments)
		{
			v11 = &v8->t[1];
			do
			{
				v12 = vy + *v11;
				*(v11 - 1) += vx;
				v13 = vz + v11[1];
				*v11 = v12;
				v11[1] = v13;
				v11 += 8;
				--numSegments;
			} while (numSegments);
		}
	}
#endif
#else
	UNIMPLEMENTED();
#endif
}

void COLLIDE_MoveAllTransforms(struct _Instance* instance, struct _Position* offset)
{
#if defined(PSX_VERSION)
	UNIMPLEMENTED();
#elif defined(PC_VERSION)
#ifndef PC_VERSION
	MATRIX* oldMatrix; // ebx
	int x; // edx
	int y; // esi
	int z; // edi
	struct Object* object; // eax
	struct _Model* v7; // ecx
	MATRIX* v8; // eax
	int numSegments; // ecx
	struct _Model* v10; // ecx
	__int32* v11; // eax
	__int32 v12; // ebp
	__int32 v13; // ebx

	oldMatrix = instance->oldMatrix;
	if (oldMatrix)
	{
		x = offset->x;
		y = offset->y;
		z = offset->z;
		object = instance->object;
		if (!object->animList || (object->oflags2 & 0x40000000) != 0)
		{
			v10 = object->modelList[instance->currentModel];
			v8 = instance->oldMatrix;
			numSegments = v10->numSegments;
		}
		else
		{
			v7 = object->modelList[instance->currentModel];
			v8 = oldMatrix - 1;
			numSegments = v7->numSegments + 1;
		}
		if (numSegments)
		{
			v11 = &v8->t[1];
			do
			{
				v12 = y + *v11;
				*(v11 - 1) += x;
				v13 = z + v11[1];
				*v11 = v12;
				v11[1] = v13;
				v11 += 8;
				--numSegments;
			} while (numSegments);
		}
	}
#endif
#else
	UNIMPLEMENTED();
#endif
}


// autogenerated function stub: 
// long /*$ra*/ COLLIDE_WithinYZBounds(struct _SVector *point /*$a0*/, struct _HBox *hbox /*$a1*/)
long COLLIDE_WithinYZBounds(struct _SVector *point, struct _HBox *hbox)
{ // line 590, offset 0x8001eb60
	/* begin block 1 */
		// Start line: 1180
	/* end block 1 */
	// End Line: 1181

	/* begin block 2 */
		// Start line: 1070
	/* end block 2 */
	// End Line: 1071
	UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// long /*$ra*/ COLLIDE_WithinXZBounds(struct _SVector *point /*$a0*/, struct _HBox *hbox /*$a1*/)
long COLLIDE_WithinXZBounds(struct _SVector *point, struct _HBox *hbox)
{ // line 596, offset 0x8001ebbc
	/* begin block 1 */
		// Start line: 1081
	/* end block 1 */
	// End Line: 1082

	/* begin block 2 */
		// Start line: 1082
	/* end block 2 */
	// End Line: 1083
	UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// long /*$ra*/ COLLIDE_WithinXYBounds(struct _SVector *point /*$a0*/, struct _HBox *hbox /*$a1*/)
long COLLIDE_WithinXYBounds(struct _SVector *point, struct _HBox *hbox)
{ // line 602, offset 0x8001ec18
	/* begin block 1 */
		// Start line: 1093
	/* end block 1 */
	// End Line: 1094

	/* begin block 2 */
		// Start line: 1094
	/* end block 2 */
	// End Line: 1095
	UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// void /*$ra*/ COLLIDE_LineWithBoxFace(short startDist /*$a0*/, long lineDist /*$a1*/, short planeDist /*$a2*/, struct _SVector *start /*$a3*/, struct _Vector *line /*stack 16*/, struct _HBox *hbox /*stack 20*/, TDRFuncPtr_COLLIDE_LineWithBoxFace6collideBoundFunc collideBoundFunc /*stack 24*/, struct _SVector *normal /*stack 28*/)
void COLLIDE_LineWithBoxFace(short startDist, long lineDist, short planeDist, struct _SVector *start, struct _Vector *line, struct _HBox *hbox, TDRFuncPtr_COLLIDE_LineWithBoxFace6collideBoundFunc collideBoundFunc, struct _SVector *normal)
{ // line 611, offset 0x8001ec74
#if 0
	/* begin block 1 */
		// Start line: 612
		// Start offset: 0x8001EC74
		// Variables:
			struct _SVector point; // stack offset -24
			long t; // stack offset -16

		/* begin block 1.1 */
			// Start line: 612
			// Start offset: 0x8001ED38
			// Variables:
				struct _SVector *point; // $t1
				struct _SVector *normal; // $s0
				struct _SVector *point0; // $a2
				struct _SVector *normal0; // $a3
				struct _SVector *point1; // $a1
				struct _SVector *normal1; // $t0

			/* begin block 1.1.1 */
				// Start line: 612
				// Start offset: 0x8001ED38

				/* begin block 1.1.1.1 */
					// Start line: 612
					// Start offset: 0x8001ED5C
					// Variables:
						short _z1; // $a0
						short _y1; // $v1
						short _x1; // $v0
				/* end block 1.1.1.1 */
				// End offset: 0x8001ED5C
				// End Line: 612

				/* begin block 1.1.1.2 */
					// Start line: 612
					// Start offset: 0x8001ED5C
					// Variables:
						short _z1; // $a0
						short _y1; // $v1
						short _x1; // $v0
				/* end block 1.1.1.2 */
				// End offset: 0x8001ED5C
				// End Line: 612

				/* begin block 1.1.1.3 */
					// Start line: 612
					// Start offset: 0x8001ED5C
					// Variables:
						short _z1; // $a0
						short _y1; // $v1
						short _x1; // $v0
				/* end block 1.1.1.3 */
				// End offset: 0x8001ED5C
				// End Line: 612

				/* begin block 1.1.1.4 */
					// Start line: 612
					// Start offset: 0x8001ED5C
					// Variables:
						short _z1; // $a0
						short _y1; // $v1
						short _x1; // $v0
				/* end block 1.1.1.4 */
				// End offset: 0x8001ED5C
				// End Line: 612

				/* begin block 1.1.1.5 */
					// Start line: 612
					// Start offset: 0x8001EDDC
					// Variables:
						short _z1; // $a0
						short _y1; // $v1
						short _x1; // $v0
				/* end block 1.1.1.5 */
				// End offset: 0x8001EDDC
				// End Line: 612

				/* begin block 1.1.1.6 */
					// Start line: 612
					// Start offset: 0x8001EDDC
					// Variables:
						short _z1; // $a0
						short _y1; // $v1
						short _x1; // $v0
				/* end block 1.1.1.6 */
				// End offset: 0x8001EDDC
				// End Line: 612
			/* end block 1.1.1 */
			// End offset: 0x8001EE10
			// End Line: 612
		/* end block 1.1 */
		// End offset: 0x8001EE10
		// End Line: 612
	/* end block 1 */
	// End offset: 0x8001EE10
	// End Line: 643

	/* begin block 2 */
		// Start line: 1111
	/* end block 2 */
	// End Line: 1112
#else
UNIMPLEMENTED();
#endif
}


// autogenerated function stub: 
// long /*$ra*/ COLLIDE_IntersectLineAndBox(struct _SVector *point0 /*$a0*/, struct _SVector *normal0 /*$a1*/, struct _SVector *point1 /*$a2*/, struct _SVector *normal1 /*$a3*/, struct _SVector *end /*stack 16*/, struct _SVector *start /*stack 20*/, struct _HBox *hbox /*stack 24*/)
long COLLIDE_IntersectLineAndBox(struct _SVector *point0, struct _SVector *normal0, struct _SVector *point1, struct _SVector *normal1, struct _SVector *end, struct _SVector *start, struct _HBox *hbox)
{ // line 650, offset 0x8001ee20
#if 0
	/* begin block 1 */
		// Start line: 651
		// Start offset: 0x8001EE20
		// Variables:
			struct _SVector normal; // stack offset -64
			struct _Vector line; // stack offset -56

		/* begin block 1.1 */
			// Start line: 651
			// Start offset: 0x8001EE20
			// Variables:
				long _x0; // $a1
				long _y0; // $a2
				long _z0; // $a0
				long _x1; // $v0
				long _y1; // $v0
				long _z1; // $v1
				struct _Vector *_v; // $s3
		/* end block 1.1 */
		// End offset: 0x8001EE20
		// End Line: 651
	/* end block 1 */
	// End offset: 0x8001F070
	// End Line: 711

	/* begin block 2 */
		// Start line: 1201
	/* end block 2 */
	// End Line: 1202
#else
	UNIMPLEMENTED();
#endif
	return 0;
}

struct _TFace* COLLIDE_PointAndTerrain(struct _Terrain* terrain, struct _PCollideInfo* pcollideInfo, struct _LCollideInfo* lcol)
{
	return COLLIDE_PointAndTerrainFunc(terrain, pcollideInfo, 0, NULL, 0, 0, lcol);
}


// autogenerated function stub: 
// struct _TFace * /*$ra*/ COLLIDE_PointAndTerrainFunc(struct _Terrain *terrain /*$t2*/, struct _PCollideInfo *pCollideInfo /*stack 4*/, int Flags /*$a2*/, short *Backface_Flag /*$a3*/, long ignoreAttr /*stack 16*/, long acceptAttr /*stack 20*/, struct _LCollideInfo *lcolinfo /*stack 24*/)
struct _TFace * COLLIDE_PointAndTerrainFunc(struct _Terrain *terrain, struct _PCollideInfo *pCollideInfo, int Flags, short *Backface_Flag, long ignoreAttr, long acceptAttr, struct _LCollideInfo *lcolinfo)
{ // line 780, offset 0x8001f0cc
#if 0
	/* begin block 1 */
		// Start line: 781
		// Start offset: 0x8001F0CC
		// Variables:
			struct PandTScratch *CSpad; // $s0
			void **stack; // $s1
			struct _BSPNode *bspNode; // $a1
			int curTree; // stack offset -48
			struct _SVector *NewPos; // stack offset -80
			struct _SVector *OldPos; // $a0
			struct _Instance *instance; // $s7

		/* begin block 1.1 */
			// Start line: 781
			// Start offset: 0x8001F0CC
			// Variables:
				short _x1; // $a3
				short _y1; // $t0
				short _z1; // $t1
				struct _SVector *_v0; // $v1
		/* end block 1.1 */
		// End offset: 0x8001F0CC
		// End Line: 781

		/* begin block 1.2 */
			// Start line: 781
			// Start offset: 0x8001F0CC
			// Variables:
				short _x1; // $v0
				short _y1; // $v1
				short _z1; // $a0
				struct _SVector *_v0; // $a2
		/* end block 1.2 */
		// End offset: 0x8001F0CC
		// End Line: 781

		/* begin block 1.3 */
			// Start line: 781
			// Start offset: 0x8001F0CC
			// Variables:
				struct _SVector *_v; // $a1
		/* end block 1.3 */
		// End offset: 0x8001F0CC
		// End Line: 781

		/* begin block 1.4 */
			// Start line: 837
			// Start offset: 0x8001F22C
			// Variables:
				struct BSPTree *bsp; // $s4

			/* begin block 1.4.1 */
				// Start line: 865
				// Start offset: 0x8001F328
				// Variables:
					short _x0; // $v0
					short _y0; // $v1
					short _z0; // $a0
					short _x1; // $a1
					short _y1; // $a2
					short _z1; // $t0
					struct _SVector *_v; // $s6
					_Position *_v1; // $a3
			/* end block 1.4.1 */
			// End offset: 0x8001F328
			// End Line: 865

			/* begin block 1.4.2 */
				// Start line: 865
				// Start offset: 0x8001F328
				// Variables:
					short _x0; // $v0
					short _y0; // $v1
					short _z0; // $a0
					short _x1; // $a1
					short _y1; // $a2
					short _z1; // $a3
					struct _SVector *_v; // $s5
			/* end block 1.4.2 */
			// End offset: 0x8001F328
			// End Line: 865

			/* begin block 1.4.3 */
				// Start line: 898
				// Start offset: 0x8001F558
				// Variables:
					struct _TFace *tface; // $s3

				/* begin block 1.4.3.1 */
					// Start line: 905
					// Start offset: 0x8001F5A4
					// Variables:
						struct _SVector *vertex0; // $a0

					/* begin block 1.4.3.1.1 */
						// Start line: 781
						// Start offset: 0x8001F62C
						// Variables:
							short *nrmlArray; // $a0
							struct _SVector *nrml; // $a1

						/* begin block 1.4.3.1.1.1 */
							// Start line: 781
							// Start offset: 0x8001F62C
							// Variables:
								short *sPtr; // $v1
						/* end block 1.4.3.1.1.1 */
						// End offset: 0x8001F6BC
						// End Line: 781
					/* end block 1.4.3.1.1 */
					// End offset: 0x8001F6BC
					// End Line: 781

					/* begin block 1.4.3.1.2 */
						// Start line: 781
						// Start offset: 0x8001F768
						// Variables:
							struct _SVector *point; // $t0
							struct _SVector *start; // $a3
							struct _SVector *line; // $a2

						/* begin block 1.4.3.1.2.1 */
							// Start line: 781
							// Start offset: 0x8001F768
							// Variables:
								long len; // $v1
								long t; // $a1
						/* end block 1.4.3.1.2.1 */
						// End offset: 0x8001F7A0
						// End Line: 781
					/* end block 1.4.3.1.2 */
					// End offset: 0x8001F7A0
					// End Line: 781

					/* begin block 1.4.3.1.3 */
						// Start line: 950
						// Start offset: 0x8001F8CC
						// Variables:
							short _x0; // $v0
							short _y0; // $v1
							short _z0; // $a1
							short _x1; // $a0
							short _y1; // $a3
							short _z1; // $a2
							_Position *_v1; // $a2
					/* end block 1.4.3.1.3 */
					// End offset: 0x8001F8CC
					// End Line: 950

					/* begin block 1.4.3.1.4 */
						// Start line: 1015
						// Start offset: 0x8001F970
						// Variables:
							short _x0; // $v0
							short _y0; // $v1
							short _z0; // $a1
							short _x1; // $a0
							short _y1; // $a2
							short _z1; // $a3
							struct _SVector *_v; // $fp
					/* end block 1.4.3.1.4 */
					// End offset: 0x8001F970
					// End Line: 1015
				/* end block 1.4.3.1 */
				// End offset: 0x8001F9F4
				// End Line: 1036
			/* end block 1.4.3 */
			// End offset: 0x8001FA34
			// End Line: 1049

			/* begin block 1.4.4 */
				// Start line: 1053
				// Start offset: 0x8001FA34
				// Variables:
					int plane_front_error; // $v1
					int plane_back_error; // $a0
			/* end block 1.4.4 */
			// End offset: 0x8001FB84
			// End Line: 1120

			/* begin block 1.4.5 */
				// Start line: 1124
				// Start offset: 0x8001FB94
				// Variables:
					short _x0; // $v0
					short _y0; // $v1
					short _z0; // $a0
					short _x1; // $a1
					short _y1; // $a2
					short _z1; // $t0
					_Position *_v1; // $a3
			/* end block 1.4.5 */
			// End offset: 0x8001FB94
			// End Line: 1124

			/* begin block 1.4.6 */
				// Start line: 1124
				// Start offset: 0x8001FB94
				// Variables:
					short _x0; // $v0
					short _y0; // $v1
					short _z0; // $a0
					short _x1; // $a1
					short _y1; // $a2
					short _z1; // $a3
			/* end block 1.4.6 */
			// End offset: 0x8001FBF8
			// End Line: 1125
		/* end block 1.4 */
		// End offset: 0x8001FBF8
		// End Line: 1126

		/* begin block 1.5 */
			// Start line: 1127
			// Start offset: 0x8001FC10
			// Variables:
				short _x1; // $v1
				short _y1; // $a0
				short _z1; // $v0
				struct _SVector *_v1; // $v0
		/* end block 1.5 */
		// End offset: 0x8001FC10
		// End Line: 1127
	/* end block 1 */
	// End offset: 0x8001FC10
	// End Line: 1127

	/* begin block 2 */
		// Start line: 1540
	/* end block 2 */
	// End Line: 1541
#endif
	UNIMPLEMENTED();
	return null;
}


// autogenerated function stub: 
// int /*$ra*/ COLLIDE_PointAndHFace(struct _SVector *newPos /*$s4*/, struct _SVector *oldPos /*$s6*/, struct _HFace *hface /*$s5*/, struct _Model *model /*$s7*/, struct _SVector *hfNormal /*stack 16*/)
int COLLIDE_PointAndHFace(struct _SVector *newPos, struct _SVector *oldPos, struct _HFace *hface, struct _Model *model, struct _SVector *hfNormal)
{ // line 1330, offset 0x8001fc64
#if 0
	/* begin block 1 */
		// Start line: 1331
		// Start offset: 0x8001FC64
		// Variables:
			MATRIX *posMatrix; // $s1
			struct _SVector *normal; // $s3
			struct _Vector *dpv; // $s2
			struct _SVector *planePoint; // stack offset -48
			struct _SVector *vertex0; // $s0
			struct _SVector *vertex1; // $s1

		/* begin block 1.1 */
			// Start line: 1341
			// Start offset: 0x8001FCD0
			// Variables:
				short _x0; // $v0
				short _y0; // $v1
				short _z0; // $a1
				short _x1; // $a2
				short _y1; // $a3
				short _z1; // $t0
		/* end block 1.1 */
		// End offset: 0x8001FCD0
		// End Line: 1341

		/* begin block 1.2 */
			// Start line: 1341
			// Start offset: 0x8001FCD0
			// Variables:
				short _x0; // $v0
				short _y0; // $v1
				short _z0; // $a1
				short _x1; // $a2
				short _y1; // $a3
				short _z1; // $t0
				struct _SVector *_v; // $t1
		/* end block 1.2 */
		// End offset: 0x8001FCD0
		// End Line: 1341

		/* begin block 1.3 */
			// Start line: 1341
			// Start offset: 0x8001FCD0
			// Variables:
				short _x1; // $v0
				short _y1; // $v1
				short _z1; // $a1
				struct _SVector *_v0; // $t3
		/* end block 1.3 */
		// End offset: 0x8001FCD0
		// End Line: 1341
	/* end block 1 */
	// End offset: 0x8001FE7C
	// End Line: 1378

	/* begin block 2 */
		// Start line: 3219
	/* end block 2 */
	// End Line: 3220
#endif
				UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// void /*$ra*/ COLLIDE_PointAndInstance(struct _PCollideInfo *pcollideInfo /*$s4*/, struct _Instance *instance /*stack 4*/)
void COLLIDE_PointAndInstance(struct _PCollideInfo *pcollideInfo, struct _Instance *instance)
{ // line 1389, offset 0x8001feac
#if 0
	/* begin block 1 */
		// Start line: 1390
		// Start offset: 0x8001FEAC
		// Variables:
			MATRIX *swTransform; // stack offset -92
			MATRIX *wsTransform; // stack offset -88
			MATRIX *swNormMat; // $fp
			struct _Vector *oldPosVec; // stack offset -84
			struct _Vector *lNormal; // stack offset -80
			struct _Vector *wNormal; // stack offset -76
			struct _Vector *dv; // $s2
			struct _Vector *newPosVec; // $s5
			struct _SVector *oldPos; // stack offset -72
			struct _SVector *newPos; // $s3
			struct _SVector *point; // stack offset -68
			long *flag; // stack offset -64
			struct _Model *model; // stack offset -60
			struct _HModel *hmodel; // $v0
			struct _HPrim *hprim; // stack offset -56
			int i; // stack offset -52
			long collideType; // stack offset -48

		/* begin block 1.1 */
			// Start line: 1416
			// Start offset: 0x8001FFCC
			// Variables:
				struct _HBox *hbox; // $s0
				struct _HFace *hface; // $s1
				struct _HSphere *hsphere; // $s0

			/* begin block 1.1.1 */
				// Start line: 1419
				// Start offset: 0x8001FFCC
				// TypeDefs:
					struct COLLIDE_258fake tmm
			/* end block 1.1.1 */
			// End offset: 0x8001FFCC
			// End Line: 1419

			/* begin block 1.1.2 */
				// Start line: 1452
				// Start offset: 0x80020184
				// Variables:
					long len; // $t0

				/* begin block 1.1.2.1 */
					// Start line: 1453
					// Start offset: 0x80020184
					// Variables:
						long a; // stack offset -104
						long b; // stack offset -100
						long c; // stack offset -96
				/* end block 1.1.2.1 */
				// End offset: 0x80020184
				// End Line: 1453
			/* end block 1.1.2 */
			// End offset: 0x80020248
			// End Line: 1459

			/* begin block 1.1.3 */
				// Start line: 1488
				// Start offset: 0x800203F0
				// Variables:
					struct _SVector hfNormal; // stack offset -136
			/* end block 1.1.3 */
			// End offset: 0x80020418
			// End Line: 1494

			/* begin block 1.1.4 */
				// Start line: 1509
				// Start offset: 0x80020450
				// Variables:
					struct _SVector hbNormal; // stack offset -136
					struct _SVector point0; // stack offset -128
					struct _SVector point1; // stack offset -120
					struct _SVector normal1; // stack offset -112

				/* begin block 1.1.4.1 */
					// Start line: 1551
					// Start offset: 0x80020590
					// Variables:
						short _x1; // $v0
						short _y1; // $v1
						short _z1; // $a3
				/* end block 1.1.4.1 */
				// End offset: 0x80020590
				// End Line: 1551
			/* end block 1.1.4 */
			// End offset: 0x800205D8
			// End Line: 1561
		/* end block 1.1 */
		// End offset: 0x80020690
		// End Line: 1580
	/* end block 1 */
	// End offset: 0x800206B0
	// End Line: 1582

	/* begin block 2 */
		// Start line: 3368
	/* end block 2 */
	// End Line: 3369
#endif
						UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ COLLIDE_PointAndInstanceTrivialReject(struct _PCollideInfo *pcollideInfo /*$s3*/, struct _Instance *instance /*$s1*/)
void COLLIDE_PointAndInstanceTrivialReject(struct _PCollideInfo *pcollideInfo, struct _Instance *instance)
{ // line 1584, offset 0x800206e0
	/* begin block 1 */
		// Start line: 1585
		// Start offset: 0x800206E0
		// Variables:
			struct _Vector *dv; // $s2
			struct _SVector linePoint; // stack offset -32

		/* begin block 1.1 */
			// Start line: 1596
			// Start offset: 0x80020768
			// Variables:
				long _x0; // $a2
				long _y0; // $v1
				long _z0; // $v0
				long _x1; // $v0
				long _y1; // $v0
				long _z1; // $a0
				struct _SVector *_v0; // $a0
		/* end block 1.1 */
		// End offset: 0x80020768
		// End Line: 1596
	/* end block 1 */
	// End offset: 0x80020848
	// End Line: 1633

	/* begin block 2 */
		// Start line: 4060
	/* end block 2 */
	// End Line: 4061
				UNIMPLEMENTED();
}

void COLLIDE_PointAndWorld(struct _PCollideInfo* pcollideInfo, struct Level* level)
{ 
	struct _Instance* instance; // $s0
	struct _InstanceList* instanceList; // $s3
	struct _LCollideInfo lcol; // stack offset -56
	int i; // $s1
	int in_warpRoom; // $s7
	struct _TFace* tface; // $s3
	struct _Terrain* terrain; // $s4
	struct Level* thislevel; // $s0

#if !defined(_DEBUG) || 1
	return;
#endif

	//s5 = pcollideInfo
	//s6 = level

	//v0 = pcollideInfo->collideType
	in_warpRoom = 0;
	
	pcollideInfo->type = 0;

	if ((pcollideInfo->collideType & 0x1))
	{
		//s3 = in_warpRoom

		//a1 = pcollideInfo
		if (level != NULL && MEMPACK_MemoryValidFunc((char*)level))
		{
			terrain = level->terrain;

			tface = COLLIDE_PointAndTerrain(terrain, pcollideInfo, &lcol);

			//v0 = 3
			if (tface != NULL)
			{
				pcollideInfo->type = 3;
				pcollideInfo->prim = tface;
				pcollideInfo->inst = (struct _Instance*)level;
				pcollideInfo->segment = lcol.curTree;

				//v1 = gameTrackerX.gameData.asmData.MorphTime

				if (gameTrackerX.gameData.asmData.MorphTime != 1000)
				{
					COLLIDE_MakeNormal(terrain, tface, (struct _SVector*)&pcollideInfo->wNormal);
				//j       loc_80020D20
				}
				else
				{
					//loc_80020CD0
					COLLIDE_GetNormal(tface->normal, (short*)terrain->normalList, (struct _SVector*)&pcollideInfo->wNormal);
				//j       loc_80020D20
				}
			}
			else
			{
				//loc_80020CFC
				if((STREAM_GetStreamUnitWithID(level->streamUnitID)->flags & 0x1))
				{
					in_warpRoom = 1;
				}
				//loc_80020D20
			}
		}
		//loc_80020D20
		// i = 0;
		
		if (tface == NULL)
		{
			//s2 = &StreamTracker.StreamList[0].flags

			//loc_80020D2C
			//v1 = 2
			//v0 = StreamTracker.StreamList[0].used
			//s0 = 
			thislevel = StreamTracker.StreamList[i].level;

			if (StreamTracker.StreamList[i].used == 2 && thislevel != level)
			{
				if (in_warpRoom == 0 || !(StreamTracker.StreamList[i].flags & 0x1))
				{
					//loc_80020D64
					if (MEMPACK_MemoryValidFunc((char*)thislevel) != 0)
					{
						tface = COLLIDE_PointAndTerrain(thislevel->terrain, pcollideInfo, &lcol);
					
						if (tface != NULL)
						{
							pcollideInfo->type = 3;
							pcollideInfo->prim = tface;
							pcollideInfo->inst = (struct _Instance*)thislevel;
							pcollideInfo->segment = lcol.curTree;
						}
						//loc_80020DD0
					}
				}
			}
			//loc_80020DD0
		}
		//loc_80020E00
	}
	//loc_80020E00
#if 0
	
		loc_80020CE8 :
		move    $a1, $s3
		jal     sub_8001EBA0
		addiu   $a2, $s5, 0xC
		j       loc_80020DE0
		nop
#endif

#if 0

		lh      $v1, -0x4230($gp)
		li      $v0, 0x3E8
		bne     $v1, $v0, loc_80020CE8
		move    $a0, $s4
		lh      $a0, 8($s3)
		lw      $a1, 0x24($s4)
		jal     sub_8001EB08
		addiu   $a2, $s5, 0xC
		j       loc_80020DE0
		nop

		loc_80020DD0 :
	addiu   $s1, 1
		slti    $v0, $s1, 0x10
		bnez    $v0, loc_80020D2C
		addiu   $s2, 0x40  # '@'

		loc_80020DE0 :
		bnez    $s3, loc_80020E00
		nop
		sh      $zero, 0($s5)
		sw      $zero, 4($s5)
		sw      $zero, 8($s5)
		sh      $zero, 0xC($s5)
		sh      $zero, 0xE($s5)
		sh      $zero, 0x10($s5)

		loc_80020E00:
	lw      $v1, 0x24($s5)
		lw      $s3, -0x4204($gp)//gameTrackerX.instanceList//gameTrackerX.instanceList
		andi    $v0, $v1, 8
		beqz    $v0, loc_80020E70
		li      $s1, 0x10
		lui     $s4, 0x2400
		addiu   $s2, $s3, 0x80

		loc_80020E1C:
	lw      $s0, 0x10($s2)
		nop
		beqz    $s0, loc_80020E58
		nop

		loc_80020E2C :
	lw      $v0, 0x18($s0)
		nop
		and $v0, $s4
		bnez    $v0, loc_80020E48
		move    $a0, $s5
		jal     sub_80020A98
		move    $a1, $s0

		loc_80020E48 :
	lw      $s0, 4($s0)
		nop
		bnez    $s0, loc_80020E2C
		nop

		loc_80020E58 :
	addiu   $s1, 1
		slti    $v0, $s1, 0x20  # ' '
		bnez    $v0, loc_80020E1C
		addiu   $s2, 8
		j       loc_80020FD8
		nop

		loc_80020E70 :
	andi    $v0, $v1, 0x10
		beqz    $v0, loc_80020F68
		andi    $v0, $v1, 2
		beqz    $v0, loc_80020EE8
		move    $s1, $zero
		lui     $s4, 0x2400
		addiu   $s2, $gp, -0x700C

		loc_80020E8C:
	lw      $v0, 0($s2)
		nop
		sll     $v0, 3
		addu    $v0, $s3
		lw      $s0, 0x10($v0)
		nop
		beqz    $s0, loc_80020ED8
		nop

		loc_80020EAC :
	lw      $v0, 0x18($s0)
		nop
		and $v0, $s4
		bnez    $v0, loc_80020EC8
		move    $a0, $s5
		jal     sub_80020A98
		move    $a1, $s0

		loc_80020EC8 :
	lw      $s0, 4($s0)
		nop
		bnez    $s0, loc_80020EAC
		nop

		loc_80020ED8 :
	addiu   $s1, 1
		slti    $v0, $s1, 8
		bnez    $v0, loc_80020E8C
		addiu   $s2, 4

		loc_80020EE8 :
		lw      $v0, 0x24($s5)
		nop
		andi    $v0, 4
		beqz    $v0, loc_80020FD8
		move    $s1, $zero
		lui     $s4, 0x2400
		addiu   $s2, $gp, -0x702C

		loc_80020F04:
	lw      $v0, 0($s2)
		nop
		sll     $v0, 3
		addu    $v0, $s3
		lw      $s0, 0x10($v0)
		nop
		beqz    $s0, loc_80020F50
		nop

		loc_80020F24 :
	lw      $v0, 0x18($s0)
		nop
		and $v0, $s4
		bnez    $v0, loc_80020F40
		move    $a0, $s5
		jal     sub_80020A98
		move    $a1, $s0

		loc_80020F40 :
	lw      $s0, 4($s0)
		nop
		bnez    $s0, loc_80020F24
		nop

		loc_80020F50 :
	addiu   $s1, 1
		slti    $v0, $s1, 8
		bnez    $v0, loc_80020F04
		addiu   $s2, 4
		j       loc_80020FD8
		nop

		loc_80020F68 :
	andi    $v0, $v1, 4
		beqz    $v0, loc_80020FD8
		move    $s1, $zero
		lui     $s4, 0x2400
		addiu   $s2, $gp, -0x6FEC

		loc_80020F7C :
		lw      $v0, 0($s2)
		nop
		sll     $v0, 3
		addu    $v0, $s3
		lw      $s0, 0x10($v0)
		nop
		beqz    $s0, loc_80020FC8
		nop

		loc_80020F9C :
	lw      $v0, 0x18($s0)
		nop
		and $v0, $s4
		bnez    $v0, loc_80020FB8
		move    $a0, $s5
		jal     sub_80020A98
		move    $a1, $s0

		loc_80020FB8 :
	lw      $s0, 4($s0)
		nop
		bnez    $s0, loc_80020F9C
		nop

		loc_80020FC8 :
	addiu   $s1, 1
		slti    $v0, $s1, 8
		bnez    $v0, loc_80020F7C
		addiu   $s2, 4

		loc_80020FD8 :
		lw      $ra, 0x20 + var_s20($sp)
		lw      $s7, 0x20 + var_s1C($sp)
		lw      $s6, 0x20 + var_s18($sp)
		lw      $s5, 0x20 + var_s14($sp)
		lw      $s4, 0x20 + var_s10($sp)
		lw      $s3, 0x20 + var_sC($sp)
		lw      $s2, 0x20 + var_s8($sp)
		lw      $s1, 0x20 + var_s4($sp)
		lw      $s0, 0x20 + var_s0($sp)
		jr      $ra
		addiu   $sp, 0x48
#endif

}


// autogenerated function stub: 
// long /*$ra*/ COLLIDE_ClosestPointInBoxToPoint(_Position *boxPoint /*$a0*/, struct _HBox *hbox /*$a1*/, struct _SVector *point /*$a2*/)
long COLLIDE_ClosestPointInBoxToPoint(_Position *boxPoint, struct _HBox *hbox, struct _SVector *point)
{ // line 1893, offset 0x80020c4c
	/* begin block 1 */
		// Start line: 1895
		// Start offset: 0x80020C4C
		// Variables:
			long inside; // $a3
	/* end block 1 */
	// End offset: 0x80020D18
	// End Line: 1941

	/* begin block 2 */
		// Start line: 4803
	/* end block 2 */
	// End Line: 4804

	/* begin block 3 */
		// Start line: 4804
	/* end block 3 */
	// End Line: 4805

	/* begin block 4 */
		// Start line: 4806
	/* end block 4 */
	// End Line: 4807
			UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// long /*$ra*/ COLLIDE_SphereAndPoint(struct _Sphere *sphere /*$s1*/, struct _SVector *point /*$s2*/, struct _SVector *normal /*$s3*/)
long COLLIDE_SphereAndPoint(struct _Sphere *sphere, struct _SVector *point, struct _SVector *normal)
{ // line 1944, offset 0x80020d20
	/* begin block 1 */
		// Start line: 1945
		// Start offset: 0x80020D20
		// Variables:
			long len; // $a2
			struct _Vector *line; // $s0

		/* begin block 1.1 */
			// Start line: 1945
			// Start offset: 0x80020D20
			// Variables:
				long _x0; // $a2
				long _y0; // $a1
				long _z0; // $a0
				long _x1; // $v0
				long _y1; // $v0
				long _z1; // $v0
		/* end block 1.1 */
		// End offset: 0x80020D20
		// End Line: 1945

		/* begin block 1.2 */
			// Start line: 1953
			// Start offset: 0x80020DB4
			// Variables:
				long a; // stack offset -40
				long b; // stack offset -36
				long c; // stack offset -32
		/* end block 1.2 */
		// End offset: 0x80020DB4
		// End Line: 1953
	/* end block 1 */
	// End offset: 0x80020F48
	// End Line: 1970

	/* begin block 2 */
		// Start line: 4905
	/* end block 2 */
	// End Line: 4906
				UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// long /*$ra*/ COLLIDE_SphereAndHBox(struct _HBox *hbox /*$s4*/, struct _Sphere *sphere /*$s1*/, _Position *oldPos /*$s5*/, struct _SVector *normal /*$s3*/)
long COLLIDE_SphereAndHBox(struct _HBox *hbox, struct _Sphere *sphere, _Position *oldPos, struct _SVector *normal)
{ // line 1975, offset 0x80020f64
#if 0
	/* begin block 1 */
		// Start line: 1976
		// Start offset: 0x80020F64
		// Variables:
			struct _SVector point; // stack offset -96
			struct _SVector point0; // stack offset -88
			struct _SVector point1; // stack offset -80
			struct _SVector normal0; // stack offset -72
			struct _SVector normal1; // stack offset -64
			struct _SVector sphereNormal; // stack offset -56
			struct _SVector dv; // stack offset -48
			struct _SVector absdv; // stack offset -40

		/* begin block 1.1 */
			// Start line: 1989
			// Start offset: 0x80020FAC
			// Variables:
				long numIntersects; // $a2

			/* begin block 1.1.1 */
				// Start line: 1993
				// Start offset: 0x80020FDC
				// Variables:
					short _x1; // $v0
					short _y1; // $v1
					short _z1; // $a0
			/* end block 1.1.1 */
			// End offset: 0x80020FDC
			// End Line: 1993

			/* begin block 1.1.2 */
				// Start line: 1993
				// Start offset: 0x80020FDC
				// Variables:
					short _x1; // $a0
					short _y1; // $v1
					short _z1; // $a1
					struct _SVector *_v0; // $v0
			/* end block 1.1.2 */
			// End offset: 0x80020FDC
			// End Line: 1993

			/* begin block 1.1.3 */
				// Start line: 2000
				// Start offset: 0x8002107C
				// Variables:
					short _y0; // $v0
					short _z0; // $v1
					short _x1; // $v0
					short _y1; // $a2
					short _z1; // $a3
					struct _SVector *_v; // $a1
					struct _SVector *_v0; // $v1
			/* end block 1.1.3 */
			// End offset: 0x8002107C
			// End Line: 2000
		/* end block 1.1 */
		// End offset: 0x80021290
		// End Line: 2076

		/* begin block 1.2 */
			// Start line: 2080
			// Start offset: 0x80021290

			/* begin block 1.2.1 */
				// Start line: 2087
				// Start offset: 0x800212D4
				// Variables:
					short _x1; // $v0
					short _y1; // $v1
					short _z1; // $a0
					struct _SVector *_v0; // $v0
					struct _SVector *_v1; // $v0
			/* end block 1.2.1 */
			// End offset: 0x800212D4
			// End Line: 2087

			/* begin block 1.2.2 */
				// Start line: 2087
				// Start offset: 0x800212D4
				// Variables:
					short _x1; // $v1
					short _y1; // $a0
					short _z1; // $a1
			/* end block 1.2.2 */
			// End offset: 0x800212D4
			// End Line: 2087

			/* begin block 1.2.3 */
				// Start line: 2096
				// Start offset: 0x80021318
				// Variables:
					short _x1; // $v0
					short _y1; // $v1
					short _z1; // $a0
			/* end block 1.2.3 */
			// End offset: 0x80021318
			// End Line: 2096

			/* begin block 1.2.4 */
				// Start line: 2096
				// Start offset: 0x80021318
				// Variables:
					short _x1; // $a0
					short _y1; // $v1
					short _z1; // $a1
					struct _SVector *_v0; // $v0
			/* end block 1.2.4 */
			// End offset: 0x80021318
			// End Line: 2096
		/* end block 1.2 */
		// End offset: 0x800213B8
		// End Line: 2106
	/* end block 1 */
	// End offset: 0x800213B8
	// End Line: 2108

	/* begin block 2 */
		// Start line: 4981
	/* end block 2 */
	// End Line: 4982
#endif
					UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// void /*$ra*/ COLLIDE_Instance1SpheresToInstance2(struct _Instance *instance1 /*stack 0*/, struct _Instance *instance2 /*$fp*/, long sphereToSphere /*$a2*/)
void COLLIDE_Instance1SpheresToInstance2(struct _Instance *instance1, struct _Instance *instance2, long sphereToSphere)
{ // line 2419, offset 0x800213dc
#if 0
	/* begin block 1 */
		// Start line: 2420
		// Start offset: 0x800213DC
		// Variables:
			MATRIX *wsTransform2; // stack offset -132
			MATRIX *oldWSTransform2; // stack offset -128
			_Position *spherePos; // stack offset -124
			struct _Vector *line; // $s7
			struct _Vector *offset; // stack offset -120
			struct _Vector *tempVec; // stack offset -116
			struct _Vector *sSpherePos1; // stack offset -112
			struct _Vector *oldSSpherePos1; // stack offset -108
			struct _SVector *svec; // stack offset -104
			struct _Sphere *sSphere1; // $s3
			struct _Sphere *oldSSphere1; // stack offset -100
			struct _Sphere *wSphere1; // stack offset -96
			struct _Sphere *wSphere2; // stack offset -92
			struct _Sphere *oldWSphere1; // stack offset -88
			struct _Sphere *oldWSphere2; // stack offset -84
			struct _CollideInfo *collideInfo; // $s2
			struct _HFaceInfo *hfaceInfo; // stack offset -80
			MATRIX *swTransform1; // stack offset -76
			MATRIX *swTransform2; // stack offset -72
			MATRIX *oldSWTransform1; // $s0
			MATRIX *oldSWTransform2; // $s4
			struct _HSphere *hsphere1; // $s6
			struct _HSphere *hsphere2; // $s0
			struct _HFace *hface; // $s0
			void (*collideFunc)(); // $a3
			long flag; // stack offset -152
			long edge; // stack offset -136
			struct _HModel *hmodel1; // $a0
			struct _HModel *hmodel2; // stack offset -68
			struct _HPrim *hprim1; // stack offset -64
			struct _HPrim *hprim2; // stack offset -60
			int i; // stack offset -56

		/* begin block 1.1 */
			// Start line: 2478
			// Start offset: 0x80021578
			// Variables:
				int i; // stack offset -52

			/* begin block 1.1.1 */
				// Start line: 2524
				// Start offset: 0x800217F0
				// Variables:
					long len; // $a3

				/* begin block 1.1.1.1 */
					// Start line: 2525
					// Start offset: 0x800217F0
					// Variables:
						long a; // stack offset -148
						long b; // stack offset -144
						long c; // stack offset -140
				/* end block 1.1.1.1 */
				// End offset: 0x800217F0
				// End Line: 2525

				/* begin block 1.1.1.2 */
					// Start line: 2531
					// Start offset: 0x80021888
					// Variables:
						short _x1; // $v1
						short _y1; // $a0
						short _z1; // $v0
						_Position *_v1; // $v0
				/* end block 1.1.1.2 */
				// End offset: 0x80021888
				// End Line: 2531

				/* begin block 1.1.1.3 */
					// Start line: 2536
					// Start offset: 0x800218B0
					// Variables:
						short _x1; // $v0
						short _y1; // $v1
						short _z1; // $a0
				/* end block 1.1.1.3 */
				// End offset: 0x800218B0
				// End Line: 2536
			/* end block 1.1.1 */
			// End offset: 0x800219E4
			// End Line: 2561

			/* begin block 1.1.2 */
				// Start line: 2577
				// Start offset: 0x80021A58
				// Variables:
					struct _Model *model2; // $s1

				/* begin block 1.1.2.1 */
					// Start line: 2676
					// Start offset: 0x80021E58
					// Variables:
						struct _HBox *hbox; // $s4
				/* end block 1.1.2.1 */
				// End offset: 0x800220B4
				// End Line: 2742
			/* end block 1.1.2 */
			// End offset: 0x800220B4
			// End Line: 2743
		/* end block 1.1 */
		// End offset: 0x800220D4
		// End Line: 2746
	/* end block 1 */
	// End offset: 0x800220FC
	// End Line: 2748

	/* begin block 2 */
		// Start line: 4838
	/* end block 2 */
	// End Line: 4839
#endif
						UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ COLLIDE_Instances(struct _Instance *instance1 /*$s1*/, struct _Instance *instance2 /*$s0*/)
void COLLIDE_Instances(struct _Instance *instance1, struct _Instance *instance2)
{ // line 2761, offset 0x8002212c
	/* begin block 1 */
		// Start line: 2762
		// Start offset: 0x8002212C
		// Variables:
			long lx; // $a1
			long ly; // $a3
			long lz; // $a2
			long mrmr; // $v0

		/* begin block 1.1 */
			// Start line: 2806
			// Start offset: 0x80022158
			// Variables:
				long x; // $a1
				long y; // $a3
				long z; // $a2
		/* end block 1.1 */
		// End offset: 0x80022158
		// End Line: 2806
	/* end block 1 */
	// End offset: 0x80022260
	// End Line: 2828

	/* begin block 2 */
		// Start line: 7060
	/* end block 2 */
	// End Line: 7061
				UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ COLLIDE_InstanceList(struct _InstanceList *instanceList /*$s7*/)
void COLLIDE_InstanceList(struct _InstanceList *instanceList)
{ // line 2839, offset 0x80022274
	/* begin block 1 */
		// Start line: 2840
		// Start offset: 0x80022274
		// Variables:
			struct _Instance *instance; // $s1
			struct _Instance *instance2; // $s0
			struct _Instance *playerInstance; // $s2
			long i; // $s4
			long j; // $s2
	/* end block 1 */
	// End offset: 0x800224EC
	// End Line: 2926

	/* begin block 2 */
		// Start line: 7228
	/* end block 2 */
	// End Line: 7229

	/* begin block 3 */
		// Start line: 7236
	/* end block 3 */
	// End Line: 7237
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// long /*$ra*/ COLLIDE_SphereAndHFace(struct _Sphere *sphere /*$s2*/, _Position *oldPos /*$a1*/, struct _HFaceInfo *hfaceInfo /*$s4*/, struct _SVector *intersect /*$s5*/, long *edge /*stack 16*/)
long COLLIDE_SphereAndHFace(struct _Sphere *sphere, _Position *oldPos, struct _HFaceInfo *hfaceInfo, struct _SVector *intersect, long *edge)
{ // line 3061, offset 0x8002251c
#if 0
	/* begin block 1 */
		// Start line: 3062
		// Start offset: 0x8002251C
		// Variables:
			struct SandHFScratch *CSpad; // $s0
			struct _SVector *vertex0; // $a0
			long result; // $s6
			long behind; // $v0
			unsigned long d0sq; // $s1

		/* begin block 1.1 */
			// Start line: 3126
			// Start offset: 0x80022734
			// Variables:
				struct _Vector dv; // stack offset -64

			/* begin block 1.1.1 */
				// Start line: 3128
				// Start offset: 0x80022734
				// Variables:
					short _x1; // $v0
					short _y1; // $v1
					short _z1; // $a0
					struct _SVector *_v0; // $v0
			/* end block 1.1.1 */
			// End offset: 0x80022734
			// End Line: 3128
		/* end block 1.1 */
		// End offset: 0x80022814
		// End Line: 3141

		/* begin block 1.2 */
			// Start line: 3143
			// Start offset: 0x80022814
			// Variables:
				long y; // $v1
				long z; // $v0
		/* end block 1.2 */
		// End offset: 0x80022814
		// End Line: 3143

		/* begin block 1.3 */
			// Start line: 3147
			// Start offset: 0x80022884
			// Variables:
				unsigned long d1sq; // $a0

			/* begin block 1.3.1 */
				// Start line: 3149
				// Start offset: 0x80022884
				// Variables:
					long y; // $v1
					long z; // $v0
			/* end block 1.3.1 */
			// End offset: 0x80022884
			// End Line: 3149

			/* begin block 1.3.2 */
				// Start line: 3161
				// Start offset: 0x80022928
				// Variables:
					long y; // $v1
					long z; // $v0
			/* end block 1.3.2 */
			// End offset: 0x80022928
			// End Line: 3161
		/* end block 1.3 */
		// End offset: 0x800229B8
		// End Line: 3170

		/* begin block 1.4 */
			// Start line: 3174
			// Start offset: 0x800229CC
			// Variables:
				long len; // $a2
				struct _Vector dv; // stack offset -64

			/* begin block 1.4.1 */
				// Start line: 3176
				// Start offset: 0x800229CC
				// Variables:
					long _x0; // $a3
					long _y0; // $t0
					long _z0; // $t1
					long _x1; // $v1
					long _y1; // $v0
					long _z1; // $v1
					struct _Vector *_v; // $v0
					struct _SVector *_v1; // $t2
			/* end block 1.4.1 */
			// End offset: 0x800229CC
			// End Line: 3176

			/* begin block 1.4.2 */
				// Start line: 3176
				// Start offset: 0x800229CC
				// Variables:
					long a; // stack offset -48
					long b; // stack offset -44
					long c; // stack offset -40
			/* end block 1.4.2 */
			// End offset: 0x800229CC
			// End Line: 3176
		/* end block 1.4 */
		// End offset: 0x80022BCC
		// End Line: 3198
	/* end block 1 */
	// End offset: 0x80022BD0
	// End Line: 3201

	/* begin block 2 */
		// Start line: 6122
	/* end block 2 */
	// End Line: 6123
#endif
					UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// long /*$ra*/ COLLIDE_SAndT(struct SCollideInfo *scollideInfo /*stack 0*/, struct Level *level /*stack 4*/)
long COLLIDE_SAndT(struct SCollideInfo *scollideInfo, struct Level *level)
{ // line 3243, offset 0x80022bf8
#if 0
	/* begin block 1 */
		// Start line: 3244
		// Start offset: 0x80022BF8
		// Variables:
			struct SandTScratch *CSpad; // $s0
			void **stack; // $s1
			struct _BSPNode *bspNode; // $a1
			struct _Terrain *terrain; // $s5
			long curTree; // stack offset -44

		/* begin block 1.1 */
			// Start line: 3280
			// Start offset: 0x80022C74
			// Variables:
				short _x1; // $v1
				short _y1; // $a0
				short _z1; // $v0
				struct _SVector *_v0; // $s2
				struct _SVector *_v1; // $v0
		/* end block 1.1 */
		// End offset: 0x80022C74
		// End Line: 3280

		/* begin block 1.2 */
			// Start line: 3280
			// Start offset: 0x80022C74
			// Variables:
				long a; // stack offset -56
				long b; // stack offset -52
				long c; // stack offset -48
		/* end block 1.2 */
		// End offset: 0x80022C74
		// End Line: 3280

		/* begin block 1.3 */
			// Start line: 3314
			// Start offset: 0x80022E64
			// Variables:
				struct BSPTree *bsp; // $s4

			/* begin block 1.3.1 */
				// Start line: 3329
				// Start offset: 0x80022EF0
				// Variables:
					short _x0; // $v0
					short _y0; // $v1
					short _z0; // $a0
					short _x1; // $a1
					short _y1; // $a2
					short _z1; // $a3
					struct _SVector *_v; // $fp
					_Position *_v1; // $t0
			/* end block 1.3.1 */
			// End offset: 0x80022EF0
			// End Line: 3329

			/* begin block 1.3.2 */
				// Start line: 3329
				// Start offset: 0x80022EF0
				// Variables:
					short _x0; // $v0
					short _y0; // $v1
					short _z0; // $a0
					short _x1; // $a1
					short _y1; // $a2
					short _z1; // $a3
					struct _SVector *_v; // $s7
			/* end block 1.3.2 */
			// End offset: 0x80022EF0
			// End Line: 3329

			/* begin block 1.3.3 */
				// Start line: 3329
				// Start offset: 0x80022EF0
				// Variables:
					short _x0; // $v0
					short _y0; // $v1
					short _z0; // $a0
					short _x1; // $a1
					short _y1; // $a2
					short _z1; // $a3
					_Position *_v; // $s6
			/* end block 1.3.3 */
			// End offset: 0x80022EF0
			// End Line: 3329

			/* begin block 1.3.4 */
				// Start line: 3244
				// Start offset: 0x80022FF4
				// Variables:
					struct _SVector *point; // $t0
					struct _BoundingBox *box; // $a3
			/* end block 1.3.4 */
			// End offset: 0x8002308C
			// End Line: 3244

			/* begin block 1.3.5 */
				// Start line: 3365
				// Start offset: 0x80023094
				// Variables:
					struct _TFace *tface; // $s3

				/* begin block 1.3.5.1 */
					// Start line: 3385
					// Start offset: 0x80023138
					// Variables:
						struct _SVector *vertex0; // $a3

					/* begin block 1.3.5.1.1 */
						// Start line: 3244
						// Start offset: 0x800231B0
						// Variables:
							short *nrmlArray; // $a0
							struct _SVector *nrml; // $a1

						/* begin block 1.3.5.1.1.1 */
							// Start line: 3244
							// Start offset: 0x800231B0
							// Variables:
								short *sPtr; // $v1
						/* end block 1.3.5.1.1.1 */
						// End offset: 0x80023240
						// End Line: 3244
					/* end block 1.3.5.1.1 */
					// End offset: 0x80023240
					// End Line: 3244

					/* begin block 1.3.5.1.2 */
						// Start line: 3417
						// Start offset: 0x800232D4
					/* end block 1.3.5.1.2 */
					// End offset: 0x80023434
					// End Line: 3469
				/* end block 1.3.5.1 */
				// End offset: 0x80023434
				// End Line: 3470
			/* end block 1.3.5 */
			// End offset: 0x80023454
			// End Line: 3473

			/* begin block 1.3.6 */
				// Start line: 3484
				// Start offset: 0x8002347C
				// Variables:
					int plane_front_error; // $v0
					int plane_back_error; // $a3
			/* end block 1.3.6 */
			// End offset: 0x800235CC
			// End Line: 3547

			/* begin block 1.3.7 */
				// Start line: 3551
				// Start offset: 0x800235DC
				// Variables:
					short _x0; // $v0
					short _y0; // $v1
					short _z0; // $a0
					short _x1; // $a1
					short _y1; // $a2
					short _z1; // $a3
					_Position *_v1; // $t0
			/* end block 1.3.7 */
			// End offset: 0x800235DC
			// End Line: 3551

			/* begin block 1.3.8 */
				// Start line: 3551
				// Start offset: 0x800235DC
				// Variables:
					short _x0; // $v0
					short _y0; // $v1
					short _z0; // $a0
					short _x1; // $a1
					short _y1; // $a2
					short _z1; // $a3
			/* end block 1.3.8 */
			// End offset: 0x800235DC
			// End Line: 3551

			/* begin block 1.3.9 */
				// Start line: 3551
				// Start offset: 0x800235DC
				// Variables:
					short _x0; // $v0
					short _y0; // $v1
					short _z0; // $a0
					short _x1; // $a1
					short _y1; // $a2
					short _z1; // $a3
			/* end block 1.3.9 */
			// End offset: 0x80023670
			// End Line: 3553
		/* end block 1.3 */
		// End offset: 0x80023670
		// End Line: 3554

		/* begin block 1.4 */
			// Start line: 3555
			// Start offset: 0x80023688
			// Variables:
				short _x1; // $a0
				short _y1; // $a1
				short _z1; // $v1
				_Position *_v0; // $v0
				_Position *_v1; // $v1
		/* end block 1.4 */
		// End offset: 0x80023688
		// End Line: 3555
	/* end block 1 */
	// End offset: 0x800236B4
	// End Line: 3557

	/* begin block 2 */
		// Start line: 8066
	/* end block 2 */
	// End Line: 8067
#endif
				UNIMPLEMENTED();
	return 0;
}

long COLLIDE_SphereAndTerrain(struct SCollideInfo* scollideInfo, struct Level* level)
{
	int result;
	int d;
	int in_warpRoom;
	struct _StreamUnit* stream;

	result = COLLIDE_SAndT(scollideInfo, level);

	in_warpRoom = 0;
	
	stream = STREAM_GetStreamUnitWithID(level->streamUnitID);

	if (stream != NULL)
	{
		in_warpRoom = stream->flags & 0x1;
	}

	for (d = 0; d < 16; d++)
	{
		if ((StreamTracker.StreamList[d].used == 2) && (StreamTracker.StreamList[d].level != level) && ((in_warpRoom == 0) || !(StreamTracker.StreamList[d].flags & 0x1)) && (MEMPACK_MemoryValidFunc((char*)StreamTracker.StreamList[d].level) != 0))
		{
			result = COLLIDE_SAndT(scollideInfo, StreamTracker.StreamList[d].level);
		}
	}

	return result;
}

void COLLIDE_InstanceTerrain(struct _Instance* instance, struct Level* level)
{
	struct _Vector* newPosVec;
	struct _Vector* oldPosVec;
	struct _SVector* oldPos;
	struct SCollideInfo scollideInfoX;
	struct SCollideInfo* scollideInfo;
	struct _Sphere* wSphere;
	MATRIX* swTransform;
	MATRIX* oldSWTransform;
	void (*collideFunc)(struct _Instance* instance, struct GameTracker* gameTracker); // stack offset -52
	struct _HSphere* hsphere;
	long flags;
	int i;
	struct _HModel* hmodel;
	struct _HPrim* hprim;

	newPosVec = (struct _Vector*)getScratchAddr(82);
	oldPos = (struct _SVector*)getScratchAddr(90);
	wSphere = (struct _Sphere*)getScratchAddr(110);
	oldPosVec = (struct _Vector*)getScratchAddr(86);

	scollideInfo = &scollideInfoX;

	if (instance->matrix != NULL && instance->oldMatrix != NULL)
	{
		if((instance->object->oflags2 & 0x80000))
		{
			gameTrackerX.monster_collide_override = 1;
		}

		collideFunc = instance->collideFunc;

		if (instance->currentModel != 0)
		{
			hmodel = &instance->hModelList[instance->currentModel];

			i = hmodel->numHPrims;
			hprim = hmodel->hPrimList;

			while (i-- != 0)
			{
				if ((hprim->hpFlags & 0x1) && (hprim->withFlags & 0x2) && hprim->type == 1)
				{
					swTransform = &instance->matrix[hprim->segment];
				
					oldSWTransform = &instance->oldMatrix[hprim->segment];

					SetRotMatrix(swTransform);

					SetTransMatrix(swTransform);

					RotTrans((SVECTOR*)&hprim->data.hsphere->position, (VECTOR*)newPosVec, &flags);
				
					SetRotMatrix(oldSWTransform);

					SetTransMatrix(oldSWTransform);

					RotTrans((SVECTOR*)&hprim->data.hsphere->position, (VECTOR*)oldPosVec, &flags);
				
					wSphere->position.x = newPosVec->x;
					wSphere->position.y = newPosVec->y;
					wSphere->position.z = newPosVec->z;

					wSphere->radius = hprim->data.hsphere->radius;

					oldPos->x = oldPosVec->x;
					oldPos->y = oldPosVec->y;
					oldPos->z = oldPosVec->z;

					wSphere->radiusSquared = hprim->data.hsphere->radiusSquared;

					scollideInfo->sphere = wSphere;
					
					scollideInfo->oldPos = (SVECTOR*)oldPos;

					scollideInfo->collideFunc = collideFunc;

					scollideInfo->instance = instance;

					scollideInfo->segment = hprim->segment;

					scollideInfo->prim = (void*)hprim;

					scollideInfo->id = hprim->data.hsphere->id;

					COLLIDE_SphereAndTerrain(scollideInfo, level);
				}
				
				hprim++;
			}
		}

		gameTrackerX.monster_collide_override = 0;
	}
}


// autogenerated function stub: 
// long /*$ra*/ COLLIDE_LineWithSignals(struct _SVector *startPoint /*$a0*/, struct _SVector *endPoint /*$a1*/, struct _MultiSignal **signalList /*stack 8*/, long maxSignals /*stack 12*/, struct Level *level /*stack 16*/)
long COLLIDE_LineWithSignals(struct _SVector* startPoint, struct _SVector* endPoint, struct _MultiSignal** signalList, long maxSignals, struct Level* level)
{ // line 4331, offset 0x80023a38
	struct IandTScratch* CSpad; // $s0
	void** stack; // $s2
	struct _BSPNode* bspNode; // $a1
	struct _TFace* tface; // $s3
	struct _Terrain* terrain; // $s4
	long curTree; // stack offset -56
	long numSignalsCollidedWith; // $fp
	short _x0; // $v0
	short _y0; // $v1
	short _z0; // $a0
	short _x1; // $a1
	short _y1; // $a2
	short _z1; // $a3
	struct _SVector* _v0; // $t1
	struct _SVector* _v; // $s6, s7, v0
	struct _Position* _v1; // $a2, t0
	struct _SVector* vertex0; // $a0
	short* nrmlArray; // $a0
	struct _SVector* nrml; // $a1
	short* sPtr; // $v1
	struct _SVector* point; // $t0
	struct _SVector* start; // $a3
	struct _SVector* line; // $a2
	long len; // $v1
	long t; // $a1
	struct _MultiSignal* msignal; // $v1
	int plane_front_error; // $v1
	int plane_back_error; // $a0

	//v0 = level
	CSpad = (struct IandTScratch*)getScratchAddr(16);

	terrain = level->terrain;

	stack = (void**)getScratchAddr(41);

	//v0 = terrain->normalList

	CSpad->normalList = (short*)terrain->normalList;
	CSpad->vertexList = terrain->vertexList;

	//v1 = gameTrackerX.gameData.asmData.MorphTime;
	//v0 = 0x3E8

	((_SVector*)getScratchAddr(33))->x = startPoint->x;
	((_SVector*)getScratchAddr(33))->y = startPoint->y;
	((_SVector*)getScratchAddr(33))->z = startPoint->z;

	((_SVector*)getScratchAddr(35))->x = endPoint->x;
	((_SVector*)getScratchAddr(35))->y = endPoint->y;
	((_SVector*)getScratchAddr(35))->z = endPoint->z;

	numSignalsCollidedWith = 0;

	if (gameTrackerX.gameData.asmData.MorphTime != 1000)
	{
		CSpad->in_spectral = 2;
	}
	else
	{
		if (gameTrackerX.gameData.asmData.MorphType == 10)
		{
			CSpad->in_spectral = 1;
		}
		else
		{
			CSpad->in_spectral = 0;
		}
	}
	//loc_80023ED8
#if 0
		loc_80023ED8 :
		addiu   $t1, $s0, 0x44  # 'D'
		addiu   $t0, $s0, 0x4C  # 'L'
		lhu     $v0, 0x44($s0)
		lhu     $v1, 2($t1)
		lhu     $a0, 4($t1)
		lhu     $a1, 0x4C($s0)
		lhu     $a2, 2($t0)
		lhu     $a3, 4($t0)
		subu    $v0, $a1
		sh      $v0, 0x3C($s0)
		addiu   $v0, $s0, 0x3C  # '<'
		subu    $v1, $a2
		subu    $a0, $a3
		sh      $v1, 2($v0)
		sh      $a0, 4($v0)
		lw      $v0, 0x3C($s0)
		nop
		bnez    $v0, loc_80023F34
		nop
		lh      $v0, 0x40($s0)
		nop
		beqz    $v0, loc_80024584
		move    $v0, $fp

		loc_80023F34 :
	lw      $v0, 0x44($s4)
		nop
		blez    $v0, loc_80024580
		sw      $zero, 0x28 + var_10($sp)
		move    $s7, $t0
		move    $s6, $t1
		addiu   $t1, $s0, 0x28  # '('
		move    $s5, $zero

		loc_80023F54 :
	lw      $v0, 0x48($s4)
		nop
		addu    $v0, $s5, $v0
		lh      $v1, 0x1A($v0)
		li      $v0, 0xFFFFFFFF
		bne     $v1, $v0, loc_80024564
		nop
		sw      $s2, 0($s2)
		lw      $v0, 0x48($s4)
		lhu     $v1, 0x4C($s0)
		lhu     $a0, 2($s7)
		lhu     $a1, 4($s7)
		addu    $v0, $s5
		addiu   $a2, $v0, 0xC
		lhu     $v0, 0xC($v0)
		lhu     $a3, 2($a2)
		lhu     $a2, 4($a2)
		subu    $v1, $v0
		subu    $a0, $a3
		subu    $a1, $a2
		sh      $v1, 0x4C($s0)
		sh      $a0, 2($s7)
		sh      $a1, 4($s7)
		lw      $v0, 0x48($s4)
		lhu     $v1, 0x44($s0)
		lhu     $a0, 2($s6)
		lhu     $a1, 4($s6)
		addu    $v0, $s5
		addiu   $a2, $v0, 0xC
		lhu     $v0, 0xC($v0)
		lhu     $a3, 2($a2)
		lhu     $a2, 4($a2)
		subu    $v1, $v0
		subu    $a0, $a3
		subu    $a1, $a2
		sh      $v1, 0x44($s0)
		sh      $a0, 2($s6)
		sh      $a1, 4($s6)
		lw      $v0, 0x48($s4)
		nop
		addu    $v0, $s5, $v0
		lw      $v0, 0($v0)
		addiu   $s2, 4
		sw      $v0, 0($s2)
		lhu     $v0, 0x4C($s0)
		lhu     $v1, 0x4E($s0)
		lhu     $a0, 0x50($s0)
		lhu     $a1, 0x44($s0)
		lhu     $a2, 0x46($s0)
		sh      $v0, 0($s0)
		sh      $v1, 2($s0)
		sh      $a0, 4($s0)
		sh      $a1, 6($s0)
		sh      $a2, 8($s0)
		lhu     $v0, 0x48($s0)
		move    $a0, $s0
		sh      $v0, 0xA($s0)
		jal     SetRotMatrix
		sw      $t1, 0x28 + var_8($sp)
		lw      $v0, 0($s2)
		lw      $t1, 0x28 + var_8($sp)
		beq     $v0, $s2, loc_800244EC
		nop

		loc_80024050 :
	lw      $a1, 0($s2)
		nop
		lhu     $v0, 0xE($a1)
		nop
		andi    $v0, 2
		beqz    $v0, loc_800243E8
		addiu   $s2, -4
		lh      $a0, 0x4C($s0)
		lh      $v1, 0x16($a1)
		nop
		slt     $v0, $v1, $a0
		beqz    $v0, loc_80024098
		nop
		lh      $v0, 0x44($s0)
		nop
		slt     $v0, $v1, $v0
		bnez    $v0, loc_800244DC
		nop

		loc_80024098 :
	lh      $v1, 0x10($a1)
		nop
		slt     $v0, $a0, $v1
		beqz    $v0, loc_800240C0
		nop
		lh      $v0, 0x44($s0)
		nop
		slt     $v0, $v1
		bnez    $v0, loc_800244DC
		nop

		loc_800240C0 :
	lh      $a0, 0x4E($s0)
		lh      $v1, 0x18($a1)
		nop
		slt     $v0, $v1, $a0
		beqz    $v0, loc_800240EC
		nop
		lh      $v0, 0x46($s0)
		nop
		slt     $v0, $v1, $v0
		bnez    $v0, loc_800244DC
		nop

		loc_800240EC :
	lh      $v1, 0x12($a1)
		nop
		slt     $v0, $a0, $v1
		beqz    $v0, loc_80024114
		nop
		lh      $v0, 0x46($s0)
		nop
		slt     $v0, $v1
		bnez    $v0, loc_800244DC
		nop

		loc_80024114 :
	lh      $a0, 0x50($s0)
		lh      $v1, 0x1A($a1)
		nop
		slt     $v0, $v1, $a0
		beqz    $v0, loc_80024140
		nop
		lh      $v0, 0x48($s0)
		nop
		slt     $v0, $v1, $v0
		bnez    $v0, loc_800244DC
		nop

		loc_80024140 :
	lh      $v1, 0x14($a1)
		nop
		slt     $v0, $a0, $v1
		beqz    $v0, loc_80024168
		nop
		lh      $v0, 0x48($s0)
		nop
		slt     $v0, $v1
		bnez    $v0, loc_800244DC
		nop

		loc_80024168 :
	lh      $v0, 0xC($a1)
		nop
		sw      $v0, 0x54($s0)
		lw      $s3, 8($a1)
		beqz    $v0, loc_800244DC
		addiu   $s1, $s3, 0xA

		loc_80024180:
	lhu     $v0, -4($s1)
		nop
		andi    $v0, 0xC0
		beqz    $v0, loc_800243C8
		li      $v0, 0xFFFF
		lhu     $v1, 0($s1)
		nop
		beq     $v1, $v0, loc_800243C8
		nop
		lh      $v1, -2($s1)
		lw      $a0, 0x5C($s0)
		bltz    $v1, loc_800241EC
		addiu   $a1, $s0, 0x20  # ' '
		sll     $v0, $v1, 1
		addu    $v0, $v1
		sll     $v0, 1
		addu    $v1, $a0, $v0
		lhu     $v0, 0($v1)
		addiu   $v1, 2
		andi    $v0, 0x1FFF
		sh      $v0, 0x20($s0)
		lhu     $v0, 0($v1)
		nop
		sh      $v0, 2($a1)
		lhu     $v0, 2($v1)
		j       loc_80024234
		sh      $v0, 4($a1)

		loc_800241EC:
	negu    $v1, $v1
		sll     $v0, $v1, 1
		addu    $v0, $v1
		sll     $v0, 1
		addu    $v1, $a0, $v0
		lhu     $v0, 0($v1)
		addiu   $v1, 2
		andi    $v0, 0x1FFF
		negu    $v0, $v0
		sh      $v0, 0x20($s0)
		lhu     $v0, 0($v1)
		nop
		negu    $v0, $v0
		sh      $v0, 2($a1)
		lhu     $v0, 2($v1)
		nop
		negu    $v0, $v0
		sh      $v0, 4($a1)

		loc_80024234:
	lhu     $v1, 0($s3)
		nop
		sll     $v0, $v1, 1
		addu    $v0, $v1
		lw      $v1, 0x60($s0)
		sll     $v0, 2
		addu    $a0, $v1, $v0
		lw      $t4, 0($a0)
		lw      $t5, 4($a0)
		ctc2    $t4, $3
		ctc2    $t5, $4
		addiu   $v0, $s0, 0x20  # ' '
		lwc2    $0, 0($v0)
		lwc2    $1, 4($v0)
		nop
		nop
		cop2    0x486012
		swc2    $25, 0($t1)
		swc2    $26, 4($t1)
		swc2    $27, 8($t1)
		lw      $v1, 0x28($s0)
		lw      $v0, 0x30($s0)
		nop
		subu    $v1, $v0
		sw      $v1, 0x28($s0)
		lw      $v1, 0x2C($s0)
		lw      $a1, 0x28($s0)
		subu    $v1, $v0
		bgez    $a1, loc_800243C8
		sw      $v1, 0x2C($s0)
		bltz    $v1, loc_800243C8
		addiu   $t0, $s0, 0x34  # '4'
		addiu   $a3, $s0, 0x44  # 'D'
		lw      $v0, 4($t1)
		nop
		subu    $v1, $a1, $v0
		beqz    $v1, loc_800242E0
		addiu   $a2, $s0, 0x3C  # '<'
		sll     $v0, 12
		div     $v0, $v1
		mflo    $a1
		j       loc_800242E4
		nop

		loc_800242E0 :
	move    $a1, $zero

		loc_800242E4 :
	lh      $v0, 0($a2)
		nop
		mult    $v0, $a1
		lhu     $v1, 0($a3)
		mflo    $t2
		sra     $v0, $t2, 12
		addu    $v1, $v0
		sh      $v1, 0($t0)
		lhu     $v0, 2($a2)
		nop
		sll     $v0, 16
		sra     $v0, 16
		mult    $v0, $a1
		lhu     $v1, 2($a3)
		mflo    $t2
		sra     $v0, $t2, 12
		addu    $v1, $v0
		sh      $v1, 2($t0)
		lh      $v0, 4($a2)
		nop
		mult    $v0, $a1
		lhu     $v1, 4($a3)
		mflo    $t2
		sra     $v0, $t2, 12
		addu    $v1, $v0
		sh      $v1, 4($t0)
		lhu     $v1, -8($s1)
		lhu     $a3, -6($s1)
		addiu   $v0, $s0, 0x20  # ' '
		sw      $v0, 0x28 + var_18($sp)
		lw      $v0, 0x60($s0)
		sw      $t1, 0x28 + var_8($sp)
		sll     $a1, $v1, 1
		addu    $a1, $v1
		sll     $a1, 2
		sll     $a2, $a3, 1
		addu    $a2, $a3
		sll     $a2, 2
		addu    $a1, $v0, $a1
		addu    $a2, $v0, $a2
		jal     sub_8001E818
		addiu   $a3, $s0, 0x34  # '4'
		lw      $t1, 0x28 + var_8($sp)
		beqz    $v0, loc_800243C8
		nop
		lw      $t3, 0x28 + arg_C($sp)
		nop
		slt     $v0, $fp, $t3
		beqz    $v0, loc_800243C8
		sll     $v0, $fp, 2
		addiu   $fp, 1
		lhu     $a0, 0($s1)
		lw      $v1, 0x50($s4)
		lw      $t6, 0x28 + arg_8($sp)
		addu    $v1, $a0
		addu    $v0, $t6
		sw      $v1, 0($v0)

		loc_800243C8:
	addiu   $s1, 0xC
		lw      $v0, 0x54($s0)
		addiu   $s3, 0xC
		addiu   $v0, -1
		bnez    $v0, loc_80024180
		sw      $v0, 0x54($s0)
		j       loc_800244DC
		nop

		loc_800243E8 :
	addiu   $v0, $a1, 8
		lwc2    $0, 0($v0)
		lwc2    $1, 4($v0)
		nop
		nop
		cop2    0x486012
		swc2    $25, 0($t1)
		swc2    $26, 4($t1)
		swc2    $27, 8($t1)
		lw      $v0, 0x28($s0)
		lw      $v1, 0x10($a1)
		nop
		subu    $v0, $v1
		sw      $v0, 0x28($s0)
		lw      $v0, 0x2C($s0)
		lw      $v1, 0x10($a1)
		lw      $a0, 0x58($s0)
		subu    $v0, $v1
		beqz    $a0, loc_80024448
		sw      $v0, 0x2C($s0)
		lh      $v1, 0x24($a1)
		lh      $a0, 0x26($a1)
		j       loc_80024450
		nop

		loc_80024448 :
	lh      $v1, 0x28($a1)
		lh      $a0, 0x2A($a1)

		loc_80024450 :
		lw      $v0, 0x28($s0)
		nop
		slt     $v0, $v1
		bnez    $v0, loc_80024484
		nop
		lw      $v0, 0x2C($s0)
		nop
		slt     $v0, $v1
		bnez    $v0, loc_80024484
		nop
		lw      $v0, 0x14($a1)
		j       loc_800244C8
		nop

		loc_80024484 :
	lw      $v0, 0x28($s0)
		nop
		slt     $v0, $a0, $v0
		bnez    $v0, loc_800244AC
		nop
		lw      $v0, 0x2C($s0)
		nop
		slt     $v0, $a0, $v0
		beqz    $v0, loc_800244C4
		nop

		loc_800244AC :
	lw      $v0, 0x14($a1)
		nop
		beqz    $v0, loc_800244C4
		nop
		addiu   $s2, 4
		sw      $v0, 0($s2)

		loc_800244C4:
	lw      $v0, 0x18($a1)

		loc_800244C8 :
		nop
		beqz    $v0, loc_800244DC
		nop
		addiu   $s2, 4
		sw      $v0, 0($s2)

		loc_800244DC :
		lw      $v0, 0($s2)
		nop
		bne     $v0, $s2, loc_80024050
		nop

		loc_800244EC :
	lw      $v0, 0x48($s4)
		lhu     $v1, 0x4C($s0)
		lhu     $a0, 2($s7)
		lhu     $a1, 4($s7)
		addu    $v0, $s5
		addiu   $a2, $v0, 0xC
		lhu     $v0, 0xC($v0)
		lhu     $a3, 2($a2)
		lhu     $a2, 4($a2)
		addu    $v1, $v0
		addu    $a0, $a3
		addu    $a1, $a2
		sh      $v1, 0x4C($s0)
		sh      $a0, 2($s7)
		sh      $a1, 4($s7)
		lw      $v0, 0x48($s4)
		lhu     $v1, 0x44($s0)
		lhu     $a0, 2($s6)
		lhu     $a1, 4($s6)
		addu    $v0, $s5
		addiu   $a2, $v0, 0xC
		lhu     $v0, 0xC($v0)
		lhu     $a3, 2($a2)
		lhu     $a2, 4($a2)
		addu    $v1, $v0
		addu    $a0, $a3
		addu    $a1, $a2
		sh      $v1, 0x44($s0)
		sh      $a0, 2($s6)
		sh      $a1, 4($s6)

		loc_80024564:
	addiu   $s5, 0x24  # '$'
		lw      $t7, 0x28 + var_10($sp)
		lw      $v0, 0x44($s4)
		addiu   $t7, 1
		slt     $v0, $t7, $v0
		bnez    $v0, loc_80023F54
		sw      $t7, 0x28 + var_10($sp)

		loc_80024580:
	move    $v0, $fp

		loc_80024584 :
	lw      $ra, 0x28 + var_s24($sp)
		lw      $fp, 0x28 + var_s20($sp)
		lw      $s7, 0x28 + var_s1C($sp)
		lw      $s6, 0x28 + var_s18($sp)
		lw      $s5, 0x28 + var_s14($sp)
		lw      $s4, 0x28 + var_s10($sp)
		lw      $s3, 0x28 + var_sC($sp)
		lw      $s2, 0x28 + var_s8($sp)
		lw      $s1, 0x28 + var_s4($sp)
		lw      $s0, 0x28 + var_s0($sp)
		jr      $ra
		addiu   $sp, 0x50
#endif

	UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// void /*$ra*/ COLLIDE_InstanceTerrainSignal(struct _Instance *instance /*$s3*/, struct Level *level /*$s1*/)
void COLLIDE_InstanceTerrainSignal(struct _Instance *instance, struct Level *level)
{ // line 4548, offset 0x800241fc
	/* begin block 1 */
		// Start line: 4549
		// Start offset: 0x800241FC
		// Variables:
			struct _SVector startPoint; // stack offset -72
			struct _SVector endPoint; // stack offset -64
			struct _Model *model; // $s0
			long numSignals; // $s4
			long d; // $s1
			struct _MultiSignal (*signalListArray[8]); // stack offset -56

		/* begin block 1.1 */
			// Start line: 4616
			// Start offset: 0x800243DC
			// Variables:
				struct _MultiSignal *msignal; // $s0
		/* end block 1.1 */
		// End offset: 0x800243FC
		// End Line: 4625
	/* end block 1 */
	// End offset: 0x80024424
	// End Line: 4630

	/* begin block 2 */
		// Start line: 11519
	/* end block 2 */
	// End Line: 11520
				UNIMPLEMENTED();
}


struct _StreamUnit* COLLIDE_CameraWithStreamSignals(struct Camera* camera)
{
	struct _SVector startPoint;
	struct _SVector endPoint;
	struct _Model* model;
	long numSignals;
	long i;
	long numStreamSignals;
	struct _MultiSignal (*signalListArray[8]);
	struct _StreamUnit (*streamSignalUnits[8]);
	struct _StreamUnit *playerStreamUnit;
	struct Level* level;
	long playerStreamUnitID;
	struct _Instance* instance;
	struct _Instance* af_instance;
	struct _MultiSignal* msignal;
	long isWarpGateSignal;
	struct _StreamUnit* cameraStreamUnit;
	long cameraStreamID;	
	int number;

	instance = camera->focusInstance;
	af_instance = gameTrackerX.playerInstance;

	playerStreamUnitID = instance->currentStreamUnitID;

	if (instance == af_instance)
	{
		if (gameTrackerX.SwitchToNewStreamUnit != 0)
		{
			playerStreamUnitID = gameTrackerX.moveRazielToStreamID;
		}
	}

	playerStreamUnit = STREAM_GetStreamUnitWithID(playerStreamUnitID);

	endPoint.x = camera->core.position.x;
	endPoint.y = camera->core.position.y;
	endPoint.z = camera->core.position.z;

	if (instance->matrix != NULL)
	{
		model = instance->object->modelList[instance->currentModel];

		if (model != NULL)
		{
			if (model->numSegments >= 2)
			{
				startPoint.x = instance->matrix[1].t[0];
				startPoint.y = instance->matrix[1].t[1];
				startPoint.z = instance->matrix[1].t[2];
			}
			else
			{
				startPoint.x = instance->position.x;
				startPoint.y = instance->position.y;
				startPoint.z = instance->position.z;
			}
		}
		else
		{
			startPoint.x = instance->position.x;
			startPoint.y = instance->position.y;
			startPoint.z = instance->position.z;
		}
	}
	else
	{
		startPoint.x = instance->position.x;
		startPoint.y = instance->position.y;
		startPoint.z = instance->position.z;
	}

	level = playerStreamUnit->level;
	numStreamSignals = 0;
	
	if (level != NULL)
	{
		numSignals = COLLIDE_LineWithSignals(&startPoint, &endPoint, signalListArray, 8, level);

		for(i = 0; i < numSignals; i++)
		{
			if (SIGNAL_IsStreamSignal(signalListArray[i]->signalList, &isWarpGateSignal) != 0)
			{
				if (isWarpGateSignal)
				{
					if (WARPGATE_IsWarpgateActive())
					{
						if (gameTrackerX.SwitchToNewWarpIndex == -1)
						{
							number = CurrentWarpNumber;
						}
						else
						{
							number = gameTrackerX.SwitchToNewWarpIndex;
						}

						cameraStreamID = WarpRoomArray[number].streamUnit->StreamUnitID;
					}
					else
					{
						cameraStreamID = 0;
					}
				}
				else
				{
					signalListArray[i]->signalList->data.StreamLevel.streamID;
				}

				if (cameraStreamID != 0)
				{
					cameraStreamUnit = STREAM_GetStreamUnitWithID(cameraStreamID);
				}
				else
				{
					cameraStreamUnit = NULL;
				}

				if (cameraStreamUnit != NULL)
				{
					streamSignalUnits[numStreamSignals++] = cameraStreamUnit;
				}
			}
		}
	}

	if (numStreamSignals == 0)
	{
		return 0;
	}
	else if (numStreamSignals != 1)
	{
		if (numStreamSignals > 0)
		{
			for (i = 0; i < numStreamSignals; i++)
			{
				if (streamSignalUnits[i]->StreamUnitID != playerStreamUnitID)
				{
					return streamSignalUnits[i];
				}
			}
		}
	}
	else
	{
		return streamSignalUnits[0];
	}

	return NULL;
}


// autogenerated function stub: 
// void /*$ra*/ COLLIDE_InstanceListWithSignals(struct _InstanceList *instanceList /*$a0*/)
void COLLIDE_InstanceListWithSignals(struct _InstanceList *instanceList)
{ // line 4797, offset 0x8002472c
	/* begin block 1 */
		// Start line: 4798
		// Start offset: 0x8002472C
		// Variables:
			struct _Instance *instance; // $s0
			struct Level *level; // $v0
	/* end block 1 */
	// End offset: 0x8002478C
	// End Line: 4814

	/* begin block 2 */
		// Start line: 12100
	/* end block 2 */
	// End Line: 12101
			UNIMPLEMENTED();
}

void COLLIDE_InstanceListTerrain(struct _InstanceList* instanceList)//Matching - 99.77%
{
	long i;
	struct _Instance* instance;
	struct Level* level;

	for (i = 1; i < 32; i += 2)
	{
		instance = (struct _Instance*)instanceList->group[i].next;

		while (instance != NULL)
		{
			if (instance->hModelList != NULL && !(instance->flags2 & 0x24040000))
			{
				level = STREAM_GetLevelWithID(instance->currentStreamUnitID);

				if (level != NULL)
				{
					COLLIDE_InstanceTerrain(instance, level);
				}
			}

			instance = (struct _Instance*)instance->node.next;
		}
	}
}


// autogenerated function stub: 
// void /*$ra*/ COLLIDE_SegmentCollisionOn(struct _Instance *instance /*$a0*/, int segment /*$a1*/)
void COLLIDE_SegmentCollisionOn(struct _Instance *instance, int segment)
{ // line 4947, offset 0x80024850
	/* begin block 1 */
		// Start line: 4949
		// Start offset: 0x80024850

		/* begin block 1.1 */
			// Start line: 4951
			// Start offset: 0x80024860
			// Variables:
				int i; // $a2
				struct _HModel *hmodel; // $v0
				struct _HPrim *hprim; // $v1
		/* end block 1.1 */
		// End offset: 0x800248C0
		// End Line: 4962
	/* end block 1 */
	// End offset: 0x800248C0
	// End Line: 4963

	/* begin block 2 */
		// Start line: 9894
	/* end block 2 */
	// End Line: 9895

	/* begin block 3 */
		// Start line: 12376
	/* end block 3 */
	// End Line: 12377
				UNIMPLEMENTED();
}

void COLLIDE_SegmentCollisionOff(struct _Instance* instance, int segment)
{
	int i;
	int enabled;
	struct _HModel* hmodel;
	struct _HPrim* hprim;

	if (instance->hModelList != NULL)
	{
		hmodel = &instance->hModelList[instance->currentModel];

		hprim = hmodel->hPrimList;

		enabled = 0;

		if (hmodel->numHPrims != 0)
		{
			for (i = hmodel->numHPrims; i != 0; i--)
			{
				if (hprim[i].segment == segment)
				{
					hprim[i].hpFlags &= 0xFE;
				}

				if (enabled == 0 && (hprim[i].hpFlags & 0x1))
				{
					enabled = 1;
				}
			}
		}

		if (enabled == 0)
		{
			instance->flags2 |= 0x40000;
		}
	}
}



// autogenerated function stub: 
// long /*$ra*/ COLLIDE_FindCollisionFaceNormal(struct _CollideInfo *collideInfo /*$a0*/, struct _Normal *normal /*$s2*/)
long COLLIDE_FindCollisionFaceNormal(struct _CollideInfo *collideInfo, struct _Normal *normal)
{ // line 5015, offset 0x80024964
#if 0
	/* begin block 1 */
		// Start line: 5016
		// Start offset: 0x80024964
		// Variables:
			long valid_normal; // $a2

		/* begin block 1.1 */
			// Start line: 5025
			// Start offset: 0x80024998
			// Variables:
				struct _TFace *tface; // $a1
		/* end block 1.1 */
		// End offset: 0x800249E0
		// End Line: 5029

		/* begin block 1.2 */
			// Start line: 5036
			// Start offset: 0x80024A18

			/* begin block 1.2.1 */
				// Start line: 5040
				// Start offset: 0x80024A18
				// Variables:
					SVECTOR*lNormal; // stack offset -24
					struct _Instance *inst1; // $s1
			/* end block 1.2.1 */
			// End offset: 0x80024A18
			// End Line: 5041
		/* end block 1.2 */
		// End offset: 0x80024A18
		// End Line: 5041

		/* begin block 1.3 */
			// Start line: 5054
			// Start offset: 0x80024A6C
			// Variables:
				struct _Instance *inst1; // $v0
		/* end block 1.3 */
		// End offset: 0x80024A84
		// End Line: 5058
	/* end block 1 */
	// End offset: 0x80024A84
	// End Line: 5060

	/* begin block 2 */
		// Start line: 10030
	/* end block 2 */
	// End Line: 10031
#endif
				UNIMPLEMENTED();
	return 0;
}

short* COLLIDE_GetBSPTreeFlag(struct _CollideInfo* collideInfo)
{
	struct Level* level;
	struct _Terrain* terrain;
	struct BSPTree* bspTree;

	level = (struct Level*)collideInfo->level;

	terrain = level->terrain;

	bspTree = &terrain->BSPTreeArray[collideInfo->bspID];

	return &bspTree->flags;
}

void COLLIDE_SetBSPTreeFlag(struct _CollideInfo* collideInfo, short flag)
{
	short* bspTreeFlags;

	bspTreeFlags = COLLIDE_GetBSPTreeFlag(collideInfo);

	bspTreeFlags[0] |= flag;
}


// autogenerated function stub: 
// int /*$ra*/ COLLIDE_PointAndTfaceFunc(struct _Terrain *terrain /*$fp*/, struct BSPTree *bsp /*$s6*/, struct _SVector *orgNewPos /*$s7*/, struct _SVector *orgOldPos /*$t4*/, struct _TFace *tface /*stack 16*/, long ignoreAttr /*stack 20*/, long flags /*stack 24*/)
int COLLIDE_PointAndTfaceFunc(struct _Terrain *terrain, struct BSPTree *bsp, struct _SVector *orgNewPos, struct _SVector *orgOldPos, struct _TFace *tface, long ignoreAttr, long flags)
{ // line 5121, offset 0x80024afc
#if 0
	/* begin block 1 */
		// Start line: 5122
		// Start offset: 0x80024AFC
		// Variables:
			struct PandTFScratch *CSpad; // $s0
			int result; // stack offset -48

		/* begin block 1.1 */
			// Start line: 5141
			// Start offset: 0x80024B8C
			// Variables:
				struct _SVector *vertex0; // $s3
				struct _SVector *vertex1; // $s4

			/* begin block 1.1.1 */
				// Start line: 5144
				// Start offset: 0x80024B8C
				// Variables:
					short _x0; // $v0
					short _y0; // $v1
					short _z0; // $a1
					short _x1; // $a2
					short _y1; // $t0
					short _z1; // $t2
					struct _SVector *_v; // $t1
					_Position *_v1; // $a3
			/* end block 1.1.1 */
			// End offset: 0x80024B8C
			// End Line: 5144

			/* begin block 1.1.2 */
				// Start line: 5144
				// Start offset: 0x80024B8C
				// Variables:
					short _x0; // $v0
					short _y0; // $v1
					short _z0; // $a1
					short _x1; // $a2
					short _y1; // $t0
					short _z1; // $a3
					struct _SVector *_v; // $t3
			/* end block 1.1.2 */
			// End offset: 0x80024B8C
			// End Line: 5144

			/* begin block 1.1.3 */
				// Start line: 5144
				// Start offset: 0x80024B8C
				// Variables:
					short *nrmlArray; // $a1
					struct _SVector *nrml; // $a0

				/* begin block 1.1.3.1 */
					// Start line: 5144
					// Start offset: 0x80024B8C
					// Variables:
						short *sPtr; // $v1
				/* end block 1.1.3.1 */
				// End offset: 0x80024CCC
				// End Line: 5154
			/* end block 1.1.3 */
			// End offset: 0x80024CCC
			// End Line: 5154

			/* begin block 1.1.4 */
				// Start line: 5185
				// Start offset: 0x80024DE0
				// Variables:
					short _x0; // $v0
					short _y0; // $v1
					short _z0; // $a0
					short _x1; // $a1
					short _y1; // $a3
					short _z1; // $a2
					_Position *_v1; // $a2
			/* end block 1.1.4 */
			// End offset: 0x80024DE0
			// End Line: 5185
		/* end block 1.1 */
		// End offset: 0x80024E18
		// End Line: 5189
	/* end block 1 */
	// End offset: 0x80024E1C
	// End Line: 5192

	/* begin block 2 */
		// Start line: 10242
	/* end block 2 */
	// End Line: 10243
#endif
					UNIMPLEMENTED();
	return 0;
}




