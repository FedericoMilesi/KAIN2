#include "CORE.H"
#include "COLLIDE.H"

#include "MEMPACK.H"
#include "Game/STREAM.H"
#include "Game/BSP.H"
#include "Game/CAMERA.H"
#include "Game/MATH3D.H"

#ifdef PC_VERSION
#pragma warning(disable: 4101)
#endif

long collide_ignoreAttr;
long collide_acceptAttr;
long dyna_clddyna[8]; // offset 0x800d056c
long stat_clddyna[8]; // offset 0x800d058c
long dyna_cldstat[8]; // offset 0x800d05ac

void G2Quat_ToMatrix(struct _G2EulerAngles_Type* a1, struct _G2Matrix_Type* a2)
{
#if defined(PC_VERSION)
	int x; // ecx
	int y; // ebp
	int z; // ebx
	int order; // esi
	int v6; // edx
	int v7; // eax
	int v8; // ebx
	int v9; // edi
	int v10; // esi
	int v11; // [esp+10h] [ebp-Ch]
	int v12; // [esp+14h] [ebp-8h]
	int v13; // [esp+18h] [ebp-4h]
	int a1a; // [esp+20h] [ebp+4h]

	x = a1->x;
	y = a1->y;
	z = a1->z;
	order = a1->order;
	v6 = x * order;
	v11 = (z * order) >> 11;
	v12 = (x * x) >> 11;
	v7 = x * z;
	v13 = (y * z) >> 11;
	v8 = (y * y) >> 11;
	a1a = (a1->z * a1->z) >> 11;
	v9 = (x * y) >> 11;
	a2->rotScale[0][0] = 4096 - v8 - a1a;
	v10 = (y * order) >> 11;
	v7 >>= 11;
	a2->rotScale[0][1] = v9 - v11;
	a2->rotScale[0][2] = v7 + v10;
	a2->rotScale[1][0] = v11 + v9;
	a2->rotScale[1][1] = 4096 - v12 - a1a;
	v6 >>= 11;
	a2->rotScale[2][0] = v7 - v10;
	a2->rotScale[2][1] = v6 + v13;
	a2->rotScale[1][2] = v13 - v6;
	a2->rotScale[2][2] = 4096 - v12 - v8;
#else
	UNIMPLEMENTED();
#endif
}

// autogenerated function stub: 
// int /*$ra*/ COLLIDE_PointInTriangle(struct _SVector *v0 /*$a0*/, struct _SVector *v1 /*$a1*/, struct _SVector *v2 /*$a2*/, struct _SVector *point /*$a3*/, struct _SVector *normal /*stack 16*/)
int COLLIDE_PointInTriangle(struct _SVector* v0, struct _SVector* v1, struct _SVector* v2, struct _SVector* point, struct _SVector* normal)
{ // line 243, offset 0x8001e460
#if defined(PC_VERSION)
	struct _Triangle2D* triangle; // eax
	int x; // edi
	__int16 y; // cx
	int v8; // edx
	int v9; // ecx
	__int16* p_x; // ecx
	__int16 v11; // si
	__int16 z; // dx
	__int16 v13; // bx
	int v14; // edi
	__int16 v15; // bp
	int v16; // edx
	__int16 v17; // bx
	int v18; // eax
	int v19; // ecx
	int v20; // eax
	int v21; // zf
	int v23; // [esp+10h] [ebp-8h]
	__int16 v0a; // [esp+1Ch] [ebp+4h]
	int v1a; // [esp+20h] [ebp+8h]
	struct _SVector* v2a; // [esp+24h] [ebp+Ch]
	int normala; // [esp+2Ch] [ebp+14h]

	triangle = (struct _Triangle2D*)getScratchAddr(0);
	x = normal->x;
	if (normal->x < 0)
		x = -x;
	y = normal->y;
	v8 = y;
	if (y < 0)
		v8 = -y;
	v9 = normal->z;
	if (x <= v8)
	{
		v9 = (__int16)v9;
		if ((v9 & 0x8000u) != 0)
			v9 = -(__int16)v9;
		if (v8 > v9)
		{
			*(DWORD*)&triangle->x0 = (unsigned __int16)v0->x | (v0->z << 16);
			p_x = &triangle->x2;
			*(DWORD*)&triangle->x1 = (unsigned __int16)v1->x | (v1->z << 16);
			*(DWORD*)&triangle->x2 = (unsigned __int16)v2->x | (v2->z << 16);
			v11 = point->x;
			z = point->z;
			goto LABEL_15;
		}
	LABEL_14:
		*(DWORD*)&triangle->x0 = (unsigned __int16)v0->x | (v0->y << 16);
		p_x = &triangle->x2;
		*(DWORD*)&triangle->x1 = (unsigned __int16)v1->x | (v1->y << 16);
		*(DWORD*)&triangle->x2 = (unsigned __int16)v2->x | (v2->y << 16);
		v11 = point->x;
		z = point->y;
		goto LABEL_15;
	}
	v9 = (__int16)v9;
	if ((v9 & 0x8000u) != 0)
		v9 = -(__int16)v9;
	if (x <= v9)
		goto LABEL_14;
	*(DWORD*)&triangle->x0 = (v0->z << 16) | (unsigned __int16)v0->y;
	p_x = &triangle->x2;
	*(DWORD*)&triangle->x1 = (v1->z << 16) | (unsigned __int16)v1->y;
	*(DWORD*)&triangle->x2 = (v2->z << 16) | (unsigned __int16)v2->y;
	v11 = point->y;
	z = point->z;
LABEL_15:
	v0a = z;
	v13 = z;
	v2a = (struct _SVector*)triangle;
	v1a = 0;
	normala = 0;
	v23 = 3;
	v14 = p_x[1] >= z;
	do
	{
		v15 = triangle->y0;
		v16 = v15 >= v13;
		if (v14 == v16)
		{
			if (v14 && v13 == p_x[1])
			{
				if (v13 == v15)
				{
					if (v11 > *p_x != v11 > triangle->x0 || v11 == *p_x || v11 == triangle->x0)
						return 1;
					v13 = v0a;
				}
				else if (v11 == *p_x)
				{
					return 1;
				}
			}
			goto LABEL_36;
		}
		v17 = triangle->x0;
		if (*p_x >= v11 == triangle->x0 >= (unsigned __int16)v11)
		{
			if (*p_x >= v11)
				v1a = v1a == 0;
		}
		else
		{
			v18 = p_x[1] - v15;
			v19 = v18 * (v17 - v11) - (*p_x - v17) * (v15 - v0a);
			if (v18 < 0)
			{
				v18 = -v18;
				v19 = -v19;
			}
			v20 = v18 / 2;
			if (v19 <= v20)
			{
				if (v19 >= -v20)
					return 1;
			}
			else
			{
				v1a = v1a == 0;
			}
			triangle = (struct _Triangle2D*)v2a;
		}
		if (normala)
			break;
		v13 = v0a;
		normala = 1;
	LABEL_36:
		v14 = v16;
		p_x = &triangle->x0;
		triangle = (struct _Triangle2D*)((char*)triangle + 4);
		v21 = v23 == 1;
		v2a = (struct _SVector*)triangle;
		--v23;
	} while (!v21);
	return v1a;
#else
UNIMPLEMENTED();
	return 0;
#endif
}

int COLLIDE_PointInTriangle2DPub(short* v0, short* v1, short* v2, short* point)
{
#if defined(PSX_VERSION)
	struct _SVector normal;

	normal.x = 0;
	normal.y = 0;
	normal.z = 4096;

	return COLLIDE_PointInTriangle((struct _SVector*)v0, (struct _SVector*)v1, (struct _SVector*)v2, (struct _SVector*)point, (struct _SVector*)&normal);

#elif defined(PC_VERSION)
	struct _SVector normal; // [esp+0h] [ebp-8h] BYREF

	normal.z = 4096;
	normal.x = 0;
	normal.y = 0;
	normal.pad = 0;
	return COLLIDE_PointInTriangle(
		(struct _SVector*)v0,
		(struct _SVector*)v1,
		(struct _SVector*)v2,
		(struct _SVector*)point,
		&normal);
#endif
}

long COLLIDE_GetNormal(short nNum, short* nrmlArray, struct _SVector* nrml)//Matching - 99.87%
{
#if defined(PSX_VERSION)
	short* sPtr;
	long bitMask;

	if (nNum >= 0)
	{
		sPtr = &nrmlArray[nNum * 3];

		bitMask = *sPtr++;

		nrml->x = bitMask & 0x1FFF;
		nrml->y = *sPtr++;
		nrml->z = *sPtr;

		bitMask >>= 13;
	}
	else
	{
		sPtr = &nrmlArray[-nNum * 3];
		bitMask = *sPtr++;

		nrml->x = -(bitMask & 0x1FFF);
		nrml->y = -(*sPtr++);
		nrml->z = -(*sPtr);

		bitMask >>= 13;
	}

	return bitMask;

#elif defined(PC_VERSION)
	__int16 v3; // dx
	int result; // eax
	__int16* v5; // ecx
	__int16 v6; // dx

	if (nNum < 0)
	{
		v5 = &nrmlArray[-3 * nNum];
		v6 = *v5++;
		nrml->x = -(v6 & 0x1FFF);
		nrml->y = -*v5;
		nrml->z = -v5[1];
		return v6 >> 13;
	}
	else
	{
		v3 = nrmlArray[3 * nNum];
		result = v3 >> 13;
		nrml->x = v3 & 0x1FFF;
		nrml->y = nrmlArray[3 * nNum + 1];
		nrml->z = nrmlArray[3 * nNum + 2];
	}
	return result;
#endif
}

void COLLIDE_MakeNormal(struct _Terrain* terrain, struct _TFace* tface, struct _SVector* normal)
{
#if defined(PSX_VERSION)
	UNIMPLEMENTED();
#elif defined(PC_VERSION)
	struct _Vector* ScratchAddr; // esi
	DWORD* v4; // edi
	int* v5; // ebx
	struct _TVertex* vertexList; // edx
	struct _TVertex* v7; // ecx
	struct _TVertex* v8; // edx
	int z; // eax
	int v10; // edx
	int v11; // eax
	int v12; // eax
	int v13; // ecx
	int v14; // sf
	int v15; // edi
	int v16; // esi
	int v17; // edx
	int v18; // edx
	struct _Terrain* terraina; // [esp+14h] [ebp+4h]

	ScratchAddr = (struct _Vector*)getScratchAddr(0);
	v4 = (DWORD*)getScratchAddr(4);
	v5 = (int*)getScratchAddr(8);
	vertexList = terrain->vertexList;
	v7 = &vertexList[tface->face.v0];
	terraina = (struct _Terrain*)&vertexList[tface->face.v1];
	v8 = &vertexList[tface->face.v2];
	ScratchAddr->x = terraina->UnitChangeFlags - v7->vertex.x;
	ScratchAddr->y = terraina->spad - v7->vertex.y;
	ScratchAddr->z = terraina->lpad2 - v7->vertex.z;
	*v4 = v8->vertex.x - v7->vertex.x;
	v4[1] = v8->vertex.y - v7->vertex.y;
	z = v8->vertex.z;
	v10 = v4[1];
	v11 = z - v7->vertex.z;
	v4[2] = v11;
	*v5 = (__int16)((ScratchAddr->y * v11 - ScratchAddr->z * v10) >> 12);
	v5[1] = -(__int16)((v4[2] * ScratchAddr->x - ScratchAddr->z * *v4) >> 12);
	v12 = *v5;
	v13 = (__int16)((v4[1] * ScratchAddr->x - ScratchAddr->y * *v4) >> 12);
	v14 = *v5 < 0;
	v5[2] = v13;
	v15 = v12;
	if (v14)
		v15 = -v12;
	v16 = v5[1];
	v17 = v16;
	if (v16 < 0)
		v17 = -v16;
	if (v15 <= v17)
	{
		if (v16 >= 0)
			goto LABEL_10;
	}
	else
	{
		v16 = v12;
		if (v12 >= 0)
			goto LABEL_10;
	}
	v16 = -v16;
LABEL_10:
	v18 = v13;
	if (v13 < 0)
		v18 = -v13;
	if (v18 > v16)
	{
		if (v13 < 0)
			v13 = -v13;
		v16 = v13;
	}
	if (v16)
	{
		normal->x = (v12 << 12) / v16;
		normal->y = (v5[1] << 12) / v16;
		normal->z = (v5[2] << 12) / v16;
	}
#endif
}


// autogenerated function stub: 
// void /*$ra*/ COLLIDE_UpdateAllTransforms(struct _Instance *instance /*$a0*/, SVECTOR*offset /*$a1*/)
void COLLIDE_UpdateAllTransforms(struct _Instance *instance, SVECTOR*offset)
{ // line 415, offset 0x8001e9c0
#if defined(PC_VERSION)
#ifndef PC_VERSION
	MATRIX* matrix; // ebx
	int vx; // edx
	int vy; // esi
	int vz; // edi
	struct Object* object; // eax
	struct _Model* v7; // ecx
	MATRIX* v8; // eax
	int numSegments; // ecx
	struct _Model* v10; // ecx
	__int32* v11; // eax
	__int32 v12; // ebp
	__int32 v13; // ebx

	matrix = instance->matrix;
	if (matrix)
	{
		vx = offset->vx;
		vy = offset->vy;
		vz = offset->vz;
		object = instance->object;
		if (!object->animList || (object->oflags2 & 0x40000000) != 0)
		{
			v10 = object->modelList[instance->currentModel];
			v8 = instance->matrix;
			numSegments = v10->numSegments;
		}
		else
		{
			v7 = object->modelList[instance->currentModel];
			v8 = matrix - 1;
			numSegments = v7->numSegments + 1;
		}
		if (numSegments)
		{
			v11 = &v8->t[1];
			do
			{
				v12 = vy + *v11;
				*(v11 - 1) += vx;
				v13 = vz + v11[1];
				*v11 = v12;
				v11[1] = v13;
				v11 += 8;
				--numSegments;
			} while (numSegments);
		}
	}
#endif
#else
	UNIMPLEMENTED();
#endif
}

void COLLIDE_MoveAllTransforms(struct _Instance* instance, struct _Position* offset)
{
#if defined(PSX_VERSION)
	UNIMPLEMENTED();
#elif defined(PC_VERSION)
#ifndef PC_VERSION
	MATRIX* oldMatrix; // ebx
	int x; // edx
	int y; // esi
	int z; // edi
	struct Object* object; // eax
	struct _Model* v7; // ecx
	MATRIX* v8; // eax
	int numSegments; // ecx
	struct _Model* v10; // ecx
	__int32* v11; // eax
	__int32 v12; // ebp
	__int32 v13; // ebx

	oldMatrix = instance->oldMatrix;
	if (oldMatrix)
	{
		x = offset->x;
		y = offset->y;
		z = offset->z;
		object = instance->object;
		if (!object->animList || (object->oflags2 & 0x40000000) != 0)
		{
			v10 = object->modelList[instance->currentModel];
			v8 = instance->oldMatrix;
			numSegments = v10->numSegments;
		}
		else
		{
			v7 = object->modelList[instance->currentModel];
			v8 = oldMatrix - 1;
			numSegments = v7->numSegments + 1;
		}
		if (numSegments)
		{
			v11 = &v8->t[1];
			do
			{
				v12 = y + *v11;
				*(v11 - 1) += x;
				v13 = z + v11[1];
				*v11 = v12;
				v11[1] = v13;
				v11 += 8;
				--numSegments;
			} while (numSegments);
		}
	}
#endif
#else
	UNIMPLEMENTED();
#endif
}

long COLLIDE_WithinYZBounds(struct _SVector* point, struct _HBox* hbox)//Matching - 86.52%
{
	if (point->y >= hbox->minY && hbox->maxY >= point->y)
	{
		if (point->z >= hbox->minZ)
		{
			return hbox->maxZ >= point->z;
		}
	}
	return 0;
}

long COLLIDE_WithinXZBounds(struct _SVector* point, struct _HBox* hbox)
{
	if (point->x >= hbox->minX && hbox->maxX >= point->x)
	{
		if (point->z >= hbox->minZ)
		{
			return hbox->maxZ >= point->z;
		}
	}
	return 0;
}

long COLLIDE_WithinXYBounds(struct _SVector* point, struct _HBox* hbox)
{
	if (point->x >= hbox->minX && hbox->maxX >= point->x)
	{
		if (point->y >= hbox->minY)
		{
			return hbox->maxY >= point->y;
		}
	}
	return 0;
}


// autogenerated function stub: 
// void /*$ra*/ COLLIDE_LineWithBoxFace(short startDist /*$a0*/, long lineDist /*$a1*/, short planeDist /*$a2*/, struct _SVector *start /*$a3*/, struct _Vector *line /*stack 16*/, struct _HBox *hbox /*stack 20*/, TDRFuncPtr_COLLIDE_LineWithBoxFace6collideBoundFunc collideBoundFunc /*stack 24*/, struct _SVector *normal /*stack 28*/)
void COLLIDE_LineWithBoxFace(short startDist, long lineDist, short planeDist, struct _SVector *start, struct _Vector *line, struct _HBox *hbox, TDRFuncPtr_COLLIDE_LineWithBoxFace6collideBoundFunc collideBoundFunc, struct _SVector *normal)
{ // line 611, offset 0x8001ec74
#if 0
	/* begin block 1 */
		// Start line: 612
		// Start offset: 0x8001EC74
		// Variables:
			struct _SVector point; // stack offset -24
			long t; // stack offset -16

		/* begin block 1.1 */
			// Start line: 612
			// Start offset: 0x8001ED38
			// Variables:
				struct _SVector *point; // $t1
				struct _SVector *normal; // $s0
				struct _SVector *point0; // $a2
				struct _SVector *normal0; // $a3
				struct _SVector *point1; // $a1
				struct _SVector *normal1; // $t0

			/* begin block 1.1.1 */
				// Start line: 612
				// Start offset: 0x8001ED38

				/* begin block 1.1.1.1 */
					// Start line: 612
					// Start offset: 0x8001ED5C
					// Variables:
						short _z1; // $a0
						short _y1; // $v1
						short _x1; // $v0
				/* end block 1.1.1.1 */
				// End offset: 0x8001ED5C
				// End Line: 612

				/* begin block 1.1.1.2 */
					// Start line: 612
					// Start offset: 0x8001ED5C
					// Variables:
						short _z1; // $a0
						short _y1; // $v1
						short _x1; // $v0
				/* end block 1.1.1.2 */
				// End offset: 0x8001ED5C
				// End Line: 612

				/* begin block 1.1.1.3 */
					// Start line: 612
					// Start offset: 0x8001ED5C
					// Variables:
						short _z1; // $a0
						short _y1; // $v1
						short _x1; // $v0
				/* end block 1.1.1.3 */
				// End offset: 0x8001ED5C
				// End Line: 612

				/* begin block 1.1.1.4 */
					// Start line: 612
					// Start offset: 0x8001ED5C
					// Variables:
						short _z1; // $a0
						short _y1; // $v1
						short _x1; // $v0
				/* end block 1.1.1.4 */
				// End offset: 0x8001ED5C
				// End Line: 612

				/* begin block 1.1.1.5 */
					// Start line: 612
					// Start offset: 0x8001EDDC
					// Variables:
						short _z1; // $a0
						short _y1; // $v1
						short _x1; // $v0
				/* end block 1.1.1.5 */
				// End offset: 0x8001EDDC
				// End Line: 612

				/* begin block 1.1.1.6 */
					// Start line: 612
					// Start offset: 0x8001EDDC
					// Variables:
						short _z1; // $a0
						short _y1; // $v1
						short _x1; // $v0
				/* end block 1.1.1.6 */
				// End offset: 0x8001EDDC
				// End Line: 612
			/* end block 1.1.1 */
			// End offset: 0x8001EE10
			// End Line: 612
		/* end block 1.1 */
		// End offset: 0x8001EE10
		// End Line: 612
	/* end block 1 */
	// End offset: 0x8001EE10
	// End Line: 643

	/* begin block 2 */
		// Start line: 1111
	/* end block 2 */
	// End Line: 1112
#else
UNIMPLEMENTED();
#endif
}


// autogenerated function stub: 
// long /*$ra*/ COLLIDE_IntersectLineAndBox(struct _SVector *point0 /*$a0*/, struct _SVector *normal0 /*$a1*/, struct _SVector *point1 /*$a2*/, struct _SVector *normal1 /*$a3*/, struct _SVector *end /*stack 16*/, struct _SVector *start /*stack 20*/, struct _HBox *hbox /*stack 24*/)
long COLLIDE_IntersectLineAndBox(struct _SVector *point0, struct _SVector *normal0, struct _SVector *point1, struct _SVector *normal1, struct _SVector *end, struct _SVector *start, struct _HBox *hbox)
{ // line 650, offset 0x8001ee20
#if 0
	/* begin block 1 */
		// Start line: 651
		// Start offset: 0x8001EE20
		// Variables:
			struct _SVector normal; // stack offset -64
			struct _Vector line; // stack offset -56

		/* begin block 1.1 */
			// Start line: 651
			// Start offset: 0x8001EE20
			// Variables:
				long _x0; // $a1
				long _y0; // $a2
				long _z0; // $a0
				long _x1; // $v0
				long _y1; // $v0
				long _z1; // $v1
				struct _Vector *_v; // $s3
		/* end block 1.1 */
		// End offset: 0x8001EE20
		// End Line: 651
	/* end block 1 */
	// End offset: 0x8001F070
	// End Line: 711

	/* begin block 2 */
		// Start line: 1201
	/* end block 2 */
	// End Line: 1202
#else
	UNIMPLEMENTED();
#endif
	return 0;
}

struct _TFace* COLLIDE_PointAndTerrain(struct _Terrain* terrain, struct _PCollideInfo* pcollideInfo, struct _LCollideInfo* lcol)
{
	return COLLIDE_PointAndTerrainFunc(terrain, pcollideInfo, 0, NULL, 0, 0, lcol);
}


// autogenerated function stub: 
// struct _TFace * /*$ra*/ COLLIDE_PointAndTerrainFunc(struct _Terrain *terrain /*$t2*/, struct _PCollideInfo *pCollideInfo /*stack 4*/, int Flags /*$a2*/, short *Backface_Flag /*$a3*/, long ignoreAttr /*stack 16*/, long acceptAttr /*stack 20*/, struct _LCollideInfo *lcolinfo /*stack 24*/)
struct _TFace * COLLIDE_PointAndTerrainFunc(struct _Terrain *terrain, struct _PCollideInfo *pCollideInfo, int Flags, short *Backface_Flag, long ignoreAttr, long acceptAttr, struct _LCollideInfo *lcolinfo)
{ // line 780, offset 0x8001f0cc
#if 0
	/* begin block 1 */
		// Start line: 781
		// Start offset: 0x8001F0CC
		// Variables:
			struct PandTScratch *CSpad; // $s0
			void **stack; // $s1
			struct _BSPNode *bspNode; // $a1
			int curTree; // stack offset -48
			struct _SVector *NewPos; // stack offset -80
			struct _SVector *OldPos; // $a0
			struct _Instance *instance; // $s7

		/* begin block 1.1 */
			// Start line: 781
			// Start offset: 0x8001F0CC
			// Variables:
				short _x1; // $a3
				short _y1; // $t0
				short _z1; // $t1
				struct _SVector *_v0; // $v1
		/* end block 1.1 */
		// End offset: 0x8001F0CC
		// End Line: 781

		/* begin block 1.2 */
			// Start line: 781
			// Start offset: 0x8001F0CC
			// Variables:
				short _x1; // $v0
				short _y1; // $v1
				short _z1; // $a0
				struct _SVector *_v0; // $a2
		/* end block 1.2 */
		// End offset: 0x8001F0CC
		// End Line: 781

		/* begin block 1.3 */
			// Start line: 781
			// Start offset: 0x8001F0CC
			// Variables:
				struct _SVector *_v; // $a1
		/* end block 1.3 */
		// End offset: 0x8001F0CC
		// End Line: 781

		/* begin block 1.4 */
			// Start line: 837
			// Start offset: 0x8001F22C
			// Variables:
				struct BSPTree *bsp; // $s4

			/* begin block 1.4.1 */
				// Start line: 865
				// Start offset: 0x8001F328
				// Variables:
					short _x0; // $v0
					short _y0; // $v1
					short _z0; // $a0
					short _x1; // $a1
					short _y1; // $a2
					short _z1; // $t0
					struct _SVector *_v; // $s6
					_Position *_v1; // $a3
			/* end block 1.4.1 */
			// End offset: 0x8001F328
			// End Line: 865

			/* begin block 1.4.2 */
				// Start line: 865
				// Start offset: 0x8001F328
				// Variables:
					short _x0; // $v0
					short _y0; // $v1
					short _z0; // $a0
					short _x1; // $a1
					short _y1; // $a2
					short _z1; // $a3
					struct _SVector *_v; // $s5
			/* end block 1.4.2 */
			// End offset: 0x8001F328
			// End Line: 865

			/* begin block 1.4.3 */
				// Start line: 898
				// Start offset: 0x8001F558
				// Variables:
					struct _TFace *tface; // $s3

				/* begin block 1.4.3.1 */
					// Start line: 905
					// Start offset: 0x8001F5A4
					// Variables:
						struct _SVector *vertex0; // $a0

					/* begin block 1.4.3.1.1 */
						// Start line: 781
						// Start offset: 0x8001F62C
						// Variables:
							short *nrmlArray; // $a0
							struct _SVector *nrml; // $a1

						/* begin block 1.4.3.1.1.1 */
							// Start line: 781
							// Start offset: 0x8001F62C
							// Variables:
								short *sPtr; // $v1
						/* end block 1.4.3.1.1.1 */
						// End offset: 0x8001F6BC
						// End Line: 781
					/* end block 1.4.3.1.1 */
					// End offset: 0x8001F6BC
					// End Line: 781

					/* begin block 1.4.3.1.2 */
						// Start line: 781
						// Start offset: 0x8001F768
						// Variables:
							struct _SVector *point; // $t0
							struct _SVector *start; // $a3
							struct _SVector *line; // $a2

						/* begin block 1.4.3.1.2.1 */
							// Start line: 781
							// Start offset: 0x8001F768
							// Variables:
								long len; // $v1
								long t; // $a1
						/* end block 1.4.3.1.2.1 */
						// End offset: 0x8001F7A0
						// End Line: 781
					/* end block 1.4.3.1.2 */
					// End offset: 0x8001F7A0
					// End Line: 781

					/* begin block 1.4.3.1.3 */
						// Start line: 950
						// Start offset: 0x8001F8CC
						// Variables:
							short _x0; // $v0
							short _y0; // $v1
							short _z0; // $a1
							short _x1; // $a0
							short _y1; // $a3
							short _z1; // $a2
							_Position *_v1; // $a2
					/* end block 1.4.3.1.3 */
					// End offset: 0x8001F8CC
					// End Line: 950

					/* begin block 1.4.3.1.4 */
						// Start line: 1015
						// Start offset: 0x8001F970
						// Variables:
							short _x0; // $v0
							short _y0; // $v1
							short _z0; // $a1
							short _x1; // $a0
							short _y1; // $a2
							short _z1; // $a3
							struct _SVector *_v; // $fp
					/* end block 1.4.3.1.4 */
					// End offset: 0x8001F970
					// End Line: 1015
				/* end block 1.4.3.1 */
				// End offset: 0x8001F9F4
				// End Line: 1036
			/* end block 1.4.3 */
			// End offset: 0x8001FA34
			// End Line: 1049

			/* begin block 1.4.4 */
				// Start line: 1053
				// Start offset: 0x8001FA34
				// Variables:
					int plane_front_error; // $v1
					int plane_back_error; // $a0
			/* end block 1.4.4 */
			// End offset: 0x8001FB84
			// End Line: 1120

			/* begin block 1.4.5 */
				// Start line: 1124
				// Start offset: 0x8001FB94
				// Variables:
					short _x0; // $v0
					short _y0; // $v1
					short _z0; // $a0
					short _x1; // $a1
					short _y1; // $a2
					short _z1; // $t0
					_Position *_v1; // $a3
			/* end block 1.4.5 */
			// End offset: 0x8001FB94
			// End Line: 1124

			/* begin block 1.4.6 */
				// Start line: 1124
				// Start offset: 0x8001FB94
				// Variables:
					short _x0; // $v0
					short _y0; // $v1
					short _z0; // $a0
					short _x1; // $a1
					short _y1; // $a2
					short _z1; // $a3
			/* end block 1.4.6 */
			// End offset: 0x8001FBF8
			// End Line: 1125
		/* end block 1.4 */
		// End offset: 0x8001FBF8
		// End Line: 1126

		/* begin block 1.5 */
			// Start line: 1127
			// Start offset: 0x8001FC10
			// Variables:
				short _x1; // $v1
				short _y1; // $a0
				short _z1; // $v0
				struct _SVector *_v1; // $v0
		/* end block 1.5 */
		// End offset: 0x8001FC10
		// End Line: 1127
	/* end block 1 */
	// End offset: 0x8001FC10
	// End Line: 1127

	/* begin block 2 */
		// Start line: 1540
	/* end block 2 */
	// End Line: 1541
#endif
	UNIMPLEMENTED();
	return null;
}


// autogenerated function stub: 
// int /*$ra*/ COLLIDE_PointAndHFace(struct _SVector *newPos /*$s4*/, struct _SVector *oldPos /*$s6*/, struct _HFace *hface /*$s5*/, struct _Model *model /*$s7*/, struct _SVector *hfNormal /*stack 16*/)
int COLLIDE_PointAndHFace(struct _SVector *newPos, struct _SVector *oldPos, struct _HFace *hface, struct _Model *model, struct _SVector *hfNormal)
{ // line 1330, offset 0x8001fc64
#if 0
	/* begin block 1 */
		// Start line: 1331
		// Start offset: 0x8001FC64
		// Variables:
			MATRIX *posMatrix; // $s1
			struct _SVector *normal; // $s3
			struct _Vector *dpv; // $s2
			struct _SVector *planePoint; // stack offset -48
			struct _SVector *vertex0; // $s0
			struct _SVector *vertex1; // $s1

		/* begin block 1.1 */
			// Start line: 1341
			// Start offset: 0x8001FCD0
			// Variables:
				short _x0; // $v0
				short _y0; // $v1
				short _z0; // $a1
				short _x1; // $a2
				short _y1; // $a3
				short _z1; // $t0
		/* end block 1.1 */
		// End offset: 0x8001FCD0
		// End Line: 1341

		/* begin block 1.2 */
			// Start line: 1341
			// Start offset: 0x8001FCD0
			// Variables:
				short _x0; // $v0
				short _y0; // $v1
				short _z0; // $a1
				short _x1; // $a2
				short _y1; // $a3
				short _z1; // $t0
				struct _SVector *_v; // $t1
		/* end block 1.2 */
		// End offset: 0x8001FCD0
		// End Line: 1341

		/* begin block 1.3 */
			// Start line: 1341
			// Start offset: 0x8001FCD0
			// Variables:
				short _x1; // $v0
				short _y1; // $v1
				short _z1; // $a1
				struct _SVector *_v0; // $t3
		/* end block 1.3 */
		// End offset: 0x8001FCD0
		// End Line: 1341
	/* end block 1 */
	// End offset: 0x8001FE7C
	// End Line: 1378

	/* begin block 2 */
		// Start line: 3219
	/* end block 2 */
	// End Line: 3220
#endif
				UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// void /*$ra*/ COLLIDE_PointAndInstance(struct _PCollideInfo *pcollideInfo /*$s4*/, struct _Instance *instance /*stack 4*/)
void COLLIDE_PointAndInstance(struct _PCollideInfo *pcollideInfo, struct _Instance *instance)
{ // line 1389, offset 0x8001feac
#if 0
	/* begin block 1 */
		// Start line: 1390
		// Start offset: 0x8001FEAC
		// Variables:
			MATRIX *swTransform; // stack offset -92
			MATRIX *wsTransform; // stack offset -88
			MATRIX *swNormMat; // $fp
			struct _Vector *oldPosVec; // stack offset -84
			struct _Vector *lNormal; // stack offset -80
			struct _Vector *wNormal; // stack offset -76
			struct _Vector *dv; // $s2
			struct _Vector *newPosVec; // $s5
			struct _SVector *oldPos; // stack offset -72
			struct _SVector *newPos; // $s3
			struct _SVector *point; // stack offset -68
			long *flag; // stack offset -64
			struct _Model *model; // stack offset -60
			struct _HModel *hmodel; // $v0
			struct _HPrim *hprim; // stack offset -56
			int i; // stack offset -52
			long collideType; // stack offset -48

		/* begin block 1.1 */
			// Start line: 1416
			// Start offset: 0x8001FFCC
			// Variables:
				struct _HBox *hbox; // $s0
				struct _HFace *hface; // $s1
				struct _HSphere *hsphere; // $s0

			/* begin block 1.1.1 */
				// Start line: 1419
				// Start offset: 0x8001FFCC
				// TypeDefs:
					struct COLLIDE_258fake tmm
			/* end block 1.1.1 */
			// End offset: 0x8001FFCC
			// End Line: 1419

			/* begin block 1.1.2 */
				// Start line: 1452
				// Start offset: 0x80020184
				// Variables:
					long len; // $t0

				/* begin block 1.1.2.1 */
					// Start line: 1453
					// Start offset: 0x80020184
					// Variables:
						long a; // stack offset -104
						long b; // stack offset -100
						long c; // stack offset -96
				/* end block 1.1.2.1 */
				// End offset: 0x80020184
				// End Line: 1453
			/* end block 1.1.2 */
			// End offset: 0x80020248
			// End Line: 1459

			/* begin block 1.1.3 */
				// Start line: 1488
				// Start offset: 0x800203F0
				// Variables:
					struct _SVector hfNormal; // stack offset -136
			/* end block 1.1.3 */
			// End offset: 0x80020418
			// End Line: 1494

			/* begin block 1.1.4 */
				// Start line: 1509
				// Start offset: 0x80020450
				// Variables:
					struct _SVector hbNormal; // stack offset -136
					struct _SVector point0; // stack offset -128
					struct _SVector point1; // stack offset -120
					struct _SVector normal1; // stack offset -112

				/* begin block 1.1.4.1 */
					// Start line: 1551
					// Start offset: 0x80020590
					// Variables:
						short _x1; // $v0
						short _y1; // $v1
						short _z1; // $a3
				/* end block 1.1.4.1 */
				// End offset: 0x80020590
				// End Line: 1551
			/* end block 1.1.4 */
			// End offset: 0x800205D8
			// End Line: 1561
		/* end block 1.1 */
		// End offset: 0x80020690
		// End Line: 1580
	/* end block 1 */
	// End offset: 0x800206B0
	// End Line: 1582

	/* begin block 2 */
		// Start line: 3368
	/* end block 2 */
	// End Line: 3369
#endif
						UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ COLLIDE_PointAndInstanceTrivialReject(struct _PCollideInfo *pcollideInfo /*$s3*/, struct _Instance *instance /*$s1*/)
void COLLIDE_PointAndInstanceTrivialReject(struct _PCollideInfo *pcollideInfo, struct _Instance *instance)
{ // line 1584, offset 0x800206e0
	/* begin block 1 */
		// Start line: 1585
		// Start offset: 0x800206E0
		// Variables:
			struct _Vector *dv; // $s2
			struct _SVector linePoint; // stack offset -32

		/* begin block 1.1 */
			// Start line: 1596
			// Start offset: 0x80020768
			// Variables:
				long _x0; // $a2
				long _y0; // $v1
				long _z0; // $v0
				long _x1; // $v0
				long _y1; // $v0
				long _z1; // $a0
				struct _SVector *_v0; // $a0
		/* end block 1.1 */
		// End offset: 0x80020768
		// End Line: 1596
	/* end block 1 */
	// End offset: 0x80020848
	// End Line: 1633

	/* begin block 2 */
		// Start line: 4060
	/* end block 2 */
	// End Line: 4061
				UNIMPLEMENTED();
}

void COLLIDE_PointAndWorld(struct _PCollideInfo* pcollideInfo, struct Level* level)//Matching - 92.67%
{
	struct _Instance* instance;
	struct _InstanceList* instanceList;
	struct _LCollideInfo lcol;
	int i;
	int in_warpRoom;
	struct _TFace* tface;
	struct _Terrain* terrain;
	struct Level* thislevel;

	in_warpRoom = 0;

	pcollideInfo->type = 0;

	if ((pcollideInfo->collideType & 0x1))
	{
		tface = NULL;

		if (level != NULL && MEMPACK_MemoryValidFunc((char*)level))
		{
			terrain = level->terrain;

			tface = COLLIDE_PointAndTerrain(terrain, pcollideInfo, &lcol);

			if (tface != NULL)
			{
				pcollideInfo->type = 3;
				pcollideInfo->prim = tface;
				pcollideInfo->inst = (struct _Instance*)level;
				pcollideInfo->segment = lcol.curTree;

				if (gameTrackerX.gameData.asmData.MorphTime != 1000)
				{
					COLLIDE_MakeNormal(terrain, tface, (struct _SVector*)&pcollideInfo->wNormal);
				}
				else
				{
					COLLIDE_GetNormal(tface->normal, &terrain->normalList->x, (struct _SVector*)&pcollideInfo->wNormal);
				}
			}
			else if ((STREAM_GetStreamUnitWithID(level->streamUnitID)->flags & 0x1) != 0)
			{
				in_warpRoom = 1;
			}
		}
		if (tface == NULL)
		{
			for (i = 0; i < 16; i++)
			{
				thislevel = StreamTracker.StreamList[i].level;

				if (StreamTracker.StreamList[i].used == 2 && thislevel != level && (!in_warpRoom || !(StreamTracker.StreamList[i].flags & 0x1)))
				{
					if (MEMPACK_MemoryValidFunc((char*)thislevel))
					{
						terrain = thislevel->terrain;

						tface = COLLIDE_PointAndTerrain(terrain, pcollideInfo, &lcol);

						if (tface != NULL)
						{
							pcollideInfo->type = 3;
							pcollideInfo->prim = tface;
							pcollideInfo->inst = (struct _Instance*)thislevel;
							pcollideInfo->segment = lcol.curTree;

							if (gameTrackerX.gameData.asmData.MorphTime != 1000)
							{
								COLLIDE_MakeNormal(terrain, tface, (struct _SVector*)&pcollideInfo->wNormal);
							}
							else
							{
								COLLIDE_GetNormal((short)tface->normal, &terrain->normalList->x, (struct _SVector*)&pcollideInfo->wNormal);
							}
							break;
						}
					}
				}
			}

			if (tface == NULL)
			{
				pcollideInfo->type = 0;
				pcollideInfo->prim = 0;
				pcollideInfo->inst = 0;
				pcollideInfo->wNormal.vx = 0;
				pcollideInfo->wNormal.vy = 0;
				pcollideInfo->wNormal.vz = 0;
			}
		}
	}

	instanceList = gameTrackerX.instanceList;

	if ((pcollideInfo->collideType & 0x8) != 0)
	{
		for (i = 16; i < 32; i++)
		{
			instance = (struct _Instance*)instanceList->group[i].next;

			while (instance)
			{
				if ((instance->flags2 & 0x24000000) == 0)
				{
					COLLIDE_PointAndInstanceTrivialReject(pcollideInfo, instance);
				}

				instance = (struct _Instance*)instance->node.next;
			}
		}
	}
	else if ((pcollideInfo->collideType & 0x10) != 0)
	{
		if ((pcollideInfo->collideType & 0x2) != 0)
		{
			for (i = 0; i < 8; i++)
			{
				instance = (struct _Instance*)instanceList->group[stat_clddyna[i]].next;

				while (instance)
				{
					if ((instance->flags2 & 0x24000000) == 0)
					{
						COLLIDE_PointAndInstanceTrivialReject(pcollideInfo, instance);
					}

					instance = (struct _Instance*)instance->node.next;
				}
			}
		}
		if ((pcollideInfo->collideType & 0x4) != 0)
		{
			for (i = 0; i < 8; i++)
			{
				instance = (struct _Instance*)instanceList->group[dyna_clddyna[i]].next;

				while (instance)
				{
					if ((instance->flags2 & 0x24000000) == 0)
					{
						COLLIDE_PointAndInstanceTrivialReject(pcollideInfo, instance);
					}

					instance = (struct _Instance*)instance->node.next;
				}
			}
		}
	}
	else
	{
		if ((pcollideInfo->collideType & 0x4))
		{
			for (i = 0; i < 8; i++)
			{
				instance = (struct _Instance*)instanceList->group[dyna_cldstat[i]].next;

				while (instance)
				{
					if ((instance->flags2 & 0x24000000) == 0)
					{
						COLLIDE_PointAndInstanceTrivialReject(pcollideInfo, instance);
					}

					instance = (struct _Instance*)instance->node.next;
				}
			}
		}
	}
}

// autogenerated function stub: 
// long /*$ra*/ COLLIDE_ClosestPointInBoxToPoint(_Position *boxPoint /*$a0*/, struct _HBox *hbox /*$a1*/, struct _SVector *point /*$a2*/)
long COLLIDE_ClosestPointInBoxToPoint(_Position *boxPoint, struct _HBox *hbox, struct _SVector *point)
{ // line 1893, offset 0x80020c4c
	/* begin block 1 */
		// Start line: 1895
		// Start offset: 0x80020C4C
		// Variables:
			long inside; // $a3
	/* end block 1 */
	// End offset: 0x80020D18
	// End Line: 1941

	/* begin block 2 */
		// Start line: 4803
	/* end block 2 */
	// End Line: 4804

	/* begin block 3 */
		// Start line: 4804
	/* end block 3 */
	// End Line: 4805

	/* begin block 4 */
		// Start line: 4806
	/* end block 4 */
	// End Line: 4807
			UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// long /*$ra*/ COLLIDE_SphereAndPoint(struct _Sphere *sphere /*$s1*/, struct _SVector *point /*$s2*/, struct _SVector *normal /*$s3*/)
long COLLIDE_SphereAndPoint(struct _Sphere *sphere, struct _SVector *point, struct _SVector *normal)
{ // line 1944, offset 0x80020d20
	/* begin block 1 */
		// Start line: 1945
		// Start offset: 0x80020D20
		// Variables:
			long len; // $a2
			struct _Vector *line; // $s0

		/* begin block 1.1 */
			// Start line: 1945
			// Start offset: 0x80020D20
			// Variables:
				long _x0; // $a2
				long _y0; // $a1
				long _z0; // $a0
				long _x1; // $v0
				long _y1; // $v0
				long _z1; // $v0
		/* end block 1.1 */
		// End offset: 0x80020D20
		// End Line: 1945

		/* begin block 1.2 */
			// Start line: 1953
			// Start offset: 0x80020DB4
			// Variables:
				long a; // stack offset -40
				long b; // stack offset -36
				long c; // stack offset -32
		/* end block 1.2 */
		// End offset: 0x80020DB4
		// End Line: 1953
	/* end block 1 */
	// End offset: 0x80020F48
	// End Line: 1970

	/* begin block 2 */
		// Start line: 4905
	/* end block 2 */
	// End Line: 4906
				UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// long /*$ra*/ COLLIDE_SphereAndHBox(struct _HBox *hbox /*$s4*/, struct _Sphere *sphere /*$s1*/, _Position *oldPos /*$s5*/, struct _SVector *normal /*$s3*/)
long COLLIDE_SphereAndHBox(struct _HBox *hbox, struct _Sphere *sphere, _Position *oldPos, struct _SVector *normal)
{ // line 1975, offset 0x80020f64
#if 0
	/* begin block 1 */
		// Start line: 1976
		// Start offset: 0x80020F64
		// Variables:
			struct _SVector point; // stack offset -96
			struct _SVector point0; // stack offset -88
			struct _SVector point1; // stack offset -80
			struct _SVector normal0; // stack offset -72
			struct _SVector normal1; // stack offset -64
			struct _SVector sphereNormal; // stack offset -56
			struct _SVector dv; // stack offset -48
			struct _SVector absdv; // stack offset -40

		/* begin block 1.1 */
			// Start line: 1989
			// Start offset: 0x80020FAC
			// Variables:
				long numIntersects; // $a2

			/* begin block 1.1.1 */
				// Start line: 1993
				// Start offset: 0x80020FDC
				// Variables:
					short _x1; // $v0
					short _y1; // $v1
					short _z1; // $a0
			/* end block 1.1.1 */
			// End offset: 0x80020FDC
			// End Line: 1993

			/* begin block 1.1.2 */
				// Start line: 1993
				// Start offset: 0x80020FDC
				// Variables:
					short _x1; // $a0
					short _y1; // $v1
					short _z1; // $a1
					struct _SVector *_v0; // $v0
			/* end block 1.1.2 */
			// End offset: 0x80020FDC
			// End Line: 1993

			/* begin block 1.1.3 */
				// Start line: 2000
				// Start offset: 0x8002107C
				// Variables:
					short _y0; // $v0
					short _z0; // $v1
					short _x1; // $v0
					short _y1; // $a2
					short _z1; // $a3
					struct _SVector *_v; // $a1
					struct _SVector *_v0; // $v1
			/* end block 1.1.3 */
			// End offset: 0x8002107C
			// End Line: 2000
		/* end block 1.1 */
		// End offset: 0x80021290
		// End Line: 2076

		/* begin block 1.2 */
			// Start line: 2080
			// Start offset: 0x80021290

			/* begin block 1.2.1 */
				// Start line: 2087
				// Start offset: 0x800212D4
				// Variables:
					short _x1; // $v0
					short _y1; // $v1
					short _z1; // $a0
					struct _SVector *_v0; // $v0
					struct _SVector *_v1; // $v0
			/* end block 1.2.1 */
			// End offset: 0x800212D4
			// End Line: 2087

			/* begin block 1.2.2 */
				// Start line: 2087
				// Start offset: 0x800212D4
				// Variables:
					short _x1; // $v1
					short _y1; // $a0
					short _z1; // $a1
			/* end block 1.2.2 */
			// End offset: 0x800212D4
			// End Line: 2087

			/* begin block 1.2.3 */
				// Start line: 2096
				// Start offset: 0x80021318
				// Variables:
					short _x1; // $v0
					short _y1; // $v1
					short _z1; // $a0
			/* end block 1.2.3 */
			// End offset: 0x80021318
			// End Line: 2096

			/* begin block 1.2.4 */
				// Start line: 2096
				// Start offset: 0x80021318
				// Variables:
					short _x1; // $a0
					short _y1; // $v1
					short _z1; // $a1
					struct _SVector *_v0; // $v0
			/* end block 1.2.4 */
			// End offset: 0x80021318
			// End Line: 2096
		/* end block 1.2 */
		// End offset: 0x800213B8
		// End Line: 2106
	/* end block 1 */
	// End offset: 0x800213B8
	// End Line: 2108

	/* begin block 2 */
		// Start line: 4981
	/* end block 2 */
	// End Line: 4982
#endif
					UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// void /*$ra*/ COLLIDE_Instance1SpheresToInstance2(struct _Instance *instance1 /*stack 0*/, struct _Instance *instance2 /*$fp*/, long sphereToSphere /*$a2*/)
void COLLIDE_Instance1SpheresToInstance2(struct _Instance *instance1, struct _Instance *instance2, long sphereToSphere)
{ // line 2419, offset 0x800213dc
#if 0
	/* begin block 1 */
		// Start line: 2420
		// Start offset: 0x800213DC
		// Variables:
			MATRIX *wsTransform2; // stack offset -132
			MATRIX *oldWSTransform2; // stack offset -128
			_Position *spherePos; // stack offset -124
			struct _Vector *line; // $s7
			struct _Vector *offset; // stack offset -120
			struct _Vector *tempVec; // stack offset -116
			struct _Vector *sSpherePos1; // stack offset -112
			struct _Vector *oldSSpherePos1; // stack offset -108
			struct _SVector *svec; // stack offset -104
			struct _Sphere *sSphere1; // $s3
			struct _Sphere *oldSSphere1; // stack offset -100
			struct _Sphere *wSphere1; // stack offset -96
			struct _Sphere *wSphere2; // stack offset -92
			struct _Sphere *oldWSphere1; // stack offset -88
			struct _Sphere *oldWSphere2; // stack offset -84
			struct _CollideInfo *collideInfo; // $s2
			struct _HFaceInfo *hfaceInfo; // stack offset -80
			MATRIX *swTransform1; // stack offset -76
			MATRIX *swTransform2; // stack offset -72
			MATRIX *oldSWTransform1; // $s0
			MATRIX *oldSWTransform2; // $s4
			struct _HSphere *hsphere1; // $s6
			struct _HSphere *hsphere2; // $s0
			struct _HFace *hface; // $s0
			void (*collideFunc)(); // $a3
			long flag; // stack offset -152
			long edge; // stack offset -136
			struct _HModel *hmodel1; // $a0
			struct _HModel *hmodel2; // stack offset -68
			struct _HPrim *hprim1; // stack offset -64
			struct _HPrim *hprim2; // stack offset -60
			int i; // stack offset -56

		/* begin block 1.1 */
			// Start line: 2478
			// Start offset: 0x80021578
			// Variables:
				int i; // stack offset -52

			/* begin block 1.1.1 */
				// Start line: 2524
				// Start offset: 0x800217F0
				// Variables:
					long len; // $a3

				/* begin block 1.1.1.1 */
					// Start line: 2525
					// Start offset: 0x800217F0
					// Variables:
						long a; // stack offset -148
						long b; // stack offset -144
						long c; // stack offset -140
				/* end block 1.1.1.1 */
				// End offset: 0x800217F0
				// End Line: 2525

				/* begin block 1.1.1.2 */
					// Start line: 2531
					// Start offset: 0x80021888
					// Variables:
						short _x1; // $v1
						short _y1; // $a0
						short _z1; // $v0
						_Position *_v1; // $v0
				/* end block 1.1.1.2 */
				// End offset: 0x80021888
				// End Line: 2531

				/* begin block 1.1.1.3 */
					// Start line: 2536
					// Start offset: 0x800218B0
					// Variables:
						short _x1; // $v0
						short _y1; // $v1
						short _z1; // $a0
				/* end block 1.1.1.3 */
				// End offset: 0x800218B0
				// End Line: 2536
			/* end block 1.1.1 */
			// End offset: 0x800219E4
			// End Line: 2561

			/* begin block 1.1.2 */
				// Start line: 2577
				// Start offset: 0x80021A58
				// Variables:
					struct _Model *model2; // $s1

				/* begin block 1.1.2.1 */
					// Start line: 2676
					// Start offset: 0x80021E58
					// Variables:
						struct _HBox *hbox; // $s4
				/* end block 1.1.2.1 */
				// End offset: 0x800220B4
				// End Line: 2742
			/* end block 1.1.2 */
			// End offset: 0x800220B4
			// End Line: 2743
		/* end block 1.1 */
		// End offset: 0x800220D4
		// End Line: 2746
	/* end block 1 */
	// End offset: 0x800220FC
	// End Line: 2748

	/* begin block 2 */
		// Start line: 4838
	/* end block 2 */
	// End Line: 4839
#endif
						UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ COLLIDE_Instances(struct _Instance *instance1 /*$s1*/, struct _Instance *instance2 /*$s0*/)
void COLLIDE_Instances(struct _Instance *instance1, struct _Instance *instance2)
{ // line 2761, offset 0x8002212c
	/* begin block 1 */
		// Start line: 2762
		// Start offset: 0x8002212C
		// Variables:
			long lx; // $a1
			long ly; // $a3
			long lz; // $a2
			long mrmr; // $v0

		/* begin block 1.1 */
			// Start line: 2806
			// Start offset: 0x80022158
			// Variables:
				long x; // $a1
				long y; // $a3
				long z; // $a2
		/* end block 1.1 */
		// End offset: 0x80022158
		// End Line: 2806
	/* end block 1 */
	// End offset: 0x80022260
	// End Line: 2828

	/* begin block 2 */
		// Start line: 7060
	/* end block 2 */
	// End Line: 7061
				UNIMPLEMENTED();
}

void COLLIDE_InstanceList(struct _InstanceList* instanceList)
{
	struct _Instance* instance; // $s1
	struct _Instance* instance2; // $s0
	struct _Instance* playerInstance; // $s2
	long i; // $s4
	long j; // $s2

}


// autogenerated function stub: 
// long /*$ra*/ COLLIDE_SphereAndHFace(struct _Sphere *sphere /*$s2*/, _Position *oldPos /*$a1*/, struct _HFaceInfo *hfaceInfo /*$s4*/, struct _SVector *intersect /*$s5*/, long *edge /*stack 16*/)
long COLLIDE_SphereAndHFace(struct _Sphere *sphere, _Position *oldPos, struct _HFaceInfo *hfaceInfo, struct _SVector *intersect, long *edge)
{ // line 3061, offset 0x8002251c
#if 0
	/* begin block 1 */
		// Start line: 3062
		// Start offset: 0x8002251C
		// Variables:
			struct SandHFScratch *CSpad; // $s0
			struct _SVector *vertex0; // $a0
			long result; // $s6
			long behind; // $v0
			unsigned long d0sq; // $s1

		/* begin block 1.1 */
			// Start line: 3126
			// Start offset: 0x80022734
			// Variables:
				struct _Vector dv; // stack offset -64

			/* begin block 1.1.1 */
				// Start line: 3128
				// Start offset: 0x80022734
				// Variables:
					short _x1; // $v0
					short _y1; // $v1
					short _z1; // $a0
					struct _SVector *_v0; // $v0
			/* end block 1.1.1 */
			// End offset: 0x80022734
			// End Line: 3128
		/* end block 1.1 */
		// End offset: 0x80022814
		// End Line: 3141

		/* begin block 1.2 */
			// Start line: 3143
			// Start offset: 0x80022814
			// Variables:
				long y; // $v1
				long z; // $v0
		/* end block 1.2 */
		// End offset: 0x80022814
		// End Line: 3143

		/* begin block 1.3 */
			// Start line: 3147
			// Start offset: 0x80022884
			// Variables:
				unsigned long d1sq; // $a0

			/* begin block 1.3.1 */
				// Start line: 3149
				// Start offset: 0x80022884
				// Variables:
					long y; // $v1
					long z; // $v0
			/* end block 1.3.1 */
			// End offset: 0x80022884
			// End Line: 3149

			/* begin block 1.3.2 */
				// Start line: 3161
				// Start offset: 0x80022928
				// Variables:
					long y; // $v1
					long z; // $v0
			/* end block 1.3.2 */
			// End offset: 0x80022928
			// End Line: 3161
		/* end block 1.3 */
		// End offset: 0x800229B8
		// End Line: 3170

		/* begin block 1.4 */
			// Start line: 3174
			// Start offset: 0x800229CC
			// Variables:
				long len; // $a2
				struct _Vector dv; // stack offset -64

			/* begin block 1.4.1 */
				// Start line: 3176
				// Start offset: 0x800229CC
				// Variables:
					long _x0; // $a3
					long _y0; // $t0
					long _z0; // $t1
					long _x1; // $v1
					long _y1; // $v0
					long _z1; // $v1
					struct _Vector *_v; // $v0
					struct _SVector *_v1; // $t2
			/* end block 1.4.1 */
			// End offset: 0x800229CC
			// End Line: 3176

			/* begin block 1.4.2 */
				// Start line: 3176
				// Start offset: 0x800229CC
				// Variables:
					long a; // stack offset -48
					long b; // stack offset -44
					long c; // stack offset -40
			/* end block 1.4.2 */
			// End offset: 0x800229CC
			// End Line: 3176
		/* end block 1.4 */
		// End offset: 0x80022BCC
		// End Line: 3198
	/* end block 1 */
	// End offset: 0x80022BD0
	// End Line: 3201

	/* begin block 2 */
		// Start line: 6122
	/* end block 2 */
	// End Line: 6123
#endif
					UNIMPLEMENTED();
	return 0;
}

long COLLIDE_SAndT(struct SCollideInfo* scollideInfo, struct Level* level)
{
	struct SandTScratch* CSpad; // $s0
	void** stack; // $s1
	struct _BSPNode* bspNode; // $a1
	struct _Terrain* terrain; // $s5
	long curTree; // stack offset -44
	struct _SVector* _v0; // $s2
	struct _SVector* _v1; // $v0
	long a; // stack offset -56
	long b; // stack offset -52
	long c; // stack offset -48
	struct BSPTree* bsp; // $s4
	struct _SVector* _v; // $fp
	//struct _Position* _v1; // $t0
	//struct _Position* _v; // $s7(struct _SVector*) $fp, $s6
	struct _SVector* point; // $t0
	struct _BoundingBox* box; // $a3
	struct _TFace* tface; // $s3
	struct _SVector* vertex0; // $a3
	short* nrmlArray; // $a0
	struct _SVector* nrml; // $a1
	short* sPtr; // $v1
	int plane_front_error; // $v0
	int plane_back_error; // $a3
	short _x0; // $v0
	short _y0; // $v1
	short _z0; // $a0
	short _x1; // $a1 $a0
	short _y1; // $a2 $a1
	short _z1; // $a3 $v1
	//struct _Position* _v0; // $v0, $s2
	//struct _Position* _v1; // $v1, $t0, $v0
	return 0;
	CSpad = (struct SandTScratch*)getScratchAddr(114);
	//s1 = 0x1F800000
	//v0 = gameTrackerX.gameData.asmData.MorphTime
	//v1 = 0x3E8
	//arg_0 = scollideInfo
	//arg_4 = level
	terrain = level->terrain;
	stack = (void**)getScratchAddr(167);

	if (gameTrackerX.gameData.asmData.MorphTime != 1000)
	{
		CSpad->in_spectral = 2;
	}
	else
	{
		//loc_80023010
		if (gameTrackerX.gameData.asmData.MorphType == 1)
		{
			CSpad->in_spectral = 1;
		}
		else
		{
			CSpad->in_spectral = 0;
		}
	}
	//loc_8002302C
	//v0 = terrain->normalList
	//v1 = collide_ignoreAttr
	CSpad->normalList = (struct _HNormal*)terrain->normalList;
	CSpad->vertexList = terrain->vertexList;
	//t2 = scollideInfo
	//a0 = collide_acceptAttr
	///CSpad->collideFunc = scollideInfo->collideFunc;
	CSpad->instance = scollideInfo->instance;
	CSpad->prim = scollideInfo->prim;
	//v0 = scollideInfo->sphere
	//t3 = scollideInfo->sphere->position.x;
	//t6 = scollideInfo->sphere->position.y;
	//t7 = scollideInfo->sphere->position.z;
	CSpad->sphere.position.x = scollideInfo->sphere->position.x;
	CSpad->sphere.position.y = scollideInfo->sphere->position.y;
	CSpad->sphere.position.z = scollideInfo->sphere->position.z;
	CSpad->result = 0;
	CSpad->collide_ignoreAttr = collide_ignoreAttr;
	CSpad->collide_acceptAttr = collide_acceptAttr;

	//t3 = scollideInfo
	//v0 = scollideInfo->oldPos
	_v = &CSpad->oldPos;

	_x0 = scollideInfo->oldPos->vx;
	_y0 = scollideInfo->oldPos->vy;
	_z0 = scollideInfo->oldPos->vz;

	//a1 = &b
	_v->x = _x0;
	_v->y = _y0;
	_v->z = _z0;

	_x0 = CSpad->sphere.position.x;//v0
	_y0 = CSpad->sphere.position.y;//a2
	_z0 = CSpad->sphere.position.z;//a3

	//v1 = CSpad->oldPos.x
	//a0 = &a

	CSpad->spherePos.y = _y0;
	CSpad->spherePos.z = _z0;

	CSpad->midPoint.x = _x0 - CSpad->oldPos.x;
	CSpad->midPoint.y = _y0 - CSpad->oldPos.y;
	CSpad->midPoint.z = _z0 - CSpad->oldPos.z;
	//v0 = _y0 -  CSpad->oldPos.y
	//v1 = CSpad->oldPos.y
	//a2 = &c

	a = ABS(CSpad->midPoint.x);
	b = ABS(CSpad->midPoint.y);
	c = ABS(CSpad->midPoint.z);

	MATH3D_Sort3VectorCoords(&a, &b, &c);

	//v1 = (c * 30) + (b * 12) + (a * 9)

	CSpad->midRadius = (c * 30) + (b * 12) + (a * 9);

	if (CSpad->midRadius != 0)
	{
		CSpad->midPoint.x = (CSpad->spherePos.x + CSpad->oldPos.x) >> 1;
		CSpad->midPoint.y = (CSpad->spherePos.y + CSpad->oldPos.y) >> 1;
		CSpad->midPoint.z = (CSpad->spherePos.z + CSpad->oldPos.z) >> 1;
		//v0 = (CSpad->midRadius + (CSpad->midRadius >> 31)) >> 1;
		//v1 = CSpad->sphere.radius
		CSpad->midRadius = ((CSpad->midRadius + (CSpad->midRadius >> 31)) >> 1) + CSpad->sphere.radius;
		
		if (CSpad->in_spectral == 2)
		{
			CSpad->midRadius += 2048;
		}
		//loc_80023200

		curTree = 0;
		if (terrain->numBSPTrees > 0)
		{
			//fp = s2
			_v = &CSpad->oldPos;//fp
			_v0 = &CSpad->midPoint;//s7
			_v1 = (struct _SVector*)&CSpad->sphere.position;//s6

			//loc_8002321C
			//t6 = curTree
			//v1 = terrain->BSPTreeArray

			bsp = &terrain->BSPTreeArray[curTree];


			if (bsp->ID >= 0)
			{
				//v0 = bsp->flags & 0x2000
				if(!(bsp->flags & 0x4000) || gameTrackerX.raziel_collide_override != 0)
				{
					//loc_80023268
					//v0 = bsp->flags & 0x102
					if (!(bsp->flags & 0x2000) || gameTrackerX.monster_collide_override != 0)
					{
						if (!(bsp->flags & 0x102) || ((bsp->flags & 0xE0) != 0 && INSTANCE_Query(CSpad->instance, 1) & 0x2))
						{
							//loc_800232A8
							//v0 = bsp->ID

							//t0 = &bsp->globalOffset
							CSpad->collideInfo.bspID = bsp->ID;

							CSpad->oldPos.x -= bsp->globalOffset.x;
							CSpad->oldPos.y -= bsp->globalOffset.y;
							CSpad->oldPos.z -= bsp->globalOffset.z;

							CSpad->midPoint.x -= bsp->globalOffset.x;
							CSpad->midPoint.y -= bsp->globalOffset.y;
							CSpad->midPoint.z -= bsp->globalOffset.z;
							
							CSpad->sphere.position.x -= bsp->globalOffset.x;
							CSpad->sphere.position.y -= bsp->globalOffset.y;
							CSpad->sphere.position.z -= bsp->globalOffset.z;

							CSpad->posMatrix.m[0][0] = CSpad->sphere.position.x;
							CSpad->posMatrix.m[0][1] = CSpad->sphere.position.y;
							CSpad->posMatrix.m[0][2] = CSpad->sphere.position.z;

							CSpad->posMatrix.m[1][0] = CSpad->oldPos.x;
							CSpad->posMatrix.m[1][1] = CSpad->oldPos.y;
							CSpad->posMatrix.m[1][2] = CSpad->oldPos.z;

							stack[0] = stack;

							SetRotMatrix(&CSpad->posMatrix);

							//v0 = bsp->bspRoot
							if ((void*)bsp->bspRoot != ++stack)
							{
								//loc_80023390
								bspNode = (struct _BSPNode*)stack[0];

								--stack;
								if ((bspNode->flags & 0x2))
								{
									//t1 = 0;
									//a3 = &bspNode->d;
									//a0 = CSPad->midPoint.x
									//a2 = CSPad->midRadius
									//v1 = ((short*)&bspNode->front)[1]
									//v0 = CSPad->midPoint.x - CSPad->midRadius

									//t0 = &CSpad->midPoint;
									if ((CSpad->midPoint.x - CSpad->midRadius) >= ((short*)&bspNode->front)[1] ||
										((short*)&bspNode->d)[0] >= (CSpad->midPoint.x + CSpad->midRadius))
									{
										//v0 = (CSpad->midPoint.y - CSPad->midRadius)
										//a0 = CSpad->midPoint.y
										//v1 = ((short*)&bspNode->back)[0];

										if ((CSpad->midPoint.y - CSpad->midRadius) >= ((short*)&bspNode->back)[0] ||
											((short*)&bspNode->d)[1] >= (CSpad->midPoint.y + CSpad->midRadius))
										{
											if ((CSpad->midPoint.z - CSpad->midRadius) >= ((short*)&bspNode->back)[1] ||
												((short*)&bspNode->front)[0] >= (CSpad->midPoint.z + CSpad->midRadius))
											{
												//loc_80023444

												//v0 = CSpad->sphere.x
												//v1 = CSpad->sphere.z

												CSpad->posMatrix.m[0][0] = CSpad->sphere.position.x;
												CSpad->posMatrix.m[0][1] = CSpad->sphere.position.y;
												CSpad->posMatrix.m[0][2] = CSpad->sphere.position.z;

												gte_ldv0(&CSpad->posMatrix);
												
												CSpad->i = bspNode->c;

												tface = (struct _TFace*)((int*)&bspNode->c)[0];

												//s2 = tface + 0x4;

												if (CSpad->i != 0)
												{
													//a0 = tface->attr
													if (!(tface->attr & CSpad->collide_ignoreAttr) && (tface->attr & collide_acceptAttr))
													{
														//loc_800234B4
														//v0 = tface->textoff

														if (tface->textoff != 0xFFFF)
														{
															if(!(((struct TextureFT3*)(((char*)terrain->StartTextureList) + tface->textoff))->attr & 0x2000))
															{
																if (!(tface->attr & 0x8))
																{
																	if (CSpad->in_spectral == 2)
																	{
																		
																		plane_front_error = (((int)terrain->faceList) - ((int*)bspNode->a)[0]) << 2;
																	}
																	//loc_80023568
																}
																//loc_800237EC
															}
															//loc_800237EC
														}
													}
													//loc_800237EC
												}
												//loc_8002380C
											}
										}
									}
									//loc_80023984
								}
								//loc_80023834
							}
							//loc_80023994
						}
						//loc_80023A28
					}
					//loc_80023A28
				}
				//loc_80023A28
			}
			//loc_80023A28
		}
		//loc_80023A40
	}
	else
	{
		return 0;
	}
#if 0
		loc_80023488:
	lbu     $a0, 2($s2)
		lw      $v0, 0xC4($s0)
		nop
		and $v0, $a0, $v0
		beqz    $v0, loc_800234B4
		nop
		lw      $v0, 0xC8($s0)
		nop
		and $v0, $a0, $v0
		beqz    $v0, loc_800237EC
		nop

		loc_800234B4 :
	lhu     $v1, 6($s2)
		li      $v0, 0xFFFF
		beq     $v1, $v0, loc_800234E4
		move    $v0, $v1
		lw      $v1, 0x34($s5)
		nop
		addu    $v1, $v0
		lhu     $v0, 0xA($v1)
		nop
		andi    $v0, 0x2000
		bnez    $v0, loc_800237EC
		nop

		loc_800234E4 :
	andi    $v0, $a0, 8
		bnez    $v0, loc_800237EC
		li      $v0, 2
		lw      $v1, 0x9C($s0)
		nop
		bne     $v1, $v0, loc_80023568
		nop
		lw      $v1, 0x20($s5)
		nop
		subu    $v1, $s3, $v1
		sllv    $v0, $v1, $v0
		addu    $v0, $v1
		sll     $v1, $v0, 4
		addu    $v0, $v1
		sll     $v1, $v0, 8
		addu    $v0, $v1
		sll     $v1, $v0, 16
		addu    $v0, $v1
		negu    $v0, $v0
		sra     $v0, 2
		lw      $v1, 0x4C($s5)
		sll     $v0, 1
		addu    $v0, $v1
		lhu     $v1, 4($s2)
		lh      $v0, 0($v0)
		nop
		beq     $v1, $v0, loc_80023568
		move    $a0, $s5
		move    $a1, $s3
		jal     sub_8001EBA0
		addiu   $a2, $s0, 0xAC
		j       loc_800235F8
		nop

		loc_80023568 :
	lh      $v1, 4($s2)
		lw      $a0, 0x2C($s0)
		bltz    $v1, loc_800235B0
		addiu   $a1, $s0, 0xAC
		sll     $v0, $v1, 1
		addu    $v0, $v1
		sll     $v0, 1
		addu    $v1, $a0, $v0
		lhu     $v0, 0($v1)
		addiu   $v1, 2
		andi    $v0, 0x1FFF
		sh      $v0, 0xAC($s0)
		lhu     $v0, 0($v1)
		nop
		sh      $v0, 2($a1)
		lhu     $v0, 2($v1)
		j       loc_800235F8
		sh      $v0, 4($a1)

		loc_800235B0:
	negu    $v1, $v1
		sll     $v0, $v1, 1
		addu    $v0, $v1
		sll     $v0, 1
		addu    $v1, $a0, $v0
		lhu     $v0, 0($v1)
		addiu   $v1, 2
		andi    $v0, 0x1FFF
		negu    $v0, $v0
		sh      $v0, 0xAC($s0)
		lhu     $v0, 0($v1)
		nop
		negu    $v0, $v0
		sh      $v0, 2($a1)
		lhu     $v0, 2($v1)
		nop
		negu    $v0, $v0
		sh      $v0, 4($a1)

		loc_800235F8:
	lhu     $v1, 0($s3)
		nop
		sll     $v0, $v1, 1
		addu    $v0, $v1
		lw      $v1, 0xD0($s0)
		sll     $v0, 2
		addu    $a3, $v1, $v0
		lw      $t4, 0($a3)
		lw      $t5, 4($a3)
		ctc2    $t4, $3
		ctc2    $t5, $4
		addiu   $v0, $s0, 0xAC
		lwc2    $0, 0($v0)
		lwc2    $1, 4($v0)
		nop
		nop
		cop2    0x486012
		addiu   $v0, $s0, 0x20  # ' '
		swc2    $25, 0($v0)
		swc2    $26, 4($v0)
		swc2    $27, 8($v0)
		lw      $a2, 0x20($s0)
		lw      $v1, 0x24($s0)
		nop
		slt     $v0, $v1, $a2
		bnez    $v0, loc_800237EC
		nop
		lw      $a0, 0x28($s0)
		lhu     $a1, 0xBA($s0)
		subu    $v0, $a2, $a0
		slt     $v0, $a1
		beqz    $v0, loc_800237EC
		subu    $v1, $a0
		negu    $v0, $a1
		slt     $v1, $v0
		bnez    $v1, loc_800237EC
		addiu   $a1, $s0, 0xA0
		addiu   $a0, $s0, 0xB4
		addiu   $a2, $s0, 0x60  # '`'
		sw      $s3, 0x68($s0)
		sw      $a3, 0x74($s0)
		lh      $v1, -2($s2)
		nop
		sll     $v0, $v1, 1
		addu    $v0, $v1
		lw      $v1, 0xD0($s0)
		sll     $v0, 2
		addu    $v1, $v0
		sw      $v1, 0x78($s0)
		lh      $v1, 0($s2)
		addiu   $v0, $s0, 0x98
		sw      $v0, 0x28 + var_18($sp)
		sll     $v0, $v1, 1
		addu    $v0, $v1
		lw      $v1, 0xD0($s0)
		sll     $v0, 2
		addu    $v1, $v0
		sw      $v1, 0x7C($s0)
		ulw     $t7, 0xAC($s0)
		ulw     $t2, 0xB0($s0)
		usw     $t7, 0x6C($s0)
		usw     $t2, 0x70($s0)
		jal     sub_800228D4
		addiu   $a3, $s0, 0x50  # 'P'
		beqz    $v0, loc_800237E4
		nop
		lw      $v0, 0x98($s0)
		nop
		beqz    $v0, loc_80023728
		sb      $zero, 0x34($s0)
		j       loc_8002372C
		li      $v0, 4

		loc_80023728:
	li      $v0, 8

		loc_8002372C :
		sb      $v0, 0x34($s0)
		li      $v0, 1
		sb      $v0, 0x36($s0)
		li      $v0, 3
		sb      $v0, 0x37($s0)
		sw      $s4, 0x44($s0)
		lw      $t7, 0x28 + arg_4($sp)
		lw      $v1, 0x94($s0)
		lw      $v0, 0xA8($s0)
		lhu     $a0, 0($s0)
		lhu     $a1, 2($s0)
		sw      $t7, 0x30($s0)
		sw      $v1, 0x40($s0)
		lw      $t2, 0x28 + arg_0($sp)
		lhu     $v1, 0xB6($s0)
		lbu     $a2, 0x10($t2)
		sw      $v0, 0x38($s0)
		lhu     $v0, 0xB4($s0)
		subu    $v1, $a1
		sh      $v1, 0x5A($s0)
		lhu     $v1, 4($s0)
		subu    $v0, $a0
		sh      $v0, 0x58($s0)
		lhu     $v0, 0xB8($s0)
		lw      $a0, 0x94($s0)
		sw      $s3, 0x3C($s0)
		sb      $a2, 0x35($s0)
		subu    $v0, $v1
		beqz    $a0, loc_800237CC
		sh      $v0, 0x5C($s0)
		addiu   $v0, $s0, 0x30  # '0'
		sw      $v0, 0xC0($a0)
		lw      $v0, 0x90($s0)
		nop
		beqz    $v0, loc_800237CC
		nop
		lw      $a0, 0x94($s0)
		addiu   $a1, $gp, -0x4238
		jalr    $v0
		nop

		loc_800237CC :
	lw      $v0, 0xB4($s0)
		lhu     $a0, 0xB8($s0)
		li      $v1, 1
		sh      $v1, 0xC0($s0)
		sw      $v0, 0($s0)
		sh      $a0, 4($s0)

		loc_800237E4:
	jal     SetRotMatrix
		move    $a0, $s0

		loc_800237EC :
	addiu   $s2, 0xC
		lhu     $v0, 0xC2($s0)
		nop
		addiu   $v0, -1
		sh      $v0, 0xC2($s0)
		sll     $v0, 16
		bnez    $v0, loc_80023488
		addiu   $s3, 0xC

		loc_8002380C:
	lw      $v0, 0xB4($s0)
		lhu     $v1, 0xB8($s0)
		sw      $v0, 0($s0)
		sh      $v1, 4($s0)
		lw      $t4, 0($s0)
		lw      $t5, 4($s0)
		ctc2    $t4, $0
		ctc2    $t5, $1
		j       loc_80023984
		nop

		loc_80023834 :
	addiu   $v0, $a1, 8
		lwc2    $0, 0($v0)
		lwc2    $1, 4($v0)
		nop
		nop
		cop2    0x486012
		addiu   $v0, $s0, 0x20  # ' '
		swc2    $25, 0($v0)
		swc2    $26, 4($v0)
		swc2    $27, 8($v0)
		lw      $v0, 0x20($s0)
		lw      $v1, 0x10($a1)
		nop
		subu    $v0, $v1
		sw      $v0, 0x20($s0)
		lw      $v0, 0x24($s0)
		lw      $v1, 0x10($a1)
		lw      $a0, 0x9C($s0)
		subu    $v0, $v1
		beqz    $a0, loc_80023898
		sw      $v0, 0x24($s0)
		lh      $v0, 0x24($a1)
		lh      $a3, 0x26($a1)
		j       loc_800238A0
		nop

		loc_80023898 :
	lh      $v0, 0x28($a1)
		lh      $a3, 0x2A($a1)

		loc_800238A0 :
		lhu     $a0, 0xBA($s0)
		lw      $a2, 0x24($s0)
		addu    $v1, $a0, $v0
		slt     $v0, $a2, $v1
		bnez    $v0, loc_800238D4
		nop
		lw      $v0, 0x20($s0)
		nop
		slt     $v0, $v1, $v0
		beqz    $v0, loc_80023954
		nop
		j       loc_8002396C
		nop

		loc_800238D4 :
	subu    $v1, $a3, $a0
		slt     $v0, $v1, $a2
		bnez    $v0, loc_8002391C
		nop
		lw      $v0, 0x20($s0)
		nop
		slt     $v0, $v1
		bnez    $v0, loc_80023910
		nop
		lw      $v0, 0x14($a1)
		nop
		beqz    $v0, loc_80023910
		nop
		addiu   $s1, 4
		sw      $v0, 0($s1)

		loc_80023910:
	lw      $v0, 0x18($a1)
		j       loc_80023970
		nop

		loc_8002391C :
	lw      $v0, 0x20($s0)
		nop
		slt     $v0, $a2
		bnez    $v0, loc_80023954
		nop
		lw      $v0, 0x14($a1)
		nop
		beqz    $v0, loc_80023948
		nop
		addiu   $s1, 4
		sw      $v0, 0($s1)

		loc_80023948:
	lw      $v0, 0x18($a1)
		j       loc_80023970
		nop

		loc_80023954 :
	lw      $v0, 0x18($a1)
		nop
		beqz    $v0, loc_8002396C
		nop
		addiu   $s1, 4
		sw      $v0, 0($s1)

		loc_8002396C:
	lw      $v0, 0x14($a1)

		loc_80023970 :
		nop
		beqz    $v0, loc_80023984
		nop
		addiu   $s1, 4
		sw      $v0, 0($s1)

		loc_80023984 :
		lw      $v0, 0($s1)
		nop
		bne     $v0, $s1, loc_80023390
		nop

		loc_80023994 :
	addiu   $t0, $s4, 0xC
		lhu     $v0, 0xA0($s0)
		lhu     $v1, 2($fp)
		lhu     $a0, 4($fp)
		lhu     $a1, 0xC($s4)
		lhu     $a2, 2($t0)
		lhu     $a3, 4($t0)
		addu    $v0, $a1
		addu    $v1, $a2
		addu    $a0, $a3
		sh      $v0, 0xA0($s0)
		sh      $v1, 2($fp)
		sh      $a0, 4($fp)
		lhu     $v0, 0x80($s0)
		lhu     $v1, 2($s7)
		lhu     $a0, 4($s7)
		lhu     $a1, 0xC($s4)
		lhu     $a2, 2($t0)
		lhu     $a3, 4($t0)
		addu    $v0, $a1
		addu    $v1, $a2
		addu    $a0, $a3
		sh      $v0, 0x80($s0)
		sh      $v1, 2($s7)
		sh      $a0, 4($s7)
		lhu     $v0, 0xB4($s0)
		lhu     $v1, 2($s6)
		lhu     $a0, 4($s6)
		lhu     $a1, 0xC($s4)
		lhu     $a2, 2($t0)
		lhu     $a3, 4($t0)
		addu    $v0, $a1
		addu    $v1, $a2
		addu    $a0, $a3
		sh      $v0, 0xB4($s0)
		sh      $v1, 2($s6)
		sh      $a0, 4($s6)

		loc_80023A28:
	lw      $t3, 0x28 + var_4($sp)
		lw      $v0, 0x44($s5)
		addiu   $t3, 1
		slt     $v0, $t3, $v0
		bnez    $v0, loc_8002321C
		sw      $t3, 0x28 + var_4($sp)

		loc_80023A40:
	addiu   $v1, $s0, 0xB4
		lw      $t6, 0x28 + arg_0($sp)
		lhu     $a0, 0xB4($s0)
		lhu     $a1, 2($v1)
		lhu     $v1, 4($v1)
		lw      $v0, 0($t6)
		nop
		sh      $a0, 0($v0)
		sh      $a1, 2($v0)
		sh      $v1, 4($v0)
		lh      $v0, 0xC0($s0)

		loc_80023A6C:
	lw      $ra, 0x28 + var_s24($sp)
		lw      $fp, 0x28 + var_s20($sp)
		lw      $s7, 0x28 + var_s1C($sp)
		lw      $s6, 0x28 + var_s18($sp)
		lw      $s5, 0x28 + var_s14($sp)
		lw      $s4, 0x28 + var_s10($sp)
		lw      $s3, 0x28 + var_sC($sp)
		lw      $s2, 0x28 + var_s8($sp)
		lw      $s1, 0x28 + var_s4($sp)
		lw      $s0, 0x28 + var_s0($sp)
		jr      $ra
		addiu   $sp, 0x50
#endif
	return 0;
}

long COLLIDE_SphereAndTerrain(struct SCollideInfo* scollideInfo, struct Level* level)
{
	int result;
	int d;
	int in_warpRoom;
	struct _StreamUnit* stream;

	result = COLLIDE_SAndT(scollideInfo, level);

	in_warpRoom = 0;
	
	stream = STREAM_GetStreamUnitWithID(level->streamUnitID);

	if (stream != NULL)
	{
		in_warpRoom = stream->flags & 0x1;
	}

	for (d = 0; d < 16; d++)
	{
		if ((StreamTracker.StreamList[d].used == 2) && (StreamTracker.StreamList[d].level != level) && ((in_warpRoom == 0) || !(StreamTracker.StreamList[d].flags & 0x1)) && (MEMPACK_MemoryValidFunc((char*)StreamTracker.StreamList[d].level) != 0))
		{
			result = COLLIDE_SAndT(scollideInfo, StreamTracker.StreamList[d].level);
		}
	}

	return result;
}

void COLLIDE_InstanceTerrain(struct _Instance* instance, struct Level* level)
{
	struct _Vector* newPosVec;
	struct _Vector* oldPosVec;
	struct _SVector* oldPos;
	struct SCollideInfo scollideInfoX;
	struct SCollideInfo* scollideInfo;
	struct _Sphere* wSphere;
	MATRIX* swTransform;
	MATRIX* oldSWTransform;
	void (*collideFunc)(struct _Instance* instance, struct GameTracker* gameTracker); // stack offset -52
	struct _HSphere* hsphere;
	long flags;
	int i;
	struct _HModel* hmodel;
	struct _HPrim* hprim;

	newPosVec = (struct _Vector*)getScratchAddr(82);
	oldPos = (struct _SVector*)getScratchAddr(90);
	wSphere = (struct _Sphere*)getScratchAddr(110);
	oldPosVec = (struct _Vector*)getScratchAddr(86);

	scollideInfo = &scollideInfoX;

	if (instance->matrix != NULL && instance->oldMatrix != NULL)
	{
		if((instance->object->oflags2 & 0x80000))
		{
			gameTrackerX.monster_collide_override = 1;
		}

		collideFunc = instance->collideFunc;

		if (collideFunc != NULL)
		{
			hmodel = &instance->hModelList[instance->currentModel];

			i = hmodel->numHPrims;
			hprim = hmodel->hPrimList;

			while (i-- != 0)
			{
				if ((hprim->hpFlags & 0x1) && (hprim->withFlags & 0x2) && hprim->type == 1)
				{
					swTransform = &instance->matrix[hprim->segment];
				
					oldSWTransform = &instance->oldMatrix[hprim->segment];

					SetRotMatrix(swTransform);

					SetTransMatrix(swTransform);

					RotTrans((SVECTOR*)&hprim->data.hsphere->position, (VECTOR*)newPosVec, &flags);
				
					SetRotMatrix(oldSWTransform);

					SetTransMatrix(oldSWTransform);

					RotTrans((SVECTOR*)&hprim->data.hsphere->position, (VECTOR*)oldPosVec, &flags);
				
					wSphere->position.x = newPosVec->x;
					wSphere->position.y = newPosVec->y;
					wSphere->position.z = newPosVec->z;

					wSphere->radius = hprim->data.hsphere->radius;

					oldPos->x = oldPosVec->x;
					oldPos->y = oldPosVec->y;
					oldPos->z = oldPosVec->z;

					wSphere->radiusSquared = hprim->data.hsphere->radiusSquared;

					scollideInfo->sphere = wSphere;
					
					scollideInfo->oldPos = (SVECTOR*)oldPos;

					scollideInfo->collideFunc = collideFunc;

					scollideInfo->instance = instance;

					scollideInfo->segment = hprim->segment;

					scollideInfo->prim = (void*)hprim;

					scollideInfo->id = hprim->data.hsphere->id;

					COLLIDE_SphereAndTerrain(scollideInfo, level);
				}
				
				hprim++;
			}
		}

		gameTrackerX.monster_collide_override = 0;
	}
}

long COLLIDE_LineWithSignals(struct _SVector* startPoint, struct _SVector* endPoint, struct _MultiSignal** signalList, long maxSignals, struct Level* level)
{
	struct IandTScratch* CSpad;
	struct _Terrain* terrain; // $s4
	void** stack; // $s2
	int v8; // $t3
	int numSignalsCollidedWith; // $fp
	int result; // $v0
	struct _Vector* p_dpv; // $t1
	int v12; // $s5
	struct _BSPNode* bspNode; // $a1
	int front_high; // $v1
	int d_low; // $v1
	int back_low; // $v1
	int d_high; // $v1
	int back_high; // $v1
	int front_low; // $v1
	struct _TFace* tface; // $s3
	unsigned short* p_textoff; // $s1
	int v27; // $v1
	short* v28; // $v1
	short v29; // $v0
	int v30; // $v0
	short* v31; // $v1
	short v32; // $v0
	int v33; // $a0
	int v37; // $v1
	int y; // $v0
	int v39; // $a1
	int v40; // $v0
	int v41; // $v0
	int front_spectral_error; // $v1
	int back_spectral_error; // $a0
	void* back; // $v0
	void* front; // $v0
	short _x1; // $a0 MAPDST
	short _y1; // $a0 MAPDST
	short _z1; // $a1 MAPDST
	int v52; // [sp+18h] [-10h]
	struct _Vector* v53; // [sp+20h] [-8h]
	struct _Vector* v54; // [sp+20h] [-8h]

	CSpad = (struct IandTScratch*)getScratchAddr(16);

	terrain = level->terrain;

	stack = (void**)getScratchAddr(41);

	CSpad->normalList = (short*)terrain->normalList;
	CSpad->vertexList = terrain->vertexList;

	CSpad->oldPos.x = startPoint->x;
	CSpad->oldPos.z = startPoint->z;

	CSpad->newPos.x = endPoint->x;
	CSpad->newPos.z = endPoint->z;

	numSignalsCollidedWith = 0;

	if (gameTrackerX.gameData.asmData.MorphTime == 1000)
	{
		CSpad->in_spectral = gameTrackerX.gameData.asmData.MorphType == 1;
	}
	else
	{
		CSpad->in_spectral = 2;
	}

	CSpad->line.x = CSpad->oldPos.x - CSpad->newPos.x;
	CSpad->line.y = CSpad->oldPos.y - CSpad->newPos.y;
	CSpad->line.z = CSpad->oldPos.z - CSpad->newPos.z;

	result = 0;

	if (CSpad->line.x || CSpad->line.y || CSpad->line.z)
	{
		v52 = 0;
		if (terrain->numBSPTrees > 0)
		{
			p_dpv = &CSpad->dpv;
			v12 = 0;
			do
			{
				if (terrain->BSPTreeArray[v12].ID == -1)
				{
					*stack = stack;

					_x1 = terrain->BSPTreeArray[v12].globalOffset.x;
					_y1 = terrain->BSPTreeArray[v12].globalOffset.y;
					_z1 = terrain->BSPTreeArray[v12].globalOffset.z;

					CSpad->newPos.x -= _x1;
					CSpad->newPos.y -= _y1;
					CSpad->newPos.z -= _z1;

					_x1 = terrain->BSPTreeArray[v12].globalOffset.x;
					_y1 = terrain->BSPTreeArray[v12].globalOffset.y;
					_z1 = terrain->BSPTreeArray[v12].globalOffset.z;

					CSpad->oldPos.x -= _x1;
					CSpad->oldPos.y -= _y1;
					CSpad->oldPos.z -= _z1;

					// *++stack = *(void **)(terrain->BSPTreeArray[v12]);

					CSpad->posMatrix.m[0][0] = CSpad->newPos.x;
					CSpad->posMatrix.m[1][1] = CSpad->newPos.y;
					CSpad->posMatrix.m[0][2] = CSpad->newPos.z;
					CSpad->posMatrix.m[1][0] = CSpad->oldPos.x;
					CSpad->posMatrix.m[1][1] = CSpad->oldPos.y;
					CSpad->posMatrix.m[1][2] = CSpad->oldPos.z;

					v53 = p_dpv;
					SetRotMatrix(&CSpad->posMatrix);
					p_dpv = v53;
					while (*stack != stack)
					{
						bspNode = (struct _BSPNode*)*stack;
						if (*((short*)*stack-- + 7) & 2)
						{
							front_high = ((unsigned short*)bspNode->front)[0];
							if (front_high >= CSpad->newPos.x || front_high >= CSpad->oldPos.x)
							{
								d_low = ((unsigned short*)bspNode->d)[1];
								if (CSpad->newPos.x >= d_low || CSpad->oldPos.x >= d_low)
								{
									back_low = ((unsigned short*)bspNode->back)[1];
									if (back_low >= CSpad->newPos.y || back_low >= CSpad->oldPos.y)
									{
										d_high = ((unsigned short*)bspNode->d)[0];
										if (CSpad->newPos.y >= d_high || CSpad->oldPos.y >= d_high)
										{
											back_high = ((unsigned short*)bspNode->back)[0];
											if (back_high >= CSpad->newPos.z || back_high >= CSpad->oldPos.z)
											{
												front_low = ((unsigned short*)bspNode->front)[1];
												if (CSpad->newPos.z >= front_low || CSpad->oldPos.z >= front_low)
												{
													CSpad->i = bspNode->c;
													tface = *(struct _TFace**)&bspNode->a;
													p_textoff = &tface->textoff;
													if (CSpad->i)
													{
														do
														{
															if ((*(p_textoff - 2) & 0xC0) != 0 && (unsigned short)*p_textoff != 0xFFFF)
															{
																v27 = *(p_textoff - 1);
																if (v27 < 0)
																{
																	v31 = (short*)(*(unsigned int*)CSpad->normalList - 6 * v27);
																	v32 = *v31++;
																	CSpad->normal.x = -(v32 & 0x1FFF);
																	CSpad->normal.y = -*v31;
																	v30 = -(unsigned short)v31[1];
																}
																else
																{
																	v28 = (short*)(*(unsigned int*)CSpad->normalList + 6 * v27);
																	v29 = *v28++;
																	CSpad->normal.x = v29 & 0x1FFF;
																	CSpad->normal.y = *v28;
																	//LOWORD(v30) = v28[1];
																}
																CSpad->normal.z = v30;
																//                              v33 = dword_1F8000A0 + 12 * *(unsigned short *)tface->face.gap0;

																gte_ldv0(&bspNode->a);
																gte_rtv0();
																//gte_stlvnl();

																CSpad->dpv.x -= CSpad->dpv.z;
																v37 = CSpad->dpv.y - CSpad->dpv.z;
																CSpad->dpv.y -= CSpad->dpv.z;
																if (CSpad->dpv.x < 0 && v37 >= 0)
																{
																	y = p_dpv->y;
																	if (CSpad->dpv.x == y)
																		v39 = 0;
																	else
																		v39 = (y << 12) / (CSpad->dpv.x - y);
																	CSpad->planePoint.x = CSpad->oldPos.x + ((CSpad->line.x * v39) >> 12);
																	CSpad->planePoint.y = CSpad->oldPos.y + ((CSpad->line.y * v39) >> 12);
																	CSpad->planePoint.z = CSpad->oldPos.z + ((CSpad->line.z * v39) >> 12);
																	v54 = p_dpv;
																	v40 = COLLIDE_PointInTriangle(
																		(struct _SVector*)v33,
																		(struct _SVector*)(CSpad->normalList + 12 * (unsigned short)*(p_textoff - 4)),
																		(struct _SVector*)(CSpad->normalList + 12 * (unsigned short)*(p_textoff - 3)),
																		&CSpad->planePoint,
																		&CSpad->normal);
																	p_dpv = v54;
																	if (v40)
																	{
																		v41 = numSignalsCollidedWith;
																		if (numSignalsCollidedWith < maxSignals)
																		{
																			++numSignalsCollidedWith;
																			signalList[v41] = (struct _MultiSignal*)(*(unsigned int*)&terrain[1].UnitChangeFlags
																				+ (unsigned short)*p_textoff);
																		}
																	}
																}
															}
															p_textoff += 6;
															++tface;
														} while (CSpad->i-- != 1);
													}
												}
											}
										}
									}
								}
							}
						}
						else
						{

							gte_ldv0(&bspNode->a);
							gte_rtv0();
							//gte_stlvnl();
							CSpad->dpv.x -= bspNode->d;
							CSpad->dpv.y -= bspNode->d;

							if (CSpad->in_spectral)
							{
								front_spectral_error = bspNode->front_spectral_error;
								back_spectral_error = bspNode->back_spectral_error;
							}
							else
							{
								front_spectral_error = bspNode->front_material_error;
								back_spectral_error = bspNode->back_material_error;
							}
							if (CSpad->dpv.x < front_spectral_error || CSpad->dpv.y < front_spectral_error)
							{
								if (back_spectral_error < CSpad->dpv.x || back_spectral_error < CSpad->dpv.y)
								{
									front = (void*)bspNode->front;
									if (front)
										*++stack = front;
								}
								back = (void*)bspNode->back;
							}
							else
							{
								back = (void*)bspNode->front;
							}
							if (back)
								*++stack = back;
						}
					}
					_x1 = terrain->BSPTreeArray[v12].globalOffset.x;
					_y1 = terrain->BSPTreeArray[v12].globalOffset.y;
					_z1 = terrain->BSPTreeArray[v12].globalOffset.z;

					CSpad->newPos.x += _x1;
					CSpad->newPos.y += _y1;
					CSpad->newPos.z += _z1;

					_x1 = terrain->BSPTreeArray[v12].globalOffset.x;
					_y1 = terrain->BSPTreeArray[v12].globalOffset.y;
					_z1 = terrain->BSPTreeArray[v12].globalOffset.z;

					CSpad->oldPos.x += _x1;
					CSpad->oldPos.y += _y1;
					CSpad->oldPos.z += _z1;
				}
				v12 += 36;
				++v52;
			} while (v52 < terrain->numBSPTrees);
		}
		return numSignalsCollidedWith;
	}
	return result;
}

// autogenerated function stub: 
// void /*$ra*/ COLLIDE_InstanceTerrainSignal(struct _Instance *instance /*$s3*/, struct Level *level /*$s1*/)
void COLLIDE_InstanceTerrainSignal(struct _Instance *instance, struct Level *level)
{ // line 4548, offset 0x800241fc
	/* begin block 1 */
		// Start line: 4549
		// Start offset: 0x800241FC
		// Variables:
			struct _SVector startPoint; // stack offset -72
			struct _SVector endPoint; // stack offset -64
			struct _Model *model; // $s0
			long numSignals; // $s4
			long d; // $s1
			struct _MultiSignal (*signalListArray[8]); // stack offset -56

		/* begin block 1.1 */
			// Start line: 4616
			// Start offset: 0x800243DC
			// Variables:
				struct _MultiSignal *msignal; // $s0
		/* end block 1.1 */
		// End offset: 0x800243FC
		// End Line: 4625
	/* end block 1 */
	// End offset: 0x80024424
	// End Line: 4630

	/* begin block 2 */
		// Start line: 11519
	/* end block 2 */
	// End Line: 11520
				UNIMPLEMENTED();
}


struct _StreamUnit* COLLIDE_CameraWithStreamSignals(struct Camera* camera)
{
	struct _SVector startPoint;
	struct _SVector endPoint;
	struct _Model* model;
	long numSignals;
	long i;
	long numStreamSignals;
	struct _MultiSignal (*signalListArray[8]);
	struct _StreamUnit (*streamSignalUnits[8]);
	struct _StreamUnit *playerStreamUnit;
	struct Level* level;
	long playerStreamUnitID;
	struct _Instance* instance;
	struct _Instance* af_instance;
	struct _MultiSignal* msignal;
	long isWarpGateSignal;
	struct _StreamUnit* cameraStreamUnit;
	long cameraStreamID;	
	int number;

	instance = camera->focusInstance;
	af_instance = gameTrackerX.playerInstance;

	playerStreamUnitID = instance->currentStreamUnitID;

	if (instance == af_instance)
	{
		if (gameTrackerX.SwitchToNewStreamUnit != 0)
		{
			playerStreamUnitID = gameTrackerX.moveRazielToStreamID;
		}
	}

	playerStreamUnit = STREAM_GetStreamUnitWithID(playerStreamUnitID);

	endPoint.x = camera->core.position.x;
	endPoint.y = camera->core.position.y;
	endPoint.z = camera->core.position.z;

	if (instance->matrix != NULL)
	{
		model = instance->object->modelList[instance->currentModel];

		if (model != NULL)
		{
			if (model->numSegments >= 2)
			{
				startPoint.x = instance->matrix[1].t[0];
				startPoint.y = instance->matrix[1].t[1];
				startPoint.z = instance->matrix[1].t[2];
			}
			else
			{
				startPoint.x = instance->position.x;
				startPoint.y = instance->position.y;
				startPoint.z = instance->position.z;
			}
		}
		else
		{
			startPoint.x = instance->position.x;
			startPoint.y = instance->position.y;
			startPoint.z = instance->position.z;
		}
	}
	else
	{
		startPoint.x = instance->position.x;
		startPoint.y = instance->position.y;
		startPoint.z = instance->position.z;
	}

	level = playerStreamUnit->level;
	numStreamSignals = 0;
	
	if (level != NULL)
	{
		numSignals = COLLIDE_LineWithSignals(&startPoint, &endPoint, signalListArray, 8, level);

		for(i = 0; i < numSignals; i++)
		{
			if (SIGNAL_IsStreamSignal(signalListArray[i]->signalList, &isWarpGateSignal) != 0)
			{
				if (isWarpGateSignal)
				{
					if (WARPGATE_IsWarpgateActive())
					{
						if (gameTrackerX.SwitchToNewWarpIndex == -1)
						{
							number = CurrentWarpNumber;
						}
						else
						{
							number = gameTrackerX.SwitchToNewWarpIndex;
						}

						cameraStreamID = WarpRoomArray[number].streamUnit->StreamUnitID;
					}
					else
					{
						cameraStreamID = 0;
					}
				}
				else
				{
					signalListArray[i]->signalList->data.StreamLevel.streamID;
				}

				if (cameraStreamID != 0)
				{
					cameraStreamUnit = STREAM_GetStreamUnitWithID(cameraStreamID);
				}
				else
				{
					cameraStreamUnit = NULL;
				}

				if (cameraStreamUnit != NULL)
				{
					streamSignalUnits[numStreamSignals++] = cameraStreamUnit;
				}
			}
		}
	}

	if (numStreamSignals == 0)
	{
		return 0;
	}
	else if (numStreamSignals != 1)
	{
		if (numStreamSignals > 0)
		{
			for (i = 0; i < numStreamSignals; i++)
			{
				if (streamSignalUnits[i]->StreamUnitID != playerStreamUnitID)
				{
					return streamSignalUnits[i];
				}
			}
		}
	}
	else
	{
		return streamSignalUnits[0];
	}

	return NULL;
}

void COLLIDE_InstanceListWithSignals(struct _InstanceList* instanceList)//Matching - 99.66%
{
	struct _Instance* instance;
	struct Level* level;

	instance = (struct _Instance*)instanceList->first;

	while (instance != NULL)
	{
		if (!(instance->flags2 & 0x24000000))
		{
			level = STREAM_GetLevelWithID(instance->currentStreamUnitID);
			
			if (level != NULL)
			{
				COLLIDE_InstanceTerrainSignal(instance, level);
			}
		}

		instance = instance->next;
	}
}

void COLLIDE_InstanceListTerrain(struct _InstanceList* instanceList)//Matching - 99.77%
{
	long i;
	struct _Instance* instance;
	struct Level* level;

	for (i = 1; i < 32; i += 2)
	{
		instance = (struct _Instance*)instanceList->group[i].next;

		while (instance != NULL)
		{
			if (instance->hModelList != NULL && !(instance->flags2 & 0x24040000))
			{
				level = STREAM_GetLevelWithID(instance->currentStreamUnitID);

				if (level != NULL)
				{
					COLLIDE_InstanceTerrain(instance, level);
				}
			}

			instance = (struct _Instance*)instance->node.next;
		}
	}
}


// autogenerated function stub: 
// void /*$ra*/ COLLIDE_SegmentCollisionOn(struct _Instance *instance /*$a0*/, int segment /*$a1*/)
void COLLIDE_SegmentCollisionOn(struct _Instance *instance, int segment)
{ // line 4947, offset 0x80024850
	/* begin block 1 */
		// Start line: 4949
		// Start offset: 0x80024850

		/* begin block 1.1 */
			// Start line: 4951
			// Start offset: 0x80024860
			// Variables:
				int i; // $a2
				struct _HModel *hmodel; // $v0
				struct _HPrim *hprim; // $v1
		/* end block 1.1 */
		// End offset: 0x800248C0
		// End Line: 4962
	/* end block 1 */
	// End offset: 0x800248C0
	// End Line: 4963

	/* begin block 2 */
		// Start line: 9894
	/* end block 2 */
	// End Line: 9895

	/* begin block 3 */
		// Start line: 12376
	/* end block 3 */
	// End Line: 12377
				UNIMPLEMENTED();
}

void COLLIDE_SegmentCollisionOff(struct _Instance* instance, int segment)
{
	int i;
	int enabled;
	struct _HModel* hmodel;
	struct _HPrim* hprim;

	if (instance->hModelList != NULL)
	{
		hmodel = &instance->hModelList[instance->currentModel];

		hprim = hmodel->hPrimList;

		enabled = 0;

		if (hmodel->numHPrims != 0)
		{
			for (i = hmodel->numHPrims; i != 0; i--)
			{
				if (hprim[i].segment == segment)
				{
					hprim[i].hpFlags &= 0xFE;
				}

				if (enabled == 0 && (hprim[i].hpFlags & 0x1))
				{
					enabled = 1;
				}
			}
		}

		if (enabled == 0)
		{
			instance->flags2 |= 0x40000;
		}
	}
}



// autogenerated function stub: 
// long /*$ra*/ COLLIDE_FindCollisionFaceNormal(struct _CollideInfo *collideInfo /*$a0*/, struct _Normal *normal /*$s2*/)
long COLLIDE_FindCollisionFaceNormal(struct _CollideInfo *collideInfo, struct _Normal *normal)
{ // line 5015, offset 0x80024964
#if 0
	/* begin block 1 */
		// Start line: 5016
		// Start offset: 0x80024964
		// Variables:
			long valid_normal; // $a2

		/* begin block 1.1 */
			// Start line: 5025
			// Start offset: 0x80024998
			// Variables:
				struct _TFace *tface; // $a1
		/* end block 1.1 */
		// End offset: 0x800249E0
		// End Line: 5029

		/* begin block 1.2 */
			// Start line: 5036
			// Start offset: 0x80024A18

			/* begin block 1.2.1 */
				// Start line: 5040
				// Start offset: 0x80024A18
				// Variables:
					SVECTOR*lNormal; // stack offset -24
					struct _Instance *inst1; // $s1
			/* end block 1.2.1 */
			// End offset: 0x80024A18
			// End Line: 5041
		/* end block 1.2 */
		// End offset: 0x80024A18
		// End Line: 5041

		/* begin block 1.3 */
			// Start line: 5054
			// Start offset: 0x80024A6C
			// Variables:
				struct _Instance *inst1; // $v0
		/* end block 1.3 */
		// End offset: 0x80024A84
		// End Line: 5058
	/* end block 1 */
	// End offset: 0x80024A84
	// End Line: 5060

	/* begin block 2 */
		// Start line: 10030
	/* end block 2 */
	// End Line: 10031
#endif
				UNIMPLEMENTED();
	return 0;
}

short* COLLIDE_GetBSPTreeFlag(struct _CollideInfo* collideInfo)
{
	struct Level* level;
	struct _Terrain* terrain;
	struct BSPTree* bspTree;

	level = (struct Level*)collideInfo->level;

	terrain = level->terrain;

	bspTree = &terrain->BSPTreeArray[collideInfo->bspID];

	return &bspTree->flags;
}

void COLLIDE_SetBSPTreeFlag(struct _CollideInfo* collideInfo, short flag)
{
	short* bspTreeFlags;

	bspTreeFlags = COLLIDE_GetBSPTreeFlag(collideInfo);

	bspTreeFlags[0] |= flag;
}


// autogenerated function stub: 
// int /*$ra*/ COLLIDE_PointAndTfaceFunc(struct _Terrain *terrain /*$fp*/, struct BSPTree *bsp /*$s6*/, struct _SVector *orgNewPos /*$s7*/, struct _SVector *orgOldPos /*$t4*/, struct _TFace *tface /*stack 16*/, long ignoreAttr /*stack 20*/, long flags /*stack 24*/)
int COLLIDE_PointAndTfaceFunc(struct _Terrain *terrain, struct BSPTree *bsp, struct _SVector *orgNewPos, struct _SVector *orgOldPos, struct _TFace *tface, long ignoreAttr, long flags)
{ // line 5121, offset 0x80024afc
#if 0
	/* begin block 1 */
		// Start line: 5122
		// Start offset: 0x80024AFC
		// Variables:
			struct PandTFScratch *CSpad; // $s0
			int result; // stack offset -48

		/* begin block 1.1 */
			// Start line: 5141
			// Start offset: 0x80024B8C
			// Variables:
				struct _SVector *vertex0; // $s3
				struct _SVector *vertex1; // $s4

			/* begin block 1.1.1 */
				// Start line: 5144
				// Start offset: 0x80024B8C
				// Variables:
					short _x0; // $v0
					short _y0; // $v1
					short _z0; // $a1
					short _x1; // $a2
					short _y1; // $t0
					short _z1; // $t2
					struct _SVector *_v; // $t1
					_Position *_v1; // $a3
			/* end block 1.1.1 */
			// End offset: 0x80024B8C
			// End Line: 5144

			/* begin block 1.1.2 */
				// Start line: 5144
				// Start offset: 0x80024B8C
				// Variables:
					short _x0; // $v0
					short _y0; // $v1
					short _z0; // $a1
					short _x1; // $a2
					short _y1; // $t0
					short _z1; // $a3
					struct _SVector *_v; // $t3
			/* end block 1.1.2 */
			// End offset: 0x80024B8C
			// End Line: 5144

			/* begin block 1.1.3 */
				// Start line: 5144
				// Start offset: 0x80024B8C
				// Variables:
					short *nrmlArray; // $a1
					struct _SVector *nrml; // $a0

				/* begin block 1.1.3.1 */
					// Start line: 5144
					// Start offset: 0x80024B8C
					// Variables:
						short *sPtr; // $v1
				/* end block 1.1.3.1 */
				// End offset: 0x80024CCC
				// End Line: 5154
			/* end block 1.1.3 */
			// End offset: 0x80024CCC
			// End Line: 5154

			/* begin block 1.1.4 */
				// Start line: 5185
				// Start offset: 0x80024DE0
				// Variables:
					short _x0; // $v0
					short _y0; // $v1
					short _z0; // $a0
					short _x1; // $a1
					short _y1; // $a3
					short _z1; // $a2
					_Position *_v1; // $a2
			/* end block 1.1.4 */
			// End offset: 0x80024DE0
			// End Line: 5185
		/* end block 1.1 */
		// End offset: 0x80024E18
		// End Line: 5189
	/* end block 1 */
	// End offset: 0x80024E1C
	// End Line: 5192

	/* begin block 2 */
		// Start line: 10242
	/* end block 2 */
	// End Line: 10243
#endif
					UNIMPLEMENTED();
	return 0;
}




