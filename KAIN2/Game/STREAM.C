#define _CRT_SECURE_NO_WARNINGS

#include "CORE.H"
#include "STREAM.H"
#include "INSTANCE.H"
#include "GAMELOOP.H"
#include "DEBUG.H"
#include "STRMLOAD.H"
#include "RELMOD.H"
#include "OBTABLE.H"
#include "PSX/AADLIB.H"
#include "MEMPACK.H"
#include "VRAM.H"
#include "GAMELOOP.H"
#include "LIGHT3D.H"
#include "EVENT.H"
#include "PLAN/PLANAPI.H"
#include "SAVEINFO.H"
#include "STRMLOAD.H"
#include "SOUND.H"
#include "CAMERA.H"
#include "MATH3D.H"

#include <stddef.h>

#ifdef PC_VERSION
#pragma warning(disable: 4101)
#endif

long CurrentWarpNumber;

struct WarpGateLoadInfo wgloadInfo;

struct WarpRoom WarpRoomArray[14];

struct STracker StreamTracker; // offset 0x800D1920

void STREAM_FillOutFileNames(char *baseAreaName, char *dramName, char *vramName, char *sfxName)
{ 
	char text[16];
	char *number;

	strcpy(text, baseAreaName);
	number = strpbrk(text, "0123456789");

	if (number != 0)
	{
		number[0] = 0;
	}

	if (dramName != NULL)
	{
		sprintf(dramName, "\\kain2\\area\\%s\\bin\\%s.drm", text, baseAreaName);
	}

	if (vramName != NULL)
	{
		sprintf(vramName, "\\kain2\\area\\%s\\bin\\%s.crm", text, baseAreaName);
	}

	if (sfxName != NULL)
	{
		sprintf(sfxName, "\\kain2\\area\\%s\\bin\\%s.snf", text, baseAreaName);
	}
}

void STREAM_AbortAreaLoad(char *baseAreaName)
{
	char vramName[80];
	STREAM_FillOutFileNames(baseAreaName, NULL, vramName, NULL);
	LOAD_AbortDirectoryChange(baseAreaName);
	LOAD_AbortFileLoad(vramName, (void*)VRAM_LoadReturn);
}

void STREAM_Init()
{
	int i;

	for (i = 0; i < 16; i++)
	{
		StreamTracker.StreamList[i].used = 0;
		StreamTracker.StreamList[i].flags = 0;
		StreamTracker.StreamList[i].StreamUnitID = 0;
	}
}

int FindObjectName(char *name)
{
	int i;
	struct _ObjectTracker *otr;

	otr = gameTrackerX.GlobalObjects;
	
	for(i = 0; i < 48; i++, otr++)
	{
		if (otr->objectStatus != 0)
		{
#if defined(UWP)
			if (_strcmpi(otr->name, name) == 0)
#else
			if (strcmpi(otr->name, name) == 0)
#endif
			{
				return i;
			}
		}
	}
	
	return -1;
}

struct _ObjectTracker* FindObjectInTracker(struct Object* object)
{
	int i;
	struct _ObjectTracker* otr;

	otr = gameTrackerX.GlobalObjects;
	
	for (i = 0; i < 48; i++, otr++)
	{
		if (otr->objectStatus != 0)
		{
			if (otr->object == object)
			{
				return otr;
			}
		}
	}

	return NULL;
}


// autogenerated function stub: 
// struct _StreamUnit * /*$ra*/ FindStreamUnitFromLevel(struct Level *level /*$a0*/)
struct _StreamUnit * FindStreamUnitFromLevel(struct Level *level)
{ // line 258, offset 0x800586d4
	/* begin block 1 */
		// Start line: 260
		// Start offset: 0x800586D4
		// Variables:
			struct _StreamUnit *ret; // $a2
			long i; // $a1
	/* end block 1 */
	// End offset: 0x8005871C
	// End Line: 272

	/* begin block 2 */
		// Start line: 516
	/* end block 2 */
	// End Line: 517

	/* begin block 3 */
		// Start line: 520
	/* end block 3 */
	// End Line: 521
			UNIMPLEMENTED();
	return null;
}

void STREAM_LoadObjectReturn(void* loadData, void* PTR_32 data, void* data2)
{
	struct Object* object;
	struct _ObjectTracker* PTR_32 objectTracker;
	char objDsfxFileName[64];

	object = (struct Object*)loadData;
	objectTracker = (struct _ObjectTracker* PTR_32)data;
	GetRCnt(0xF2000000);

	if ((object->oflags & 0x8000000) && object->relocList != NULL && object->relocModule != NULL)
	{
		RELMOD_InitModulePointers((int)object->relocModule, (int*)object->relocList);
	}

	STREAM_PackVRAMObject(objectTracker);
	OBTABLE_InitAnimPointers(objectTracker);
	OBTABLE_InitObjectWithID(object);

	if ((object->oflags2 & 0x800000))
	{
		sprintf(objDsfxFileName, "\\kain2\\sfx\\object\\%s\\%s.snf", objectTracker->name, objectTracker->name);

		object->sfxFileHandle = 0;

		if (LOAD_DoesFileExist(objDsfxFileName) != 0)
		{
			object->sfxFileHandle = aadLoadDynamicSfx(objectTracker->name, 0, 0);
		}
	}

	if (objectTracker->vramBlock == NULL)
	{
		objectTracker->objectStatus = 2;
	}
	else
	{
		objectTracker->objectStatus = 4;
	}
}


// autogenerated function stub: 
// void /*$ra*/ STREAM_DumpMonster(struct _ObjectTracker *dumpee /*$s2*/)
void STREAM_DumpMonster(struct _ObjectTracker *dumpee)
{ // line 399, offset 0x8005882c
	/* begin block 1 */
		// Start line: 400
		// Start offset: 0x8005882C
		// Variables:
			struct Object *object; // $s1
			struct _Instance *instance; // $a1

		/* begin block 1.1 */
			// Start line: 407
			// Start offset: 0x80058858
			// Variables:
				struct _Instance *next; // $s0
		/* end block 1.1 */
		// End offset: 0x80058874
		// End Line: 414
	/* end block 1 */
	// End offset: 0x80058880
	// End Line: 417

	/* begin block 2 */
		// Start line: 806
	/* end block 2 */
	// End Line: 807

	/* begin block 3 */
		// Start line: 811
	/* end block 3 */
	// End Line: 812
				UNIMPLEMENTED();
}

int STREAM_InList(char *name, char **nameList)
{
	char** mon = nameList;

	while (*mon != NULL)
	{
#if defined(PSXPC_VERSION)
		if (_strcmpi(name, *mon) == 0)
#else
		if (strcmpi(name, *mon) == 0)
#endif
		{
			return 1;
		}

		mon++;
	}

	return 0;
}

int STREAM_IsSpecialMonster(char *name)
{
	static char* mon[6] = {
		"wallcr",
		"aluka",
		"ronin",
		"slaugh"
		"vwraith",
		NULL
	};

	return STREAM_InList(name, mon);
}


// autogenerated function stub: 
// void /*$ra*/ STREAM_DumpSomeMonsters()
void STREAM_DumpSomeMonsters()
{ // line 475, offset 0x8005892c
	/* begin block 1 */
		// Start line: 476
		// Start offset: 0x8005892C
		// Variables:
			struct _ObjectTracker *otr; // $s1
			int i; // $s2
	/* end block 1 */
	// End offset: 0x800589A0
	// End Line: 491

	/* begin block 2 */
		// Start line: 984
	/* end block 2 */
	// End Line: 985
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ STREAM_NoMonsters()
void STREAM_NoMonsters()
{ // line 492, offset 0x800589bc
	/* begin block 1 */
		// Start line: 1037
	/* end block 1 */
	// End Line: 1038
	UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ STREAM_YesMonsters()
void STREAM_YesMonsters()
{ // line 498, offset 0x800589ec
#if defined(PC_VERSION)
	gameTrackerX.gameFlags &= ~0x4000000u;
#else
	UNIMPLEMENTED();
#endif
}


int STREAM_IsMonster(char *name)
{ 
	static char* monnames[19] = {
		"skinner",
		"morlock",
		"vlgra",
		"vlgrb",
		"vlgrc",
		"hunter",
		"wrshp",
		"roninbss",
		"skinbos",
		"priests",
		"alukabss",
		"morboss",
		"soul",
		"wallcr",
		"aluka",
		"ronin",
		"sluagh",
		"vwraith",
		NULL,
	};
	
	return STREAM_InList(name, monnames);
}

int STREAM_TryAndDumpANonResidentObject()
{ 
	struct _ObjectTracker* otr;
	int i;

	otr = gameTrackerX.GlobalObjects;

	for (i = 0; i < 48; i++, otr++)
	{
		if (STREAM_TryAndDumpNonResident(otr) != 0)
		{
			return i;
		}
	}

	return -1;
}

int InsertGlobalObject(char *name, struct GameTracker *gameTracker)
{ 
	char string[64];
	char vramname[64];
	int i;
	struct _ObjectTracker *otr;
	
	if ((gameTrackerX.gameFlags & 0x4000000))
	{
		if (STREAM_IsSpecialMonster(name) != 0)
		{
			return -1;
		}
	}
	
	if ((gameTracker->debugFlags2 & 0x8000))
	{
		if (STREAM_IsMonster(name) != 0)
		{
			return -1;
		}
	}

	otr = gameTracker->GlobalObjects;

	for (i = 0; i < 48; i++, otr++)
	{
		if (otr->objectStatus != 0)
		{
#if defined(PSXPC_VERSION)
			if (_strcmpi(otr->name, name) == 0)
#else
			if (strcmpi(otr->name, name) == 0)
#endif
			{
				break;
			}
		}
	}

	if (i == 48)
	{
		otr = gameTracker->GlobalObjects;
		i = 0;

		do
		{
			if (otr->objectStatus == 0)
			{
				break;
			}
			i++;
			otr++;
		} while (i < 48);

		if (i == 48)
		{
			i = STREAM_TryAndDumpANonResidentObject();

			if (i == -1)
			{
				DEBUG_FatalError("The Object tracker is full MAX_OBJECTS=%d\n", 48);
			}
		}

		sprintf(string, "\\kain2\\object\\%s\\%s.drm", name, name);
		sprintf(vramname, "\\kain2\\object\\%s\\%s.crm", name, name);
		
		strcpy(otr->name, name);

		otr->objectStatus = 1;
		LOAD_NonBlockingBinaryLoad(string, (void*)STREAM_LoadObjectReturn, (void*)otr, NULL, (void**)&otr->object, 1);
		otr->numInUse = 0;
		otr->numObjectsUsing = 0;
	}

	return i;
}

struct _ObjectTracker * STREAM_GetObjectTracker(char *name)
{ 
	int i;

	i = InsertGlobalObject(name, &gameTrackerX);
	
	if (i != -1)
	{
		return &gameTrackerX.GlobalObjects[i];
	}

	return NULL;
}

void LoadLevelObjects(struct _StreamUnit *stream)
{
	int objlist_pos;
	char name[20];
	struct Level *level;
	int i;
	
	STREAM_NextLoadAsNormal();
	objlist_pos = 0;
	
	while (((unsigned char*)stream->level->objectNameList)[objlist_pos] != 255)
	{
		strcpy(name, (char*)stream->level->objectNameList + objlist_pos);
		InsertGlobalObject(name, &gameTrackerX);

		objlist_pos += 16;
	}

	level = stream->level;

	if (level->numIntros > 0)
	{
		for (i = 0; i < level->numIntros; i++)
		{
			if (FindObjectName(level->introList[i].name) != -1)
			{
				level->introList[i].flags &= 0xFFFFBFFF;
			}
			else
			{
				level->introList[i].flags |= 0x4000;
			}
		}
	}
}


// autogenerated function stub: 
// long /*$ra*/ STREAM_IsAnInstanceUsingObject(struct Object *object /*$a0*/)
long STREAM_IsAnInstanceUsingObject(struct Object *object)
{ // line 715, offset 0x80058d88
	/* begin block 1 */
		// Start line: 717
		// Start offset: 0x80058D88
		// Variables:
			struct _Instance *instance; // $v1
			struct _Instance *next; // $v1
			long ret; // $a1
	/* end block 1 */
	// End offset: 0x80058DC0
	// End Line: 733

	/* begin block 2 */
		// Start line: 1483
	/* end block 2 */
	// End Line: 1484

	/* begin block 3 */
		// Start line: 1484
	/* end block 3 */
	// End Line: 1485
			UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// void /*$ra*/ STREAM_StreamLoadObjectAbort(void *loadData /*$a0*/, void *data /*$a1*/, void *data2 /*$a2*/)
void STREAM_StreamLoadObjectAbort(void *loadData, void *data, void *data2)
{ // line 736, offset 0x80058dc8
	/* begin block 1 */
		// Start line: 737
		// Start offset: 0x80058DC8
		// Variables:
			struct _ObjectTracker *objectTracker; // $s0
	/* end block 1 */
	// End offset: 0x80058DE4
	// End Line: 741

	/* begin block 2 */
		// Start line: 1527
	/* end block 2 */
	// End Line: 1528
			UNIMPLEMENTED();
}

void STREAM_DumpLoadingObjects()
{
	int i;
	struct _ObjectTracker* tracker;

	tracker = gameTrackerX.GlobalObjects;

	for (i = 0; i < 48; i++, tracker++)
	{
		if (tracker->objectStatus == 2)
		{
			STREAM_DumpObject(tracker);
		}
	}
}

void STREAM_DumpObject(struct _ObjectTracker *objectTracker)
{ 
	struct Object *object;
	char dramName[64];

	object = objectTracker->object;
	
	if (objectTracker->objectStatus == 1)
	{
		sprintf(dramName, "\\kain2\\object\\%s\\%s.drm", objectTracker->name, objectTracker->name);
		LOAD_AbortFileLoad(dramName, (void*)STREAM_StreamLoadObjectAbort);
	}
	else
	{
		if (object != NULL)
		{
			if (!(object->oflags & 0x2000000))
			{
				if (objectTracker->vramBlock != NULL)
				{
					VRAM_ClearVramBlock((struct _BlockVramEntry*)objectTracker->vramBlock);
				}

				if ((object->oflags2 & 0x800000) && object->sfxFileHandle != 0)
				{
					aadFreeDynamicSfx(object->sfxFileHandle);
				}
			
				OBTABLE_RemoveObjectEntry(object);
				MEMPACK_Free((char*)object);

				objectTracker->objectStatus = 0;
			}

			if (object == NULL)
			{
				objectTracker->objectStatus = 0;
			}
		}

		objectTracker->objectStatus = 0;
	}
}

int STREAM_IsObjectInAnyUnit(struct _ObjectTracker *tracker)
{
	int d;
	unsigned char *objlist;

	for (d = 0; d < 16; d++)
	{
		if (StreamTracker.StreamList[d].used == 2 && StreamTracker.StreamList[d].level == NULL)
		{
			objlist = (unsigned char*)StreamTracker.StreamList[d].level->objectNameList;

			while (objlist[0] != 255)
			{
#if defined(PSXPC_VERSION)
				if (_strcmpi(&tracker->name[0], (char*)objlist) == 0)
#else
				if (strcmpi(&tracker->name[0], (char*)objlist) == 0)
#endif
				{
					return 1;
				}

				objlist += 16;
			}
		}
	}

	return 0;
}


// autogenerated function stub: 
// void /*$ra*/ STREAM_RemoveAllObjectsNotInUse()
void STREAM_RemoveAllObjectsNotInUse()
{ // line 829, offset 0x80059000
	/* begin block 1 */
		// Start line: 830
		// Start offset: 0x80059000
		// Variables:
			int i; // $s3
			int abort; // $a3
			struct _ObjectTracker *tracker; // $s1
			struct _ObjectTracker *trackerList; // $s4

		/* begin block 1.1 */
			// Start line: 839
			// Start offset: 0x8005904C
			// Variables:
				struct Object *object; // $s2
		/* end block 1.1 */
		// End offset: 0x8005908C
		// End Line: 854

		/* begin block 1.2 */
			// Start line: 862
			// Start offset: 0x800590C8
			// Variables:
				int j; // $a0
		/* end block 1.2 */
		// End offset: 0x80059124
		// End Line: 875

		/* begin block 1.3 */
			// Start line: 883
			// Start offset: 0x8005915C
			// Variables:
				//int j; // $t0
				struct _ObjectTracker *otr; // $a3

			/* begin block 1.3.1 */
				// Start line: 887
				// Start offset: 0x80059188
				// Variables:
					int k; // $a0

				/* begin block 1.3.1.1 */
					// Start line: 896
					// Start offset: 0x800591AC
					// Variables:
						int l; // $a1
				/* end block 1.3.1.1 */
				// End offset: 0x800591F8
				// End Line: 903
			/* end block 1.3.1 */
			// End offset: 0x80059210
			// End Line: 905
		/* end block 1.3 */
		// End offset: 0x8005922C
		// End Line: 908
	/* end block 1 */
	// End offset: 0x80059298
	// End Line: 926

	/* begin block 2 */
		// Start line: 1753
	/* end block 2 */
	// End Line: 1754
						UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ RemoveAllObjects(struct GameTracker *gameTracker /*$a0*/)
void RemoveAllObjects(struct GameTracker *gameTracker)
{ // line 929, offset 0x800592c0
	/* begin block 1 */
		// Start line: 930
		// Start offset: 0x800592C0
		// Variables:
			int i; // $s1
			struct _ObjectTracker *tracker; // $s0
	/* end block 1 */
	// End offset: 0x80059304
	// End Line: 940

	/* begin block 2 */
		// Start line: 2083
	/* end block 2 */
	// End Line: 2084
			UNIMPLEMENTED();
}

struct Level * STREAM_GetLevelWithID(long id)
{ 
#if defined(PSX_VERSION)
	struct Level* retLevel;
	long i;

	retLevel = NULL;

	for (i = 0; i < 16; i++)
	{
		if (StreamTracker.StreamList[i].used == 2)
		{
			if (StreamTracker.StreamList[i].StreamUnitID == id)
			{
				retLevel = StreamTracker.StreamList[i].level;
				return retLevel;
			}
		}
	}

	return retLevel;

#elif 0//defined(PC_VERSION)
	// line 945, offset 0x80059318
	struct Level* result; // eax
	int v2; // edx
	WORD* v3; // ecx

	result = 0;
	v2 = 0;
	v3 = &StreamTracker;
	while (v3[2] != 2 || *(DWORD*)v3 != id)
	{
		v3 += 32;
		++v2;
		if ((int)v3 >= (int)&MORPH_SavedLevel)
			return result;
	}
	return (struct Level*)dword_C593C8[16 * v2];
#endif
}

struct _StreamUnit* STREAM_GetStreamUnitWithID(long id)
{
	struct _StreamUnit* retUnit;
	long i;

	retUnit = NULL;
	
	for (i = 0; i < 16; i++)
	{
		if (StreamTracker.StreamList[i].used == 2)
		{
			if (StreamTracker.StreamList[i].StreamUnitID == id)
			{
				retUnit = &StreamTracker.StreamList[i];
				break;
			}
		}
	}

	return retUnit;
}


// autogenerated function stub: 
// struct _StreamUnit * /*$ra*/ STREAM_GetStreamUnitWithName(char *name /*$s4*/)
struct _StreamUnit * STREAM_GetStreamUnitWithName(char *name)
{ // line 981, offset 0x800593c0
	/* begin block 1 */
		// Start line: 982
		// Start offset: 0x800593C0
		// Variables:
			struct _StreamUnit *retUnit; // $s3
			long i; // $s2
	/* end block 1 */
	// End offset: 0x8005942C
	// End Line: 995

	/* begin block 2 */
		// Start line: 2208
	/* end block 2 */
	// End Line: 2209
			UNIMPLEMENTED();
	return null;
}


// autogenerated function stub: 
// void /*$ra*/ STREAM_CalculateWaterLevel(struct Level *level /*$t3*/)
void STREAM_CalculateWaterLevel(struct Level *level)
{
	struct _Terrain *terrain; // $t2
	int i; // $t0
	struct _TFace *tface; // $a3
	long waterZLevel; // $t1

	//t3 = level
	waterZLevel = -32767;

	if (level->waterZLevel == 0)
	{
		if ((level->unitFlags & 0x1))
		{
			level->waterZLevel = 32767;
			return;
		}
		//loc_80059948

		terrain = level->terrain;
		i = terrain->numFaces;
		tface = terrain->faceList;

		//v0 = -0x7FFF
		if (i > 0)
		{
			//t4 = -0x7FFF
			//a2 = &tface->face.v2
			//loc_80059968
			{
				if ((tface->attr & 0x8))
				{
					//v0 = tface->face.v0
					//a1 = terrain->vertexList
					//a0 = tface->face.v1

					//v1 = terrain->vertexList[tface->face.v0];
					//v0 = terrain->vertexList[tface->face.v1];

					if (terrain->vertexList[tface->face.v0].vertex.z == terrain->vertexList[tface->face.v1].vertex.z &&
						terrain->vertexList[tface->face.v0].vertex.z == terrain->vertexList[tface->face.v2].vertex.z)
					{

					}
					//loc_800599FC
				}
			}
			//loc_800599FC
		}
		//loc_80059A10
	}
	//locret_80059A40
	UNIMPLEMENTED();
#if 0

		bne     $t1, $t4, loc_800599F4
		nop
		j       loc_800599FC
		move    $t1, $a0

		loc_800599F4 :
	bne     $t1, $a0, loc_80059A10
		li      $v0, 0xFFFF8001

		loc_800599FC :
		addiu   $t0, -1
		addiu   $a2, 0xC
		bgtz    $t0, loc_80059968
		addiu   $a3, 0xC
		li      $v0, 0xFFFF8001

		loc_80059A10 :
		bne     $t1, $v0, loc_80059A20
		nop
		jr      $ra
		sw      $t1, 0x38($t3)

		loc_80059A20 :
		lw      $v0, 0($t3)
		nop
		lw      $v0, 0x48($v0)
		nop
		lh      $v0, 0x10($v0)
		nop
		addu    $v0, $t1, $v0
		sw      $v0, 0x38($t3)

		locret_80059A40:
	jr      $ra
		nop
#endif
}


// autogenerated function stub: 
// int /*$ra*/ STREAM_IsMorphInProgress()
int STREAM_IsMorphInProgress()
{ // line 1057, offset 0x80059580
	/* begin block 1 */
		// Start line: 2395
	/* end block 1 */
	// End Line: 2396

	/* begin block 2 */
		// Start line: 2396
	/* end block 2 */
	// End Line: 2397
	UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// long /*$ra*/ STREAM_GetWaterZLevel(struct Level *level /*$a0*/, struct _Instance *instance /*$a1*/)
long STREAM_GetWaterZLevel(struct Level *level, struct _Instance *instance)
{ // line 1063, offset 0x80059594
	/* begin block 1 */
		// Start line: 1065
		// Start offset: 0x80059594
		// Variables:
			long waterZLevel; // $a1
	/* end block 1 */
	// End offset: 0x8005960C
	// End Line: 1090

	/* begin block 2 */
		// Start line: 2407
	/* end block 2 */
	// End Line: 2408

	/* begin block 3 */
		// Start line: 2408
	/* end block 3 */
	// End Line: 2409

	/* begin block 4 */
		// Start line: 2410
	/* end block 4 */
	// End Line: 2411
			UNIMPLEMENTED();
	return 0;
}

void STREAM_SetMainFog(struct _StreamUnit *streamUnit)
{ 
	struct Level *level;

	level = streamUnit->level;

	if (gameTrackerX.gameData.asmData.MorphType != 0)
	{
		streamUnit->UnitFogNear = level->spectralFogNear;
		streamUnit->UnitFogFar = level->spectralFogFar;
	}
	else
	{
		streamUnit->UnitFogNear = level->holdFogNear;
		streamUnit->UnitFogFar = level->holdFogFar;
	}
}

void STREAM_SetStreamFog(struct _StreamUnit *streamUnit, short fogNear, short fogFar)
{
	streamUnit->TargetFogFar = streamUnit->UnitFogFar = MIN(fogFar, FindStreamUnitFromLevel(gameTrackerX.level)->UnitFogFar) - 2000;
	streamUnit->TargetFogNear = streamUnit->UnitFogNear = MIN(fogNear, streamUnit->UnitFogFar) - 2000;
}


// autogenerated function stub: 
// void /*$ra*/ STREAM_ConnectStream(struct _StreamUnit *streamUnit /*$s6*/)
void STREAM_ConnectStream(struct _StreamUnit* streamUnit)
{ // line 1171, offset 0x800596f8
	/* begin block 1 */
		// Start line: 1172
		// Start offset: 0x800596F8
		// Variables:
	struct _StreamUnit* mainUnit; // stack offset -48
	struct StreamUnitPortal* streamPortal; // $a0
	int numportals; // $v1
	struct StreamUnitPortal* streamPortal2; // $s4
	int numportals2; // $fp
	int i; // $s0
	int j; // $s3
	char text[16]; // stack offset -72
	char* commapos; // $v0
	int signalID; // $s2

/* begin block 1.1 */
	// Start line: 1196
	// Start offset: 0x80059774
	// Variables:
	struct _StreamUnit* connectStream; // $s0

/* begin block 1.1.1 */
	// Start line: 1230
	// Start offset: 0x8005988C
	// Variables:
	struct _SVector offset; // stack offset -56
/* end block 1.1.1 */
// End offset: 0x8005988C
// End Line: 1241
/* end block 1.1 */
// End offset: 0x80059898
// End Line: 1250

/* begin block 1.2 */
	// Start line: 1255
	// Start offset: 0x800598AC
	// Variables:
	long d; // stack offset -44
	//struct _StreamUnit *connectStream; // $s5

/* begin block 1.2.1 */
	// Start line: 1270
	// Start offset: 0x800598FC
	// Variables:
	long hookedUp; // $s0

/* begin block 1.2.1.1 */
	// Start line: 1310
	// Start offset: 0x80059A1C
	// Variables:
		//struct _SVector offset; // stack offset -56
/* end block 1.2.1.1 */
// End offset: 0x80059A1C
// End Line: 1321
/* end block 1.2.1 */
// End offset: 0x80059A28
// End Line: 1330
/* end block 1.2 */
// End offset: 0x80059A58
// End Line: 1330
/* end block 1 */
// End offset: 0x80059AD4
// End Line: 1344

/* begin block 2 */
	// Start line: 2636
/* end block 2 */
// End Line: 2637
	UNIMPLEMENTED();
}

// autogenerated function stub: 
// void /*$ra*/ STREAM_StreamLoadLevelAbort(void *loadData /*$a0*/, void *data /*$a1*/, void *data2 /*$a2*/)
void STREAM_StreamLoadLevelAbort(void* loadData, void* data, void* data2)
{ // line 1346, offset 0x80059b04
	/* begin block 1 */
		// Start line: 1347
		// Start offset: 0x80059B04
		// Variables:
	struct _StreamUnit* streamUnit; // $s0
/* end block 1 */
// End offset: 0x80059B20
// End Line: 1351

/* begin block 2 */
	// Start line: 3223
/* end block 2 */
// End Line: 3224
	UNIMPLEMENTED();
}

void STREAM_DoObjectLoadAndDump(struct _StreamUnit* streamUnit)
{
	int i;

	i = 0;
	do
	{
		if (StreamTracker.StreamList[i].used == 1)
		{
			break;
		}

	} while (i++ < 16);

	STREAM_RemoveAllObjectsNotInUse();
}

void STREAM_FinishLoad(struct _StreamUnit *streamUnit)
{
	struct Level *level;
	char sfxName[80];

	STREAM_FillOutFileNames(streamUnit->baseAreaName, NULL, NULL, sfxName);

	level = streamUnit->level;
	level->morphLastStep = -1;
	
	streamUnit->sfxFileHandle = 0;
	
	if (LOAD_DoesFileExist(sfxName) != 0)
	{
		streamUnit->sfxFileHandle = aadLoadDynamicSfx(streamUnit->baseAreaName, streamUnit->StreamUnitID, 1);
	}
	
	LoadLevelObjects(streamUnit);
	
	streamUnit->FogColor = (level->cpad1 << 24) | (level->backColorB << 16) | (level->backColorG << 8) | (level->backColorR);
	streamUnit->TargetFogFar = level->fogFar;
	streamUnit->TargetFogNear = level->fogNear;

	LIGHT_CalcDQPTable(level);
	
	STREAM_CalculateWaterLevel(level);

	if (gameTrackerX.gameData.asmData.MorphType == 1)
	{
		MORPH_UpdateNormals(level);
	}

	STREAM_ConnectStream(streamUnit);

	streamUnit->used = 2;

	STREAM_DoObjectLoadAndDump(streamUnit);

	EVENT_LoadEventsForLevel(streamUnit->StreamUnitID, level);
	
	PLANAPI_InitPlanMkrList(streamUnit);

	if (level->startUnitLoadedSignal != NULL)
	{
		level->startUnitLoadedSignal->flags |= 0x1;
		
		SIGNAL_HandleSignal(gameTrackerX.playerInstance, (Signal*)level->startUnitLoadedSignal, 8);
		
		EVENT_AddSignalToReset(level->startUnitLoadedSignal);
	}

	SAVE_IntroForStreamID(streamUnit);
	SAVE_UpdateLevelWithSave(streamUnit);
	
	EVENT_AddStreamToInstanceList(streamUnit);
	
	WARPGATE_FixUnit(streamUnit);
}

void STREAM_LoadLevelReturn(void *loadData, void *data, void *data2)
{
	GetRCnt(0xF2000000);

	((_StreamUnit*)data2)->StreamUnitID = ((Level*)loadData)->streamUnitID;

	gameTrackerX.level = (Level*)loadData;
	gameTrackerX.StreamUnitID = ((Level*)loadData)->streamUnitID;
	
	STREAM_SetMainFog(((_StreamUnit*)data2));
	STREAM_FinishLoad(((_StreamUnit*)data2));
}


// autogenerated function stub: 
// void /*$ra*/ STREAM_StreamLoadLevelReturn(void *loadData /*$s0*/, void *data /*$a1*/, void *data2 /*$s1*/)
void STREAM_StreamLoadLevelReturn(void *loadData, void *data, void *data2)
{ // line 1498, offset 0x80059d30
	/* begin block 1 */
		// Start line: 1499
		// Start offset: 0x80059D30
		// Variables:
			struct Level *level; // $s0
			struct _StreamUnit *streamUnit; // $s1
	/* end block 1 */
	// End offset: 0x80059E04
	// End Line: 1596

	/* begin block 2 */
		// Start line: 3546
	/* end block 2 */
	// End Line: 3547
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ STREAM_UpdateLevelPointer(struct Level *oldLevel /*$a0*/, struct Level *newLevel /*$a1*/, long sizeOfLevel /*$a2*/)
void STREAM_UpdateLevelPointer(struct Level *oldLevel, struct Level *newLevel, long sizeOfLevel)
{ // line 1623, offset 0x80059e18
	/* begin block 1 */
		// Start line: 1624
		// Start offset: 0x80059E18
		// Variables:
			long i; // $t0
			long offset; // $t1
			struct GameTracker *gameTracker; // $v0

		/* begin block 1.1 */
			// Start line: 1652
			// Start offset: 0x80059E7C
			// Variables:
				struct _Instance *instance; // $a3
		/* end block 1.1 */
		// End offset: 0x8005A00C
		// End Line: 1692
	/* end block 1 */
	// End offset: 0x8005A0F0
	// End Line: 1714

	/* begin block 2 */
		// Start line: 3246
	/* end block 2 */
	// End Line: 3247
				UNIMPLEMENTED();
}


// autogenerated function stub: 
// struct _StreamUnit * /*$ra*/ STREAM_WhichUnitPointerIsIn(void *pointer /*$s3*/)
struct _StreamUnit * STREAM_WhichUnitPointerIsIn(void *pointer)
{ // line 1719, offset 0x8005a108
	/* begin block 1 */
		// Start line: 1720
		// Start offset: 0x8005A108
		// Variables:
			int i; // $s2
			int size; // $v1
			struct Level *level; // $s0
	/* end block 1 */
	// End offset: 0x8005A194
	// End Line: 1740

	/* begin block 2 */
		// Start line: 3981
	/* end block 2 */
	// End Line: 3982
			UNIMPLEMENTED();
	return null;
}


// autogenerated function stub: 
// void /*$ra*/ STREAM_UpdateObjectPointer(struct Object *oldObject /*$s2*/, struct Object *newObject /*$s3*/, long sizeOfObject /*$s4*/)
void STREAM_UpdateObjectPointer(struct Object *oldObject, struct Object *newObject, long sizeOfObject)
{ // line 1742, offset 0x8005a1b4
	/* begin block 1 */
		// Start line: 1743
		// Start offset: 0x8005A1B4
		// Variables:
			long i; // $a3
			long d; // $a1
			struct GameTracker *gameTracker; // $s0
			long offset; // $s1
			struct _ObjectTracker *otr; // $t0

		/* begin block 1.1 */
			// Start line: 1763
			// Start offset: 0x8005A208
			// Variables:
				int j; // $a1
				struct Object *object; // $a2
		/* end block 1.1 */
		// End offset: 0x8005A294
		// End Line: 1773

		/* begin block 1.2 */
			// Start line: 1791
			// Start offset: 0x8005A2F0
			// Variables:
				struct _Instance *instance; // $s0
		/* end block 1.2 */
		// End offset: 0x8005A408
		// End Line: 1820
	/* end block 1 */
	// End offset: 0x8005A434
	// End Line: 1828

	/* begin block 2 */
		// Start line: 4049
	/* end block 2 */
	// End Line: 4050
				UNIMPLEMENTED();
}

void STREAM_UpdateInstanceCollisionInfo(struct _HModel *oldHModel, struct _HModel *newHModel)
{
	struct _Instance* instance;

	instance = gameTrackerX.instanceList->first;
	
	while (instance != NULL)
	{
		if (instance->hModelList == oldHModel)
		{
			instance->hModelList = newHModel;
		}

		instance = instance->next;
	}
}

void STREAM_LoadMainVram(struct GameTracker *gameTracker, char *baseAreaName, struct _StreamUnit *streamUnit)
{
	char dramName[80];
	char vramName[80];
	struct VramBuffer *vramBuffer;
	struct Level* level;

	level = streamUnit->level;

	STREAM_FillOutFileNames(gameTrackerX.baseAreaName, dramName, vramName, NULL);

	vramBuffer = (struct VramBuffer*)MEMPACK_Malloc((level->vramSize.w << 1) + 20, 0x23);

	vramBuffer->lineOverFlow = (short*)(vramBuffer + 1);
	vramBuffer->flags = 0;
	vramBuffer->x = (level->vramSize.x) + SCREEN_WIDTH;
	vramBuffer->y = level->vramSize.y;
	vramBuffer->w = level->vramSize.w;
	vramBuffer->h = level->vramSize.h;

	M_TrackClutUpdate = 0;

	vramBuffer->yOffset = 0;
	vramBuffer->lengthOfLeftOverData = 0;
	
	LOAD_NonBlockingBufferedLoad(vramName, (void*)VRAM_TransferBufferToVram, vramBuffer, NULL);
}

void STREAM_MoveIntoNewStreamUnit()
{
	gameTrackerX.playerInstance->cachedTFace = -1;
	gameTrackerX.playerInstance->cachedTFaceLevel = NULL;
	gameTrackerX.playerInstance->currentStreamUnitID = gameTrackerX.moveRazielToStreamID;

	INSTANCE_UpdateFamilyStreamUnitID(gameTrackerX.playerInstance);

	GAMELOOP_StreamLevelLoadAndInit(gameTrackerX.baseAreaName, &gameTrackerX, gameTrackerX.toSignal, gameTrackerX.fromSignal);

	gameTrackerX.SwitchToNewStreamUnit = 0;

	if (gameTrackerX.SwitchToNewWarpIndex != -1)
	{
		SndPlayVolPan(388, 127, 64, 0);
		CurrentWarpNumber = gameTrackerX.SwitchToNewWarpIndex;
	}
}

struct _StreamUnit * STREAM_LoadLevel(char *baseAreaName, struct StreamUnitPortal *streamPortal, int loadnext)
{
	int i;
	long streamID;
	struct _StreamUnit *streamUnit;
	struct Level *level;
	char dramName[80];

	streamID = -1;

	if (streamPortal != NULL)
	{
		streamID = streamPortal->streamID;
	}

	for (i = 0; i < 16; i++)
	{
		streamUnit = &StreamTracker.StreamList[i];
		
		if (streamUnit->used != 0)
		{
#if defined(PSXPC_VERSION)
			if (_strcmpi(streamUnit->baseAreaName, baseAreaName) == 0)
#else
			if (strcmpi(streamUnit->baseAreaName, baseAreaName) == 0)
#endif
			{
				if (streamUnit->used != 3)
				{
					if (streamUnit->used != 1)
					{
						streamUnit->FrameCount = 0;
						
						if (streamPortal == NULL)
						{
							strcpy(gameTrackerX.baseAreaName, baseAreaName);
							
							STREAM_SetMainFog(streamUnit);
							
							gameTrackerX.StreamUnitID = streamUnit->StreamUnitID;
							gameTrackerX.level = streamUnit->level;
						}
						else
						{
							level = streamUnit->level;
				
							STREAM_ConnectStream(streamUnit);

							if (gameTrackerX.gameData.asmData.MorphType != 0)
							{
								STREAM_SetStreamFog(streamUnit, level->spectralFogNear, level->spectralFogFar);
							}
							else
							{
								STREAM_SetStreamFog(streamUnit, level->holdFogNear, level->holdFogFar);
							}
						}
					}
					break;
				}
				else
				{
					streamUnit->used = 1;
				}
			}
		}
	}

	if (i == 16)
	{
		for (i = 0; i < 16; i++)
		{
			streamUnit = &StreamTracker.StreamList[i];

			if (streamUnit->used == 0)
			{
				STREAM_FillOutFileNames(baseAreaName, dramName, NULL, NULL);
				
				streamUnit->used = 1;
				
				strcpy(streamUnit->baseAreaName, baseAreaName);

				streamUnit->StreamUnitID = streamID;
				streamUnit->FrameCount = 0;
				streamUnit->flags = 0;

				if (streamPortal == NULL)
				{
					strcpy(gameTrackerX.baseAreaName, baseAreaName);

					gameTrackerX.StreamUnitID = streamUnit->StreamUnitID;

					LOAD_NonBlockingBinaryLoad(dramName, (void*)STREAM_LoadLevelReturn, NULL, streamUnit, (void**)&streamUnit->level, 2);

					break;
				}
				else
				{
					streamPortal->toStreamUnit = NULL;

					LOAD_NonBlockingBinaryLoad(dramName, (void*)STREAM_StreamLoadLevelReturn, NULL, streamUnit, (void**)&streamUnit->level, 2);

					break;
				}
			}
		}
	}
	
	return streamUnit;
}


// autogenerated function stub: 
// void /*$ra*/ RemoveIntroducedLights(struct Level *level /*$s2*/)
void RemoveIntroducedLights(struct Level *level)
{ // line 2144, offset 0x8005a7f8
	/* begin block 1 */
		// Start line: 2145
		// Start offset: 0x8005A7F8
		// Variables:
			int i; // $s0
	/* end block 1 */
	// End offset: 0x8005A8C4
	// End Line: 2166

	/* begin block 2 */
		// Start line: 5067
	/* end block 2 */
	// End Line: 5068
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ STREAM_RemoveInstancesWithIDInInstanceList(struct _InstanceList *list /*$s4*/, long id /*$s2*/, struct Level *level /*$s3*/)
void STREAM_RemoveInstancesWithIDInInstanceList(struct _InstanceList *list, long id, struct Level *level)
{ // line 2168, offset 0x8005a8dc
	/* begin block 1 */
		// Start line: 2169
		// Start offset: 0x8005A8DC
		// Variables:
			struct _Instance *instance; // $s0
			struct _Instance *next; // $s1
	/* end block 1 */
	// End offset: 0x8005A968
	// End Line: 2197

	/* begin block 2 */
		// Start line: 5126
	/* end block 2 */
	// End Line: 5127
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ STREAM_MarkUnitNeeded(long streamID /*$a0*/)
void STREAM_MarkUnitNeeded(long streamID)
{ // line 2199, offset 0x8005a988
	/* begin block 1 */
		// Start line: 2201
		// Start offset: 0x8005A988
		// Variables:
			int i; // $a1
	/* end block 1 */
	// End offset: 0x8005A9CC
	// End Line: 2217

	/* begin block 2 */
		// Start line: 5191
	/* end block 2 */
	// End Line: 5192

	/* begin block 3 */
		// Start line: 5192
	/* end block 3 */
	// End Line: 5193

	/* begin block 4 */
		// Start line: 5195
	/* end block 4 */
	// End Line: 5196
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ STREAM_DumpUnit(struct _StreamUnit *streamUnit /*$s2*/, long doSave /*$s3*/)
void STREAM_DumpUnit(struct _StreamUnit *streamUnit, long doSave)
{ // line 2219, offset 0x8005a9d4
	/* begin block 1 */
		// Start line: 2220
		// Start offset: 0x8005A9D4
		// Variables:
			int i; // $s0
			int j; // $a0
			int numportals; // $a1

		/* begin block 1.1 */
			// Start line: 2249
			// Start offset: 0x8005AA88
			// Variables:
				char dramName[80]; // stack offset -104
		/* end block 1.1 */
		// End offset: 0x8005AAB4
		// End Line: 2260

		/* begin block 1.2 */
			// Start line: 2277
			// Start offset: 0x8005AAF0
			// Variables:
				struct _SFXMkr *sfxMkr; // $a1
		/* end block 1.2 */
		// End offset: 0x8005AAF0
		// End Line: 2277
	/* end block 1 */
	// End offset: 0x8005AB9C
	// End Line: 2309

	/* begin block 2 */
		// Start line: 5240
	/* end block 2 */
	// End Line: 5241
				UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ STREAM_DumpAllUnitsNotNeeded()
void STREAM_DumpAllUnitsNotNeeded()
{ // line 2311, offset 0x8005abb8
	/* begin block 1 */
		// Start line: 2312
		// Start offset: 0x8005ABB8
		// Variables:
			int i; // $s1
	/* end block 1 */
	// End offset: 0x8005AC0C
	// End Line: 2324

	/* begin block 2 */
		// Start line: 5445
	/* end block 2 */
	// End Line: 5446
			UNIMPLEMENTED();
}

void STREAM_DumpAllLevels(long IDNoRemove, int DoSave)
{
	int i;

	for (i = 0; i < 16; i++)
	{
		if (StreamTracker.StreamList[i].used != 0 && StreamTracker.StreamList[i].StreamUnitID != IDNoRemove)
		{
			STREAM_DumpUnit(&StreamTracker.StreamList[i], DoSave);
		}
	}
}


// autogenerated function stub: 
// void /*$ra*/ STREAM_LoadCurrentWarpRoom(struct StreamUnitPortal *streamPortal /*$s1*/, struct _StreamUnit *mainStreamUnit /*$a1*/)
void STREAM_LoadCurrentWarpRoom(struct StreamUnitPortal *streamPortal, struct _StreamUnit *mainStreamUnit)
{ // line 2343, offset 0x8005ac9c
	/* begin block 1 */
		// Start line: 5533
	/* end block 1 */
	// End Line: 5534

	/* begin block 2 */
		// Start line: 5534
	/* end block 2 */
	// End Line: 5535
	UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ WARPGATE_RelocateLoadedWarpRooms(struct _StreamUnit *mainUnit /*$s4*/, struct StreamUnitPortal *streamPortal /*$s5*/)
void WARPGATE_RelocateLoadedWarpRooms(struct _StreamUnit *mainUnit, struct StreamUnitPortal *streamPortal)
{ // line 2360, offset 0x8005ad58
	/* begin block 1 */
		// Start line: 2361
		// Start offset: 0x8005AD58
		// Variables:
			int i; // $s2
	/* end block 1 */
	// End offset: 0x8005ADDC
	// End Line: 2374

	/* begin block 2 */
		// Start line: 5570
	/* end block 2 */
	// End Line: 5571
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// long /*$ra*/ WARPGATE_GetWarpRoomIndex(char *name /*$s2*/)
long WARPGATE_GetWarpRoomIndex(char *name)
{ // line 2377, offset 0x8005ae00
	/* begin block 1 */
		// Start line: 2378
		// Start offset: 0x8005AE00
		// Variables:
			int i; // $s0
	/* end block 1 */
	// End offset: 0x8005AE48
	// End Line: 2390

	/* begin block 2 */
		// Start line: 5623
	/* end block 2 */
	// End Line: 5624
			UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// void /*$ra*/ WARPGATE_UpdateAddToArray(struct _StreamUnit *streamUnit /*$s0*/)
void WARPGATE_UpdateAddToArray(struct _StreamUnit *streamUnit)
{ // line 2392, offset 0x8005ae60
	/* begin block 1 */
		// Start line: 2393
		// Start offset: 0x8005AE60
		// Variables:
			int i; // $v1
	/* end block 1 */
	// End offset: 0x8005AE9C
	// End Line: 2401

	/* begin block 2 */
		// Start line: 5661
	/* end block 2 */
	// End Line: 5662
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ WARPGATE_RemoveFromArray(struct _StreamUnit *streamUnit /*$a0*/)
void WARPGATE_RemoveFromArray(struct _StreamUnit *streamUnit)
{ // line 2403, offset 0x8005aeac
	/* begin block 1 */
		// Start line: 2404
		// Start offset: 0x8005AEAC
	/* end block 1 */
	// End offset: 0x8005AECC
	// End Line: 2411

	/* begin block 2 */
		// Start line: 5683
	/* end block 2 */
	// End Line: 5684
	UNIMPLEMENTED();
}

void WARPGATE_Init()
{ 
	int n;
	
	wgloadInfo.fadeValue = 4096;
	wgloadInfo.warpgate_in_use = 0;
	wgloadInfo.loading = 0;
	wgloadInfo.blocked = 0;
	wgloadInfo.curTime = 0;
	wgloadInfo.maxTime = 61440;
	wgloadInfo.warpFaceInstance = NULL;

	CurrentWarpNumber = 0;

	for (n = 13; n >= 0; n--)
	{
		WarpRoomArray[n].streamUnit = NULL;
	}
}


// autogenerated function stub: 
// void /*$ra*/ WARPGATE_StartUsingWarpgate()
void WARPGATE_StartUsingWarpgate()
{ // line 2433, offset 0x8005af24
	/* begin block 1 */
		// Start line: 5756
	/* end block 1 */
	// End Line: 5757

	/* begin block 2 */
		// Start line: 5757
	/* end block 2 */
	// End Line: 5758
	UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ WARPGATE_EndUsingWarpgate()
void WARPGATE_EndUsingWarpgate()
{ // line 2440, offset 0x8005af5c
	/* begin block 1 */
		// Start line: 5771
	/* end block 1 */
	// End Line: 5772
	UNIMPLEMENTED();
}


// autogenerated function stub: 
// int /*$ra*/ WARPGATE_IsWarpgateInUse()
int WARPGATE_IsWarpgateInUse()
{ // line 2447, offset 0x8005af94
	/* begin block 1 */
		// Start line: 5785
	/* end block 1 */
	// End Line: 5786

	/* begin block 2 */
		// Start line: 5786
	/* end block 2 */
	// End Line: 5787
	UNIMPLEMENTED();
	return 0;
}

int WARPGATE_IsWarpgateActive()
{ 
	return 0 < wgloadInfo.loading;
}


// autogenerated function stub: 
// int /*$ra*/ WARPGATE_IsWarpgateUsable()
int WARPGATE_IsWarpgateUsable()
{ // line 2460, offset 0x8005afac
	/* begin block 1 */
		// Start line: 5811
	/* end block 1 */
	// End Line: 5812

	/* begin block 2 */
		// Start line: 5812
	/* end block 2 */
	// End Line: 5813
	UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ WARPGATE_IsWarpgateReady()
int WARPGATE_IsWarpgateReady()
{ // line 2467, offset 0x8005afc0
	/* begin block 1 */
		// Start line: 5825
	/* end block 1 */
	// End Line: 5826

	/* begin block 2 */
		// Start line: 5826
	/* end block 2 */
	// End Line: 5827
	UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ WARPGATE_IsWarpgateSpectral()
int WARPGATE_IsWarpgateSpectral()
{ // line 2474, offset 0x8005afd4
	/* begin block 1 */
		// Start line: 5839
	/* end block 1 */
	// End Line: 5840
	UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ WARPGATE_IsObjectOnWarpSide(struct _Instance *instance /*$a0*/)
int WARPGATE_IsObjectOnWarpSide(struct _Instance *instance)
{ // line 2481, offset 0x8005b010
	/* begin block 1 */
		// Start line: 2483
		// Start offset: 0x8005B010
		// Variables:
			int side; // $a0
	/* end block 1 */
	// End offset: 0x8005B06C
	// End Line: 2502

	/* begin block 2 */
		// Start line: 5854
	/* end block 2 */
	// End Line: 5855

	/* begin block 3 */
		// Start line: 5855
	/* end block 3 */
	// End Line: 5856

	/* begin block 4 */
		// Start line: 5856
	/* end block 4 */
	// End Line: 5857
			UNIMPLEMENTED();
	return 0;
}

void WARPGATE_IsItActive(struct _StreamUnit *streamUnit)
{
	struct Level *level;
	int d;

	level = streamUnit->level;
	streamUnit->flags |= 0x1;

	if (level->PuzzleInstances != NULL && level->PuzzleInstances->numPuzzles > 0)
	{
		for (d = 0; d < level->PuzzleInstances->numPuzzles; d++)
		{
			if (level->PuzzleInstances->eventInstances[d]->eventNumber == 1)
			{
				if ((gameTrackerX.streamFlags & 0x400000))
				{
					level->PuzzleInstances->eventInstances[d]->eventVariables[0] = level->PuzzleInstances->eventInstances[d]->eventNumber;
				}

				if (level->PuzzleInstances->eventInstances[d]->eventVariables[0] != level->PuzzleInstances->eventInstances[d]->eventNumber)
				{
					return;
				}

				streamUnit->flags |= 0x8;
				return;
			}
		}
	}

	return;
}

long WARPGATE_IsUnitWarpRoom(struct _StreamUnit *streamUnit)
{
	struct Level *level;
	long isWarpRoom;
	struct StreamUnitPortal *streamPortal;
	long numPortals;
	long d;

	level = streamUnit->level;
	
	isWarpRoom = 0;
	
	numPortals = ((long*)level->terrain->StreamUnits)[0];
	
	streamPortal = (struct StreamUnitPortal*)((long*)level->terrain->StreamUnits + 1);

	if (numPortals > 0)
	{
		for (d = 0; d < numPortals; d++)
		{
			if ((streamPortal[d].flags & 0x1))
			{
				isWarpRoom = 1;
			}
		}
	}

	return isWarpRoom;
}

void WARPGATE_FixUnit(struct _StreamUnit *streamUnit)
{ 
	if (WARPGATE_IsUnitWarpRoom(streamUnit) != 0)
	{
		WARPGATE_IsItActive(streamUnit);
	}
}


// autogenerated function stub: 
// void /*$ra*/ STREAM_MarkWarpUnitsNeeded()
void STREAM_MarkWarpUnitsNeeded()
{ // line 2570, offset 0x8005b1c8
	/* begin block 1 */
		// Start line: 2572
		// Start offset: 0x8005B1C8
		// Variables:
			int i; // $a0
	/* end block 1 */
	// End offset: 0x8005B200
	// End Line: 2581

	/* begin block 2 */
		// Start line: 6055
	/* end block 2 */
	// End Line: 6056

	/* begin block 3 */
		// Start line: 6056
	/* end block 3 */
	// End Line: 6057

	/* begin block 4 */
		// Start line: 6058
	/* end block 4 */
	// End Line: 6059
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// long /*$ra*/ WARPGATE_IncrementIndex()
long WARPGATE_IncrementIndex()
{ // line 2586, offset 0x8005b208
	/* begin block 1 */
		// Start line: 2587
		// Start offset: 0x8005B208
		// Variables:
			long result; // $s1
	/* end block 1 */
	// End offset: 0x8005B308
	// End Line: 2612

	/* begin block 2 */
		// Start line: 6091
	/* end block 2 */
	// End Line: 6092
			UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// void /*$ra*/ WARPGATE_CalcWarpFade(int timeInc /*$a0*/)
void WARPGATE_CalcWarpFade(int timeInc)
{ // line 2615, offset 0x8005b320
	/* begin block 1 */
		// Start line: 6175
	/* end block 1 */
	// End Line: 6176

	/* begin block 2 */
		// Start line: 6176
	/* end block 2 */
	// End Line: 6177
	UNIMPLEMENTED();
}


// autogenerated function stub: 
// long /*$ra*/ WARPGATE_DecrementIndex()
long WARPGATE_DecrementIndex()
{ // line 2624, offset 0x8005b390
	/* begin block 1 */
		// Start line: 2625
		// Start offset: 0x8005B390
		// Variables:
			long result; // $s0
	/* end block 1 */
	// End offset: 0x8005B454
	// End Line: 2652

	/* begin block 2 */
		// Start line: 6194
	/* end block 2 */
	// End Line: 6195
			UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// void /*$ra*/ PreloadAllConnectedUnits(struct _StreamUnit *streamUnit /*$s4*/, struct _SVector *offset /*$s5*/)
void PreloadAllConnectedUnits(struct _StreamUnit *streamUnit, struct _SVector *offset)
{ // line 2656, offset 0x8005b468
	/* begin block 1 */
		// Start line: 2657
		// Start offset: 0x8005B468
		// Variables:
			int i; // $s1
			char text[16]; // stack offset -48
			int numportals; // $s3
			char *commapos; // $v0
			struct StreamUnitPortal *stream; // $s0
	/* end block 1 */
	// End offset: 0x8005B608
	// End Line: 2802

	/* begin block 2 */
		// Start line: 6271
	/* end block 2 */
	// End Line: 6272

	/* begin block 3 */
		// Start line: 6279
	/* end block 3 */
	// End Line: 6280
			UNIMPLEMENTED();
}

void RelocateLevel(struct Level* level, struct _SVector* offset)
{
	int curTree;
	short _x0;
	short _y0;
	short _z0;
	short _x1;
	short _y1;
	short _z1;
	struct _Position* _v;

	RelocateTerrain(level->terrain, offset);

	RelocateVMObjects(level->vmobjectList, level->numVMObjects, offset);

	RelocateBGObjects(level->bgObjectList, level->numBGObjects, offset);

	RelocateCameras((struct _CameraKey*)level->cameraList, level->numCameras, offset);

	RelocateSavedCameras(&theCamera, level, offset);

	level->deathZ += offset->z;
	
	RelocatePlanMarkers(level->PlanMarkerList, level->NumberOfPlanMarkers, offset);

	RelocateSFXMarkers(level->SFXMarkerList, level->NumberOfSFXMarkers, offset);

	if (level->waterZLevel != -32767 && level->waterZLevel != 32767)
	{
		level->waterZLevel += offset->z;
	}

	for (curTree = 0; curTree < level->terrain->numBSPTrees; curTree++)
	{
		_x1 = offset->x;
		_y1 = offset->y;
		_z1 = offset->z;

		_v = &level->terrain->BSPTreeArray[curTree].globalOffset;

		_x0 = _v->x;
		_y0 = _v->y;
		_z0 = _v->z;

		_x0 += _x1;
		_y0 += _y1;
		_z0 += _z1;

		_v->x = _x0;
		_v->y = _y0;
		_v->z = _z0;
	}
}


// autogenerated function stub: 
// void /*$ra*/ RelocateCameras(struct _CameraKey *cameraList /*$a0*/, long numCameras /*$a1*/, struct _SVector *offset /*$a2*/)
void RelocateCameras(struct _CameraKey *cameraList, long numCameras, struct _SVector *offset)
{ // line 2902, offset 0x8005b76c
	/* begin block 1 */
		// Start line: 2904
		// Start offset: 0x8005B76C
		// Variables:
			int i; // $a3
	/* end block 1 */
	// End offset: 0x8005B7F8
	// End Line: 2916

	/* begin block 2 */
		// Start line: 6786
	/* end block 2 */
	// End Line: 6787

	/* begin block 3 */
		// Start line: 6787
	/* end block 3 */
	// End Line: 6788

	/* begin block 4 */
		// Start line: 6789
	/* end block 4 */
	// End Line: 6790
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ RelocateSavedCameras(struct Camera *camera /*$t7*/, struct Level *level /*$t8*/, struct _SVector *offset /*$t2*/)
void RelocateSavedCameras(struct Camera *camera, struct Level *level, struct _SVector *offset)
{ // line 2918, offset 0x8005b800
#if 0
  /* begin block 1 */
		// Start line: 2919
		// Start offset: 0x8005B800
		// Variables:
			int i; // $t6

		/* begin block 1.1 */
			// Start line: 2929
			// Start offset: 0x8005B848
			// Variables:
				short _x0; // $v0
				short _y0; // $v0
				short _z0; // $v1
				short _x1; // $v1
				short _y1; // $a1
				short _z1; // $a2
				_Position *_v; // $a0
		/* end block 1.1 */
		// End offset: 0x8005B848
		// End Line: 2931

		/* begin block 1.2 */
			// Start line: 2931
			// Start offset: 0x8005B848
			// Variables:
				short _x0; // $v0
				short _y0; // $v1
				short _z0; // $a1
				short _x1; // $a2
				short _y1; // $t0
				short _z1; // $t1
				_Position *_v; // $a3
		/* end block 1.2 */
		// End offset: 0x8005B848
		// End Line: 2931

		/* begin block 1.3 */
			// Start line: 2931
			// Start offset: 0x8005B848
			// Variables:
				short _x0; // $v0
				short _y0; // $v1
				short _z0; // $a1
				short _x1; // $a2
				short _y1; // $t0
				short _z1; // $t1
				_Position *_v; // $a3
		/* end block 1.3 */
		// End offset: 0x8005B848
		// End Line: 2931

		/* begin block 1.4 */
			// Start line: 2931
			// Start offset: 0x8005B848
			// Variables:
				short _x0; // $v0
				short _y0; // $v1
				short _z0; // $a1
				short _x1; // $a2
				short _y1; // $t0
				short _z1; // $t1
				_Position *_v; // $a3
		/* end block 1.4 */
		// End offset: 0x8005B914
		// End Line: 2940
	/* end block 1 */
	// End offset: 0x8005B930
	// End Line: 2947

	/* begin block 2 */
		// Start line: 6834
	/* end block 2 */
	// End Line: 6835
#endif
				UNIMPLEMENTED();
}

void RelocateLevelWithInstances(struct Level *level, struct _SVector *offset)
{
	RelocateLevel(level, offset);

	RelocateInstances(offset);

	RelocatePlanPool((struct _PlanningNode*)gameTrackerX.planningPool, offset);
}

void RelocateTerrain(struct _Terrain *terrain, struct _SVector *offset)
{
	int i;

	for (i = 0; i < terrain->numIntros; i++)
	{
		terrain->introList[i].position.x += offset->x;
		terrain->introList[i].position.y += offset->y;
		terrain->introList[i].position.z += offset->z;

		if (terrain->introList[i].multiSpline != NULL)
		{
			STREAM_AdjustMultiSpline(terrain->introList[i].multiSpline, offset);
		}
	}

	RelocateStreamPortals((struct StreamUnitPortal*)((long*)terrain->StreamUnits + 1), ((long*)terrain->StreamUnits)[0], offset);
}


// autogenerated function stub: 
// void /*$ra*/ RelocateVMObjects(struct _VMObject *vobjectlist /*$a0*/, long numvmobjs /*$a1*/, struct _SVector *offset /*$a2*/)
void RelocateVMObjects(struct _VMObject *vobjectlist, long numvmobjs, struct _SVector *offset)
{ // line 3094, offset 0x8005ba60
	/* begin block 1 */
		// Start line: 3096
		// Start offset: 0x8005BA60
		// Variables:
			int i; // $a3
	/* end block 1 */
	// End offset: 0x8005BAB0
	// End Line: 3118

	/* begin block 2 */
		// Start line: 7218
	/* end block 2 */
	// End Line: 7219

	/* begin block 3 */
		// Start line: 7219
	/* end block 3 */
	// End Line: 7220

	/* begin block 4 */
		// Start line: 7222
	/* end block 4 */
	// End Line: 7223
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ RelocateBGObjects(struct _BGObject *BGObjList /*$a0*/, long numBGObjs /*$t2*/, struct _SVector *offset /*$a2*/)
void RelocateBGObjects(struct _BGObject *BGObjList, long numBGObjs, struct _SVector *offset)
{ // line 3149, offset 0x8005bab8
	/* begin block 1 */
		// Start line: 3150
		// Start offset: 0x8005BAB8
		// Variables:
			int i; // $t1
			int d; // $a3
	/* end block 1 */
	// End offset: 0x8005BB54
	// End Line: 3162

	/* begin block 2 */
		// Start line: 6298
	/* end block 2 */
	// End Line: 6299
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ RelocatePlanPool(struct PlanningNode *planPool /*$s0*/, struct _SVector *offset /*$a1*/)
void RelocatePlanPool(struct PlanningNode *planPool, struct _SVector *offset)
{ // line 3164, offset 0x8005bb5c
	/* begin block 1 */
		// Start line: 3165
		// Start offset: 0x8005BB5C
		// Variables:
			int i; // $a1
			short ox; // $s1
			short oy; // $s2
			short oz; // $s3
	/* end block 1 */
	// End offset: 0x8005BBC8
	// End Line: 3180

	/* begin block 2 */
		// Start line: 7340
	/* end block 2 */
	// End Line: 7341
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ RelocatePlanMarkers(struct _PlanMkr *planMkrList /*$a3*/, int numPlanMkrs /*$a1*/, struct _SVector *offset /*$a2*/)
void RelocatePlanMarkers(struct _PlanMkr *planMkrList, int numPlanMkrs, struct _SVector *offset)
{ // line 3185, offset 0x8005bc10
	/* begin block 1 */
		// Start line: 3186
		// Start offset: 0x8005BC10
		// Variables:
			int i; // $a1
			short ox; // $t1
			short oy; // $t0
			short oz; // $a2
	/* end block 1 */
	// End offset: 0x8005BC5C
	// End Line: 3200

	/* begin block 2 */
		// Start line: 7395
	/* end block 2 */
	// End Line: 7396

	/* begin block 3 */
		// Start line: 7399
	/* end block 3 */
	// End Line: 7400
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ RelocateSFXMarkers(struct _SFXMkr *sfxMkrList /*$a0*/, int numSFXMkrs /*$a1*/, struct _SVector *offset /*$a2*/)
void RelocateSFXMarkers(struct _SFXMkr *sfxMkrList, int numSFXMkrs, struct _SVector *offset)
{ // line 3202, offset 0x8005bc64
	/* begin block 1 */
		// Start line: 3204
		// Start offset: 0x8005BC64
		// Variables:
			int i; // $a1
			short ox; // $t0
			short oy; // $a3
			short oz; // $a2
	/* end block 1 */
	// End offset: 0x8005BCA8
	// End Line: 3217

	/* begin block 2 */
		// Start line: 7439
	/* end block 2 */
	// End Line: 7440

	/* begin block 3 */
		// Start line: 7440
	/* end block 3 */
	// End Line: 7441

	/* begin block 4 */
		// Start line: 7443
	/* end block 4 */
	// End Line: 7444
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ STREAM_AdjustMultiSpline(struct MultiSpline *multi /*$a3*/, struct _SVector *offset /*$t0*/)
void STREAM_AdjustMultiSpline(struct MultiSpline *multi, struct _SVector *offset)
{ // line 3219, offset 0x8005bcb0
	/* begin block 1 */
		// Start line: 3220
		// Start offset: 0x8005BCB0
		// Variables:
			int i; // $a2
	/* end block 1 */
	// End offset: 0x8005BD58
	// End Line: 3241

	/* begin block 2 */
		// Start line: 7479
	/* end block 2 */
	// End Line: 7480

			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ STREAM_RelocateInstance(struct _Instance *instance /*$s0*/, struct _SVector *offset /*$s1*/)
void STREAM_RelocateInstance(struct _Instance *instance, struct _SVector *offset)
{ // line 3243, offset 0x8005bd60
	/* begin block 1 */
		// Start line: 7531
	/* end block 1 */
	// End Line: 7532
	UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ STREAM_OffsetInstancePosition(struct _Instance *instance /*$s0*/, struct _SVector *offset /*$s1*/, int streamSignalFlag /*$s2*/)
void STREAM_OffsetInstancePosition(struct _Instance *instance, struct _SVector *offset, int streamSignalFlag)
{ // line 3251, offset 0x8005bda8
	/* begin block 1 */
		// Start line: 7547
	/* end block 1 */
	// End Line: 7548
	UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ STREAM_SetInstancePosition(struct _Instance *instance /*$a0*/, struct evPositionData *data /*$a1*/)
void STREAM_SetInstancePosition(struct _Instance *instance, struct evPositionData *data)
{ // line 3278, offset 0x8005bec0
	/* begin block 1 */
		// Start line: 3279
		// Start offset: 0x8005BEC0
		// Variables:
			struct _SVector offset; // stack offset -16
	/* end block 1 */
	// End offset: 0x8005BEC0
	// End Line: 3279

	/* begin block 2 */
		// Start line: 7610
	/* end block 2 */
	// End Line: 7611
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ RelocateInstances(struct _SVector *offset /*$s1*/)
void RelocateInstances(struct _SVector *offset)
{ // line 3289, offset 0x8005bf18
	/* begin block 1 */
		// Start line: 3290
		// Start offset: 0x8005BF18
		// Variables:
			struct _Instance *instance; // $s0
	/* end block 1 */
	// End offset: 0x8005BF58
	// End Line: 3300

	/* begin block 2 */
		// Start line: 7637
	/* end block 2 */
	// End Line: 7638

	/* begin block 3 */
		// Start line: 7638
	/* end block 3 */
	// End Line: 7639
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ RelocateStreamPortals(struct StreamUnitPortal *StreamUnitList /*$a0*/, int NumStreamUnits /*$a1*/, struct _SVector *offset /*$a2*/)
void RelocateStreamPortals(struct StreamUnitPortal *StreamUnitList, int NumStreamUnits, struct _SVector *offset)
{ // line 3303, offset 0x8005bf74
	/* begin block 1 */
		// Start line: 3305
		// Start offset: 0x8005BF74
		// Variables:
			int i; // $t1
			int d; // $t0
	/* end block 1 */
	// End offset: 0x8005C09C
	// End Line: 3330

	/* begin block 2 */
		// Start line: 7667
	/* end block 2 */
	// End Line: 7668

	/* begin block 3 */
		// Start line: 7668
	/* end block 3 */
	// End Line: 7669

	/* begin block 4 */
		// Start line: 7670
	/* end block 4 */
	// End Line: 7671
			UNIMPLEMENTED();
}

void STREAM_PackVRAMObject(struct _ObjectTracker* PTR_32 objectTracker)
{ 
	struct VramSize* vramSize;
	struct VramBuffer* vramBuffer;
	char fileName[64];
	struct _BlockVramEntry* vramBlock;
	
	vramSize = &objectTracker->object->vramSize;

	if (vramSize->x != -1 && VRAM_GetObjectVramSpace(vramSize, objectTracker) != 0)
	{
		vramBlock = (struct _BlockVramEntry*)objectTracker->vramBlock;

		if (vramBlock != NULL)
		{
			AdjustVramCoordsObject(SCREEN_WIDTH, 0, vramBlock->x, vramBlock->y, objectTracker->object);
		}
			
		sprintf(fileName, "\\kain2\\object\\%s\\%s.crm", objectTracker->name, objectTracker->name);
			
		vramBuffer = (struct VramBuffer*)MEMPACK_Malloc((vramBlock->w << 1) + sizeof(VramBuffer), 0x23);
			
		vramBuffer->lineOverFlow = (short*)(vramBuffer + 1);
		vramBuffer->flags = 0;
		vramBuffer->x = vramBlock->x;
		vramBuffer->y = vramBlock->y;
		vramBuffer->w = vramBlock->w;
		vramBuffer->yOffset = 0;
		vramBuffer->lengthOfLeftOverData = 0;
		vramBuffer->h = vramBlock->h;
			
		LOAD_NonBlockingBufferedLoad(fileName, (void*)VRAM_TransferBufferToVram, vramBuffer, objectTracker);
	}
	else
	{
		objectTracker->vramBlock = NULL;
	}
}

void MORPH_SetupInstanceFlags(struct _Instance *instance)
{ 
	if (!(instance->object->oflags & 0x80000))
	{
		if (gameTrackerX.gameData.asmData.MorphType == 0)
		{
			if (!(instance->flags2 & 0x8000000))
			{
				instance->flags2 &= 0xEFFFFFFF;
				instance->flags2 &= 0xFBFFFFFF;
				return;
			}
		}
		else
		{
			instance->flags2 &= 0xEFFFFFFF;
			instance->flags2 &= 0xFBFFFFFF;
			return;
		}

		instance->flags2 &= 0x10000000;

		if (MEMPACK_MemoryValidFunc((char*)instance->data) != 0)
		{
			if (!(instance->object->oflags2 & 0x2000000) && instance->LinkParent != NULL && !(instance->LinkParent->object->oflags2 & 0x2000000))
			{
				return;
			}

			INSTANCE_Post(instance, 0x40026, 0);

			instance->flags2 |= 0x4000000;
		}
	}
}


// autogenerated function stub: 
// void /*$ra*/ MORPH_SetupInstanceListFlags()
void MORPH_SetupInstanceListFlags()
{ // line 3475, offset 0x8005c2d8
	/* begin block 1 */
		// Start line: 3476
		// Start offset: 0x8005C2D8
		// Variables:
			struct _Instance *instance; // $s0
	/* end block 1 */
	// End offset: 0x8005C310
	// End Line: 3487

	/* begin block 2 */
		// Start line: 8084
	/* end block 2 */
	// End Line: 8085

	/* begin block 3 */
		// Start line: 8089
	/* end block 3 */
	// End Line: 8090
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MORPH_InMorphInstanceListFlags()
void MORPH_InMorphInstanceListFlags()
{ // line 3489, offset 0x8005c320
	/* begin block 1 */
		// Start line: 3491
		// Start offset: 0x8005C320
		// Variables:
			struct _Instance *instance; // $v1
	/* end block 1 */
	// End offset: 0x8005C380
	// End Line: 3514

	/* begin block 2 */
		// Start line: 8117
	/* end block 2 */
	// End Line: 8118

	/* begin block 3 */
		// Start line: 8118
	/* end block 3 */
	// End Line: 8119

	/* begin block 4 */
		// Start line: 8122
	/* end block 4 */
	// End Line: 8123
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MORPH_InMorphDoFadeValues()
void MORPH_InMorphDoFadeValues()
{ // line 3516, offset 0x8005c388
	/* begin block 1 */
		// Start line: 3518
		// Start offset: 0x8005C388
		// Variables:
			int fade1; // $a0
			int fade2; // $v0
	/* end block 1 */
	// End offset: 0x8005C3D8
	// End Line: 3532

	/* begin block 2 */
		// Start line: 8171
	/* end block 2 */
	// End Line: 8172

	/* begin block 3 */
		// Start line: 8172
	/* end block 3 */
	// End Line: 8173

	/* begin block 4 */
		// Start line: 8174
	/* end block 4 */
	// End Line: 8175
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MORPH_UpdateTimeMult()
void MORPH_UpdateTimeMult()
{ // line 3538, offset 0x8005c3e0
	/* begin block 1 */
		// Start line: 3541
		// Start offset: 0x8005C3E0

		/* begin block 1.1 */
			// Start line: 3544
			// Start offset: 0x8005C3F4
			// Variables:
				short ratio; // $v1
		/* end block 1.1 */
		// End offset: 0x8005C510
		// End Line: 3582
	/* end block 1 */
	// End offset: 0x8005C54C
	// End Line: 3598

	/* begin block 2 */
		// Start line: 8215
	/* end block 2 */
	// End Line: 8216

	/* begin block 3 */
		// Start line: 8217
	/* end block 3 */
	// End Line: 8218
				UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MORPH_UpdateNormals(struct Level *BaseLevel /*$t0*/)
void MORPH_UpdateNormals(struct Level *BaseLevel)
{ // line 3602, offset 0x8005c554
	/* begin block 1 */
		// Start line: 3603
		// Start offset: 0x8005C554
		// Variables:
			struct _TFace *face; // $v1
			long faceCount; // $a2
			struct _TVertex *v; // $a1
			struct _MorphVertex *mv; // $a3
			struct _MorphColor *mc; // $a0
			short h1; // $v1
			short *morphNormals; // $a1

		/* begin block 1.1 */
			// Start line: 3652
			// Start offset: 0x8005C650
			// Variables:
				struct _TVertex *endv; // $a2
		/* end block 1.1 */
		// End offset: 0x8005C6C4
		// End Line: 3673

		/* begin block 1.2 */
			// Start line: 3673
			// Start offset: 0x8005C6C4
			// Variables:
				struct _BSPNode *node; // $v1
				struct _BSPLeaf *leaf; // $a1
				//struct _Sphere_noSq hsphere; // stack offset -32
				//struct _BoundingBox hbox; // stack offset -24
				struct _Terrain *terrain; // $a0
				long curTree; // $t0
		/* end block 1.2 */
		// End offset: 0x8005C8D8
		// End Line: 3724

		/* begin block 1.3 */
			// Start line: 3726
			// Start offset: 0x8005C8D8
			// Variables:
				struct _Instance *instance; // $s0

			/* begin block 1.3.1 */
				// Start line: 3732
				// Start offset: 0x8005C900
				// Variables:
					SVECTOR realDiff; // stack offset -32
					_Position oldPos; // stack offset -24
			/* end block 1.3.1 */
			// End offset: 0x8005C9E8
			// End Line: 3756
		/* end block 1.3 */
		// End offset: 0x8005C9F8
		// End Line: 3759
	/* end block 1 */
	// End offset: 0x8005C9F8
	// End Line: 3760

	/* begin block 2 */
		// Start line: 8347
	/* end block 2 */
	// End Line: 8348
					UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MORPH_BringBackNormals(struct Level *BaseLevel /*$a3*/)
void MORPH_BringBackNormals(struct Level *BaseLevel)
{ // line 3762, offset 0x8005ca08
	/* begin block 1 */
		// Start line: 3763
		// Start offset: 0x8005CA08
		// Variables:
			struct _TFace *face; // $v1
			long faceCount; // $a2
			struct _TVertex *v; // $a1
			struct _MorphVertex *mv; // $a0
			struct _MorphColor *mc; // $v0
			short h1; // $v1
			short *morphNormals; // $a1

		/* begin block 1.1 */
			// Start line: 3818
			// Start offset: 0x8005CAE4
			// Variables:
				struct _TVertex *endv; // $a2
		/* end block 1.1 */
		// End offset: 0x8005CB4C
		// End Line: 3829

		/* begin block 1.2 */
			// Start line: 3844
			// Start offset: 0x8005CB4C
			// Variables:
				struct _BSPNode *node; // $v1
				struct _BSPLeaf *leaf; // $a1
				//struct _Sphere_noSq hsphere; // stack offset -32
				//sstruct _BoundingBox hbox; // stack offset -24
				struct _Terrain *terrain; // $a0
				long curTree; // $t0
		/* end block 1.2 */
		// End offset: 0x8005CD60
		// End Line: 3894

		/* begin block 1.3 */
			// Start line: 3897
			// Start offset: 0x8005CD60
			// Variables:
				struct _Instance *instance; // $s0

			/* begin block 1.3.1 */
				// Start line: 3903
				// Start offset: 0x8005CD88
				// Variables:
					SVECTOR realDiff; // stack offset -32
					_Position oldPos; // stack offset -24
			/* end block 1.3.1 */
			// End offset: 0x8005CE58
			// End Line: 3927
		/* end block 1.3 */
		// End offset: 0x8005CE68
		// End Line: 3930
	/* end block 1 */
	// End offset: 0x8005CE68
	// End Line: 3931

	/* begin block 2 */
		// Start line: 8739
	/* end block 2 */
	// End Line: 8740
					UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MORPH_AddOffsets(struct Level *BaseLevel /*$s2*/, int time /*$a1*/)
void MORPH_AddOffsets(struct Level *BaseLevel, int time)
{ // line 3933, offset 0x8005ce78
	/* begin block 1 */
		// Start line: 3934
		// Start offset: 0x8005CE78
		// Variables:
			struct _TVertex *v; // $a3
			struct _MorphVertex *mv; // $a2
			struct _MorphColor *mc; // $t2
			long m; // $v0
			long fixed_time; // $s1
			struct _Instance *instance; // $s0

		/* begin block 1.1 */
			// Start line: 3982
			// Start offset: 0x8005D040
			// Variables:
				SVECTOR diff; // stack offset -40
				SVECTOR realDiff; // stack offset -32
				_Position oldPos; // stack offset -24
		/* end block 1.1 */
		// End offset: 0x8005D13C
		// End Line: 4001

		/* begin block 1.2 */
			// Start line: 4010
			// Start offset: 0x8005D164
			// Variables:
				long r0; // $a2
				long g0; // $a1
				long b0; // $a0
				long r1; // $v0
				long g1; // $v0
				long b1; // $v1

			/* begin block 1.2.1 */
				// Start line: 4020
				// Start offset: 0x8005D164
				// Variables:
					struct _TVertex *endv; // $t4
			/* end block 1.2.1 */
			// End offset: 0x8005D22C
			// End Line: 4035
		/* end block 1.2 */
		// End offset: 0x8005D22C
		// End Line: 4058
	/* end block 1 */
	// End offset: 0x8005D22C
	// End Line: 4060

	/* begin block 2 */
		// Start line: 9143
	/* end block 2 */
	// End Line: 9144

	/* begin block 3 */
		// Start line: 9149
	/* end block 3 */
	// End Line: 9150
					UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MORPH_SubtractOffsets(struct Level *BaseLevel /*$s2*/, int time /*$a1*/)
void MORPH_SubtractOffsets(struct Level *BaseLevel, int time)
{ // line 4062, offset 0x8005d244
	/* begin block 1 */
		// Start line: 4063
		// Start offset: 0x8005D244
		// Variables:
			struct _TVertex *v; // $a3
			struct _MorphVertex *mv; // $a2
			struct _MorphColor *mc; // $t2
			long m; // $v0
			long fixed_time; // $s1
			struct _Instance *instance; // $s0

		/* begin block 1.1 */
			// Start line: 4109
			// Start offset: 0x8005D414
			// Variables:
				SVECTOR diff; // stack offset -40
				SVECTOR realDiff; // stack offset -32
				_Position oldPos; // stack offset -24
		/* end block 1.1 */
		// End offset: 0x8005D510
		// End Line: 4129

		/* begin block 1.2 */
			// Start line: 4138
			// Start offset: 0x8005D538
			// Variables:
				long r0; // $a2
				long g0; // $a1
				long b0; // $a0
				long r1; // $v0
				long g1; // $v0
				long b1; // $v1

			/* begin block 1.2.1 */
				// Start line: 4147
				// Start offset: 0x8005D538
				// Variables:
					struct _TVertex *endv; // $t4
			/* end block 1.2.1 */
			// End offset: 0x8005D600
			// End Line: 4162
		/* end block 1.2 */
		// End offset: 0x8005D600
		// End Line: 4185
	/* end block 1 */
	// End offset: 0x8005D600
	// End Line: 4187

	/* begin block 2 */
		// Start line: 9485
	/* end block 2 */
	// End Line: 9486

	/* begin block 3 */
		// Start line: 9491
	/* end block 3 */
	// End Line: 9492
					UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MORPH_GetComponentsForTrackingPoint(struct _TFace *face /*$a2*/, struct Level *level /*$a3*/)
void MORPH_GetComponentsForTrackingPoint(struct _TFace *face, struct Level *level)
{ // line 4192, offset 0x8005d618
	/* begin block 1 */
		// Start line: 4193
		// Start offset: 0x8005D618
		// Variables:
			struct _SVector (*v[3]); // stack offset -32
			_Position *offset; // $a2
			_Position player; // stack offset -16
			int n; // $a1
			int saved_div; // $t0
			int next; // $a0
			int side; // $t1
			int track; // $t3
			int x[2]; // stack offset -8
			struct _TVertex *vertexList; // $a0

		/* begin block 1.1 */
			// Start line: 4205
			// Start offset: 0x8005D638
			// Variables:
				short _x0; // $v0
				short _y0; // $a1
				short _z0; // $a0
				short _x1; // $v1
				short _y1; // $a3
				short _z1; // $a2
				_Position *_v; // $v0
				_Position *_v0; // $a0
		/* end block 1.1 */
		// End offset: 0x8005D638
		// End Line: 4205

		/* begin block 1.2 */
			// Start line: 4221
			// Start offset: 0x8005D708
			// Variables:
				//int next; // $v1

			/* begin block 1.2.1 */
				// Start line: 4228
				// Start offset: 0x8005D790
				// Variables:
					int div; // $a0
			/* end block 1.2.1 */
			// End offset: 0x8005D7DC
			// End Line: 4233
		/* end block 1.2 */
		// End offset: 0x8005D7DC
		// End Line: 4234
	/* end block 1 */
	// End offset: 0x8005D8F0
	// End Line: 4260

	/* begin block 2 */
		// Start line: 9826
	/* end block 2 */
	// End Line: 9827
					UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MORPH_AveragePoint(struct _SVector *start /*$t0*/, struct _SVector *end /*$a1*/, int interp /*$v1*/, struct _SVector *out /*$a3*/)
void MORPH_AveragePoint(struct _SVector *start, struct _SVector *end, int interp, struct _SVector *out)
{ // line 4262, offset 0x8005d8f8
	/* begin block 1 */
		// Start line: 10031
	/* end block 1 */
	// End Line: 10032
	UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MORPH_UpdateTrackingPoint(struct _TFace *face /*$a2*/, struct Level *level /*$s2*/)
void MORPH_UpdateTrackingPoint(struct _TFace *face, struct Level *level)
{ // line 4278, offset 0x8005d970
	/* begin block 1 */
		// Start line: 4279
		// Start offset: 0x8005D970
		// Variables:
			struct _SVector (*v[3]); // stack offset -56
			struct _SVector p1; // stack offset -40
			struct _SVector p2; // stack offset -32
			struct _SVector p3; // stack offset -24
			_Position *offset; // $a3
			int next; // $a1
			struct _TVertex *vertexList; // $a0

		/* begin block 1.1 */
			// Start line: 4299
			// Start offset: 0x8005DA44
			// Variables:
				short _x0; // $v0
				short _y0; // $a0
				short _z0; // $a1
				short _x1; // $v1
				short _y1; // $t0
				short _z1; // $a3
		/* end block 1.1 */
		// End offset: 0x8005DA44
		// End Line: 4299

		/* begin block 1.2 */
			// Start line: 4299
			// Start offset: 0x8005DA44
			// Variables:
				_Position *_v0; // $a2
		/* end block 1.2 */
		// End offset: 0x8005DA44
		// End Line: 4299
	/* end block 1 */
	// End offset: 0x8005DAFC
	// End Line: 4312

	/* begin block 2 */
		// Start line: 10063
	/* end block 2 */
	// End Line: 10064
				UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MORPH_ToggleMorph()
void MORPH_ToggleMorph()
{ // line 4314, offset 0x8005db14
	/* begin block 1 */
		// Start line: 4315
		// Start offset: 0x8005DB14

		/* begin block 1.1 */
			// Start line: 4333
			// Start offset: 0x8005DB80
			// Variables:
				struct Level *level; // $s0
				int i; // $s2
		/* end block 1.1 */
		// End offset: 0x8005DC48
		// End Line: 4369
	/* end block 1 */
	// End offset: 0x8005DC48
	// End Line: 4371

	/* begin block 2 */
		// Start line: 10146
	/* end block 2 */
	// End Line: 10147

	/* begin block 3 */
		// Start line: 10148
	/* end block 3 */
	// End Line: 10149
				UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MORPH_DoStep(struct _StreamUnit *streamUnit /*$s0*/, char *baseAreaName /*$a1*/)
void MORPH_DoStep(struct _StreamUnit *streamUnit, char *baseAreaName)
{ // line 4373, offset 0x8005dc60
	/* begin block 1 */
		// Start line: 4374
		// Start offset: 0x8005DC60
		// Variables:
			struct Level *level; // $s0
	/* end block 1 */
	// End offset: 0x8005DD2C
	// End Line: 4431

	/* begin block 2 */
		// Start line: 10300
	/* end block 2 */
	// End Line: 10301
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MORPH_SetFog(struct _StreamUnit *streamUnit /*$a0*/, int mainUnitFlag /*$t0*/)
void MORPH_SetFog(struct _StreamUnit *streamUnit, int mainUnitFlag)
{ // line 4433, offset 0x8005dd3c
	/* begin block 1 */
		// Start line: 4434
		// Start offset: 0x8005DD3C
		// Variables:
			long time; // $v1
			struct Level *level; // $a2
			int fogNear; // $a1
			int fogFar; // $v0
	/* end block 1 */
	// End offset: 0x8005DE00
	// End Line: 4456

	/* begin block 2 */
		// Start line: 10423
	/* end block 2 */
	// End Line: 10424

	/* begin block 3 */
		// Start line: 10429
	/* end block 3 */
	// End Line: 10430
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MORPH_UpdateTextures()
void MORPH_UpdateTextures()
{ // line 4458, offset 0x8005de10
	/* begin block 1 */
		// Start line: 4459
		// Start offset: 0x8005DE10
		// Variables:
			long time; // $a0
	/* end block 1 */
	// End offset: 0x8005DE50
	// End Line: 4469

	/* begin block 2 */
		// Start line: 10483
	/* end block 2 */
	// End Line: 10484

	/* begin block 3 */
		// Start line: 10486
	/* end block 3 */
	// End Line: 10487
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MORPH_Continue()
void MORPH_Continue()
{ // line 4473, offset 0x8005de68
	/* begin block 1 */
		// Start line: 4474
		// Start offset: 0x8005DE68
		// Variables:
			int i; // $s2
			long mode; // $v0
	/* end block 1 */
	// End offset: 0x8005DFC0
	// End Line: 4532

	/* begin block 2 */
		// Start line: 10516
	/* end block 2 */
	// End Line: 10517

	/* begin block 3 */
		// Start line: 10521
	/* end block 3 */
	// End Line: 10522
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ STREAM_MORPH_Relocate()
void STREAM_MORPH_Relocate()
{ // line 4533, offset 0x8005dfdc
	/* begin block 1 */
		// Start line: 10656
	/* end block 1 */
	// End Line: 10657

	/* begin block 2 */
		// Start line: 10657
	/* end block 2 */
	// End Line: 10658
	UNIMPLEMENTED();
}

int AddVertex(VECTOR *v0, PSX_RECT *rect)
{
	SVECTOR v;
	int x;
	int y;
	int z;
	int scr_x;
	int scr_y;

	if (v0->vx < 0)
	{
		v0->vx += -32768;
	}
	else if (v0->vx > 0)
	{
		v0->vx += 32768;
	}

	if (v0->vy < 0)
	{
		v0->vy += -32768;
	}
	else if (v0->vy > 0)
	{
		v0->vy += 32768;
	}

	if (v0->vz < 0)
	{
		v0->vz += -32768;
	}
	else if (v0->vz > 0)
	{
		v0->vz += 32768;
	}

	v.vx = v0->vx;
	v.vy = v0->vy;
	v.vz = v0->vz;

	gte_ldv0(&v);
	gte_rt();
	gte_stsv(&v);

	if (v.vz > 0)
	{
		x = v.vx;
		y = v.vy;
		z = v.vz;

		scr_x = (((x * 320) / z)) + (SCREEN_WIDTH / 2);
		scr_y = (((y * 320) / z)) + (SCREEN_HEIGHT / 2);

		rect->x = (rect->x < scr_x) ? rect->x : scr_x;
		rect->w = (scr_x < rect->w) ? rect->w : scr_x;

		rect->y = (rect->y < scr_y) ? rect->y : scr_y;
		rect->h = (scr_y < rect->h) ? rect->h : scr_y;

		return z;
	}
	
	return -1;
}

int GetPlaneDist(int k, int j, int i, VECTOR *v)
{
	return (((v->vx >> 12) - (theCamera.core.position.x << 4)) * theCamera.core.vvNormalWorVecMat[k].m[j + 1][1]) + 
		   (((v->vy >> 12) - (theCamera.core.position.y << 4)) * theCamera.core.vvNormalWorVecMat[k].m[j + 1][2]) + 
		   (((v->vz >> 12) - (theCamera.core.position.z << 4)) * theCamera.core.vvNormalWorVecMat[k].m[j + 1][3]) ;
}

void CalcVert(VECTOR *v, VECTOR *v1, VECTOR *v2, int dist1, int dist2, int k, int j)
{ 
	int diff;

	diff = (dist1 - dist2) >> 12;

	v->vx = (((v2->vx - v1->vx) >> 12) * (dist1 / diff)) + v2->vx;

	v->vy = (((v2->vy - v1->vy) >> 12) * (dist1 / diff)) + v2->vy;

	v->vz = (((v2->vz - v1->vz) >> 12) * (dist1 / diff)) + v2->vz;
}

int AddClippedTri(SVECTOR*iv, PSX_RECT *cliprect, int *minz)
{
	int clip0;
	int clip1;
	int i;
	int j;
	int k;
	int l;
	int l_1;
	int numvert;
	int newnumvert;
	VECTOR v0[16];
	VECTOR v1[16];
	VECTOR* src;
	VECTOR* dst;
	VECTOR* tmp;
	int z;

	minz[0] = 65535;
	
	src = &v0[0];
	dst = &v1[0];

	for (i = 0; i < 3; i++, iv++)
	{
		v0[i].vx = iv->vx << 16;

		v0[i].vy = iv->vy << 16;

		v0[i].vz = iv->vz << 16;
	}

	numvert = 3;
	i = 0;
	j = 0;

	do
	{
		if (i >= 3)
		{
			j = i - 3;
			k = 1;
		}
		else
		{
			k = 0;
		}


		clip0 = GetPlaneDist(k, j, i, src);
		l_1 = 1;
		newnumvert = 0;
		l = 0;

		if (numvert > 0)
		{

			do
			{
				if (l_1 >= numvert)
				{
					l_1 = 0;
				}

				clip1 = GetPlaneDist(k, j, i, &src[l_1]);

				if (clip0 > 0)
				{
					if (clip1 <= 0)
					{
						dst[l].vx = src[l].vx;
						dst[l].vy = src[l].vy;
						dst[l].vz = src[l].vz;
						dst[l].pad = src[l].pad;

						newnumvert++;

						CalcVert(&dst[(l * 2) + 1], &src[l_1], &src[l], clip1, clip0, k, j);
					}
					else
					{
						dst[l].vx = src[l].vx;
						dst[l].vy = src[l].vy;
						dst[l].vz = src[l].vz;
						dst[l].pad = src[l].pad;
					}
				}
				else
				{
					if (clip1 > 0)
					{
						CalcVert(&dst[l], &src[l], &src[l_1], clip0, clip1, k, j);
					}
				}

				newnumvert++;
				clip0 = clip1;
				l++;
				l_1++;

			} while (l < numvert);
		}
		
		tmp = dst;
		numvert = newnumvert;
		dst = src;
		src = tmp;

		if (numvert < 3)
		{
			return (0 < numvert);
		}

		i++;

	} while (i < 5);

	if (numvert > 0)
	{
		for (i = 0; i < numvert; i++)
		{
			z = AddVertex(&src[i], cliprect);

			if (z < minz[0])
			{
				minz[0] = z;
			}
		}
	}
	
	return 1;
}

int STREAM_GetClipRect(struct StreamUnitPortal *portal, PSX_RECT *rect)
{
	int v1x;
	int v1y;
	int v1z;
	int v2x;
	int v2y;
	int v2z;
	int nx;
	int ny;
	int nz;
	int nx2;
	int ny2;
	int nz2;
	int len;
	int side;
	int side2;
	int retval;
	int horizontal_flag;
	int fullscreen_flag;
	int minz;
	int minz2;
	int dot;

	fullscreen_flag = 0;

	horizontal_flag = 0;

	if (portal->t1[0].z == portal->t1[1].z)
	{
		horizontal_flag = (portal->t1[0].z ^ portal->t1[2].z) < 1;
	}
	
	v1y = portal->t1[0].y - portal->t1[1].y;
	v2z = portal->t1[0].z - portal->t1[2].z;
	v1z = portal->t1[0].z - portal->t1[1].z;
	v2y = portal->t1[0].y - portal->t1[2].y;
	v2x = portal->t1[0].x - portal->t1[2].x;
	v1x = portal->t1[0].x - portal->t1[1].x;

	nx = ((v1y * v2z) - (v2y * v1z)) >> 12;
	ny = ((v2x * v1z) - (v1x * v2z)) >> 12;
	nz = ((v2x * v1y) - (v2x * v1y)) >> 12;

	side = -(((portal->t1[0].x - theCamera.core.position.x) * nx) + ((portal->t1[0].y - theCamera.core.position.y) * ny) + ((portal->t1[0].z - theCamera.core.position.z) * nz));
	
	len = MATH3D_FastSqrt((nx * nx) + (ny * ny) + (nz * nz));
	
	if (ABS(side) < len)
	{
		v1y = portal->t2[0].y - portal->t2[1].y;
		v2z = portal->t2[0].z - portal->t2[2].z;
		v1z = portal->t2[0].z - portal->t2[1].z;
		v2y = portal->t2[0].y - portal->t2[1].y;
		v2x = portal->t2[0].x - portal->t2[2].x;
		v1x = portal->t2[0].x - portal->t2[1].x;

		nx2 = ((v1y * v2z) - (v2y * v1z)) >> 12;
		ny2 = ((v2x * v1z) - (v1x * v2z)) >> 12;
		nz2 = ((v1x * v2y) - (v2x * v1y)) >> 12;

		side2 = -(((portal->t2[0].x - theCamera.core.position.x) * nx2) + ((portal->t2[0].y - theCamera.core.position.y) * ny2) + ((portal->t2[0].z - theCamera.core.position.z) * nz2));
		
		MATH3D_FastSqrt((nx2 * nx2) + (ny2 * ny2) + (nz2 * nz2));

		if (side < side2)
		{
			side = side2;
			nx = nx2;
			ny = ny2;
			nz = nz2;
		}
	}

	if (memcmp(portal->tolevelname, "warpgate", sizeof("warpgate") - 1) != 0)
	{
		if (ABS(side) < len)
		{
			dot = -((((theCamera.focusInstance->matrix + 1)->t[0] - theCamera.core.position.x) * nx) + (((theCamera.focusInstance->matrix + 1)->t[1] - theCamera.core.position.y) * ny) + (((theCamera.focusInstance->matrix + 1)->t[2] - theCamera.core.position.z) * nz));

			if (dot > 0 && horizontal_flag == 0)
			{
				fullscreen_flag = 1;
			}
		}
	}

	if (side < 1024)
	{
		if (fullscreen_flag == 0)
		{
			return 0;
		}
	}

	rect->w += rect->x;
	rect->h += rect->y;

	gte_SetRotMatrix(theCamera.core.wcTransform);
	gte_SetTransMatrix(theCamera.core.wcTransform);

	retval = AddClippedTri((SVECTOR*)&portal->t1[0], rect, &minz);
	retval |= AddClippedTri((SVECTOR*)&portal->t2[0], rect, &minz2);

	if (retval == 0)
	{
		rect->w -= rect->x;
		rect->h -= rect->y;

		return 0;
	}
	else
	{
		if (minz2 < minz)
		{
			minz = minz2;
		}

		if (fullscreen_flag != 0)
		{
			if (minz < 64)
			{
				rect->x = 0;
				rect->y = 0;
				rect->w = SCREEN_WIDTH;
				rect->y = SCREEN_HEIGHT;
				
				return 1;
			}
		}

		if (rect->x < 0)
		{
			rect->x = 0;
		}

		if (rect->y < 0)
		{
			rect->y = 0;
		}

		if (rect->w >= 513)
		{
			rect->w = SCREEN_WIDTH;
		}

		if (rect->h >= 241)
		{
			rect->h = SCREEN_HEIGHT;
		}

		rect->w -= rect->x;
		rect->h -= rect->y;

		if (horizontal_flag != 0)
		{
			if (ABS(side) < len)
			{
				if (nz > 0)
				{
					rect->h = SCREEN_HEIGHT - rect->y;
				}
				else
				{
					rect->h += rect->y;
				}

			}
		}

		if (rect->w > 0)
		{

			return (0 < rect->h);
		}
	}

	return 0;
}


// autogenerated function stub: 
// long /*$ra*/ GetFogColor(struct StreamUnitPortal *portal /*$s0*/, struct _StreamUnit *mainStreamUnit /*$a1*/, struct Level *mainLevel /*$s1*/)
long GetFogColor(struct StreamUnitPortal *portal, struct _StreamUnit *mainStreamUnit, struct Level *mainLevel)
{ // line 5012, offset 0x8005eafc
	/* begin block 1 */
		// Start line: 5013
		// Start offset: 0x8005EAFC
		// Variables:
			long z1; // stack offset -36
			long z2; // stack offset -32
			long z3; // stack offset -28
			long zval; // $a1
			long zval2; // $v1
			long interp; // $s0
			long Color; // stack offset -20
			long MainColor; // stack offset -24
			long LevelColor; // stack offset -40
			struct Level *level; // $a1

		/* begin block 1.1 */
			// Start line: 5025
			// Start offset: 0x8005EB30
			// Variables:
				int time; // $a2
		/* end block 1.1 */
		// End offset: 0x8005EB68
		// End Line: 5031
	/* end block 1 */
	// End offset: 0x8005EE0C
	// End Line: 5119

	/* begin block 2 */
		// Start line: 11907
	/* end block 2 */
	// End Line: 11908
				UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// void /*$ra*/ DrawFogRectangle(struct PSX_RECT *cliprect /*$a0*/, struct _PrimPool *primPool /*$a1*/, int otzpos /*$a2*/, unsigned long **drawot /*$a3*/, long color /*stack 16*/)
void DrawFogRectangle(PSX_RECT *cliprect, struct _PrimPool *primPool, int otzpos, unsigned long **drawot, long color)
{ // line 5121, offset 0x8005ee20
	/* begin block 1 */
		// Start line: 5122
		// Start offset: 0x8005EE20
		// Variables:
			POLY_G4 *polyg4; // $t0
	/* end block 1 */
	// End offset: 0x8005EF04
	// End Line: 5163

	/* begin block 2 */
		// Start line: 12137
	/* end block 2 */
	// End Line: 12138

	/* begin block 3 */
		// Start line: 12140
	/* end block 3 */
	// End Line: 12141
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ STREAM_RenderAdjacantUnit(unsigned long **curOT /*$s3*/, struct StreamUnitPortal *curStreamPortal /*$s0*/, struct _StreamUnit *toStreamUnit /*$s1*/, struct _StreamUnit *mainStreamUnit /*$s2*/, struct PSX_RECT *cliprect /*stack 16*/)
void STREAM_RenderAdjacantUnit(unsigned long **curOT, struct StreamUnitPortal *curStreamPortal, struct _StreamUnit *toStreamUnit, struct _StreamUnit *mainStreamUnit, PSX_RECT *cliprect)
{ // line 5169, offset 0x8005ef0c
	/* begin block 1 */
		// Start line: 5170
		// Start offset: 0x8005EF0C

		/* begin block 1.1 */
			// Start line: 5174
			// Start offset: 0x8005EF44
			// Variables:
				long portalFogColor; // $s0
		/* end block 1.1 */
		// End offset: 0x8005EF9C
		// End Line: 5186
	/* end block 1 */
	// End offset: 0x8005EF9C
	// End Line: 5187

	/* begin block 2 */
		// Start line: 12319
	/* end block 2 */
	// End Line: 12320
				UNIMPLEMENTED();
}


// autogenerated function stub: 
// struct BSPTree * /*$ra*/ STREAM_GetBspTree(struct _StreamUnit *streamUnit /*$a0*/, long bspNumber /*$a1*/)
struct BSPTree * STREAM_GetBspTree(struct _StreamUnit *streamUnit, long bspNumber)
{ // line 5189, offset 0x8005efb8
	/* begin block 1 */
		// Start line: 5191
		// Start offset: 0x8005EFB8
		// Variables:
			struct Level *level; // $v0
			struct _Terrain *terrain; // $v0
			int d; // $a0
	/* end block 1 */
	// End offset: 0x8005F010
	// End Line: 5211

	/* begin block 2 */
		// Start line: 12365
	/* end block 2 */
	// End Line: 12366

	/* begin block 3 */
		// Start line: 12366
	/* end block 3 */
	// End Line: 12367
			UNIMPLEMENTED();
	return null;
}


// autogenerated function stub: 
// void /*$ra*/ WARPGATE_BlockWarpGateEntrance(struct _StreamUnit *streamUnit /*$a0*/, long collideOn /*$s0*/)
void WARPGATE_BlockWarpGateEntrance(struct _StreamUnit *streamUnit, long collideOn)
{ // line 5214, offset 0x8005f018
	/* begin block 1 */
		// Start line: 5215
		// Start offset: 0x8005F018
		// Variables:
			struct BSPTree *bspTree; // $v1
	/* end block 1 */
	// End offset: 0x8005F078
	// End Line: 5232

	/* begin block 2 */
		// Start line: 12419
	/* end block 2 */
	// End Line: 12420
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ WARPGATE_DrawWarpGateRim(struct _StreamUnit *streamUnit /*$a0*/, long drawOn /*$s0*/)
void WARPGATE_DrawWarpGateRim(struct _StreamUnit *streamUnit, long drawOn)
{ // line 5235, offset 0x8005f088
	/* begin block 1 */
		// Start line: 5236
		// Start offset: 0x8005F088
		// Variables:
			struct BSPTree *bspTree; // $v1
	/* end block 1 */
	// End offset: 0x8005F0D0
	// End Line: 5256

	/* begin block 2 */
		// Start line: 12461
	/* end block 2 */
	// End Line: 12462
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ WARPGATE_HideAllCloudCovers()
void WARPGATE_HideAllCloudCovers()
{ // line 5258, offset 0x8005f0e0
	/* begin block 1 */
		// Start line: 5260
		// Start offset: 0x8005F0E0
		// Variables:
			struct Object *warpFaceObject; // $a1

		/* begin block 1.1 */
			// Start line: 5266
			// Start offset: 0x8005F0F4
			// Variables:
				struct _Instance *instance; // $v1
				struct _Instance *next; // $a0
		/* end block 1.1 */
		// End offset: 0x8005F138
		// End Line: 5281
	/* end block 1 */
	// End offset: 0x8005F138
	// End Line: 5283

	/* begin block 2 */
		// Start line: 12507
	/* end block 2 */
	// End Line: 12508

	/* begin block 3 */
		// Start line: 12508
	/* end block 3 */
	// End Line: 12509

	/* begin block 4 */
		// Start line: 12511
	/* end block 4 */
	// End Line: 12512
				UNIMPLEMENTED();
}


// autogenerated function stub: 
// struct _Instance * /*$ra*/ WARPGATE_UnHideCloudCoverInUnit(long streamUnitID /*$a0*/)
struct _Instance * WARPGATE_UnHideCloudCoverInUnit(long streamUnitID)
{ // line 5285, offset 0x8005f140
	/* begin block 1 */
		// Start line: 5287
		// Start offset: 0x8005F140
		// Variables:
			struct Object *warpFaceObject; // $a3
			struct _Instance *result; // $a2

		/* begin block 1.1 */
			// Start line: 5294
			// Start offset: 0x8005F154
			// Variables:
				struct _Instance *instance; // $v1
				struct _Instance *next; // $a1
		/* end block 1.1 */
		// End offset: 0x8005F1B0
		// End Line: 5312
	/* end block 1 */
	// End offset: 0x8005F1B0
	// End Line: 5314

	/* begin block 2 */
		// Start line: 12563
	/* end block 2 */
	// End Line: 12564

	/* begin block 3 */
		// Start line: 12564
	/* end block 3 */
	// End Line: 12565

	/* begin block 4 */
		// Start line: 12568
	/* end block 4 */
	// End Line: 12569
				UNIMPLEMENTED();
	return null;
}


// autogenerated function stub: 
// void /*$ra*/ STREAM_RenderWarpGate(unsigned long **mainOT /*$s3*/, struct StreamUnitPortal *curStreamPortal /*$s2*/, struct _StreamUnit *mainStreamUnit /*$s1*/, struct PSX_RECT *cliprect /*$s4*/)
void STREAM_RenderWarpGate(unsigned long **mainOT, struct StreamUnitPortal *curStreamPortal, struct _StreamUnit *mainStreamUnit, PSX_RECT *cliprect)
{ // line 5318, offset 0x8005f1b8
	/* begin block 1 */
		// Start line: 5319
		// Start offset: 0x8005F1B8
		// Variables:
			struct _StreamUnit *toStreamUnit; // $s0
	/* end block 1 */
	// End offset: 0x8005F4D0
	// End Line: 5428

	/* begin block 2 */
		// Start line: 12634
	/* end block 2 */
	// End Line: 12635
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ WARPGATE_RenderWarpUnit(unsigned long **mainOT /*$fp*/, struct StreamUnitPortal *curStreamPortal /*$s0*/, struct _StreamUnit *mainStreamUnit /*$s4*/, struct PSX_RECT *cliprect /*$s2*/)
void WARPGATE_RenderWarpUnit(unsigned long** mainOT, struct StreamUnitPortal* curStreamPortal, struct _StreamUnit* mainStreamUnit, PSX_RECT* cliprect)
{ // line 5431, offset 0x8005f4f0
	/* begin block 1 */
		// Start line: 5432
		// Start offset: 0x8005F4F0
		// Variables:
	unsigned long** curOT; // $s3
	DR_AREA* PortalClip; // $s0
	struct _StreamUnit* toStreamUnit; // $s1

/* begin block 1.1 */
	// Start line: 5465
	// Start offset: 0x8005F5B8
	// Variables:
		//PSX_RECT PortalRect; // stack offset -48
	long portalFogColor; // $s0

/* begin block 1.1.1 */
	// Start line: 5534
	// Start offset: 0x8005F800
	// Variables:
	unsigned long* hld; // $a0
/* end block 1.1.1 */
// End offset: 0x8005F898
// End Line: 5552
/* end block 1.1 */
// End offset: 0x8005F898
// End Line: 5553
/* end block 1 */
// End offset: 0x8005F898
// End Line: 5555

/* begin block 2 */
	// Start line: 12871
/* end block 2 */
// End Line: 12872
	UNIMPLEMENTED();
}

void STREAM_DumpNonResidentObjects()
{
	struct _Instance* instance;
	struct _Instance* next;
	struct Object* object;

	instance = gameTrackerX.instanceList->first;

	while (instance != NULL)
	{
		object = instance->object;

		if (!(object->oflags & 0x2000000))
		{
			if (STREAM_GetStreamUnitWithID(instance->birthStreamUnitID) == 0 &&
				STREAM_IsObjectInAnyUnit(FindObjectInTracker(object)) == 0)
			{
#if !defined(PSX_VERSION)//Temporarily disabled to make PSX compile.
				INSTANCE_ReallyRemoveInstance(gameTrackerX.instanceList, instance, 0);
#endif
			}
		}
		instance = instance->next;
	}

	STREAM_RemoveAllObjectsNotInUse();
}

int STREAM_TryAndDumpNonResident(struct _ObjectTracker* otr)
{
	struct _Instance* instance;
	struct _Instance* next;

	if (otr->objectStatus == 2 && !(otr->object->oflags & 0x2000000) && STREAM_IsObjectInAnyUnit(otr) == 0)
	{
		instance = gameTrackerX.instanceList->first;

		while (instance != NULL)
		{
			if (instance->object == otr->object && instance->LinkParent != NULL)
			{
				if (!(instance->object->oflags2 & 0x80000))
				{
					return 0;
				}
			}

			instance = instance->next;
		}

		instance = gameTrackerX.instanceList->first;

		while (instance != NULL)
		{
			next = instance->next;

			if (instance->object == otr->object)
			{
				SAVE_DeleteInstance(instance);

				if (instance->LinkChild != NULL)
				{
					INSTANCE_ReallyRemoveAllChildren(instance);
					instance = instance->next;
				}

				INSTANCE_ReallyRemoveInstance(gameTrackerX.instanceList, instance, 0);
			}

			instance = next;
		}

		STREAM_RemoveAllObjectsNotInUse();

		return otr->objectStatus < 1;
	}
}