#include "CORE.H"
#include "VRAM.H"
#include "MEMPACK.H"
#include "GAMELOOP.H"

#include <stddef.h>

#if defined(PSXPC_VERSION)
#include <assert.h>//TEMP
#endif

#ifdef PC_VERSION
#pragma warning(disable: 4101)
#endif

short M_TrackClutUpdate;
struct _BlockVramEntry* openVramBlocks; // offset 0x800D482C
struct _BlockVramEntry* usedVramBlocks; // offset 0x800D4828
struct _BlockVramEntry vramBlockList[90]; // offset 0x800D3E2C
long numOfBlocksUsed; // offset 0x800D4808
long VRAM_NeedToUpdateMorph;

void VRAM_PrintVramBlock(struct _BlockVramEntry* vblock)
{
}

void VRAM_PrintInfo()
{
	struct _BlockVramEntry* vblock;

	vblock = usedVramBlocks;
	while (vblock != NULL)
	{
		vblock = vblock->next;
	}

	vblock = openVramBlocks;
	while (vblock != NULL)
	{
		vblock = vblock->next;
	}
}

void VRAM_InitVramBlockCache()
{ 
	int i;
	
	i = 89;

	openVramBlocks = NULL;
	usedVramBlocks = NULL;
	numOfBlocksUsed = 0;

	do
	{
		vramBlockList[i].flags = 0;

	} while (i--);

	VRAM_InsertFreeVram(SCREEN_WIDTH, SCREEN_HEIGHT + 16, SCREEN_WIDTH, SCREEN_HEIGHT + 16, 1);
	VRAM_InitMorphPalettes();
}

void VRAM_EnableTerrainArea()
{ 
	VRAM_InsertFreeVram(SCREEN_WIDTH, 0, SCREEN_WIDTH, SCREEN_HEIGHT + 16, 0);
}

void VRAM_DisableTerrainArea()
{
	VRAM_DeleteFreeVram(SCREEN_WIDTH, 0, SCREEN_WIDTH, SCREEN_HEIGHT + 16);
}

int VRAM_ConcatanateMemory(struct _BlockVramEntry* curBlock)
{
	struct _BlockVramEntry* nextBlock;

	while (curBlock != NULL)
	{
		nextBlock = curBlock->next;

		while (nextBlock != NULL)
		{
			if (curBlock->x == nextBlock->x && curBlock->w == nextBlock->w &&
				(curBlock->y >> 8) == (nextBlock->y >> 8))
			{
				if ((curBlock->y + curBlock->h) == nextBlock->y)
				{
					curBlock->h += nextBlock->h;
					VRAM_DeleteFreeBlock(nextBlock);
					nextBlock->flags = 0;
					return 1;
				}
				else
				{
					if ((nextBlock->y + nextBlock->h) == nextBlock->y)
					{
						nextBlock->h += curBlock->h;
					}

					VRAM_DeleteFreeBlock(curBlock);
					curBlock->flags = 0;
					return 1;
				}
			}
			else
			{
				if (curBlock->y == nextBlock->y && curBlock->h == nextBlock->h)
				{
					if ((curBlock->x + curBlock->w) == nextBlock->x &&
						!(curBlock->x & 0x3F) || curBlock->w + nextBlock->w < 65)
					{
						curBlock->w += nextBlock->w;
						VRAM_DeleteFreeBlock(nextBlock);
						nextBlock->flags = 0;
						return 1;
					}

					if ((nextBlock->x + nextBlock->w) == curBlock->x)
					{
						if (!(nextBlock->x & 0x3F) || curBlock->w + nextBlock->w < 65)
						{
							curBlock->w += nextBlock->w;
							VRAM_DeleteFreeBlock(curBlock);
							curBlock->flags = 0;
							return 1;
						}
					}
				}
			}
			nextBlock = nextBlock->next;
		}
		curBlock = curBlock->next;
	}

	return 0;
}

void VRAM_GarbageCollect()
{ 
	while (VRAM_ConcatanateMemory(openVramBlocks) == 1)
	{

	}
}

int VRAM_InsertFreeBlock(struct _BlockVramEntry* block)
{
	struct _BlockVramEntry* next;
	struct _BlockVramEntry* prev;

	prev = NULL;
	if (block == NULL)
	{
		return 0;
	}

	next = openVramBlocks;
	while (next != NULL)
	{
		if (next->area >= block->area)
		{
			break;
		}

		prev = next;
		next = prev->next;
	}


	if (prev == NULL)
	{
		block->next = openVramBlocks;
		openVramBlocks = block;
	}
	else
	{
		block->next = next;
		prev->next = block;
	}

	VRAM_GarbageCollect();

	return 1;
}

void VRAM_DeleteFreeBlock(struct _BlockVramEntry *block)
{
	struct _BlockVramEntry *next;
	struct _BlockVramEntry *prev;
	
	next = openVramBlocks;
	prev = NULL;

	if (block != NULL)
	{
		if (block != next)
		{
			do
			{
				if (next == NULL)
				{
					break;
				}

				prev = next;
				next = prev->next;

			} while (block != next);
		
			if (block != next)
			{
				return;
			}
		}

		if (prev == NULL)
		{
			openVramBlocks = block->next;
		}
		else
		{
			prev->next = block->next;
		}
	}

	return;
}

void VRAM_InsertUsedBlock(struct _BlockVramEntry *block)
{ 
	if (block != NULL)
	{
		if (usedVramBlocks == NULL)
		{
			usedVramBlocks = block;
		}
		else
		{
			block->next = usedVramBlocks;
			usedVramBlocks = block;
		}
	}
}


// autogenerated function stub: 
// void /*$ra*/ VRAM_DeleteUsedBlock(struct _BlockVramEntry *block /*$a0*/)
void VRAM_DeleteUsedBlock(struct _BlockVramEntry *block)
{ // line 349, offset 0x80072cd4
	/* begin block 1 */
		// Start line: 351
		// Start offset: 0x80072CD4
		// Variables:
			struct _BlockVramEntry *next; // $v1
			struct _BlockVramEntry *prev; // $a1
	/* end block 1 */
	// End offset: 0x80072D30
	// End Line: 372

	/* begin block 2 */
		// Start line: 637
	/* end block 2 */
	// End Line: 638

	/* begin block 3 */
		// Start line: 638
	/* end block 3 */
	// End Line: 639

	/* begin block 4 */
		// Start line: 640
	/* end block 4 */
	// End Line: 641

}

struct _BlockVramEntry * VRAM_GetOpenBlock()
{ 
	int i;

	for (i = 0; i < 90; i++)
	{
		if (vramBlockList[i].flags == 0)
		{
			return &vramBlockList[i];
		}
	}

	return NULL;
}


// autogenerated function stub: 
// int /*$ra*/ VRAM_DeleteFreeVram(short x /*$a0*/, short y /*$a1*/, short w /*$a2*/, short h /*$a3*/)
int VRAM_DeleteFreeVram(short x, short y, short w, short h)
{ // line 391, offset 0x80072d6c
	/* begin block 1 */
		// Start line: 392
		// Start offset: 0x80072D6C
		// Variables:
			struct _BlockVramEntry *prev; // $t1
			struct _BlockVramEntry *vblock; // $a2
			struct _BlockVramEntry *nextVBlock; // $t0
			struct _BlockVramEntry (*blockLists[2]); // stack offset -24
			int i; // $t2
			int delCount; // $t3
	/* end block 1 */
	// End offset: 0x80072E88
	// End Line: 427

	/* begin block 2 */
		// Start line: 727
	/* end block 2 */
	// End Line: 728

	return 0;
}

int VRAM_InsertFreeVram(short x, short y, short w, short h, int flags)
{
	struct _BlockVramEntry* useBlock;

	if ((x & 0x3F) && (64 - (x & 0x3F)) < w)
	{
		useBlock = VRAM_GetOpenBlock();

		useBlock->w = 64 - (x & 0x3F);
		useBlock->next = NULL;
		useBlock->flags = flags;
		useBlock->time = 0;
		useBlock->ID = 0;
		useBlock->x = x;
		useBlock->y = y;
		useBlock->h = h;
		useBlock->area = useBlock->w * h;

		VRAM_InsertFreeBlock(useBlock);

		useBlock = VRAM_GetOpenBlock();
		useBlock->w = (w - 64) + (x & 0x3F);
		useBlock->next = NULL;
		useBlock->flags = flags;
		useBlock->time = 0;
		useBlock->ID = 0;
		useBlock->y = y;
		useBlock->h = h;
		useBlock->x = (x + 64) - (x & 0x3F);
		useBlock->area = useBlock->w * h;

		VRAM_InsertFreeBlock(useBlock);
	}
	else
	{
		useBlock = VRAM_GetOpenBlock();

		useBlock->next = NULL;
		useBlock->flags = flags;
		useBlock->time = 0;
		useBlock->ID = 0;
		useBlock->x = x;
		useBlock->y = y;
		useBlock->w = w;
		useBlock->h = h;
		useBlock->area = w * h;

		VRAM_InsertFreeBlock(useBlock);
	}

	return 1;
}

struct _BlockVramEntry* VRAM_CheckVramSlot(short* x, short* y, short w, short h, int type, int startY)
{
	struct _BlockVramEntry* vblock;
	short hldx;
	short hldy;
	short hldw;
	short hldh;
	long fits;
	long offset;
	struct _BlockVramEntry* vblockright;
	long offsetright;
	int newx;
	int xval;

	vblock = openVramBlocks;
	fits = 0;
	vblockright = NULL;
	offsetright = 0;

	while (vblock != NULL)
	{
		if ((((vblock->w >= w) && (vblock->h >= h))) && ((startY == -1 || ((vblock->y >= startY) && (vblock->y < startY + 256)))))
		{
			if ((vblock->x & 0x3F))
			{
				if ((64 - (vblock->x & 0x3F)) >= w)
				{
					if (((vblock->x & 0x3F) & 0xF))
					{
						hldw = (16 - (64 - (vblock->x & 0x3F)));
						newx = 64 - ((vblock->x + hldw) & 0x3F);

						if (newx >= w || (vblock->w - hldw) >= w)
						{
							VRAM_InsertFreeVram(vblock->x, vblock->y, hldw, vblock->h, vblock->flags);

							fits = 0;

							vblock->x += hldw;
							vblock->w -= hldw;
							break;
						}
					}
					else
					{
						fits = 0;
						break;
					}
				}
				else
				{
					hldw = 64 - (vblock->x & 0x3F);
					newx = 64 - ((vblock->x + hldw) & 0x3F);

					if (newx >= w || (vblock->w - hldw) >= w)
					{
						fits = 1;
						vblockright = vblock;
						offsetright = hldw;
					}
				}
			}
			else
			{
				fits = 0;
				break;
			}
		}

		vblock = vblock->next;
	}

	if (vblock == NULL)
	{
		if (vblockright != NULL && fits == 1)
		{
			vblock = vblockright;
	
			VRAM_InsertFreeVram(vblock->x, vblock->y, offsetright, vblock->h, vblock->flags);
			
			fits = 0;
			
			vblock->x += offsetright;
			vblock->w -= offsetright;
		}
		
		if (vblock == NULL)
		{
			return vblock;
		}

	}

	if (fits != 0)
	{
		return vblock;
	}

	hldx = vblock->x;
	hldy = vblock->y;
	hldw = vblock->w;
	hldh = vblock->h;

	VRAM_DeleteFreeBlock(vblock);

	vblock->next = NULL;
	vblock->flags = 1;
	vblock->w = w;
	vblock->h = h;
	vblock->type = type;

	VRAM_InsertUsedBlock(vblock);

	x[0] = vblock->x;
	y[0] = vblock->y;

	offsetright = hldw;

	if (offsetright != vblock->w)
	{
		if (hldh != h)
		{
			if (ABS(((hldw - w) * hldh) - (w * (hldh - h))) < ABS(((hldw - w) * h) - (hldw * (hldh - h))))
			{
				VRAM_InsertFreeVram(hldx + w, hldy, hldw - w, h, 1);
				VRAM_InsertFreeVram(hldx, hldy + h, hldw, hldh - h, 1);
			}
			else
			{
				VRAM_InsertFreeVram(hldx + w, hldy, hldw - w, hldh, 1);
				VRAM_InsertFreeVram(hldx, hldy + h, w, hldh - h, 1);
			}
		}
		else
		{
			VRAM_InsertFreeVram(hldx + w, hldy, hldw - w, hldh, 16);
		}
	}
	else
	{
		if (hldh != h)
		{
			VRAM_InsertFreeVram(hldx, hldy + h, vblock->w, hldh - h, 16);
		}
	}

	return vblock;
}

void VRAM_ClearVramBlock(struct _BlockVramEntry* block)
{
	if (block != NULL)
	{
		VRAM_DeleteUsedBlock(block);
		VRAM_InsertFreeBlock(block);
	}
}


// autogenerated function stub: 
// void /*$ra*/ AdjustVramCoordsObject(int oldx /*$s3*/, int oldy /*$s1*/, int newx /*$a2*/, int newy /*$t7*/, struct Object *object /*stack 16*/)
void AdjustVramCoordsObject(int oldx, int oldy, int newx, int newy, struct Object *object)
{
	struct TextureMT3* texture; // $t1
	int oldclutxoffset; // $v0
	int oldclutyoffset; // $a0
	int newclut; // $a0
	int d; // $t4
	int oldtpagexoffset; // $v1
	int oldtpageyoffset; // $v0
	int newtpage; // $a3
	struct _Model* model; // $t3
	short diffy; // $s5
	short diffx; // $s6

	//s3 = oldx
	//s1 = oldy
	//t7 = newy

	//oldtpagexoffset = newx & 0x3F;
	//oldclutxoffset = oldx & 0x3F;

	diffx = (newx & 0x3F) - (oldx & 0x3F);
	diffy = (newy & 0xFF) - (oldy & 0xFF);

	//s2 = object;

	d = 0;
	if (object->numModels > 0)
	{
		//s4 = 0xFFFFFFF0
		//s0 = newx & 0xFFFFFFF0
		//v0 = 0xFFFFFFC0
		//t9 = newx & 0xFFFFFFC0
		//t8 = oldx & 0xFFFFFFC0

		//loc_80073ADC
		model = object->modelList[d];

		//v1 = model->startTextures
		if (model->startTextures != NULL)
		{
			texture = model->startTextures;

			//v0 = 0xFFFFFF00
			if (texture < model->endTextures)
			{
				//t6 = oldy & 0xFFFFFF00
				//t2 = diffy
				//t5 = diffx
				//t0 = &texture->clut

				//loc_80073B28
				//a2 = texture->tpage
				//a1 = 2
				//a3 = texture->tpage & 0x1E0
				//v1 = (newx & 0xFFFFFFC0) - (((texture->tpage & 0xF) << 6) - (oldx & 0xFFFFFFC0))
				oldtpagexoffset = (newx & 0xFFFFFFC0) - (((texture->tpage & 0xF) << 6) - (oldx & 0xFFFFFFC0));
				oldtpageyoffset = newy - (((texture->tpage & 0x10) << 4) - (oldy & 0xFFFFFF00));


				newtpage = getTPage(0, 0, oldtpagexoffset, oldtpageyoffset);
				//a1 = diffx << (2 - ((texture->tpage >> 7) & 0x3))
				texture->v0 += diffy;
				texture->v2 += diffy;
				
				//a0 = texture->clut

				texture->v1 += diffy;

				//v0 = (texture->clut & 0xFF) + (diffx << (2 - ((texture->tpage >> 7) & 0x3)));
				//v1 = oldx & 0xFFFFFFF0
				///@FIXME storing and loading a byte from CLUT? 
			}
			//loc_80073C24
		}
		//loc_80073C24
	}
	//loc_80073C38
#if 0
		addu    $v0, $a1
		sb      $v0, 0($t1)
		andi    $v0, $a0, 0x3F
		sll     $v0, 4
		subu    $v0, $v1
		srl     $a0, 6
		subu    $a0, $s1
		addu    $a0, $t7, $a0
		sll     $a0, 6
		addu    $v0, $s0, $v0
		sra     $v0, 4
		andi    $v0, 0x3F
		or $a0, $v0
		lbu     $v0, 2($t0)
		lbu     $v1, 6($t0)
		addiu   $t1, 0x10
		sh      $a3, 4($t0)
		sh      $a0, 0($t0)
		addu    $v0, $a1
		addu    $v1, $a1
		sb      $v0, 2($t0)
		sb      $v1, 6($t0)
		lw      $v0, 0x34($t3)
		nop
		sltu    $v0, $t1, $v0
		bnez    $v0, loc_80073B28
		addiu   $t0, 0x10

		loc_80073C24:
	lh      $v0, 8($s2)
		addiu   $t4, 1
		slt     $v0, $t4, $v0
		bnez    $v0, loc_80073ADC
		nop

		loc_80073C38 :
	lw      $s6, var_s18($sp)
		lw      $s5, var_s14($sp)
		lw      $s4, var_s10($sp)
		lw      $s3, var_sC($sp)
		lw      $s2, var_s8($sp)
		lw      $s1, var_s4($sp)
		lw      $s0, var_s0($sp)
		jr      $ra
		addiu   $sp, 0x20
#endif

}


// autogenerated function stub: 
// struct _BlockVramEntry * /*$ra*/ VRAM_InsertionSort(struct _BlockVramEntry *rootNode /*$a0*/, struct _BlockVramEntry *newBlock /*$a1*/, int pack_type /*$a2*/)
struct _BlockVramEntry * VRAM_InsertionSort(struct _BlockVramEntry *rootNode, struct _BlockVramEntry *newBlock, int pack_type)
{ // line 922, offset 0x8007364c
#if defined(PC_VERSION)
	struct _BlockVramEntry* result; // eax
	struct _BlockVramEntry* v4; // esi
	struct _BlockVramEntry* v5; // ecx
	__int16 w; // di
	__int16 v7; // dx

	result = rootNode;
	v4 = 0;
	v5 = rootNode;
	if (pack_type)
	{
		if (rootNode)
		{
			w = newBlock->w;
			do
			{
				v7 = v5->w;
				if (w >= v7 && (w != v7 || newBlock->h >= v5->h))
					break;
				v4 = v5;
				v5 = v5->next;
			} while (v5);
		}
	}
	else if (rootNode)
	{
		do
		{
			if (newBlock->area >= v5->area)
				break;
			v4 = v5;
			v5 = v5->next;
		} while (v5);
	}
	if (v4)
	{
		newBlock->next = v5;
		v4->next = newBlock;
	}
	else
	{
		newBlock->next = rootNode;
		return newBlock;
	}
	return result;
#else
	return NULL;
#endif
}


// autogenerated function stub: 
// void /*$ra*/ VRAM_ClearVram()
void VRAM_ClearVram()
{ // line 970, offset 0x80073704
	/* begin block 1 */
		// Start line: 971
		// Start offset: 0x80073704
		// Variables:
			struct _BlockVramEntry *vblock; // $a0
			struct _BlockVramEntry *next; // $s0
	/* end block 1 */
	// End offset: 0x80073730
	// End Line: 981

	/* begin block 2 */
		// Start line: 2226
	/* end block 2 */
	// End Line: 2227

	/* begin block 3 */
		// Start line: 2229
	/* end block 3 */
	// End Line: 2230

}


#if defined(PSX_VERSION)
struct _BlockVramEntry* VRAM_RearrangeVramsLayer(long whichLayer)
{ // line 991, offset 0x80073740
	return NULL;
}

#elif defined(PC_VERSION)
// autogenerated function stub: 
// struct _BlockVramEntry * /*$ra*/ VRAM_RearrangeVramsLayer(long whichLayer /*stack 0*/, short *AddX /*stack 4*/, short *AddY /*stack 8*/, short AddW /*$fp*/, int AddH /*stack 16*/, int AddType /*stack 20*/, int AddStartY /*stack 24*/)
struct _BlockVramEntry * VRAM_RearrangeVramsLayer(long whichLayer, short *AddX, short *AddY, short AddW, int AddH, int AddType, int AddStartY)
{ // line 991, offset 0x80073740
	/* begin block 1 */
		// Start line: 992
		// Start offset: 0x80073740
		// Variables:
			struct _BlockVramEntry *vblock; // $a0
			struct _BlockVramEntry *retvblock; // $s5
			struct _BlockVramEntry *sortedBlocks; // $s2
			struct _BlockVramEntry *curBlock; // $s0
			struct _BlockVramEntry (*savedVramBlocksPTR[48]); // stack offset -1624
			struct _BlockVramEntry savedVramBlocks[48]; // stack offset -1432
			PSX_RECT vramLoc; // stack offset -88
			long numBlocks; // $s3
			long d; // $s1
			int error_retry; // $s4
			int good_pack; // $s7
			int pack_type; // $s6
			short x; // stack offset -80
			short y; // stack offset -78
			short dispYPos; // stack offset -56

		/* begin block 1.1 */
			// Start line: 1052
			// Start offset: 0x80073868
			// Variables:
				int startY; // stack offset -48

			/* begin block 1.1.1 */
				// Start line: 1117
				// Start offset: 0x80073A70
				// Variables:
					int type; // $t0
			/* end block 1.1.1 */
			// End offset: 0x80073C08
			// End Line: 1217
		/* end block 1.1 */
		// End offset: 0x80073D8C
		// End Line: 1278
	/* end block 1 */
	// End offset: 0x80073D8C
	// End Line: 1281

	/* begin block 2 */
		// Start line: 2271
	/* end block 2 */
	// End Line: 2272

	/* begin block 3 */
		// Start line: 2292
	/* end block 3 */
	// End Line: 2293

	return null;
}
#endif

void VRAM_TransferBufferToVram(void *dataPtr, long dataSize, short status, void *data1, void *data2)
{ 
	struct VramBuffer* vramControl;
	PSX_RECT rect;
	long *nextOTag;
	long *drawTimerReturn;

	nextOTag = (long*)BreakDraw();
	
	DrawSync(0);
	
	drawTimerReturn = gameTrackerX.drawTimerReturn;
	
	vramControl = (struct VramBuffer*)data1;
	
	gameTrackerX.drawTimerReturn = NULL;

	if (vramControl != NULL)
	{
		if (!(vramControl->flags & 0x1))
		{
			vramControl->flags |= 0x1;
		
			dataPtr = ((char*)dataPtr + 0x24);
			
			dataSize -= 0x24;;
		}

		if (vramControl->lengthOfLeftOverData != 0)
		{
			if (dataSize < ((vramControl->w << 1) - vramControl->lengthOfLeftOverData))
			{
				memcpy(vramControl->lineOverFlow, dataPtr, dataSize);
				vramControl->lengthOfLeftOverData += dataSize;
				dataSize = 0;
			}
			else
			{
				memcpy(&vramControl->lineOverFlow[vramControl->lengthOfLeftOverData], dataPtr, ((vramControl->w << 1) - vramControl->lengthOfLeftOverData));
			
				dataPtr = ((char*)dataPtr + ((vramControl->w << 1) - vramControl->lengthOfLeftOverData));
				dataSize -= ((vramControl->w << 1) - vramControl->lengthOfLeftOverData);

				vramControl->lengthOfLeftOverData += ((vramControl->w << 1) - vramControl->lengthOfLeftOverData);
		
				rect.x = vramControl->x;
				rect.y = vramControl->y + vramControl->yOffset;
				rect.h = 1;
				rect.w = vramControl->w;
				
				vramControl->yOffset++;
				
				LoadImage(&rect, (unsigned long*)vramControl->lineOverFlow);
				vramControl->lengthOfLeftOverData = 0;
			}
		}

		if (dataSize > 0)
		{
			rect.x = vramControl->x;
			rect.y = vramControl->y + vramControl->yOffset;
			rect.h = dataSize / (vramControl->w << 1);
			rect.w = vramControl->w;
	
			LoadImage(&rect, (unsigned long*)((char*)dataPtr + (vramControl->w * ((dataSize / vramControl->w << 1) << 1))));

			vramControl->yOffset += (dataSize / (vramControl->w << 1));
			dataSize -= vramControl->w * ((dataSize / vramControl->w << 1) << 1);
			dataPtr = ((char*)dataPtr + (vramControl->w * ((dataSize / vramControl->w << 1) << 1)));

			if (dataSize > 0)
			{
				memcpy(((char*)vramControl->lineOverFlow + vramControl->lengthOfLeftOverData), dataPtr, dataSize);
				vramControl->lengthOfLeftOverData += dataSize;
			}
		}

		if (status == 1 && data2 != NULL && ((struct _ObjectTracker*)data2)->objectStatus == 4)
		{
			((struct _ObjectTracker*)data2)->objectStatus = 2;
		}
	}

	DrawSync(0);
	gameTrackerX.drawTimerReturn = drawTimerReturn;
	
	if ((unsigned long)nextOTag != 0xFFFFFFFF)
	{
		DrawOTag((u_long*)nextOTag);
	}
}

void VRAM_LoadReturn(void *dataPtr, void *data1, void *data2)
{
	MEMPACK_Free((char*)data1);
}

long VRAM_GetObjectVramSpace(struct VramSize *vramSize, struct _ObjectTracker *objectTracker)
{
#if defined(PSX_VERSION)
	PSX_RECT rect;
	long result;
	struct _BlockVramEntry* lastVramBlockUsed;

	result = 1;
	
	rect.x = SCREEN_WIDTH;
	rect.y = vramSize->y;
	rect.w = vramSize->w;
	rect.h = vramSize->h;

	lastVramBlockUsed = VRAM_CheckVramSlot(&rect.x, &rect.y, vramSize->w, vramSize->h, 2, 256);

	if (lastVramBlockUsed == NULL)
	{
		VRAM_RearrangeVramsLayer(result);
		lastVramBlockUsed = VRAM_CheckVramSlot(&rect.x, &rect.y, rect.w, rect.h, 2, 256);

		if (lastVramBlockUsed == 0)
		{
			result = 0;
			VRAM_PrintInfo();
		}
	}
	
	if (lastVramBlockUsed != NULL)
	{
		objectTracker->vramBlock = lastVramBlockUsed;
		lastVramBlockUsed->udata.streamObject = objectTracker;
	}

	return result;

#elif defined(PC_VERSION)
	__int16 x; // cx
	__int16 h; // dx
	__int16 w; // cx
	int v5; // esi
	struct _BlockVramEntry* v6; // eax
	PSX_RECT AddX; // [esp+4h] [ebp-Ch] OVERLAPPED BYREF

	x = vramSize->x + 512;
	AddX.y = vramSize->y;
	h = vramSize->h;
	AddX.x = x;
	w = vramSize->w;
	AddX.h = h;
	AddX.w = w;
	v5 = 1;
	v6 = VRAM_CheckVramSlot(&AddX.x, &AddX.y, w, h, 2, 256);
	if (!v6)
	{
		v6 = VRAM_RearrangeVramsLayer(1, &AddX.x, &AddX.y, AddX.w, AddX.h, 2, 256);
		if (!v6)
		{
			v6 = VRAM_CheckVramSlot(&AddX.x, &AddX.y, AddX.w, AddX.h, 2, 256);
			if (!v6)
				v5 = 0;
		}
	}
	objectTracker->vramBlock = v6;
	if (v6)
		v6->udata.streamUnit = (struct _StreamUnit*)objectTracker;
	return v5;
#else
	return NULL;
#endif
}


// autogenerated function stub: 
// void /*$ra*/ VRAM_InitMorphPalettes()
void VRAM_InitMorphPalettes()
{ // line 1511, offset 0x80074158
	/* begin block 1 */
		// Start line: 3502
	/* end block 1 */
	// End Line: 3503

	/* begin block 2 */
		// Start line: 3509
	/* end block 2 */
	// End Line: 3510

}

void VRAM_UpdateMorphPalettes()
{
}


// autogenerated function stub: 
// void /*$ra*/ MORPH_ChangeAreaPalettes(long time /*$a0*/)
void MORPH_ChangeAreaPalettes(long time)
{ // line 1703, offset 0x80074168
	/* begin block 1 */
		// Start line: 3886
	/* end block 1 */
	// End Line: 3887

	/* begin block 2 */
		// Start line: 3912
	/* end block 2 */
	// End Line: 3913

}




