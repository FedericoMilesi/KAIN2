#include "CORE.H"

#include "Game/COLLIDE.H"
#include "Game/PHYSICS.H"
#include "Game/STREAM.H"
#include "Game/BSP.H"
#include "Game/MATH3D.H"
#include "Game/PHYSOBS.H"
#include "Game/STATE.H"
#include "Game/FX.H"
#include "G2/QUATG2.H"
#include "PSX/COLLIDES.H"

void SetNoPtCollideInFamily(struct _Instance* instance)
{
	struct _Instance* child;

	child = instance->LinkChild;

	instance->flags &= 0xFFFFFFBF;

	while (child != NULL)
	{
		ResetNoPtCollideInFamily(child);

		child = child->LinkSibling;
	}
}

void ResetNoPtCollideInFamily(struct _Instance* instance)
{
	struct _Instance* child;

	child = instance->LinkChild;

	instance->flags &= 0xFFFFFFBF;

	while (child != NULL)
	{
		ResetNoPtCollideInFamily(child);

		child = child->LinkSibling;
	}
}

void PHYSICS_CheckLineInWorld(struct _Instance* instance, struct _PCollideInfo* pcollideInfo)
{
	pcollideInfo->collideType = 63;

	PHYSICS_CheckLineInWorldMask(instance, pcollideInfo);
}

void PHYSICS_CheckLineInWorldMask(struct _Instance* instance, struct _PCollideInfo* pcollideInfo)//Matching - 99.31%
{
	struct Level* level;

	level = STREAM_GetLevelWithID(instance->currentStreamUnitID);

	pcollideInfo->inst = NULL;
	pcollideInfo->instance = instance;

	SetNoPtCollideInFamily(instance);

	if (level != NULL)
	{
		COLLIDE_PointAndWorld(pcollideInfo, level);
	}
	else
	{
		pcollideInfo->type = 0;
	}

	ResetNoPtCollideInFamily(instance);
}


// autogenerated function stub: 
// int /*$ra*/ PhysicsCheckLinkedMove(struct _Instance *instance /*$s2*/, int Data /*stack 4*/, short Mode /*stack -72*/)
int PhysicsCheckLinkedMove(struct _Instance *instance, int Data, short Mode)
{ // line 124, offset 0x80074754
	UNIMPLEMENTED();
	return 0;
}

void PhysicsDefaultLinkedMoveResponse(struct _Instance* instance, struct evPhysicsLinkedMoveData* Data, int updateTransforms) { // Matching - 100%
	instance->position.x += Data->posDelta.x;
	instance->position.y += Data->posDelta.y;
	instance->position.z += Data->posDelta.z;
	if (updateTransforms != 0)
	{
		COLLIDE_UpdateAllTransforms(instance, (SVECTOR*)&Data->posDelta);
	}
	instance->rotation.z += Data->rotDelta.z;
}

int PhysicsCheckGravity(struct _Instance* instance, int Data, short Mode)//Matching - 93.98%
{
	struct evPhysicsGravityData* Ptr;
	SVECTOR D;
	SVECTOR N;
	short Dot;
	int rc;
	struct _PCollideInfo CInfo;
	SVECTOR Old;
	SVECTOR New;
	int slide;
	int stillOnOldTFace;
	struct Level* level;
	struct _TFace* tface;
	struct _Instance* oldOn;
	int dx;
	int dy;
	int dz;

	rc = 0;

	D.vx = 0;
	D.vy = 0;
	D.vz = 240;

	slide = 0;

	CInfo.newPoint = &New;
	CInfo.oldPoint = &Old;

	Old.vx = New.vx = instance->position.x;
	Old.vy = New.vy = instance->position.y;
	Old.vz = New.vz = instance->position.z;

	Ptr = (struct evPhysicsGravityData*)Data;

	Old.vz += Ptr->UpperOffset;
	New.vz -= Ptr->LowerOffset;

	if (Old.vz < New.vz)
	{
		CInfo.type = 0;
	}
	else
	{
		if (instance->cachedTFace != -1 && instance->cachedTFaceLevel != NULL)
		{
			tface = NULL;

			level = STREAM_GetLevelWithID(((struct Level*)instance->cachedTFaceLevel)->streamUnitID);

			gameTrackerX.gameFlags |= 0x8000;

			if (level != NULL)
			{
				tface = &level->terrain->faceList[instance->cachedTFace];

				stillOnOldTFace = COLLIDE_PointAndTfaceFunc(level->terrain, &level->terrain->BSPTreeArray[instance->cachedBSPTree], (struct _SVector*)&New, (struct _SVector*)&Old, tface, 0, 0);
			}
			else
			{
				stillOnOldTFace = 0;

			}

			if (stillOnOldTFace == 0)
			{
				instance->waterFace = NULL;

				PHYSICS_CheckLineInWorld(instance, &CInfo);
			}
			else
			{
				CInfo.type = 3;
				CInfo.prim = tface;
				CInfo.inst = (struct _Instance*)level;
				CInfo.segment = instance->cachedBSPTree;

				COLLIDE_GetNormal((short)tface->normal, (short*)level->terrain->normalList, (struct _SVector*)&CInfo.wNormal);
			}
		}
		else
		{
			instance->waterFace = NULL;

			gameTrackerX.gameFlags |= 0x8000;

			PHYSICS_CheckLineInWorld(instance, &CInfo);
		}

		gameTrackerX.gameFlags &= ~0x8000;
	}

	if ((unsigned)(short)(CInfo.type - 2) < 2 || CInfo.type == 5)
	{
		if (CInfo.wNormal.vz < Ptr->slipSlope && CInfo.wNormal.vz > 0)
		{
			N.vx = (-((unsigned short)CInfo.wNormal.vx * -(unsigned short)CInfo.wNormal.vz) < 0) ? ((-((unsigned short)CInfo.wNormal.vx * -(unsigned short)CInfo.wNormal.vz) + 0xFFF)) : ((-((unsigned short)CInfo.wNormal.vx * -(unsigned short)CInfo.wNormal.vz)));
			N.vx >>= 12;
			N.vy = (-((unsigned short)CInfo.wNormal.vy * -(unsigned short)CInfo.wNormal.vz) < 0) ? ((-((unsigned short)CInfo.wNormal.vy * -(unsigned short)CInfo.wNormal.vz) + 0xFFF)) : ((-((unsigned short)CInfo.wNormal.vy * -(unsigned short)CInfo.wNormal.vz)));
			N.vy >>= 12;
			N.vz = (-((unsigned short)CInfo.wNormal.vz * -(unsigned short)CInfo.wNormal.vz) < 0) ? ((-((unsigned short)CInfo.wNormal.vz * -(unsigned short)CInfo.wNormal.vz) + 0xFFF)) : ((-((unsigned short)CInfo.wNormal.vz * -(unsigned short)CInfo.wNormal.vz)));
			N.vz >>= 12;

			Dot = (short)((instance->zVel < -48) ? -instance->zVel : 48);

			Old.vx = New.vx = CInfo.newPoint->vx + N.vx * Dot / 4096;
			Old.vy = New.vy = CInfo.newPoint->vy + N.vy * Dot / 4096;
			Old.vz = New.vz = CInfo.newPoint->vz + N.vz * Dot / 4096;

			Old.vz += Ptr->UpperOffset;
			New.vz -= Ptr->LowerOffset;

			PHYSICS_CheckLineInWorld(instance, &CInfo);

			if ((unsigned)((unsigned short)CInfo.type - 2) < 2 || CInfo.type == 5)
			{
				if (CInfo.wNormal.vz < Ptr->slipSlope && CInfo.wNormal.vz > 0)
				{
					slide = 1;
				}
				else
				{
					instance->position.x = CInfo.newPoint->vx;
					instance->position.y = CInfo.newPoint->vy;
				}
			}
		}
	}

	if (CInfo.type == 3)
	{
		instance->cachedBSPTree = CInfo.segment;

		instance->cachedTFace = (int)(-0x55555555 * (unsigned int)((char*)CInfo.prim - (unsigned int)CInfo.inst->node.prev[4].prev)) >> 2;

		instance->cachedTFaceLevel = CInfo.inst;
	}
	else
	{
		instance->cachedTFace = -1;

		instance->cachedTFaceLevel = NULL;
	}

	if ((unsigned)((unsigned short)CInfo.type - 2 < 2) || CInfo.type == 5)
	{
		if ((Mode & 0x7))
		{
			if (slide != 0)
			{
				Ptr->x = CInfo.newPoint->vx - instance->position.x;
				Ptr->y = CInfo.newPoint->vy - instance->position.y;
			}
			else
			{
				Ptr->x = 0;
				Ptr->y = 0;
			}

			Ptr->z = CInfo.newPoint->vz - instance->position.z;

		}

		if ((Mode & 0x2) && slide == 0)
		{
			INSTANCE_Post(instance, 0x4010008, Data);
		}

		if (slide == 1)
		{
			if ((Mode & 0x2))
			{
				INSTANCE_Post(instance, 0x4010200, Data);
			}

			rc |= 0x100000;
		}

		if ((Mode & 0x4))
		{
			if (CheckPhysOb(instance) == 0 || CheckPhysObFamily(instance, 1) == 0 || instance->attachedID == 0)
			{
				PhysicsDefaultGravityResponse(instance, Ptr);
			}
		}

		if (CInfo.type != 1)
		{
			instance->wNormal.x = CInfo.wNormal.vx;
			instance->wNormal.y = CInfo.wNormal.vy;
			instance->wNormal.z = CInfo.wNormal.vz;
		}
		else
		{
			instance->wNormal.x = 0;
			instance->wNormal.y = 0;
			instance->wNormal.z = 4096;
		}

		if (CInfo.type != 3 && CInfo.inst != NULL && (CInfo.inst->object->oflags & 0x400))
		{
			rc |= PhysicsCheckLinkedMove(instance, SetPhysicsLinkedMoveData(CInfo.inst, CInfo.segment, NULL, NULL), Mode);
		}
		else
		{
			if (instance->attachedID != 0)
			{
				oldOn = INSTANCE_Find(instance->attachedID);

				if (oldOn != NULL)
				{
					oldOn->flags2 &= 0xFFFFFF7F;
				}
			}

			instance->attachedID = 0;
		}

		if ((instance->flags2 & 0x40))
		{
			instance->shadowPosition = instance->position;

			instance->flags |= 0x8000000;
		}

		if (CInfo.type == 3)
		{
			if (instance->tface != CInfo.prim)
			{
				instance->oldTFace = (struct _TFace*)CInfo.prim;

				instance->tface = (struct _TFace*)CInfo.prim;

				instance->tfaceLevel = CInfo.inst;

				instance->bspTree = CInfo.segment;

				if (CInfo.segment == 0)
				{
					rc |= 0x80000;
				}
			}
		}
		else
		{
			if (instance->tface != NULL)
			{
				instance->oldTFace = instance->tface;

				instance->tface = NULL;

				instance->tfaceLevel = NULL;

				instance->bspTree = 0;
			}
		}

		rc |= 0x1;
	}
	else
	{
		if (instance->tface != NULL)
		{
			instance->oldTFace = instance->tface;

			instance->tface = NULL;

			instance->tfaceLevel = NULL;

			instance->bspTree = 0;
		}

		instance->attachedID = 0;

		if ((Mode & 0x2))
		{
			INSTANCE_Post(instance, 0x4000001, Data);
		}
	}

	return rc;
}

void PhysicsDefaultGravityResponse(struct _Instance *instance, struct evPhysicsGravityData *Data)
{
	instance->position.x += Data->x;
	instance->position.y += Data->y;

	if (instance == gameTrackerX.playerInstance && Data->z >= 129)
	{
		instance->position.z += 128;
	}
	else
	{
		instance->position.z += Data->z;
	}
}

int PhysicsCheckEdgeGrabbing(struct _Instance* instance, struct GameTracker* gameTracker, int Data, short Mode)  // Matching - 99.01%
{
	VECTOR OutTrans;
	struct evPhysicsEdgeData* Ptr;
	int rc;
	struct _PCollideInfo CInfo;
	SVECTOR Old;
	SVECTOR New;
	int wallCrawl;
	int freeSpot;
	SVECTOR* ExtraRot;
	static MATRIX TempMat;
	static MATRIX* pTempMat;

	rc = 0;
	wallCrawl = 0;
	freeSpot = 1;
	Ptr = (struct evPhysicsEdgeData*)Data;
	if (Mode & 1)
	{
		Ptr->instance = NULL;
	}
	CInfo.oldPoint = &Old;
	CInfo.newPoint = &New;
	ExtraRot = (SVECTOR*)INSTANCE_Query(instance, 7);
	if (ExtraRot != NULL)
	{
		pTempMat = &TempMat;
		RotMatrix(ExtraRot, &TempMat);
	}
	else
	{
		pTempMat = instance->matrix;
	}
	PHYSICS_GenericLineCheckSetup(0, 0, Ptr->UpperOffset + Ptr->AboveOffset, &Old);
	PHYSICS_GenericLineCheckSetup(0, Ptr->ForwardOffset, Ptr->UpperOffset + Ptr->AboveOffset, &New);
	PHYSICS_GenericLineCheck(instance, instance->matrix, pTempMat, &CInfo);
	if (PHYSICS_CheckFaceStick(&CInfo) != 0)
	{
		wallCrawl += 1;
	}
	if (CInfo.type == 0)
	{
		PHYSICS_GenericLineCheckSetup(0, 0, Ptr->AboveOffset, &Old);
		PHYSICS_GenericLineCheckSetup(0, 0, (Ptr->UpperOffset + Ptr->AboveOffset) + 128, &New);
		PHYSICS_GenericLineCheck(instance, instance->matrix, pTempMat, &CInfo);
	}
	if (CInfo.type != 0)
	{
		freeSpot = 0;
	}
	if ((freeSpot != 0) || (wallCrawl != 0))
	{
		New.vx = 0;
		New.vy = 0;
		New.vz = Ptr->UpperOffset;
		gte_SetRotMatrix(&pTempMat->m[0][0]);
		gte_ldv0(&New.vx);
		gte_rtv0();
		gte_stlvnl(&OutTrans);
		Old.vx = instance->position.x + (short)OutTrans.vx;
		Old.vy = instance->position.y + (short)OutTrans.vy;
		Old.vz = instance->position.z + (short)OutTrans.vz;
		New.vx = 0;
		New.vy = Ptr->ForwardOffset;
		New.vz = Ptr->UpperOffset;
		gte_SetRotMatrix(&pTempMat->m[0][0]);
		gte_ldv0(&New.vx);
		gte_rtv0();
		gte_stlvnl(&OutTrans);
		New.vx = instance->position.x + (short)OutTrans.vx;
		New.vy = instance->position.y + (short)OutTrans.vy;
		New.vz = instance->position.z + (short)OutTrans.vz;
		PHYSICS_CheckLineInWorld(instance, &CInfo);
		if (PHYSICS_CheckDontGrabEdge(&CInfo) == 0)
		{
			if (((CInfo.type == 3) || (CInfo.type == 5) || (CInfo.type == 2)) && ((CInfo.wNormal.vz < 2048) != 0))
			{
				if (PHYSICS_CheckFaceStick(&CInfo) != 0)
				{
					wallCrawl += 1;
				}
				if ((Mode & 1) != 0)
				{
					Ptr->Normal1->x = CInfo.wNormal.vx;
					Ptr->Normal1->y = CInfo.wNormal.vy;
					Ptr->Normal1->z = CInfo.wNormal.vz;
					Ptr->Delta->y = CInfo.newPoint->vy - CInfo.oldPoint->vy;
					Ptr->Delta->x = CInfo.newPoint->vx - CInfo.oldPoint->vx;
					if ((CInfo.type == 5) || (CInfo.type == 2))
					{
						Ptr->instance = CInfo.inst;
					}
				}
				rc |= 2;
				Old.vx = 0;
				Old.vy = -16;
				Old.vz = 0;
				gte_SetRotMatrix(&pTempMat->m[0][0]);
				gte_ldv0(&Old.vx);
				gte_rtv0();
				gte_stlvnl(&OutTrans);
				New.vx = CInfo.newPoint->vx + (short)OutTrans.vx;
				New.vy = CInfo.newPoint->vy + (short)OutTrans.vy;
				New.vz = CInfo.newPoint->vz + (short)OutTrans.vz;
				Old.vx = New.vx;
				Old.vy = New.vy;
				Old.vz = New.vz + Ptr->AboveOffset;
				PHYSICS_CheckLineInWorld(instance, &CInfo);
				if (PHYSICS_CheckDontGrabEdge(&CInfo) == 0)
				{
					if ((((CInfo.type == 3) || (CInfo.type == 5) || CInfo.type == 2)) && ((CInfo.wNormal.vz < 3548) == 0))
					{
						if ((Mode & 1) != 0)
						{
							Ptr->Normal2->x = CInfo.wNormal.vx;
							Ptr->Normal2->y = CInfo.wNormal.vy;
							Ptr->Normal2->z = CInfo.wNormal.vz;
							Ptr->Delta->z = CInfo.newPoint->vz - CInfo.oldPoint->vz;
							if ((CInfo.type == 5) || (CInfo.type == 2))
							{
								Ptr->instance = CInfo.inst;
							}
						}
						if ((CInfo.wNormal.vz < 2897) == 0)
						{
							rc |= 0x4;
							if ((Mode & 0x2) != 0)
							{
								INSTANCE_Post(instance, 0x4010010, Data);
							}
							if ((Mode & 0x4) != 0)
							{
								PhysicsDefaultEdgeGrabResponse(instance, Ptr, 0);
							}
						}
					}
				}
			}
		}
	}
	else if ((CInfo.type == 3) || (CInfo.type == 5) || (CInfo.type == 2))
	{
		if ((Mode & 1) != 0)
		{
			Ptr->Normal1->x = CInfo.wNormal.vx;
			Ptr->Normal1->y = CInfo.wNormal.vy;
			Ptr->Normal1->z = CInfo.wNormal.vz;
			Ptr->Delta->y = CInfo.newPoint->vy - CInfo.oldPoint->vy;
			Ptr->Delta->x = CInfo.newPoint->vx - CInfo.oldPoint->vx;
			Ptr->Delta->z = 0;
			if ((CInfo.type == 5) || (CInfo.type == 2))
			{
				Ptr->instance = CInfo.inst;
			}
		}
		rc |= 0x2;
	}
	if (((Mode & 2) != 0) && (wallCrawl == 2))
	{
		INSTANCE_Post(instance, 0x4000011, Data);
	}
	return rc;
}

void PhysicsDefaultEdgeGrabResponse(struct _Instance* instance, struct evPhysicsEdgeData* Data, int blockFlag)  // Matching - 100%
{
	struct _SVector normal;
	struct _G2EulerAngles_Type ea1;
	VECTOR OutTrans;
	MATRIX TempMat;
	SVECTOR New;
	long dp;

	if (blockFlag != 0)
	{
		normal.z = 0;
		normal.y = 0;
		normal.x = 0;
		if ((Data->Normal1->y < 513) == 0)
		{
			normal.y = 4096;
			ea1.z = 0;
		}
		else if ((Data->Normal1->y < -512))
		{
			normal.y = -4096;
			ea1.z = -2048;
		}
		if ((Data->Normal1->x < 513) == 0)
		{
			normal.x = 4096;
			ea1.z = -1024;
		}
		else if (Data->Normal1->x < -512)
		{
			normal.x = -4096;
			ea1.z = 1024;
		}
		ea1.y = 0;
		ea1.x = 0;
		MATH3D_RotateAxisToVector(&TempMat, instance->matrix, &normal, AXIS_Y);
		instance->rotation.x = 0;
	}
	else
	{
		normal.x = Data->Normal1->x;
		normal.y = Data->Normal1->y;
		normal.z = 0;
		MATH3D_RotateAxisToVector(&TempMat, instance->matrix + 1, &normal, AXIS_Y);
		G2EulerAngles_FromMatrix(&ea1, (struct _G2Matrix_Type*)&TempMat, 0);
		instance->rotation.x = 0;
	}
	instance->rotation.y = 0;
	instance->rotation.z = ea1.z;
	Data->zRot = ea1.z;
	New.vz = Data->ZDistance;
	New.vx = Data->XDistance;
	New.vy = Data->YDistance;
	RotMatrix((SVECTOR*)&instance->rotation, &TempMat);
	gte_SetRotMatrix(&TempMat);
	gte_ldv0(&New);
	gte_rtv0();
	gte_stlvnl(&OutTrans);
	dp = ((Data->Delta->x * normal.x) + (Data->Delta->y * normal.y) + (Data->Delta->z * normal.z)) >> 12;
	Data->Delta->x = ((int)dp * normal.x) >> 12;
	Data->Delta->y = ((int)dp * normal.y) >> 12;
	instance->position.z = instance->position.z - ((short)OutTrans.vz - (Data->UpperOffset + Data->AboveOffset + Data->Delta->z));
	instance->position.x = instance->position.x + (Data->Delta->x - (short)OutTrans.vx);
	instance->position.y = instance->position.y - ((short)OutTrans.vy - Data->Delta->y);
}

// autogenerated function stub: 
// int /*$ra*/ PhysicsCheckSliding(struct _Instance *instance /*$s3*/, int Data /*$a1*/, short Mode /*$s6*/)
int PhysicsCheckSliding(struct _Instance *instance, int Data, short Mode)
{ // line 983, offset 0x80075dc4
	/* begin block 1 */
		// Start line: 984
		// Start offset: 0x80075DC4
		// Variables:
			struct evPhysicsSlideData *Ptr; // $s0
			int rc; // $s1
			VECTOR OutTrans; // stack offset -120
			struct _SVector normal; // stack offset -104
			//struct _PCollideInfo CInfo; // stack offset -96
			SVECTOR Old; // stack offset -48
			SVECTOR New; // stack offset -40
			static MATRIX *pTempMat; // offset 0x24

		/* begin block 1.1 */
			// Start line: 1015
			// Start offset: 0x80075E4C
		/* end block 1.1 */
		// End offset: 0x80075E4C
		// End Line: 1017

		/* begin block 1.2 */
			// Start line: 1024
			// Start offset: 0x80075E88
			// Variables:
				int Temp; // $a3
		/* end block 1.2 */
		// End offset: 0x80075F5C
		// End Line: 1032
	/* end block 1 */
	// End offset: 0x80076244
	// End Line: 1166

	/* begin block 2 */
		// Start line: 2245
	/* end block 2 */
	// End Line: 2246
				UNIMPLEMENTED();
	return 0;
}

int PhysicsUpdateTface(struct _Instance* instance, int Data) { // Matching - 100%
	struct _PCollideInfo CInfo;
	SVECTOR Old;
	SVECTOR New;
	CInfo.oldPoint = &Old;
	CInfo.newPoint = &New;
	New.vx = instance->position.x;
	Old.vx = New.vx;
	New.vy = instance->position.y;
	Old.vy = New.vy;
	New.vz = instance->position.z;
	Old.vz = New.vz;
	Old.vz = New.vz + ((short*)Data)[0];
	New.vz = New.vz - ((short*)Data)[1];
	PHYSICS_CheckLineInWorld(instance, &CInfo);
	if (CInfo.type == 3)
	{
		if (instance->tface != CInfo.prim)
		{
			instance->oldTFace = instance->tface;
			instance->tface = (_TFace*)CInfo.prim;
			instance->tfaceLevel = CInfo.inst;
			instance->bspTree = CInfo.segment;
		}
		return 1;
	}
	if (instance->tface != NULL)
	{
		instance->oldTFace = instance->tface;
		instance->tface = NULL;
		instance->tfaceLevel = NULL;
		instance->bspTree = 0;
	}
	return 0;
}

int PhysicsCheckBlockers(struct _Instance* instance, struct GameTracker* gameTracker, int Data, short Mode)  // Matching - 99.48%
{
	struct evPhysicsEdgeData* Ptr;
	VECTOR OutTrans;
	struct _PCollideInfo CInfo;
	SVECTOR Old;
	SVECTOR New;
	static MATRIX* pTempMat;
	struct _TFace* tface;
	int Dot;
	SVECTOR Force;
	struct _HFace* hface;
	int temp;

	Ptr = (struct evPhysicsEdgeData*)Data;
	Ptr->rc = 0;
	Ptr->instance = NULL;
	CInfo.oldPoint = &Old;
	CInfo.newPoint = &New;
	PHYSICS_GenericLineCheckSetup(0, 0, 0, &Old);
	PHYSICS_GenericLineCheckSetup(0, Ptr->ForwardOffset, 0, &New);
	PHYSICS_GenericLineCheck(instance, &instance->matrix[1], instance->matrix, &CInfo);
	pTempMat = instance->matrix;
	if ((CInfo.type == 3) || (CInfo.type == 5) || (CInfo.type == 2))
	{
		tface = (struct _TFace*)CInfo.prim;
		Force.vy = 0;
		Force.vx = 0;
		Force.vy = -4096;
		ApplyMatrix(pTempMat, &Force, &OutTrans);
		Dot = CInfo.wNormal.vx * OutTrans.vx;
		Dot += CInfo.wNormal.vy * OutTrans.vy;
		Dot += CInfo.wNormal.vz * OutTrans.vz;
		temp = Dot;
		if (temp < 0)
		{
			temp = (Dot + 0xFFF);
		}
		Dot = temp >> 12;
		if (CInfo.type == 3 && (tface->textoff != 0xFFFF) && (((unsigned short*)((char*)((struct _Terrain*)(CInfo.inst->node.prev))->StartTextureList + tface->textoff))[5] & 0x1000) != 0)
		{
			if (Dot > -0xec8)
			{
				return Ptr->rc;
			}
		}
		else
		{
			if (Dot >= -0xFC0)
			{
				return Ptr->rc;
			}
		}
		if ((Mode & 1) != 0)
		{
			Ptr->Normal1->x = CInfo.wNormal.vx;
			Ptr->Normal1->y = CInfo.wNormal.vy;
			Ptr->Normal1->z = CInfo.wNormal.vz;
			Ptr->Delta->y = CInfo.newPoint->vy;
			Ptr->Delta->x = CInfo.newPoint->vx;
			Ptr->Delta->z = CInfo.newPoint->vz;
		}
		if (CInfo.type == 3)
		{
			if (tface->textoff != 0xFFFF)
			{
				if ((((unsigned short*)((char*)((struct _Terrain*)(CInfo.inst->node.prev))->StartTextureList + tface->textoff))[5] & 0x1000) != 0)
				{
					Ptr->rc |= 0x20000;
				}
			}
		}
		Ptr->rc |= 2;
		Old.vx = 0;
		Old.vy = -16;
		Old.vz = 0;
		ApplyMatrix(pTempMat, &Old, &OutTrans);
		New.vx = CInfo.newPoint->vx + (short)OutTrans.vx;
		New.vy = CInfo.newPoint->vy + (short)OutTrans.vy;
		New.vz = CInfo.newPoint->vz + (short)OutTrans.vz;
		Old.vx = New.vx;
		Old.vy = New.vy;
		Old.vz = New.vz + Ptr->AboveOffset;
		PHYSICS_CheckLineInWorld(instance, &CInfo);
		if ((CInfo.type == 3) || (CInfo.type == 5))
		{
			if ((Mode & 0x1) != 0)
			{
				Ptr->Normal2->x = CInfo.wNormal.vx;
				Ptr->Normal2->y = CInfo.wNormal.vy;
				Ptr->Normal2->z = CInfo.wNormal.vz;
			}
			if ((CInfo.wNormal.vz < 0xB51) == 0)
			{
				Ptr->rc |= 0x4;
			}
		}
		if ((Mode & 2) != 0)
		{
			INSTANCE_Post(instance, 0x4010400, Data);
		}
	}
	return Ptr->rc;
}

int PhysicsCheckSwim(struct _Instance* instance, int Data, short Mode)//Matching - 98.81%
{
	struct evPhysicsSwimData* Ptr;
	int rc;
	int Depth;
	int WaterDepth;
	struct _PCollideInfo CInfo;
	SVECTOR Old;
	SVECTOR New;
	long waterZLevel;

	Ptr = (struct evPhysicsSwimData*)Data;

	waterZLevel = STREAM_GetWaterZLevel(STREAM_GetLevelWithID(instance->currentStreamUnitID), instance);

	Depth = instance->matrix[1].t[2] - waterZLevel;

	if (waterZLevel == -32767)
	{
		Depth = 1;
		WaterDepth = -32767;
	}
	else
	{
		WaterDepth = -32767;

		if (waterZLevel == 0x7FFF)
		{
			Depth = -32767;
		}
		else if (Ptr->CheckDepth)
		{
			CInfo.oldPoint = &Old;
			CInfo.newPoint = &New;

			Old.vx = New.vx = (short)instance->matrix[1].t[0];
			Old.vy = New.vy = (short)instance->matrix[1].t[1];
			Old.vz = New.vz = (short)instance->matrix[1].t[2];

			New.vz -= Ptr->WadeDepth * 4;
			Old.vz += Ptr->TreadDepth;

			gameTrackerX.gameFlags |= 0x8000;
			
			instance->waterFace = 0;
			
			PHYSICS_CheckLineInWorld(instance, &CInfo);

			gameTrackerX.gameFlags &= ~0x8000;

			if (CInfo.type)
			{
				WaterDepth = Depth + CInfo.newPoint->vz - instance->matrix[1].t[2];
			}
			else
			{
				WaterDepth = Depth - 4 * Ptr->WadeDepth;
			}
		}
		else
		{
			Ptr->Depth = Depth;
			
			WaterDepth = instance->matrix->t[2] - waterZLevel;
	
			Ptr->WaterDepth = WaterDepth;
		}
	}
	
	if ((Mode & 0x3))
	{
		Ptr->Depth = Depth;
		
		Ptr->WaterDepth = WaterDepth;
	}
	
	Ptr->WaterLevel = waterZLevel;
	
	rc = PhysicsDefaultCheckSwimResponse(instance, (struct evPhysicsSwimData*)Data);
	
	Ptr->rc = rc;
	
	if ((Mode & 0x2))
	{
		INSTANCE_Post(instance, 0x4020000, Data);
	}

	FX_UpdateInstanceWaterSplit(instance);
	
	return rc;
}

int PhysicsDefaultCheckSwimResponse(struct _Instance* instance, struct evPhysicsSwimData* Data) // Matching - 99.76%
{
	int rc;
	long waterZLevel;

	STREAM_GetLevelWithID(instance->currentStreamUnitID);
	waterZLevel = Data->WaterLevel;

	rc = (-Data->WadeDepth < Data->WaterDepth) << 7;

	if (-Data->TreadDepth < Data->Depth && Data->Depth < 0)
	{
		rc |= 0x0040;
	}

	if (Data->Depth < -Data->SwimDepth)
	{
		rc |= 0x0010;
	}

	if (0 < Data->Depth)
	{
		rc |= 0x0020;
	}

	if (instance->position.z < waterZLevel && waterZLevel < instance->oldPos.z && Data->iVelocity->z < 0)
	{
		SIGNAL_InWater(instance);
		rc |= 0x0100;
	}

	if (instance->matrix != NULL && instance->oldMatrix != NULL &&
		waterZLevel < instance->matrix[1].t[2] && instance->oldMatrix[1].t[2] < waterZLevel)
	{
		SIGNAL_OutOfWater(instance);
		rc |= 0x0200;
	}

	if (waterZLevel < instance->position.z && instance->oldPos.z < waterZLevel && 0 < Data->iVelocity->z)
	{
		rc |= 0x0400;
	}

	if (instance->matrix != NULL && instance->oldMatrix != NULL)
	{
		if (instance->matrix[1].t[2] < (waterZLevel - Data->SwimDepth) && (waterZLevel = Data->SwimDepth) < instance->oldMatrix[1].t[2] && Data->iVelocity->z < 0)
		{
			rc |= 0x0800;
		}
	}

	return rc;
}


// autogenerated function stub: 
// void /*$ra*/ PhysicsForceSetWater(struct _Instance *instance /*$s1*/, int *Time /*$t0*/, int Depth /*$a2*/, int rate /*$a3*/, int maxAmplitude /*stack 16*/)
void PhysicsForceSetWater(struct _Instance *instance, int *Time, int Depth, int rate, int maxAmplitude)
{ // line 1856, offset 0x80076af4
	UNIMPLEMENTED();
}

int PhysicsCheckLOS(struct _Instance* instance, int Data, int Mode) //Matching - 99.58%
{
	struct _PCollideInfo CInfo;

	CInfo.oldPoint = (SVECTOR*)(Data + 8);
	CInfo.newPoint = (SVECTOR*)Data;
	PHYSICS_CheckLineInWorld(instance, &CInfo);

	return CInfo.type == 0;
}


// autogenerated function stub: 
// int /*$ra*/ PhysicsCheckDropHeight(struct _Instance *instance /*$s2*/, int Data /*$a1*/, int Mode /*$s3*/)
int PhysicsCheckDropHeight(struct _Instance *instance, int Data, int Mode)
{ // line 1915, offset 0x80076bfc
	/* begin block 1 */
		// Start line: 1916
		// Start offset: 0x80076BFC
		// Variables:
			struct evPhysicsDropHeightData *data; // $s0
			struct Level *level; // $v0
			SVECTOR newPos; // stack offset -104
			SVECTOR oldPos; // stack offset -96
			int rc; // $s1
			int lowZ; // $v1
			//struct _PCollideInfo CInfo; // stack offset -88
			static MATRIX TempMat; // offset 0x30
			static MATRIX *pTempMat; // offset 0x50

		/* begin block 1.1 */
			// Start line: 1929
			// Start offset: 0x80076C30
			// Variables:
				VECTOR outTrans; // stack offset -40
				SVECTOR *ExtraRot; // $v0
		/* end block 1.1 */
		// End offset: 0x80076C74
		// End Line: 1958

		/* begin block 1.2 */
			// Start line: 1982
			// Start offset: 0x80076D40
			// Variables:
				long waterZLevel; // $a0
		/* end block 1.2 */
		// End offset: 0x80076D7C
		// End Line: 2000
	/* end block 1 */
	// End offset: 0x80076E6C
	// End Line: 2048

	/* begin block 2 */
		// Start line: 4438
	/* end block 2 */
	// End Line: 4439
				UNIMPLEMENTED();
	return 0;
}

int PhysicsCheckDropOff(struct _Instance* instance, int Data, short Mode)//Matching - 98.79%
{
	struct evPhysicsDropOffData* Ptr;
	int rc;
	VECTOR OutTrans;
	SVECTOR* ExtraRot;
	struct _PCollideInfo CInfo;
	SVECTOR New;
	SVECTOR Old;
	static MATRIX TempMat;
	static MATRIX* pTempMat;

	CInfo.oldPoint = &Old;

	Ptr = (struct evPhysicsDropOffData*)Data;

	CInfo.newPoint = &New;

	ExtraRot = (SVECTOR*)INSTANCE_Query(instance, 0x8);
	rc = 0;

	if (instance->matrix != NULL)
	{
		if (ExtraRot != NULL)
		{
			pTempMat = &TempMat;

			RotMatrix(ExtraRot, pTempMat);

			MulMatrix2(instance->matrix, pTempMat);
		}
		else
		{
			pTempMat = instance->matrix;
		}

		New.vx = Ptr->xOffset;
		New.vy = Ptr->yOffset;
		New.vz = 0;

		ApplyMatrix(pTempMat, &New, &OutTrans);

		Old.vx = instance->position.x + (short)OutTrans.vx;
		Old.vy = instance->position.y + (short)OutTrans.vy;
		Old.vz = instance->position.z + (short)OutTrans.vz;

		New.vx = Old.vx;
		New.vy = Old.vy;
		New.vz = Old.vz - Ptr->DropOffset;
		Old.vz += Ptr->UpperOffset;

		PHYSICS_CheckLineInWorld(instance, &CInfo);

		if ((unsigned int)((unsigned short)CInfo.type - 2) < 2 || (CInfo.type == 5))
		{
			if (Mode & 0x2)
			{
				if (CInfo.wNormal.vz > Ptr->slipSlope)
				{
					INSTANCE_Post(instance, 0x4010080, 1);
				}
				else
				{

					INSTANCE_Post(instance, 0x4010080, 0);
					rc = 8;
				}
			}
			if (CInfo.wNormal.vz < Ptr->slipSlope && CInfo.wNormal.vz > 0 && CInfo.newPoint->vz > instance->position.z)
			{
				INSTANCE_Post(instance, 0x4010401, 0);
			}
		}
		else
		{
			if (!CInfo.type)
			{
				if ((Mode & 0x2))
				{
					INSTANCE_Post(instance, 0x4010080, 0);
				}
				rc = 8;
			}
		}
	}
	return rc;
}

int PhysicsFollowWall(struct _Instance* instance, struct GameTracker* gameTracker, int Data, short Mode) { // Matching - 99.89%
	VECTOR OutTrans;
	struct evPhysicsWallCrawlData* Ptr;
	struct _PCollideInfo CInfo;
	SVECTOR New;
	SVECTOR Old;
	static MATRIX* pTempMat;
	_Position A;
	_Position B;
	MATRIX mat;
	Ptr = (struct evPhysicsWallCrawlData*)Data;
	Ptr->rc = 0;
	CInfo.oldPoint = &Old;
	CInfo.newPoint = &New;
	pTempMat = instance->matrix + Ptr->Segment;
	PHYSICS_GenericLineCheckSetup(0, 64, 0, &Old);
	PHYSICS_GenericLineCheckSetup(0, Ptr->Length, 0, &New);
	PHYSICS_GenericLineCheck(instance, pTempMat, pTempMat, &CInfo);
	if ((CInfo.type == 3) || (CInfo.type == 5))
	{
		instance->shadowPosition.x = New.vx;
		instance->shadowPosition.y = New.vy;
		instance->shadowPosition.z = New.vz;
		if ((instance->flags2 & 0x40) != 0)
		{
			instance->flags |= 0x8000000;
		}
		Ptr->rc |= 8;
		if ((Mode & 7) != 0)
		{
			Ptr->DropNormal.x = CInfo.wNormal.vx;
			Ptr->DropNormal.y = CInfo.wNormal.vy;
			Ptr->DropNormal.z = CInfo.wNormal.vz;
		}
		if ((Mode & 4) != 0)
		{
			B.z = 0;
			B.y = 0;
			B.x = 0;
			A.x = Ptr->DropNormal.x;
			A.y = Ptr->DropNormal.y;
			A.z = Ptr->DropNormal.z;
			MATH3D_RotationFromPosToPos(&A, &B, &Ptr->DropRotation);
			RotMatrix((SVECTOR*) & Ptr->DropRotation, &mat);
			Ptr->NewPosition.x = New.vx;
			Ptr->NewPosition.y = New.vy;
			Ptr->NewPosition.z = New.vz;
			New.vx = 0;
			New.vy = -Ptr->NormalDistance;
			New.vz = 0;
			ApplyMatrix(&mat, &New, &OutTrans);
			Ptr->NewPosition.x += (short)OutTrans.vx;
			Ptr->NewPosition.y += (short)OutTrans.vy;
			Ptr->NewPosition.z += (short)OutTrans.vz;
			Ptr->NewPosition.x = instance->position.x - Ptr->NewPosition.x;
			Ptr->NewPosition.y = instance->position.y - Ptr->NewPosition.y;
			Ptr->NewPosition.z = instance->position.z - Ptr->NewPosition.z;
		}
		instance->wNormal.x = CInfo.wNormal.vx;
		instance->wNormal.y = CInfo.wNormal.vy;
		instance->wNormal.z = CInfo.wNormal.vz;
		instance->oldTFace = instance->tface;
		instance->tface = (_TFace*)CInfo.prim;
		instance->tfaceLevel = CInfo.inst;
		instance->bspTree = CInfo.segment;
	}
	PHYSICS_GenericLineCheckSetup(0, 64, Ptr->ForwardOffset, &Old);
	PHYSICS_GenericLineCheckSetup(0, (short)(Ptr->NormalDistance / 2) + (Ptr->Length), Ptr->ForwardOffset, &New);
	PHYSICS_GenericLineCheck(instance, pTempMat, pTempMat, &CInfo);
	if ((CInfo.type == 3) || (CInfo.type == 5))
	{
		Ptr->rc |= 2;
		if ((Mode & 7) != 0)
		{
			Ptr->ForwardNormal.x = CInfo.wNormal.vx;
			Ptr->ForwardNormal.y = CInfo.wNormal.vy;
			Ptr->ForwardNormal.z = CInfo.wNormal.vz;
		}
		if ((Mode & 4) != 0)
		{
			Ptr->ForwardXRotation = MATH3D_AngleBetweenVectors(&Ptr->DropNormal, &Ptr->ForwardNormal);
		}
		Old.vx = 0;
		Old.vy = -32;
		Old.vz = 0;
		ApplyMatrix(pTempMat, &Old, &OutTrans);
		Old.vx = 0;
		Old.vy = 0;
		Old.vz = 64;
		New.vx += (short)OutTrans.vx;
		New.vy += (short)OutTrans.vy;
		New.vz += (short)OutTrans.vz;
		ApplyMatrix(pTempMat, &Old, &OutTrans);
		Old.vx = New.vx + (short)OutTrans.vx;
		Old.vy = New.vy + (short)OutTrans.vy;
		Old.vz = New.vz + (short)OutTrans.vz;
		PHYSICS_CheckLineInWorld(instance, &CInfo);
		if ((CInfo.type == 3) || (CInfo.type == 5))
		{
			Old.vx = 0;
			Old.vy = 0;
			Old.vz = 64;
			ApplyMatrix(pTempMat, &Old, &OutTrans);
			New.vx += (short)OutTrans.vx;
			New.vy += (short)OutTrans.vy;
			New.vz += (short)OutTrans.vz;
			Old.vx = (short)pTempMat->t[0] + (short)OutTrans.vx;
			Old.vy = (short)pTempMat->t[1] + (short)OutTrans.vy;
			Old.vz = (short)pTempMat->t[2] + (short)OutTrans.vz;
			PHYSICS_CheckLineInWorld(instance, &CInfo);
			if (CInfo.type == 0)
			{
				Ptr->rc |= 4;
			}
		}
	}
	if ((Mode & 2) != 0)
	{
		INSTANCE_Post(instance, 0x4010000 | 0x11, Data);
	}
	return Ptr->rc;
}

void PhysicsMoveLocalZClamp(struct _Instance* instance, long segment, long time, long clamp) //Matching - 99.91%
{
	struct _Position pos;
	SVECTOR v;
	SVECTOR dv;

	memset(&pos, 0, sizeof(struct _Position));

	PhysicsMove(instance, &pos, time);

	v.vx = pos.x;
	v.vy = -pos.y;
	v.vz = pos.z;

	ApplyMatrixSV(&instance->matrix[segment], &v, &dv);

	instance->position.x += dv.vx;
	instance->position.y += dv.vy;

	if (clamp == 0)
	{
		instance->position.z += dv.vz;
	}
}

void PhysicsMove(struct _Instance* instance, struct _Position* position, long time)//Matching - 97.33%
{
	long xVel;
	long yVel;
	long zVel;
	long xat;
	long yat;
	long zat;
	long x;
	long y;
	long z;
	long _x;
	long _y;
	long _z;

	xVel = instance->xVel;
	yVel = instance->yVel;
	zVel = instance->zVel;

	_x = (instance->xAccl * time) < 0 ? ((instance->xAccl * time) + 0xFFF) : (instance->xAccl * time);
	xat = _x >> 12;
	_y = (instance->yAccl * time) < 0 ? ((instance->yAccl * time) + 0xFFF) : (instance->yAccl * time);
	yat = _y >> 12;
	_z = (instance->zAccl * time) < 0 ? ((instance->zAccl * time) + 0xFFF) : (instance->zAccl * time);
	zat = _z >> 12;

	xVel = (xVel * time) < 0 ? ((xVel * time) + 0xFFF) : (xVel * time);
	xVel >>= 12;
	_x = (xat * time) < 0 ? (((xat * time) + 0x1FFF)) : (xat * time);
	x = _x >> 13;
	position->x += (short)(xVel + x);

	yVel = (yVel * time) < 0 ? ((yVel * time) + 0xFFF) : (yVel * time);
	yVel >>= 12;
	_y = (yat * time) < 0 ? (((yat * time) + 0x1FFF)) : (yat * time);
	y = _y >> 13;
	position->y += (short)(yVel + y);

	zVel = (zVel * time) < 0 ? ((zVel * time) + 0xFFF) : (zVel * time);
	zVel >>= 12;
	_z = (zat * time) < 0 ? (((zat * time) + 0x1FFF)) : (zat * time);
	z = _z >> 13;
	position->z += (short)(z + zVel);

	xVel += xat;
	yVel += yat;
	zVel += zat;

	if (instance->maxXVel < xVel)
	{
		xVel = instance->maxXVel;
	}
	else if (xVel < -instance->maxXVel)
	{
		xVel = -instance->maxXVel;
	}

	if (instance->maxYVel < yVel)
	{
		yVel = instance->maxYVel;
	}
	else if (yVel < -instance->maxYVel)
	{
		yVel = -instance->maxYVel;
	}

	if (instance->maxZVel < zVel)
	{
		zVel = instance->maxZVel;
	}
	else if (zVel < -instance->maxZVel)
	{
		zVel = -instance->maxZVel;
	}

	instance->xVel = xVel;
	instance->yVel = yVel;
	instance->zVel = zVel;
}

void PhysicsSetVelFromZRot(struct _Instance* instance, short angle, long magnitude)  // Matching - 100%
{
	instance->xVel = rcos(angle - 1024) * magnitude >> 12;
	instance->yVel = rsin(angle - 1024) * magnitude >> 12;
}


// autogenerated function stub: 
// void /*$ra*/ PhysicsSetVelFromRot(struct _Instance *instance /*$s0*/, struct _Rotation *rot /*$a1*/, long magnitude /*$a2*/)
void PhysicsSetVelFromRot(struct _Instance *instance, struct _Rotation *rot, long magnitude)
{ // line 2745, offset 0x800778a0
	UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ PHYSICS_SetVAndAFromRot(struct _Instance *instance /*$s0*/, struct _Rotation *rot /*$a1*/, long v /*$s1*/, long a /*$s2*/)
void PHYSICS_SetVAndAFromRot(struct _Instance *instance, struct _Rotation *rot, long v, long a)
{ // line 2765, offset 0x80077910
	UNIMPLEMENTED();
}

long PHYSICS_FindAFromDAndT(long d, long t)
{
	if (t != 0)
	{
		return MAX((d * 8192) / (t * t), (d * 8192) / (t * t) + 4095) >> 12;
	}
	else
	{
		return 0;
	}
}

long PHYSICS_FindVFromAAndD(long a, long d)
{
	long vsq; // $a0

	vsq = a * (d * 2);

	if (vsq == 0)
	{
		return 0;
	}
	else
	{
		return MATH3D_FastSqrt0(vsq);
	}
}

void PHYSICS_StopIfCloseToTarget(struct _Instance* instance, int x, int y, int z) { // Matching - 100%
	if (((instance->xAccl < 0) && ((instance->xVel <= x) != 0)) || ((instance->xAccl > 0) && ((instance->xVel < x) == 0)))
	{
		instance->xAccl = 0;
		instance->xVel = x;
	}
	if (((instance->yAccl < 0) && ((instance->yVel <= y) != 0)) || ((instance->yAccl > 0) && ((instance->yVel < y) == 0)))
	{
		instance->yAccl = 0;
		instance->yVel = y;
	}
	if (((instance->zAccl < 0) && ((instance->zVel <= z) != 0)) || ((instance->zAccl > 0) && ((instance->zVel < z) == 0)))
	{
		instance->zAccl = 0;
		instance->zVel = z;
	}
}

int PHYSICS_CheckForTerrainCollide(struct _Instance* instance, SVECTOR* startVec, SVECTOR* endVec, int segment)  // Matching - 100%
{
	struct _PCollideInfo CInfo;
	MATRIX* pTempMat;

	CInfo.oldPoint = startVec;
	CInfo.newPoint = endVec;
	pTempMat = instance->matrix + segment;
	CInfo.collideType = 1;
	PHYSICS_GenericLineCheckMask(instance, pTempMat, pTempMat, &CInfo);
	return CInfo.type == 3;
}


int PHYSICS_CheckForObjectCollide(struct _Instance* instance, SVECTOR* startVec, SVECTOR* endVec, int segment)
{
	struct _PCollideInfo CInfo;
	MATRIX* pTempMat;

	pTempMat = instance->matrix;
	
	CInfo.collideType = 62;

	PHYSICS_GenericLineCheckMask(instance, &pTempMat[segment], &pTempMat[segment], &CInfo);

	return (unsigned)0 < CInfo.type;
}

int PHYSICS_CheckForValidMove(struct _Instance* instance, SVECTOR* startVec, SVECTOR* endVec, int segment) { // Matching - 100%
	struct _PCollideInfo CInfo;
	MATRIX* pTempMat;
	int rc;
	CInfo.oldPoint = startVec;
	CInfo.newPoint = endVec;
	pTempMat = instance->matrix + segment;
	PHYSICS_GenericLineCheck(instance, pTempMat, pTempMat, &CInfo);
	rc = PHYSICS_CheckFaceStick(&CInfo) != 0;
	if (((unsigned short)(CInfo.type - 2) < 2) || (CInfo.type == 5))
	{
		rc += 2;
	}
	return rc;
}

int PHYSICS_CheckFaceStick(struct _PCollideInfo* CInfo)  // Matching - 100%
{
	char unused[8];  // stack padding
	int rc;
	struct _TFace* tface;
	struct _HFace* hface;

	rc = 0;
	if (CInfo->type == 3)
	{
		tface = (struct _TFace*)CInfo->prim;
		if (tface->textoff != 0xFFFF)
		{
			hface = (struct _HFace*)(((unsigned short*)((char*)((struct _Terrain*)(CInfo->inst->node.prev))->StartTextureList + tface->textoff))[5] & 0x200);
			rc = (unsigned int)rc < (unsigned int)hface;
		}
	}
	return rc;
}


// autogenerated function stub: 
// int /*$ra*/ PHYSICS_CheckDontGrabEdge(struct _PCollideInfo *CInfo /*$s0*/)
int PHYSICS_CheckDontGrabEdge(struct _PCollideInfo *CInfo)
{ // line 2992, offset 0x80077cb0
	UNIMPLEMENTED();
	return 0;
}

void PHYSICS_GenericLineCheckSetup(short x, short y, short z, SVECTOR* inVec)
{
	inVec->vx = x;
	inVec->vy = y;
	inVec->vz = z;
}

void PHYSICS_GenericLineCheck(struct _Instance* instance, MATRIX* transMat, MATRIX* rotMat, struct _PCollideInfo* cInfo)
{
	cInfo->collideType = 63;
	PHYSICS_GenericLineCheckMask(instance, transMat, rotMat, cInfo);
}

void PHYSICS_GenericLineCheckMask(struct _Instance* instance, MATRIX* transMat, MATRIX* rotMat, struct _PCollideInfo* cInfo)  // Matching - 100%
{
	SVECTOR* startVec;
	SVECTOR* endVec;
	VECTOR outVec;

	startVec = cInfo->oldPoint;
	endVec = cInfo->newPoint;
	gte_SetRotMatrix(&rotMat->m[0][0]);
	gte_ldv0(&startVec->vx);
	gte_rtv0();
	gte_stlvnl(&outVec);
	startVec->vx = (short)(transMat->t[0] + outVec.vx);
	startVec->vy = (short)(transMat->t[1] + outVec.vy);
	startVec->vz = (short)(transMat->t[2] + outVec.vz);
	gte_SetRotMatrix(&rotMat->m[0][0]);
	gte_ldv0(&endVec->vx);
	gte_rtv0();
	gte_stlvnl(&outVec);
	endVec->vx = (short)(transMat->t[0] + outVec.vx);
	endVec->vy = (short)(transMat->t[1] + outVec.vy);
	endVec->vz = (short)(transMat->t[2] + outVec.vz);
	PHYSICS_CheckLineInWorldMask(instance, cInfo);
}
