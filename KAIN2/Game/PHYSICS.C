#include "CORE.H"

#include "Game/COLLIDE.H"
#include "Game/PHYSICS.H"
#include "Game/STREAM.H"
#include "Game/BSP.H"
#include "Game/MATH3D.H"
#include "Game/PHYSOBS.H"
#include "Game/STATE.H"
#include "Game/FX.H"

void SetNoPtCollideInFamily(struct _Instance* instance)
{
#if defined(PSX_VERSION)
	struct _Instance* child;

	child = instance->LinkChild;

	instance->flags &= 0xFFFFFFBF;

	while (child != NULL)
	{
		ResetNoPtCollideInFamily(child);

		child = child->LinkSibling;
	}

#elif defined(PC_VERSION)
	struct _Instance* LinkChild; // esi

	LinkChild = instance->LinkChild;
	for (instance->flags |= 0x40u; LinkChild; LinkChild = LinkChild->LinkSibling)
		SetNoPtCollideInFamily(LinkChild);
#endif
}


void ResetNoPtCollideInFamily(struct _Instance* instance)
{
#if defined(PSX_VERSION)
	struct _Instance* child;

	child = instance->LinkChild;

	instance->flags &= 0xFFFFFFBF;

	while (child != NULL)
	{
		ResetNoPtCollideInFamily(child);

		child = child->LinkSibling;
	}

#elif defined(PC_VERSION)
	struct _Instance* LinkChild; // esi

	LinkChild = instance->LinkChild;
	for (instance->flags &= ~0x40u; LinkChild; LinkChild = LinkChild->LinkSibling)
		ResetNoPtCollideInFamily(LinkChild);
#endif
}

void PHYSICS_CheckLineInWorld(struct _Instance* instance, struct _PCollideInfo* pcollideInfo)
{
#if defined(PSX_VERSION)

	pcollideInfo->collideType = 63;

	PHYSICS_CheckLineInWorldMask(instance, pcollideInfo);

#elif defined(PC_VERSION)
	struct Level* LevelWithID; // eax
	struct _Instance* LinkChild; // esi
	struct Level* v4; // ebp
	struct _Instance* v5; // esi

	pcollideInfo->collideType = 63;
	LevelWithID = STREAM_GetLevelWithID(instance->currentStreamUnitID);
	pcollideInfo->inst = 0;
	pcollideInfo->instance = instance;
	LinkChild = instance->LinkChild;
	v4 = LevelWithID;
	for (instance->flags |= 0x40u; LinkChild; LinkChild = LinkChild->LinkSibling)
		SetNoPtCollideInFamily(LinkChild);
	if (v4)
		COLLIDE_PointAndWorld(pcollideInfo, v4);
	else
		pcollideInfo->type = 0;
	v5 = instance->LinkChild;
	for (instance->flags &= ~0x40u; v5; v5 = v5->LinkSibling)
		ResetNoPtCollideInFamily(v5);
#endif
}

void PHYSICS_CheckLineInWorldMask(struct _Instance* instance, struct _PCollideInfo* pcollideInfo)//Matching - 99.31%
{
#if defined(PSX_VERSION)

	struct Level* level;

	level = STREAM_GetLevelWithID(instance->currentStreamUnitID);

	pcollideInfo->inst = NULL;
	pcollideInfo->instance = instance;

	SetNoPtCollideInFamily(instance);

	if (level != NULL)
	{
		COLLIDE_PointAndWorld(pcollideInfo, level);
	}
	else
	{
		pcollideInfo->type = 0;
	}

	ResetNoPtCollideInFamily(instance);

#elif defined(PC_VERSION)
	struct Level* LevelWithID; // ebp
	struct _Instance* LinkChild; // esi
	struct _Instance* v4; // esi

	LevelWithID = STREAM_GetLevelWithID(instance->currentStreamUnitID);
	pcollideInfo->inst = 0;
	pcollideInfo->instance = instance;
	LinkChild = instance->LinkChild;
	for (instance->flags |= 0x40u; LinkChild; LinkChild = LinkChild->LinkSibling)
		SetNoPtCollideInFamily(LinkChild);
	if (LevelWithID)
		COLLIDE_PointAndWorld(pcollideInfo, LevelWithID);
	else
		pcollideInfo->type = 0;
	v4 = instance->LinkChild;
	for (instance->flags &= ~0x40u; v4; v4 = v4->LinkSibling)
		ResetNoPtCollideInFamily(v4);
#endif
}


// autogenerated function stub: 
// int /*$ra*/ PhysicsCheckLinkedMove(struct _Instance *instance /*$s2*/, int Data /*stack 4*/, short Mode /*stack -72*/)
int PhysicsCheckLinkedMove(struct _Instance *instance, int Data, short Mode)
{ // line 124, offset 0x80074754
#if defined(PC_VERSION)
	struct _Instance* v5; // eax
	MATRIX* v6; // ebx
	int x; // ebp
	struct evPhysicsLinkedMoveData* z; // edx
	int attachedID; // ecx
	__int32 v10; // ecx
	__int32 v11; // eax
	SVECTOR* p_posDelta; // ebx
	__int16 v13; // ax
	__int16 vz; // cx
	__int16 v15; // dx
	__int16 v16; // ax
	__int16 v17; // cx
	struct _Instance* v18; // eax
	int flags2; // ecx
	int v20; // ecx
	int introUniqueID; // edx
	__int16 vy; // cx
	__int16 v23; // dx
	char v24; // al
	int v25; // eax
	int v27; // [esp+4h] [ebp-68h]
	int v28; // [esp+8h] [ebp-64h]
	__int32 v29; // [esp+Ch] [ebp-60h]
	__int32 v30; // [esp+10h] [ebp-5Ch]
	__int32 v31; // [esp+14h] [ebp-58h]
	struct _Instance* v32; // [esp+18h] [ebp-54h]
	struct evPhysicsLinkedMoveData* v33; // [esp+18h] [ebp-54h]
	int v34; // [esp+1Ch] [ebp-50h]
	int y; // [esp+20h] [ebp-4Ch]
	struct _G2EulerAngles_Type euler; // [esp+24h] [ebp-48h] BYREF
	VECTOR v0; // [esp+2Ch] [ebp-40h] BYREF
	VECTOR v1; // [esp+3Ch] [ebp-30h] BYREF
	struct _G2Matrix_Type matrix; // [esp+4Ch] [ebp-20h] BYREF
	struct _Instance* instancea; // [esp+70h] [ebp+4h]
	struct evPhysicsLinkedMoveData* Dataa; // [esp+74h] [ebp+8h]

	struct evPhysicsLinkedMoveData* ptr = (struct evPhysicsLinkedMoveData*)Data;

	if (instance->matrix)
	{
		v5 = ptr->instance;
		v32 = v5;
		v6 = &ptr->instance->matrix[ptr->segment];
		x = instance->position.x;
		v29 = v6->t[0];
		v30 = v6->t[1];
		v31 = v6->t[2];
		z = (struct evPhysicsLinkedMoveData*)instance->position.z;
		instancea = (struct _Instance*)instance->position.y;
		attachedID = instance->attachedID;
		Dataa = z;
		if (v5->introUniqueID == attachedID && ptr->segment == instance->attachedSegment)
		{
			v33 = (struct evPhysicsLinkedMoveData*)instance->oldPos.z;
			v34 = instance->oldPos.x;
			y = instance->oldPos.y;
			v28 = 0;
			v27 = 0;
			if (instance->rotation.x != instance->oldRotation.x
				|| instance->rotation.y != instance->oldRotation.y
				|| instance->rotation.z != instance->oldRotation.z)
			{
				v27 = 1;
			}
			if (x != instance->oldPos.x || instancea != (struct _Instance*)instance->oldPos.y || z != v33)
				v28 = 1;
			if (v28 || v27)
			{
				TransposeMatrix(v6, (MATRIX*)&matrix);
				if (v27)
					MulMatrix0((MATRIX*)&matrix, instance->matrix, &instance->relativeMatrix);
				if (v28)
				{
					v0.vx = x - v34;
					v0.vy = (__int32)instancea - y;
					v0.vz = (char*)Dataa - (char*)v33;
					ApplyMatrixLV((MATRIX*)&matrix, &v0, &v0);
					v10 = instance->relativeMatrix.t[1];
					instance->relativeMatrix.t[0] += v0.vx;
					v11 = instance->relativeMatrix.t[2];
					instance->relativeMatrix.t[1] = v0.vy + v10;
					instance->relativeMatrix.t[2] = v0.vz + v11;
				}
			}
			ApplyMatrixLV(v6, (VECTOR*)instance->relativeMatrix.t, &v1);
			MulMatrix0(v6, &instance->relativeMatrix, (MATRIX*)&matrix);
			G2EulerAngles_FromMatrix(&euler, &matrix, 21);
			p_posDelta = (struct SVECTOR*)&ptr->posDelta;
			v13 = LOWORD(v1.vy) - (WORD)instancea;
			vz = v1.vz;
			ptr->posDelta.x = v29 + LOWORD(v1.vx) - x;
			v15 = euler.x;
			ptr->posDelta.y = v30 + v13;
			v16 = euler.y;
			ptr->posDelta.z = v31 + vz - (WORD)Dataa;
			v17 = euler.z;
			ptr->rotDelta.x = v15 - instance->oldRotation.x;
			ptr->rotDelta.y = v16 - instance->oldRotation.y;
			ptr->rotDelta.z = v17 - instance->oldRotation.z;
		}
		else
		{
			if (attachedID != v5->introUniqueID)
			{
				v18 = INSTANCE_Find(attachedID);
				if (v18)
				{
					flags2 = v18->flags2;
					flags2 = flags2 & 0x7F;
					v18->flags2 = flags2;
				}
				v5 = v32;
			}
			v20 = v5->flags2;
			introUniqueID = v5->introUniqueID;
			v20 = v20 | 0x80;
			v5->flags2 = v20;
			instance->attachedID = introUniqueID;
			instance->attachedSegment = ptr->segment;
			instance->zAccl = 0;
			instance->zVel = 0;
			TransposeMatrix(v6, (MATRIX*)&matrix);
			v0.vx = x - v29;
			v0.vy = (__int32)instancea - v30;
			v0.vz = (__int32)Dataa - v31;
			ApplyMatrixLV((MATRIX*)&matrix, &v0, (VECTOR*)instance->relativeMatrix.t);
			MulMatrix0((MATRIX*)&matrix, instance->matrix, &instance->relativeMatrix);
			ApplyMatrixLV(v6, (VECTOR*)instance->relativeMatrix.t, &v0);
			vy = v0.vy;
			ptr->rotDelta.z = 0;
			ptr->rotDelta.y = 0;
			ptr->rotDelta.x = 0;
			p_posDelta = (struct SVECTOR*)&ptr->posDelta;
			v23 = v0.vz;
			ptr->posDelta.x = x - LOWORD(v0.vx) - v29;
			ptr->posDelta.y = (WORD)instancea - vy - v30;
			ptr->posDelta.z = (WORD)Dataa - v23 - v31;
		}
		v24 = Mode;
		if ((Mode & 4) != 0)
		{
			instance->position.x += p_posDelta->vx;
			instance->position.y += ptr->posDelta.y;
			instance->position.z += ptr->posDelta.z;
			if ((~(BYTE)Mode & 8) != 0)
			{
				COLLIDE_UpdateAllTransforms(instance, p_posDelta);
				v24 = Mode;
			}
			instance->rotation.z += ptr->rotDelta.z;
		}
		if ((v24 & 2) != 0)
			INSTANCE_Post(instance, 0x4010008, (int)ptr);
		if (p_posDelta->vx || ptr->posDelta.y || ptr->posDelta.z || ptr->rotDelta.x || ptr->rotDelta.y || ptr->rotDelta.z)
		{
			v25 = instance->flags2;
			v25 = v25 | 8;
			instance->flags2 = v25;
		}
		return 0x10000;
	}
	else
	{
		instance->attachedID = 0;
		return 0;
	}
#else
UNIMPLEMENTED();
	return 0;
#endif
}


// autogenerated function stub: 
// void /*$ra*/ PhysicsDefaultLinkedMoveResponse(struct _Instance *instance /*$s0*/, struct evPhysicsLinkedMoveData *Data /*$s1*/, int updateTransforms /*$a2*/)
void PhysicsDefaultLinkedMoveResponse(struct _Instance *instance, struct evPhysicsLinkedMoveData *Data, int updateTransforms)
{ // line 272, offset 0x80074bb0
#if defined(PC_VERSION)
	instance->position.x += Data->posDelta.x;
	instance->position.y += Data->posDelta.y;
	instance->position.z += Data->posDelta.z;
	if (updateTransforms)
		COLLIDE_UpdateAllTransforms(instance, (SVECTOR*)&Data->posDelta);
	instance->rotation.z += Data->rotDelta.z;
#else
	UNIMPLEMENTED();
#endif
}

int PhysicsCheckGravity(struct _Instance* instance, int Data, short Mode)//Matching - 93.35%
{
	struct evPhysicsGravityData* Ptr;
	SVECTOR D;
	SVECTOR N;
	short Dot;
	int rc;
	struct _PCollideInfo CInfo;
	SVECTOR Old;
	SVECTOR New;
	int slide;
	int stillOnOldTFace;
	struct Level* level;
	struct _TFace* tface;
	struct _Instance* oldOn;
	int dx;
	int dy;
	int dz;

	rc = 0;

	D.vx = 0;
	D.vy = 0;
	D.vz = 240;

	slide = 0;

	CInfo.newPoint = &New;
	CInfo.oldPoint = &Old;

	Old.vx = New.vx = instance->position.x;
	Old.vy = New.vy = instance->position.y;
	Old.vz = New.vz = instance->position.z;

	Ptr = (struct evPhysicsGravityData*)Data;

	Old.vz += Ptr->UpperOffset;
	New.vz -= Ptr->LowerOffset;

	if (Old.vz < New.vz)
	{
		CInfo.type = 0;
	}
	else
	{
		if (instance->cachedTFace != -1 && instance->cachedTFaceLevel != NULL)
		{
			tface = NULL;

			level = STREAM_GetLevelWithID(((struct Level*)instance->cachedTFaceLevel)->streamUnitID);

			gameTrackerX.gameFlags |= 0x8000;

			if (level != NULL)
			{
				tface = &level->terrain->faceList[instance->cachedTFace];

				stillOnOldTFace = COLLIDE_PointAndTfaceFunc(level->terrain, &level->terrain->BSPTreeArray[instance->cachedBSPTree], (struct _SVector*)&New, (struct _SVector*)&Old, &level->terrain->faceList[instance->cachedTFace], 0, 0);
			}
			else
			{
				stillOnOldTFace = 0;

			}

			if (stillOnOldTFace == 0)
			{
				instance->waterFace = NULL;

				PHYSICS_CheckLineInWorld(instance, &CInfo);
			}
			else
			{
				CInfo.type = 3;
				CInfo.prim = tface;
				CInfo.inst = (struct _Instance*)level;
				CInfo.segment = instance->cachedBSPTree;

				COLLIDE_GetNormal((short)tface->normal, (short*)level->terrain->normalList, (struct _SVector*)&CInfo.wNormal);
			}
		}
		else
		{
			instance->waterFace = NULL;

			gameTrackerX.gameFlags |= 0x8000;

			PHYSICS_CheckLineInWorld(instance, &CInfo);
		}

		gameTrackerX.gameFlags &= ~0x8000;
	}

	if ((unsigned)(short)(CInfo.type - 2) < 2 || CInfo.type == 5)
	{
		if (CInfo.wNormal.vz < Ptr->slipSlope && CInfo.wNormal.vz > 0)
		{
			N.vx = (-(CInfo.wNormal.vx * -(unsigned short)CInfo.wNormal.vz) < 0) ? ((-(CInfo.wNormal.vx * -(unsigned short)CInfo.wNormal.vz) + 0xFFF)) : ((-(CInfo.wNormal.vx * -(unsigned short)CInfo.wNormal.vz)));
			N.vx >>= 12;
			N.vy = (-(CInfo.wNormal.vy * -(unsigned short)CInfo.wNormal.vz) < 0) ? ((-(CInfo.wNormal.vy * -(unsigned short)CInfo.wNormal.vz) + 0xFFF)) : ((-(CInfo.wNormal.vy * -(unsigned short)CInfo.wNormal.vz)));
			N.vy >>= 12;
			N.vz = (-(CInfo.wNormal.vz * -(unsigned short)CInfo.wNormal.vz) < 0) ? ((-(CInfo.wNormal.vz * -(unsigned short)CInfo.wNormal.vz) + 0xFFF)) : ((-(CInfo.wNormal.vz * -(unsigned short)CInfo.wNormal.vz)));
			N.vz >>= 12;

			Dot = ((instance->zVel < -48) ? -instance->zVel : 48);

			Old.vx = New.vx = CInfo.newPoint->vx + N.vx * Dot / 4096;
			Old.vy = New.vy = CInfo.newPoint->vy + N.vy * Dot / 4096;
			Old.vz = New.vz = CInfo.newPoint->vz + N.vz * Dot / 4096;

			Old.vz += Ptr->UpperOffset;
			New.vz -= Ptr->LowerOffset;

			PHYSICS_CheckLineInWorld(instance, &CInfo);

			if ((unsigned)((unsigned short)CInfo.type - 2) < 2 || CInfo.type == 5)
			{
				if (CInfo.wNormal.vz < Ptr->slipSlope && CInfo.wNormal.vz > 0)
				{
					slide = 1;
				}
				else
				{
					instance->position.x = CInfo.newPoint->vx;
					instance->position.y = CInfo.newPoint->vy;
				}
			}
		}
	}

	if (CInfo.type == 3)
	{
		instance->cachedBSPTree = CInfo.segment;

		instance->cachedTFace = -(((unsigned long)CInfo.prim - ((unsigned long*)CInfo.inst->node.prev)[8]) * 0x55555555) >> 2;

		instance->cachedTFaceLevel = CInfo.instance;
	}
	else
	{
		instance->cachedTFace = -1;

		instance->cachedTFaceLevel = NULL;
	}

	if ((unsigned)((unsigned short)CInfo.type - 2) < 2 || CInfo.type == 5)
	{
		if ((Mode & 0x7))
		{
			if (slide != 0)
			{
				Ptr->x = CInfo.newPoint->vx - instance->position.x;
				Ptr->y = CInfo.newPoint->vy - instance->position.y;
			}
			else
			{
				Ptr->x = 0;
				Ptr->y = 0;
			}

			Ptr->z = CInfo.newPoint->vz - instance->position.z;

		}

		if ((Mode & 0x2) && slide == 0)
		{
			INSTANCE_Post(instance, 0x4010008, Data);
		}

		if (slide == 1)
		{
			if ((Mode & 0x2))
			{
				INSTANCE_Post(instance, 0x4010200, Data);
			}

			rc |= 0x100000;
		}

		if ((Mode & 0x4))
		{
			if (CheckPhysOb(instance) == 0 || CheckPhysObFamily(instance, 1) == 0 || instance->attachedID == 0)
			{
				PhysicsDefaultGravityResponse(instance, Ptr);
			}
		}

		if (CInfo.type != 1)
		{
			instance->wNormal.x = CInfo.wNormal.vx;
			instance->wNormal.y = CInfo.wNormal.vy;
			instance->wNormal.z = CInfo.wNormal.vz;
		}
		else
		{
			instance->wNormal.x = 0;
			instance->wNormal.y = 0;
			instance->wNormal.z = 4096;
		}

		if (CInfo.type != 3 && CInfo.inst != NULL && (CInfo.inst->object->oflags & 0x400))
		{
			rc |= PhysicsCheckLinkedMove(instance, SetPhysicsLinkedMoveData(CInfo.inst, CInfo.segment, NULL, NULL), Mode);
		}
		else
		{
			if (instance->attachedID != 0)
			{
				oldOn = INSTANCE_Find(instance->attachedID);

				if (oldOn != NULL)
				{
					oldOn->flags2 &= 0xFFFFFF7F;
				}
			}

			instance->attachedID = 0;
		}

		if ((instance->flags2 & 0x40))
		{
			instance->shadowPosition = instance->position;

			instance->flags |= 0x8000000;
		}

		if (CInfo.type == 3)
		{
			if (instance->tface != CInfo.prim)
			{
				instance->oldTFace = (struct _TFace*)CInfo.prim;

				instance->tface = (struct _TFace*)CInfo.prim;

				instance->tfaceLevel = CInfo.inst;

				instance->bspTree = CInfo.segment;

				if (CInfo.segment == 0)
				{
					rc |= 0x80000;
				}
			}
		}
		else
		{
			if (instance->tface != NULL)
			{
				instance->oldTFace = instance->tface;

				instance->tface = NULL;

				instance->tfaceLevel = NULL;

				instance->bspTree = 0;
			}
		}

		rc |= 0x1;
	}
	else
	{
		if (instance->tface != NULL)
		{
			instance->oldTFace = instance->tface;

			instance->tface = NULL;

			instance->tfaceLevel = NULL;

			instance->bspTree = 0;
		}
	}

	instance->attachedID = 0;

	if ((Mode & 0x2))
	{
		INSTANCE_Post(instance, 0x4000001, Data);
	}

	return rc;
}

void PhysicsDefaultGravityResponse(struct _Instance *instance, struct evPhysicsGravityData *Data)
{
#if defined(PSX_VERSION)
	instance->position.x += Data->x;
	instance->position.y += Data->y;

	if (instance == gameTrackerX.playerInstance && Data->z >= 129)
	{
		instance->position.z += 128;
	}
	else
	{
		instance->position.z += Data->z;
	}
#elif defined(PC_VERSION)
	instance->position.x += Data->x;
	instance->position.y += Data->y;
	if (instance == gameTrackerX.playerInstance && Data->z > 128)
		instance->position.z += 128;
	else
		instance->position.z += Data->z;
#endif
}


// autogenerated function stub: 
// int /*$ra*/ PhysicsCheckEdgeGrabbing(struct _Instance *instance /*$s2*/, struct GameTracker *gameTracker /*$a1*/, int Data /*stack 8*/, short Mode /*$s7*/)
int PhysicsCheckEdgeGrabbing(struct _Instance *instance, struct GameTracker *gameTracker, int Data, short Mode)
{ // line 589, offset 0x80075468
	/* begin block 1 */
		// Start line: 590
		// Start offset: 0x80075468
		// Variables:
			struct evPhysicsEdgeData *Ptr; // $s1
			int rc; // $s6
			VECTOR OutTrans; // stack offset -120
			SVECTOR *ExtraRot; // $v0
			//struct _PCollideInfo CInfo; // stack offset -104
			SVECTOR Old; // stack offset -56
			SVECTOR New; // stack offset -48
			static MATRIX TempMat; // offset 0x0
			static MATRIX *pTempMat; // offset 0x20
			int wallCrawl; // $fp
			int freeSpot; // $s3
	/* end block 1 */
	// End offset: 0x80075AEC
	// End Line: 873

	/* begin block 2 */
		// Start line: 1345
	/* end block 2 */
	// End Line: 1346
			UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// void /*$ra*/ PhysicsDefaultEdgeGrabResponse(struct _Instance *instance /*$s2*/, struct evPhysicsEdgeData *Data /*$s1*/, int blockFlag /*$a2*/)
void PhysicsDefaultEdgeGrabResponse(struct _Instance *instance, struct evPhysicsEdgeData *Data, int blockFlag)
{ // line 886, offset 0x80075b20
	/* begin block 1 */
		// Start line: 887
		// Start offset: 0x80075B20
		// Variables:
			struct _SVector normal; // stack offset -88
			struct _G2EulerAngles_Type ea1; // stack offset -80
			VECTOR OutTrans; // stack offset -72
			MATRIX TempMat; // stack offset -56
			SVECTOR New; // stack offset -24

		/* begin block 1.1 */
			// Start line: 936
			// Start offset: 0x80075C3C
			// Variables:
				long dp; // $v0
		/* end block 1.1 */
		// End offset: 0x80075C3C
		// End Line: 936
	/* end block 1 */
	// End offset: 0x80075C3C
	// End Line: 936

	/* begin block 2 */
		// Start line: 2031
	/* end block 2 */
	// End Line: 2032
				UNIMPLEMENTED();
}


// autogenerated function stub: 
// int /*$ra*/ PhysicsCheckSliding(struct _Instance *instance /*$s3*/, int Data /*$a1*/, short Mode /*$s6*/)
int PhysicsCheckSliding(struct _Instance *instance, int Data, short Mode)
{ // line 983, offset 0x80075dc4
	/* begin block 1 */
		// Start line: 984
		// Start offset: 0x80075DC4
		// Variables:
			struct evPhysicsSlideData *Ptr; // $s0
			int rc; // $s1
			VECTOR OutTrans; // stack offset -120
			struct _SVector normal; // stack offset -104
			//struct _PCollideInfo CInfo; // stack offset -96
			SVECTOR Old; // stack offset -48
			SVECTOR New; // stack offset -40
			static MATRIX *pTempMat; // offset 0x24

		/* begin block 1.1 */
			// Start line: 1015
			// Start offset: 0x80075E4C
		/* end block 1.1 */
		// End offset: 0x80075E4C
		// End Line: 1017

		/* begin block 1.2 */
			// Start line: 1024
			// Start offset: 0x80075E88
			// Variables:
				int Temp; // $a3
		/* end block 1.2 */
		// End offset: 0x80075F5C
		// End Line: 1032
	/* end block 1 */
	// End offset: 0x80076244
	// End Line: 1166

	/* begin block 2 */
		// Start line: 2245
	/* end block 2 */
	// End Line: 2246
				UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ PhysicsUpdateTface(struct _Instance *instance /*$s0*/, int Data /*$a1*/)
int PhysicsUpdateTface(struct _Instance *instance, int Data)
{ // line 1177, offset 0x80076270
	/* begin block 1 */
		// Start line: 1178
		// Start offset: 0x80076270
		// Variables:
			//struct _PCollideInfo CInfo; // stack offset -72
			SVECTOR Old; // stack offset -24
			SVECTOR New; // stack offset -16
	/* end block 1 */
	// End offset: 0x8007635C
	// End Line: 1219

	/* begin block 2 */
		// Start line: 2786
	/* end block 2 */
	// End Line: 2787
			UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ PhysicsCheckBlockers(struct _Instance *instance /*$s3*/, struct GameTracker *gameTracker /*$a1*/, int Data /*$s4*/, short Mode /*$s2*/)
int PhysicsCheckBlockers(struct _Instance *instance, struct GameTracker *gameTracker, int Data, short Mode)
{ // line 1232, offset 0x8007636c
	/* begin block 1 */
		// Start line: 1233
		// Start offset: 0x8007636C
		// Variables:
			struct evPhysicsEdgeData *Ptr; // $s1
			VECTOR OutTrans; // stack offset -120
			//struct _PCollideInfo CInfo; // stack offset -104
			SVECTOR Old; // stack offset -56
			SVECTOR New; // stack offset -48
			static MATRIX *pTempMat; // offset 0x28

		/* begin block 1.1 */
			// Start line: 1276
			// Start offset: 0x80076418
			// Variables:
				struct _TFace *tface; // $s0

			/* begin block 1.1.1 */
				// Start line: 1278
				// Start offset: 0x80076418
				// Variables:
					int Dot; // $a0
					SVECTOR Force; // stack offset -40
			/* end block 1.1.1 */
			// End offset: 0x800764FC
			// End Line: 1323

			/* begin block 1.1.2 */
				// Start line: 1351
				// Start offset: 0x800765D0
				// Variables:
					struct _HFace *hface; // stack offset -32
			/* end block 1.1.2 */
			// End offset: 0x800765D0
			// End Line: 1357
		/* end block 1.1 */
		// End offset: 0x800766E8
		// End Line: 1401
	/* end block 1 */
	// End offset: 0x800766EC
	// End Line: 1404

	/* begin block 2 */
		// Start line: 2909
	/* end block 2 */
	// End Line: 2910
					UNIMPLEMENTED();
	return 0;
}


int PhysicsCheckSwim(struct _Instance* instance, int Data, short Mode)//Matching - 98.81%
{
	struct evPhysicsSwimData* Ptr;
	int rc;
	int Depth;
	int WaterDepth;
	struct _PCollideInfo CInfo;
	SVECTOR Old;
	SVECTOR New;
	long waterZLevel;

	Ptr = (struct evPhysicsSwimData*)Data;

	waterZLevel = STREAM_GetWaterZLevel(STREAM_GetLevelWithID(instance->currentStreamUnitID), instance);

	Depth = instance->matrix[1].t[2] - waterZLevel;

	if (waterZLevel == -32767)
	{
		Depth = 1;
		WaterDepth = -32767;
	}
	else
	{
		WaterDepth = -32767;

		if (waterZLevel == 0x7FFF)
		{
			Depth = -32767;
		}
		else if (Ptr->CheckDepth)
		{
			CInfo.oldPoint = &Old;
			CInfo.newPoint = &New;

			Old.vx = New.vx = instance->matrix[1].t[0];
			Old.vy = New.vy = instance->matrix[1].t[1];
			Old.vz = New.vz = instance->matrix[1].t[2];

			New.vz -= Ptr->WadeDepth * 4;
			Old.vz += Ptr->TreadDepth;

			gameTrackerX.gameFlags |= 0x8000;
			
			instance->waterFace = 0;
			
			PHYSICS_CheckLineInWorld(instance, &CInfo);

			gameTrackerX.gameFlags &= ~0x8000;

			if (CInfo.type)
			{
				WaterDepth = Depth + CInfo.newPoint->vz - instance->matrix[1].t[2];
			}
			else
			{
				WaterDepth = Depth - 4 * Ptr->WadeDepth;
			}
		}
		else
		{
			Ptr->Depth = Depth;
			
			WaterDepth = instance->matrix->t[2] - waterZLevel;
	
			Ptr->WaterDepth = WaterDepth;
		}
	}
	
	if ((Mode & 0x3))
	{
		Ptr->Depth = Depth;
		
		Ptr->WaterDepth = WaterDepth;
	}
	
	Ptr->WaterLevel = waterZLevel;
	
	rc = PhysicsDefaultCheckSwimResponse(instance, (struct evPhysicsSwimData*)Data);
	
	Ptr->rc = rc;
	
	if ((Mode & 0x2))
	{
		INSTANCE_Post(instance, 0x4020000, Data);
	}

	FX_UpdateInstanceWaterSplit(instance);
	
	return rc;
}

// autogenerated function stub: 
// int /*$ra*/ PhysicsDefaultCheckSwimResponse(struct _Instance *instance /*$s2*/, struct evPhysicsSwimData *Data /*$s3*/)
int PhysicsDefaultCheckSwimResponse(struct _Instance *instance, struct evPhysicsSwimData *Data)
{ // line 1584, offset 0x800768fc
#if defined(PC_VERSION)
	int v2; // ebp
	int WaterLevel; // ebx
	__int16 Depth; // ax
	MATRIX* matrix; // ecx
	MATRIX* oldMatrix; // eax
	MATRIX* v7; // ecx
	MATRIX* v8; // esi
	int v9; // eax

	v2 = 0;
	STREAM_GetLevelWithID(instance->currentStreamUnitID);
	WaterLevel = Data->WaterLevel;
	if (Data->WaterDepth > -Data->WadeDepth)
		v2 = 128;
	Depth = Data->Depth;
	if (Depth > -Data->TreadDepth && Depth < 0)
		v2 |= 0x40u;
	if (Depth < -Data->SwimDepth)
		v2 |= 0x10u;
	if (Depth > 0)
		v2 |= 0x20u;
	if (WaterLevel > instance->position.z && WaterLevel < instance->oldPos.z && Data->iVelocity->z < 0)
	{
		SIGNAL_InWater(instance);
		v2 |= 0x100u;
	}
	matrix = instance->matrix;
	if (matrix)
	{
		oldMatrix = instance->oldMatrix;
		if (oldMatrix)
		{
			if (WaterLevel < matrix[1].t[2] && WaterLevel > oldMatrix[1].t[2])
			{
				SIGNAL_OutOfWater(instance);
				v2 |= 0x200u;
			}
		}
	}
	if (WaterLevel < instance->position.z && WaterLevel > instance->oldPos.z && Data->iVelocity->z > 0)
		v2 |= 0x400u;
	v7 = instance->matrix;
	if (v7)
	{
		v8 = instance->oldMatrix;
		if (v8)
		{
			v9 = WaterLevel - Data->SwimDepth;
			if (v9 > v7[1].t[2] && v9 < v8[1].t[2] && Data->iVelocity->z < 0)
				return v2 | 0x800;
		}
	}
	return v2;
#else
	UNIMPLEMENTED();
	return 0;
#endif
}


// autogenerated function stub: 
// void /*$ra*/ PhysicsForceSetWater(struct _Instance *instance /*$s1*/, int *Time /*$t0*/, int Depth /*$a2*/, int rate /*$a3*/, int maxAmplitude /*stack 16*/)
void PhysicsForceSetWater(struct _Instance *instance, int *Time, int Depth, int rate, int maxAmplitude)
{ // line 1856, offset 0x80076af4
#if defined(PC_VERSION)
	int v5; // eax
	int v6; // edx

	v5 = Depth;
	if (Depth < -3072)
		v5 = -3072;
	if (v5 > 0)
		v5 = 0;
	v6 = (rate << 12) / gameTrackerX.timeMult + *Time;
	*Time = v6;
	if (v6 > 4096)
		*Time = v6 - 4096;
	if (Depth < 0)
		instance->position.z += maxAmplitude * v5 / -3072 * rcos(*Time) / 4096;
#else
	UNIMPLEMENTED();
#endif
}

int PhysicsCheckLOS(struct _Instance* instance, int Data, int Mode) //Matching - 99.58%
{
#if defined(PSX_VERSION)

	struct _PCollideInfo CInfo;

	CInfo.oldPoint = (SVECTOR*)(Data + 8);
	CInfo.newPoint = (SVECTOR*)Data;
	PHYSICS_CheckLineInWorld(instance, &CInfo);

	return CInfo.type == 0;
#elif defined(PC_VERSION)
	int v3; // ebp
	int currentStreamUnitID; // edx
	struct Level* LevelWithID; // eax
	struct _Instance* LinkChild; // esi
	int v7; // ecx
	struct Level* v8; // ebx
	struct _Instance* v9; // esi
	struct _PCollideInfo v11; // [esp+10h] [ebp-2Ch] BYREF

	v3 = 0;
	currentStreamUnitID = instance->currentStreamUnitID;
	v11.oldPoint = (SVECTOR*)(Data + 8);
	v11.newPoint = (SVECTOR*)Data;
	v11.collideType = 63;
	LevelWithID = STREAM_GetLevelWithID(currentStreamUnitID);
	LinkChild = instance->LinkChild;
	v7 = instance->flags | 0x40;
	v8 = LevelWithID;
	v11.inst = 0;
	v11.instance = instance;
	for (instance->flags = v7; LinkChild; LinkChild = LinkChild->LinkSibling)
		SetNoPtCollideInFamily(LinkChild);
	if (v8)
		COLLIDE_PointAndWorld(&v11, v8);
	else
		v11.type = 0;
	v9 = instance->LinkChild;
	for (instance->flags &= ~0x40u; v9; v9 = v9->LinkSibling)
		ResetNoPtCollideInFamily(v9);
	if (!v11.type)
		return 1;
	return v3;
#else
	UNIMPLEMENTED();
	return 0;
#endif
}


// autogenerated function stub: 
// int /*$ra*/ PhysicsCheckDropHeight(struct _Instance *instance /*$s2*/, int Data /*$a1*/, int Mode /*$s3*/)
int PhysicsCheckDropHeight(struct _Instance *instance, int Data, int Mode)
{ // line 1915, offset 0x80076bfc
	/* begin block 1 */
		// Start line: 1916
		// Start offset: 0x80076BFC
		// Variables:
			struct evPhysicsDropHeightData *data; // $s0
			struct Level *level; // $v0
			SVECTOR newPos; // stack offset -104
			SVECTOR oldPos; // stack offset -96
			int rc; // $s1
			int lowZ; // $v1
			//struct _PCollideInfo CInfo; // stack offset -88
			static MATRIX TempMat; // offset 0x30
			static MATRIX *pTempMat; // offset 0x50

		/* begin block 1.1 */
			// Start line: 1929
			// Start offset: 0x80076C30
			// Variables:
				VECTOR outTrans; // stack offset -40
				SVECTOR *ExtraRot; // $v0
		/* end block 1.1 */
		// End offset: 0x80076C74
		// End Line: 1958

		/* begin block 1.2 */
			// Start line: 1982
			// Start offset: 0x80076D40
			// Variables:
				long waterZLevel; // $a0
		/* end block 1.2 */
		// End offset: 0x80076D7C
		// End Line: 2000
	/* end block 1 */
	// End offset: 0x80076E6C
	// End Line: 2048

	/* begin block 2 */
		// Start line: 4438
	/* end block 2 */
	// End Line: 4439
				UNIMPLEMENTED();
	return 0;
}

int PhysicsCheckDropOff(struct _Instance* instance, int Data, short Mode)//Matching - 98.79%
{
	struct evPhysicsDropOffData* Ptr;
	int rc;
	VECTOR OutTrans;
	SVECTOR* ExtraRot;
	struct _PCollideInfo CInfo;
	SVECTOR New;
	SVECTOR Old;
	static MATRIX TempMat;
	static MATRIX* pTempMat;

	CInfo.oldPoint = &Old;

	Ptr = (struct evPhysicsDropOffData*)Data;

	CInfo.newPoint = &New;

	ExtraRot = (SVECTOR*)INSTANCE_Query(instance, 0x8);
	rc = 0;

	if (instance->matrix != NULL)
	{
		if (ExtraRot != NULL)
		{
			pTempMat = &TempMat;

			RotMatrix(ExtraRot, pTempMat);

			MulMatrix2(instance->matrix, pTempMat);
		}
		else
		{
			pTempMat = instance->matrix;
		}

		New.vx = Ptr->xOffset;
		New.vy = Ptr->yOffset;
		New.vz = 0;

		ApplyMatrix(pTempMat, &New, &OutTrans);

		Old.vx = instance->position.x + OutTrans.vx;
		Old.vy = instance->position.y + OutTrans.vy;
		Old.vz = instance->position.z + OutTrans.vz;

		New.vx = Old.vx;
		New.vy = Old.vy;
		New.vz = Old.vz - Ptr->DropOffset;
		Old.vz += Ptr->UpperOffset;

		PHYSICS_CheckLineInWorld(instance, &CInfo);

		if ((unsigned int)((unsigned short)CInfo.type - 2) < 2 || (CInfo.type == 5))
		{
			if (Mode & 0x2)
			{
				if (CInfo.wNormal.vz > Ptr->slipSlope)
				{
					INSTANCE_Post(instance, 0x4010080, 1);
				}
				else
				{

					INSTANCE_Post(instance, 0x4010080, 0);
					rc = 8;
				}
			}
			if (CInfo.wNormal.vz < Ptr->slipSlope && CInfo.wNormal.vz > 0 && CInfo.newPoint->vz > instance->position.z)
			{
				INSTANCE_Post(instance, 0x4010401, 0);
			}
		}
		else
		{
			if (!CInfo.type)
			{
				if ((Mode & 0x2))
				{
					INSTANCE_Post(instance, 0x4010080, 0);
				}
				rc = 8;
			}
		}
	}
	return rc;
}


// autogenerated function stub: 
// int /*$ra*/ PhysicsFollowWall(struct _Instance *instance /*$s2*/, struct GameTracker *gameTracker /*$a1*/, int Data /*$s7*/, short Mode /*$s5*/)
int PhysicsFollowWall(struct _Instance *instance, struct GameTracker *gameTracker, int Data, short Mode)
{ // line 2209, offset 0x800770ac
	/* begin block 1 */
		// Start line: 2210
		// Start offset: 0x800770AC
		// Variables:
			VECTOR OutTrans; // stack offset -168
			struct evPhysicsWallCrawlData *Ptr; // $s1
			//struct _PCollideInfo CInfo; // stack offset -152
			SVECTOR New; // stack offset -104
			SVECTOR Old; // stack offset -96
			static MATRIX *pTempMat; // offset 0x84

		/* begin block 1.1 */
			// Start line: 2281
			// Start offset: 0x800771E8
			// Variables:
				_Position A; // stack offset -88
				_Position B; // stack offset -80
				MATRIX mat; // stack offset -72
		/* end block 1.1 */
		// End offset: 0x800772E4
		// End Line: 2341
	/* end block 1 */
	// End offset: 0x8007758C
	// End Line: 2488

	/* begin block 2 */
		// Start line: 4418
	/* end block 2 */
	// End Line: 4419
				UNIMPLEMENTED();
	return 0;
}

void PhysicsMoveLocalZClamp(struct _Instance* instance, long segment, long time, long clamp) //Matching - 99.91%
{
#if defined(PSX_VERSION)
	struct _Position pos;
	SVECTOR v;
	SVECTOR dv;

	memset(&pos, 0, sizeof(struct _Position));

	PhysicsMove(instance, &pos, time);

	v.vx = pos.x;
	v.vy = -pos.y;
	v.vz = pos.z;

	ApplyMatrixSV(&instance->matrix[segment], &v, &dv);

	instance->position.x += dv.vx;
	instance->position.y += dv.vy;

	if (clamp == 0)
	{
		instance->position.z += dv.vz;
	}

#elif defined(PC_VERSION)
	MATRIX* matrix; // edx
	__int16 vy; // cx
	_Position position; // [esp+4h] [ebp-18h] BYREF
	SVECTOR v0; // [esp+Ch] [ebp-10h] BYREF
	SVECTOR v1; // [esp+14h] [ebp-8h] BYREF

	position.x = 0;
	position.y = 0;
	position.z = 0;
	PhysicsMove(instance, &position, time);
	v0.vx = position.x;
	v0.vz = position.z;
	matrix = instance->matrix;
	v0.vy = -position.y;
	ApplyMatrixSV(&matrix[segment], &v0, &v1);
	vy = v1.vy;
	instance->position.x += v1.vx;
	instance->position.y += vy;
	if (!clamp)
		instance->position.z += v1.vz;
#else
	UNIMPLEMENTED();
#endif
}

void PhysicsMove(struct _Instance* instance, struct _Position* position, long time)
{
#if defined(PSX_VERSION)
	long xVel;
	long yVel;
	long zVel;
	long xat;
	long yat;
	long zat;

	xVel = instance->xVel;
	yVel = instance->yVel;
	zVel = instance->zVel;

	xat = (instance->xAccl * time) < 0 ? ((instance->xAccl * time) + 0xFFF) >> 12 : (instance->xAccl * time) >> 12;
	yat = (instance->yAccl * time) < 0 ? ((instance->yAccl * time) + 0xFFF) >> 12 : (instance->yAccl * time) >> 12;
	zat = (instance->zAccl * time) < 0 ? ((instance->zAccl * time) + 0xFFF) >> 12 : (instance->zAccl * time) >> 12;

	position->x += (xVel * time) < 0 ? ((xVel * time) + 0xFFF) >> 12 : (xVel * time) >> 12 + (xat * time) < 0 ? ((xat * time) + 0x1FFF) >> 13 : (xat * time) >> 13;
	position->y += (yVel * time) < 0 ? ((yVel * time) + 0xFFF) >> 12 : (yVel * time) >> 12 + (yat * time) < 0 ? ((yat * time) + 0x1FFF) >> 13 : (yat * time) >> 13;
	position->z += (zVel * time) < 0 ? ((zVel * time) + 0xFFF) >> 12 : (zVel * time) >> 12 + (zat * time) < 0 ? ((zat * time) + 0x1FFF) >> 13 : (zat * time) >> 13;

	xVel += xat;
	yVel += yat;
	zVel += zat;

	if (instance->maxXVel < xVel || xVel < instance->maxXVel)
	{
		xVel = instance->maxXVel;
	}

	if (instance->maxYVel < yVel || yVel < instance->maxYVel)
	{
		yVel = instance->maxYVel;
	}

	if (instance->maxZVel < zVel || zVel < instance->maxZVel)
	{
		zVel = instance->maxZVel;
	}

	instance->xVel = xVel;
	instance->yVel = yVel;
	instance->zVel = zVel;

#elif defined(PC_VERSION)
	int zVel; // ecx
	int v6; // kr18_4
	int v7; // ebx
	int v8; // ecx
	int v9; // eax
	int maxXVel; // edx
	int v11; // ebp
	int maxYVel; // edx
	int maxZVel; // edx
	int v14; // [esp+14h] [ebp-Ch]
	int xVel; // [esp+18h] [ebp-8h]
	int instancea; // [esp+24h] [ebp+4h]
	int timea; // [esp+2Ch] [ebp+Ch]

	zVel = instance->zVel;
	instancea = instance->yVel;
	v14 = zVel;
	xVel = instance->xVel;
	v6 = time * instance->yAccl;
	v7 = time * instance->xAccl / 4096;
	timea = time * instance->zAccl / 4096;
	position->x += time * xVel / 4096 + time * v7 / 0x2000;
	position->y += time * instancea / 4096 + time * (v6 / 4096) / 0x2000;
	position->z += time * v14 / 4096 + time * timea / 0x2000;
	v8 = v7 + xVel;
	v9 = v6 / 4096 + instancea;
	maxXVel = instance->maxXVel;
	v11 = timea + v14;
	if (v7 + xVel > maxXVel || (maxXVel = -maxXVel, v8 < maxXVel))
		v8 = maxXVel;
	maxYVel = instance->maxYVel;
	if (v9 > maxYVel || (maxYVel = -maxYVel, v9 < maxYVel))
		v9 = maxYVel;
	maxZVel = instance->maxZVel;
	if (v11 > maxZVel || (maxZVel = -maxZVel, v11 < maxZVel))
		v11 = maxZVel;
	instance->xVel = v8;
	instance->yVel = v9;
	instance->zVel = v11;
#else
	UNIMPLEMENTED();
#endif
}


// autogenerated function stub: 
// void /*$ra*/ PhysicsSetVelFromZRot(struct _Instance *instance /*$s2*/, short angle /*$a1*/, long magnitude /*$s1*/)
void PhysicsSetVelFromZRot(struct _Instance *instance, short angle, long magnitude)
{ // line 2734, offset 0x80077830
#if defined(PC_VERSION)
	instance->xVel = (magnitude * rcos(angle - 1024)) >> 12;
	instance->yVel = (magnitude * rsin(angle - 1024)) >> 12;
#else
	UNIMPLEMENTED();
#endif
}


// autogenerated function stub: 
// void /*$ra*/ PhysicsSetVelFromRot(struct _Instance *instance /*$s0*/, struct _Rotation *rot /*$a1*/, long magnitude /*$a2*/)
void PhysicsSetVelFromRot(struct _Instance *instance, struct _Rotation *rot, long magnitude)
{ // line 2745, offset 0x800778a0
#if defined(PC_VERSION)
	int vy; // edx
	int vz; // eax
	SVECTOR v0; // [esp+4h] [ebp-30h] BYREF
	SVECTOR v1; // [esp+Ch] [ebp-28h] BYREF
	MATRIX m; // [esp+14h] [ebp-20h] BYREF

	v0.vx = 0;
	v0.vz = 0;
	v0.vy = -(__int16)magnitude;
	RotMatrix((SVECTOR*)&instance->rotation, &m);
	ApplyMatrixSV(&m, &v0, &v1);
	vy = v1.vy;
	vz = v1.vz;
	instance->xVel = v1.vx;
	instance->yVel = vy;
	instance->zVel = vz;
#else
	UNIMPLEMENTED();
#endif
}


// autogenerated function stub: 
// void /*$ra*/ PHYSICS_SetVAndAFromRot(struct _Instance *instance /*$s0*/, struct _Rotation *rot /*$a1*/, long v /*$s1*/, long a /*$s2*/)
void PHYSICS_SetVAndAFromRot(struct _Instance *instance, struct _Rotation *rot, long v, long a)
{ // line 2765, offset 0x80077910
#if defined(PC_VERSION)
	int vy; // eax
	int vz; // ecx
	int v6; // eax
	int v7; // ecx
	SVECTOR v0; // [esp+10h] [ebp-30h] BYREF
	SVECTOR v1; // [esp+18h] [ebp-28h] BYREF
	MATRIX m; // [esp+20h] [ebp-20h] BYREF

	if (v || a)
	{
		RotMatrix((SVECTOR*)&instance->rotation, &m);
		v0.vx = 0;
		v0.vz = 0;
	}
	if (v)
	{
		v0.vy = -(__int16)v;
		ApplyMatrixSV(&m, &v0, &v1);
		vy = v1.vy;
		vz = v1.vz;
		instance->xVel = v1.vx;
		instance->yVel = vy;
		instance->zVel = vz;
	}
	else
	{
		instance->xVel = 0;
		instance->yVel = 0;
		instance->zVel = 0;
	}
	if (a)
	{
		v0.vy = -(__int16)a;
		ApplyMatrixSV(&m, &v0, &v1);
		v6 = v1.vy;
		v7 = v1.vz;
		instance->xAccl = v1.vx;
		instance->yAccl = v6;
		instance->zAccl = v7;
	}
	else
	{
		instance->xAccl = 0;
		instance->yAccl = 0;
		instance->zAccl = 0;
	}
#else
	UNIMPLEMENTED();
#endif
}

long PHYSICS_FindAFromDAndT(long d, long t)
{
#if defined(PSX_VERSION)
	if (t != 0)
	{
		return MAX((d * 8192) / (t * t), (d * 8192) / (t * t) + 4095) >> 12;
	}
	else
	{
		return 0;
	}
#elif defined(PC_VERSION)
	if (t)
		return (d << 13) / (t * t) / 4096;
	else
		return 0;
#endif
}

long PHYSICS_FindVFromAAndD(long a, long d)
{
#if defined(PSX_VERSION)
	long vsq; // $a0

	vsq = a * (d * 2);

	if (vsq == 0)
	{
		return 0;
	}
	else
	{
		return MATH3D_FastSqrt0(vsq);
	}

#elif defined(PC_VERSION)
	if (2 * a * d)
		return MATH3D_FastSqrt0(2 * a * d);
	else
		return 0;
#endif
}


// autogenerated function stub: 
// void /*$ra*/ PHYSICS_StopIfCloseToTarget(struct _Instance *instance /*$a0*/, int x /*$a1*/, int y /*$a2*/, int z /*$a3*/)
void PHYSICS_StopIfCloseToTarget(struct _Instance *instance, int x, int y, int z)
{ // line 2876, offset 0x80077a74
#if defined(PC_VERSION)
	int xAccl; // ecx
	int yAccl; // ecx
	int zAccl; // ecx

	xAccl = instance->xAccl;
	if (xAccl < 0 && instance->xVel <= x || xAccl > 0 && instance->xVel >= x)
	{
		instance->xAccl = 0;
		instance->xVel = x;
	}
	yAccl = instance->yAccl;
	if (yAccl < 0 && instance->yVel <= y || yAccl > 0 && instance->yVel >= y)
	{
		instance->yAccl = 0;
		instance->yVel = y;
	}
	zAccl = instance->zAccl;
	if (zAccl < 0 && instance->zVel <= z || zAccl > 0 && instance->zVel >= z)
	{
		instance->zAccl = 0;
		instance->zVel = z;
	}
#else
	UNIMPLEMENTED();
#endif
}

int PHYSICS_CheckForTerrainCollide(struct _Instance* instance, SVECTOR* startVec, SVECTOR* endVec, int segment)
{
#if defined(PSX_VERSION)
	struct _PCollideInfo CInfo;
	MATRIX* pTempMat;

	pTempMat = instance->matrix + segment;

	PHYSICS_GenericLineCheckMask(instance, pTempMat, pTempMat, &CInfo);

	return (CInfo.type ^ 3) < 1;

#elif defined(PC_VERSION)
	MATRIX* matrix; // eax
	struct _PCollideInfo v6; // [esp+0h] [ebp-2Ch] BYREF

	v6.newPoint = endVec;
	v6.oldPoint = startVec;
	matrix = instance->matrix;
	v6.collideType = 1;
	PHYSICS_GenericLineCheckMask(instance, &matrix[segment], &matrix[segment], &v6);
	return v6.type == 3;
#else
	UNIMPLEMENTED();
	return 0;
#endif
}


int PHYSICS_CheckForObjectCollide(struct _Instance* instance, SVECTOR* startVec, SVECTOR* endVec, int segment)
{
#if defined(PSX_VERSION)
	struct _PCollideInfo CInfo;
	MATRIX* pTempMat;

	pTempMat = instance->matrix;
	
	CInfo.collideType = 62;

	PHYSICS_GenericLineCheckMask(instance, &pTempMat[segment], &pTempMat[segment], &CInfo);

	return (unsigned)0 < CInfo.type;

#elif defined(PC_VERSION)
	MATRIX* matrix; // eax
	struct _PCollideInfo v6; // [esp+0h] [ebp-2Ch] BYREF

	v6.newPoint = endVec;
	v6.oldPoint = startVec;
	matrix = instance->matrix;
	v6.collideType = 62;
	PHYSICS_GenericLineCheckMask(instance, &matrix[segment], &matrix[segment], &v6);
	return v6.type != 0;
#endif
}


// autogenerated function stub: 
// int /*$ra*/ PHYSICS_CheckForValidMove(struct _Instance *instance /*$a0*/, SVECTOR *startVec /*$a1*/, SVECTOR *endVec /*$a2*/, int segment /*$a3*/)
int PHYSICS_CheckForValidMove(struct _Instance *instance, SVECTOR *startVec, SVECTOR *endVec, int segment)
{ // line 2938, offset 0x80077be0
#if defined(PC_VERSION)
	int v4; // edi
	int v5; // edx
	int v6 = 0; // ecx
	MATRIX* v8; // [esp-Ch] [ebp-44h]
	struct _PCollideInfo v9; // [esp+Ch] [ebp-2Ch] BYREF

	v9.newPoint = endVec;
	v9.oldPoint = startVec;
	v8 = &instance->matrix[segment];
	v4 = 0;
	v9.collideType = 63;
	PHYSICS_GenericLineCheckMask(instance, v8, v8, &v9);
	v5 = 0;
	if (v9.type == 3)
	{
		if (*((WORD*)v9.prim + 5) == 0xFFFF)
			v6 &= 0xff00;
		else
			v6 = *(unsigned __int16*)((char*)&v9.inst->node.prev[6].next[1].prev + *((unsigned __int16*)v9.prim + 5) + 2);
		if ((v6 & 0x200) != 0)
			v5 = 1;
	}
	if (v5)
		v4 = 1;
	if (v9.type == 3 || v9.type == 2 || v9.type == 5)
		v4 += 2;
	return v4;
#else
	UNIMPLEMENTED();
	return 0;
#endif
}


// autogenerated function stub: 
// int /*$ra*/ PHYSICS_CheckFaceStick(struct _PCollideInfo *CInfo /*$a0*/)
int PHYSICS_CheckFaceStick(struct _PCollideInfo *CInfo)
{ // line 2966, offset 0x80077c4c
	/* begin block 1 */
		// Start line: 2967
		// Start offset: 0x80077C4C
		// Variables:
			int rc; // $a1

		/* begin block 1.1 */
			// Start line: 2973
			// Start offset: 0x80077C60
			// Variables:
				struct _TFace *tface; // $a2
		/* end block 1.1 */
		// End offset: 0x80077C78
		// End Line: 2975

		/* begin block 1.2 */
			// Start line: 2979
			// Start offset: 0x80077CA4
			// Variables:
				struct _HFace *hface; // stack offset -8
		/* end block 1.2 */
		// End offset: 0x80077CA4
		// End Line: 2987
	/* end block 1 */
	// End offset: 0x80077CA4
	// End Line: 2988

	/* begin block 2 */
		// Start line: 6640
	/* end block 2 */
	// End Line: 6641
				UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ PHYSICS_CheckDontGrabEdge(struct _PCollideInfo *CInfo /*$s0*/)
int PHYSICS_CheckDontGrabEdge(struct _PCollideInfo *CInfo)
{ // line 2992, offset 0x80077cb0
#if defined(PC_VERSION)
	int v1; // edi
	__int16 type; // ax
	int v3; // ecx

	v1 = 0;
	type = CInfo->type;
	if (CInfo->type == 3)
	{
		if (*((WORD*)CInfo->prim + 5) == 0xFFFF)
			v3 = 0;
		else
			v3 = *(unsigned __int16*)((char*)&CInfo->inst->node.prev[6].next[1].prev
				+ *((unsigned __int16*)CInfo->prim + 5)
				+ 2);
		if ((v3 & 0x80u) != 0)
			v1 = 1;
		if (*((char*)&CInfo->inst->node.prev[9].prev[2].prev + 36 * CInfo->segment + 3) < 0)
			return 1;
	}
	else if (type == 2)
	{
		if (*((char*)CInfo->prim + 6) < 0)
			return 1;
	}
	else if (type == 5 && (INSTANCE_Query(CInfo->inst, 1) & 0x20) != 0 && (INSTANCE_Query(CInfo->inst, 3) & 1) == 0)
	{
		return 1;
	}
	return v1;
#else
	UNIMPLEMENTED();
	return 0;
#endif
}

void PHYSICS_GenericLineCheckSetup(short x, short y, short z, SVECTOR* inVec)
{
#if defined(PSX_VERSION)
	inVec->vx = x;
	inVec->vy = y;
	inVec->vz = z;
#elif defined(PC_VERSION)
	inVec->vx = x;
	inVec->vy = y;
	inVec->vz = z;
#endif
}

void PHYSICS_GenericLineCheck(struct _Instance* instance, MATRIX* transMat, MATRIX* rotMat, struct _PCollideInfo* cInfo)
{
#if defined(PSX_VERSION)
	cInfo->collideType = 63;
	PHYSICS_GenericLineCheckMask(instance, transMat, rotMat, cInfo);
#elif defined(PC_VERSION)
	cInfo->collideType = 63;
	PHYSICS_GenericLineCheckMask(instance, transMat, rotMat, cInfo);
#endif
}


// autogenerated function stub: 
// void /*$ra*/ PHYSICS_GenericLineCheckMask(struct _Instance *instance /*$a0*/, MATRIX *transMat /*$a1*/, MATRIX *rotMat /*$a2*/, struct _PCollideInfo *cInfo /*$a3*/)
void PHYSICS_GenericLineCheckMask(struct _Instance *instance, MATRIX *transMat, MATRIX *rotMat, struct _PCollideInfo *cInfo)
{ // line 3057, offset 0x80077e0c
#if defined(PC_VERSION)
	SVECTOR* oldPoint; // edi
	SVECTOR* newPoint; // ebx
	struct Level* LevelWithID; // eax
	struct _Instance* LinkChild; // esi
	struct Level* v8; // ebx
	struct _Instance* i; // edi
	VECTOR v10; // [esp+10h] [ebp-10h] BYREF

	oldPoint = cInfo->oldPoint;
	newPoint = cInfo->newPoint;
	TRANS_ApplyMatrix(rotMat, oldPoint, &v10);
	oldPoint->vx = transMat->t[0] + v10.vx;
	oldPoint->vy = transMat->t[1] + v10.vy;
	oldPoint->vz = transMat->t[2] + v10.vz;
	TRANS_ApplyMatrix(rotMat, newPoint, &v10);
	newPoint->vx = transMat->t[0] + v10.vx;
	newPoint->vy = transMat->t[1] + v10.vy;
	newPoint->vz = transMat->t[2] + v10.vz;
	LevelWithID = STREAM_GetLevelWithID(instance->currentStreamUnitID);
	cInfo->inst = 0;
	cInfo->instance = instance;
	LinkChild = instance->LinkChild;
	v8 = LevelWithID;
	for (instance->flags |= 0x40u; LinkChild; LinkChild = LinkChild->LinkSibling)
		SetNoPtCollideInFamily(LinkChild);
	if (v8)
		COLLIDE_PointAndWorld(cInfo, v8);
	else
		cInfo->type = 0;
	instance->flags &= ~0x40u;
	for (i = instance->LinkChild; i; i = i->LinkSibling)
		ResetNoPtCollideInFamily(i);
#else
	UNIMPLEMENTED();
#endif
}




