#include "CORE.H"
#include "UNDRWRLD.H"
#include "GAMELOOP.H"
#include "STREAM.H"
#include "MEMPACK.H"
#include "PSX/MAIN.H"
#include "STRMLOAD.H"
#include "DRAW.H"
#include "BSP.H"

static struct UW_ScreenXY* ScreenMorphArray; // offset 0x800D1DC4
static long UW_angle; // offset 0x800D7364
static long UW_scalex; // offset 0x800D7368
static long UW_scalexInc; // offset 0x800D736C
static long UW_angleInc; // offset 0x800D7370

static inline int getPage()
{
	return gameTrackerX.gameData.asmData.dispPage;
}

void UNDERWORLD_StartProcess()  // Matching - 100%
{ 
	INSTANCE_Post(gameTrackerX.playerInstance, 0x40001, 0);

	STREAM_DumpAllLevels(gameTrackerX.playerInstance->currentStreamUnitID, 1);

	UNDERWORLD_InitDisplayProcess();

	UNDERWORLD_LoadLevel("under1", &gameTrackerX);

	if (ScreenMorphArray != NULL)
	{
		MEMPACK_Free((char*)ScreenMorphArray);

		ScreenMorphArray = NULL;
	}
}


// autogenerated function stub: 
// long /*$ra*/ UNDERWORLD_RotateScreenStep(long time /*$s1*/)
long UNDERWORLD_RotateScreenStep(long time)
{ // line 93, offset 0x800b4c14
	/* begin block 1 */
		// Start line: 94
		// Start offset: 0x800B4C14
		// Variables:
			int row; // $t2
			int col; // $a3
			int sinAngle; // $s0
			int cosAngle; // $t3
			int hx; // $v1
			int hy; // $v0

		/* begin block 1.1 */
			// Start line: 109
			// Start offset: 0x800B4C74
			// Variables:
				struct UW_ScreenXY *p; // $a0
				int scaleY; // $t0
		/* end block 1.1 */
		// End offset: 0x800B4C74
		// End Line: 109
	/* end block 1 */
	// End offset: 0x800B4D68
	// End Line: 132

	/* begin block 2 */
		// Start line: 186
	/* end block 2 */
	// End Line: 187

	/* begin block 3 */
		// Start line: 192
	/* end block 3 */
	// End Line: 193
				UNIMPLEMENTED();
	return 0;
}

void UNDERWORLD_DoUV(unsigned char* uv, struct UW_ScreenXY* p0, int tx)//Matching - 100%
{
	int u;

	u = p0->sx - tx;

	if (u >= 256)
	{
		uv[0] = -1;
	}
	else
	{
		uv[0] = u;
	}

	if (p0->sy >= 256)
	{
		uv[1] = -1;
	}
	else
	{
		uv[1] = (unsigned char)p0->sy;
	}
}

// autogenerated function stub: 
// struct POLY_GT3 * /*$ra*/ UNDERWORLD_Poly(struct POLY_GT3 *last /*$s4*/, struct UW_ScreenXY *p0 /*$a1*/, struct UW_ScreenXY *p1 /*$s3*/, struct UW_ScreenXY *p2 /*$s2*/, int drawY /*stack 16*/)
POLY_GT3 * UNDERWORLD_Poly(POLY_GT3 *last, struct UW_ScreenXY *p0, struct UW_ScreenXY *p1, struct UW_ScreenXY *p2, int drawY)
{ // line 182, offset 0x800b4dcc
	/* begin block 1 */
		// Start line: 183
		// Start offset: 0x800B4DCC
		// Variables:
			int tx; // $s0
			POLY_GT3 *poly; // $s1
			int col; // $v1
	/* end block 1 */
	// End offset: 0x800B4E54
	// End Line: 188

	/* begin block 2 */
		// Start line: 399
	/* end block 2 */
	// End Line: 400
			UNIMPLEMENTED();
	return null;
}


// autogenerated function stub: 
// void /*$ra*/ UNDERWORLD_DisplayFrame(long *primStart /*$a0*/, long drawY /*$s7*/)
void UNDERWORLD_DisplayFrame(long *primStart, long drawY)
{ // line 229, offset 0x800b4f44
	/* begin block 1 */
		// Start line: 230
		// Start offset: 0x800B4F44
		// Variables:
			long row; // $s5
			long col; // $s0
			long d; // $v0
			struct UW_ScreenXY *p0; // $s2
			struct UW_ScreenXY *p1; // $s1
			struct UW_ScreenXY *p2; // $s3
			struct UW_ScreenXY *p3; // $s4
			//struct POLY_GT3 *poly; // $a1
			//struct POLY_GT3 *terminator; // $fp
	/* end block 1 */
	// End offset: 0x800B5050
	// End Line: 274

	/* begin block 2 */
		// Start line: 535
	/* end block 2 */
	// End Line: 536
			UNIMPLEMENTED();
}

void UNDERWORLD_SetupSource()  // Matching - 100%
{
	PSX_RECT rect;
	DR_STP stp;

	//SetDrawStp(&stp, 1);		@fixme SetDrawStp() needs libValkyrie implementation

	DrawPrim(&stp);

	rect.x = 0;

	rect.y = getPage() << 8;

	rect.w = SCREEN_WIDTH;
	rect.h = SCREEN_HEIGHT;

	MoveImage(&rect, 0, (getPage() ^ 1) << 8);

	//SetDrawStp(&stp, 0);

	DrawPrim(&stp);

	DrawSync(0);

	PutDrawEnv(&draw[getPage()]);
}

void UNDERWORLD_InitDisplayProcess()  // Matching - 100%
{
	int row;
	int col;

#if !defined(PSXPC_VERSION)
	do
	{
		while (CheckVolatile(gameTrackerX.drawTimerReturn) != 0);
	} while (CheckVolatile(gameTrackerX.reqDisp) != 0);
#endif

	ScreenMorphArray = (struct UW_ScreenXY*)MEMPACK_Malloc(sizeof(struct UW_ScreenXY[3][3]), 24);

	for (row = 0; row < 3; row++)
	{
		for (col = 0; col < 3; col++)
		{
			struct UW_ScreenXY* p;

			p = ScreenMorphArray + col + (row * 3);

			p->sx = (col * 254) + 1;
			p->sy = (row * 119) + 1;
		}
	}

	UW_scalex = 4096;
	UW_scalexInc = 32;
	UW_angle = 0;
	UW_angleInc = 8;

	UNDERWORLD_SetupSource();
}


struct _StreamUnit* UNDERWORLD_LoadLevel(char* baseAreaName, struct GameTracker* gameTracker)  // Matching - 99.97%
{
	struct _SVector offset;
	struct _StreamUnit* streamUnit;
	long i;
	long UW_time;

	UW_time = gameTrackerX.vblCount;

	while (STREAM_PollLoadQueue() != 0)
	{
		UW_time = UNDERWORLD_RotateScreenStep(UW_time);
	}

	LOAD_ChangeDirectory(baseAreaName);

	streamUnit = STREAM_LoadLevel(baseAreaName, NULL, 0);

	while (STREAM_PollLoadQueue() != 0)
	{
		UW_time = UNDERWORLD_RotateScreenStep(UW_time);
	}

	if (streamUnit->level->startUnitMainSignal != NULL)
	{
		SIGNAL_HandleSignal(gameTracker->playerInstance, streamUnit->level->startUnitMainSignal->signalList, 0);
	}

	STREAM_LoadMainVram(gameTracker, "under1", streamUnit);

	INSTANCE_Post(gameTracker->playerInstance, 0x40001, streamUnit->level->streamUnitID);

	{
		short _x1;
		short _y1;
		short _z1;
		struct _SVector* _v0;
		struct _Position* _v1;

		_v0 = &offset;

		_x1 = streamUnit->level->terrain->BSPTreeArray->bspRoot->sphere.position.x;
		_y1 = streamUnit->level->terrain->BSPTreeArray->bspRoot->sphere.position.y;
		_z1 = streamUnit->level->terrain->BSPTreeArray->bspRoot->sphere.position.z;

		_v0->x = _x1;
		_v0->y = _y1;
		_v0->z = _z1;

		offset.x = -offset.x;
		offset.y = -offset.y;
		offset.z = -offset.z;
	}

	for (i = 0; i < streamUnit->level->numIntros; i++)
	{
		if (strcmpi(streamUnit->level->introList[i].name, "raziel") == 0)
		{
			streamUnit->level->introList[i].flags |= 8;

			break;
		}
	}

	gameTrackerX.playerInstance->currentStreamUnitID = gameTracker->StreamUnitID;

	UNDERWORLD_UpdatePlayer(&streamUnit->level->introList[i], gameTrackerX.playerInstance);

	UW_time = UNDERWORLD_RotateScreenStep(UW_time);

	PreloadAllConnectedUnits(streamUnit, &offset);

	RENDER_currentStreamUnitID = (int)gameTracker->StreamUnitID;

	gameTracker->wipeType = 10;
	gameTracker->maxWipeTime = 30;
	gameTracker->wipeTime = 30;

	while (STREAM_PollLoadQueue() != 0)
	{
		UW_time = UNDERWORLD_RotateScreenStep(UW_time);
	}

	{
		//@fixme prim drawing needs porting to libValkyrie 
		POLY_F4 poly;
		DR_TPAGE tpage;

		setDrawTPage(&tpage, 1, 1, 320);

		setPolyF4(&poly);

		setXY4(&poly, 0, 0, 512, 0, 0, 240, 512, 240);

		setRGB0(&poly, 8, 8, 8);

		setcode(&poly, 42);

		for (i = 0; i < 30; i++)
		{
			VSync(0);
			DrawPrim(&tpage);
			DrawPrim(&poly);
		}

		DrawSync(0);
	}

	return streamUnit;
}

void UNDERWORLD_UpdatePlayer(struct Intro* playerIntro, struct _Instance* instance) // Matching - 100%
{
	struct _SVector offset;
	short _x0;
	short _y0;
	short _z0;
	short _x1;
	short _y1;
	short _z1;
	struct _SVector* _v;
	_Position* _v0;
	_Position* _v1;
	_v = &offset;
	_v0 = &playerIntro->position;
	_v1 = &instance->position;
	_x0 = _v0->x;
	_y0 = _v0->y;
	_z0 = _v0->z;
	_x1 = _v1->x;
	_y1 = _v1->y;
	_z1 = _v1->z;
	_v->x = _x0 - _x1;
	_v->y = _y0 - _y1;
	_v->z = _z0 - _z1;
	STREAM_RelocateInstance(instance, &offset);
}
