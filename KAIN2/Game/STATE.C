#include "CORE.H"
#include "STATE.H"
#include "PLAYER.H"
#include "G2/ANMG2ILF.H"
#include "G2/INSTNCG2.H"
#include "G2/ANIMG2.H"
#include "MEMPACK.H"

struct _G2AnimAlphaTable_Type* G2AlphaTables[7] = {
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
};

char circBuf[4096];

void* circWhere = &circBuf[92];

void InitMessageQueue(struct __MessageQueue* In)
{
	In->Head = 0;
	In->Tail = 0;
}

struct __Event* DeMessageQueue(struct __MessageQueue* In)//Matching - 100%
{
	int head = In->Head;

	if (In->Head == In->Tail)
	{
		return NULL;
	}
	else if (++In->Head == 16)
	{
		In->Head = 0;
	}

	return &In->Queue[head];
}

void PurgeMessageQueue(struct __MessageQueue* In)
{
	In->Tail = 0;
	In->Head = 0;
}

struct __Event* PeekMessageQueue(struct __MessageQueue* In)//Matching - 100%
{
	if (In->Head == In->Tail)
	{
		return NULL;
	}

	return &In->Queue[In->Head];
}

void EnMessageQueue(struct __MessageQueue* In, struct __Event* Element)
{ 
	EnMessageQueueData(In, Element->ID, Element->Data);
}

void EnMessageQueueData(struct __MessageQueue* In, int ID, int Data)//Matching - 100%
{
	int i;

	In->Queue[In->Tail].ID = ID;
	In->Queue[In->Tail].Data = Data;

	if (++In->Tail == 16)
	{
		In->Tail = 0;
	}

	i = In->Head;

	if (i == In->Tail)
	{
		do
		{
			if (++i == 0x10)
			{
				i = 0;
			}

		} while (i != In->Tail);
	}
}


void* CIRC_Alloc(int size)
{
	void* ret;
	
	size = (size + 3) & -4;

	if (&circBuf[sizeof(circBuf)] < (char*)circWhere + size)
	{
		ret = &circBuf[0];

		circWhere = (char*)circWhere + size;

		return ret;
	}
	else
	{
		ret = circWhere;

		circWhere = (char*)circWhere + size;

		return circWhere;
	}
}


// autogenerated function stub: 
// int /*$ra*/ SetCollideInfoData(struct _CollideInfo *srcCI /*$s0*/)
int SetCollideInfoData(struct _CollideInfo *srcCI)
{ // line 298, offset 0x80070884
	/* begin block 1 */
		// Start line: 299
		// Start offset: 0x80070884
		// Variables:
			struct _CollideInfo *Ptr; // $v0
	/* end block 1 */
	// End offset: 0x800708D0
	// End Line: 305

	/* begin block 2 */
		// Start line: 494
	/* end block 2 */
	// End Line: 495
			UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ SetMonsterHitData(struct _Instance *Sender /*$s1*/, struct _Instance *lastHit /*$s2*/, int Power /*$s3*/, int knockBackDistance /*$s4*/, int knockBackFrames /*stack 16*/)
int SetMonsterHitData(struct _Instance *Sender, struct _Instance *lastHit, int Power, int knockBackDistance, int knockBackFrames)
{ // line 315, offset 0x800708e0
	/* begin block 1 */
		// Start line: 316
		// Start offset: 0x800708E0
		// Variables:
			struct evMonsterHitData *Ptr; // $v0
	/* end block 1 */
	// End offset: 0x800708E0
	// End Line: 316

	/* begin block 2 */
		// Start line: 528
	/* end block 2 */
	// End Line: 529
			UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ SetMonsterThrownData(struct _Instance *Sender /*$s1*/, struct _Rotation *Direction /*$s0*/, int Power /*$s2*/)
int SetMonsterThrownData(struct _Instance *Sender, struct _Rotation *Direction, int Power)
{ // line 332, offset 0x8007094c
	/* begin block 1 */
		// Start line: 333
		// Start offset: 0x8007094C
		// Variables:
			struct evMonsterThrownData *Ptr; // $v0
	/* end block 1 */
	// End offset: 0x8007094C
	// End Line: 333

	/* begin block 2 */
		// Start line: 562
	/* end block 2 */
	// End Line: 563
			UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ SetMonsterAlarmData(struct _Instance *sender /*$s1*/, _Position *position /*$s0*/, int type /*$s2*/)
int SetMonsterAlarmData(struct _Instance *sender, _Position *position, int type)
{ // line 348, offset 0x800709b4
	/* begin block 1 */
		// Start line: 349
		// Start offset: 0x800709B4
		// Variables:
			struct evMonsterAlarmData *Ptr; // $v0
	/* end block 1 */
	// End offset: 0x800709B4
	// End Line: 349

	/* begin block 2 */
		// Start line: 595
	/* end block 2 */
	// End Line: 596
			UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ SetMonsterSoulSuckData(struct _Instance *Sender /*$s0*/, int x /*$s1*/, int y /*$s2*/, int z /*$s3*/)
int SetMonsterSoulSuckData(struct _Instance *Sender, int x, int y, int z)
{ // line 365, offset 0x80070a1c
	/* begin block 1 */
		// Start line: 366
		// Start offset: 0x80070A1C
		// Variables:
			struct evMonsterSoulSuckData *Ptr; // $v0
	/* end block 1 */
	// End offset: 0x80070A1C
	// End Line: 366

	/* begin block 2 */
		// Start line: 630
	/* end block 2 */
	// End Line: 631
			UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ SetMonsterImpaleData(struct _Instance *weapon /*$s2*/, struct _Rotation *direction /*$s0*/, _Position *position /*$s1*/, int distance /*$s3*/)
int SetMonsterImpaleData(struct _Instance *weapon, struct _Rotation *direction, _Position *position, int distance)
{ // line 382, offset 0x80070a78
	/* begin block 1 */
		// Start line: 383
		// Start offset: 0x80070A78
		// Variables:
			struct evMonsterImpaleData *Ptr; // $v0
	/* end block 1 */
	// End offset: 0x80070A78
	// End Line: 383

	/* begin block 2 */
		// Start line: 664
	/* end block 2 */
	// End Line: 665
			UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ SetObjectData(int x /*$s1*/, int y /*$s2*/, int PathNumber /*$s3*/, struct _Instance *Force /*$s4*/, int node /*stack 16*/)
int SetObjectData(int x, int y, int PathNumber, struct _Instance *Force, int node)
{ // line 403, offset 0x80070b10
	/* begin block 1 */
		// Start line: 404
		// Start offset: 0x80070B10
		// Variables:
			struct evObjectData *Ptr; // $v0
	/* end block 1 */
	// End offset: 0x80070B10
	// End Line: 404

	/* begin block 2 */
		// Start line: 707
	/* end block 2 */
	// End Line: 708
			UNIMPLEMENTED();
	return 0;
}

int SetPositionData(int x, int y, int z)
{
	struct evPositionData* Ptr;
	
	Ptr = (struct evPositionData*)CIRC_Alloc(sizeof(struct evPositionData));

	Ptr->x = x;
	Ptr->y = y;
	Ptr->z = z;

	return (int)Ptr;
}

int SetPhysicsGravityData(int UpperOffset, int LowerOffset, int x, int y, int z, int slope)
{
	struct evPhysicsGravityData* Ptr;
	
	Ptr = (struct evPhysicsGravityData*)CIRC_Alloc(sizeof(struct evPhysicsGravityData));
	Ptr->UpperOffset = UpperOffset;
	Ptr->LowerOffset = LowerOffset;
	Ptr->x = x;
	Ptr->y = y;
	Ptr->z = z;
	Ptr->slipSlope = slope;
	
	return (int)Ptr;
}


// autogenerated function stub: 
// int /*$ra*/ SetPhysicsEdgeData(int UpperOffset /*$s5*/, int ForwardOffset /*$s6*/, int AboveOffset /*$s7*/, int x /*$fp*/, int y /*stack 16*/, int z /*stack 20*/, struct _SVector *Normal1 /*stack 24*/, struct _SVector *Normal2 /*stack 28*/, struct _SVector *Delta /*stack 32*/)
int SetPhysicsEdgeData(int UpperOffset, int ForwardOffset, int AboveOffset, int x, int y, int z, struct _SVector *Normal1, struct _SVector *Normal2, struct _SVector *Delta)
{ // line 462, offset 0x80070c44
	/* begin block 1 */
		// Start line: 463
		// Start offset: 0x80070C44
		// Variables:
			struct evPhysicsEdgeData *Ptr; // $v0
	/* end block 1 */
	// End offset: 0x80070C44
	// End Line: 463

	/* begin block 2 */
		// Start line: 825
	/* end block 2 */
	// End Line: 826
			UNIMPLEMENTED();
	return 0;
}

int SetPhysicsSwimData(int CheckDepth, struct _SVector* iVelocity, int SwimDepth, int WadeDepth, int TreadDepth)
{
	struct evPhysicsSwimData* Ptr;

	Ptr = (struct evPhysicsSwimData*)CIRC_Alloc(sizeof(struct evPhysicsSwimData));

	Ptr->CheckDepth = CheckDepth;
	Ptr->iVelocity = iVelocity;
	Ptr->SwimDepth = SwimDepth;
	Ptr->WadeDepth = WadeDepth;
	Ptr->TreadDepth = TreadDepth;
	
	return (int)Ptr;
}


// autogenerated function stub: 
// int /*$ra*/ SetPhysicsDropOffData(int xOffset /*$s1*/, int yOffset /*$s2*/, int DropOffset /*$s3*/, int slipSlope /*$s4*/, int UpperOffset /*stack 16*/)
int SetPhysicsDropOffData(int xOffset, int yOffset, int DropOffset, int slipSlope, int UpperOffset)
{ // line 503, offset 0x80070d5c
	/* begin block 1 */
		// Start line: 504
		// Start offset: 0x80070D5C
		// Variables:
			struct evPhysicsDropOffData *Ptr; // $v0
	/* end block 1 */
	// End offset: 0x80070D5C
	// End Line: 504

	/* begin block 2 */
		// Start line: 907
	/* end block 2 */
	// End Line: 908
			UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ SetPhysicsSlideData(int Segment /*$s3*/, int ForwardVectorX /*$s4*/, int ForwardVectorY /*$s5*/, int ForwardVectorZ /*$s6*/, int DropOffset /*stack 16*/, int UpperOffset /*stack 20*/, int Height /*stack 24*/)
int SetPhysicsSlideData(int Segment, int ForwardVectorX, int ForwardVectorY, int ForwardVectorZ, int DropOffset, int UpperOffset, int Height)
{ // line 523, offset 0x80070dc8
	/* begin block 1 */
		// Start line: 524
		// Start offset: 0x80070DC8
		// Variables:
			struct evPhysicsSlideData *Ptr; // $v0
	/* end block 1 */
	// End offset: 0x80070DC8
	// End Line: 524

	/* begin block 2 */
		// Start line: 947
	/* end block 2 */
	// End Line: 948
			UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ SetPhysicsWallCrawlData(int Segment /*$s0*/, int Length /*$s1*/, int ForwardOffset /*$s2*/, int NormalDistance /*$s3*/)
int SetPhysicsWallCrawlData(int Segment, int Length, int ForwardOffset, int NormalDistance)
{ // line 544, offset 0x80070e54
	/* begin block 1 */
		// Start line: 545
		// Start offset: 0x80070E54
		// Variables:
			struct evPhysicsWallCrawlData *Ptr; // $v0
	/* end block 1 */
	// End offset: 0x80070E54
	// End Line: 545

	/* begin block 2 */
		// Start line: 989
	/* end block 2 */
	// End Line: 990
			UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ SetPhysicsLinkedMoveData(struct _Instance *instance /*$s1*/, int segment /*$s0*/, struct _SVector *posDelta /*$s2*/, struct _SVector *rotDelta /*$s3*/)
int SetPhysicsLinkedMoveData(struct _Instance *instance, int segment, struct _SVector *posDelta, struct _SVector *rotDelta)
{ // line 561, offset 0x80070eb0
	/* begin block 1 */
		// Start line: 562
		// Start offset: 0x80070EB0
		// Variables:
			struct evPhysicsLinkedMoveData *Ptr; // $v0
	/* end block 1 */
	// End offset: 0x80070F34
	// End Line: 574

	/* begin block 2 */
		// Start line: 1023
	/* end block 2 */
	// End Line: 1024
			UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ SetPhysicsDropHeightData(_Position *offset /*$s0*/, int dropOffset /*$s1*/, int mode /*$s2*/)
int SetPhysicsDropHeightData(_Position *offset, int dropOffset, int mode)
{ // line 582, offset 0x80070f50
	/* begin block 1 */
		// Start line: 583
		// Start offset: 0x80070F50
		// Variables:
			struct evPhysicsDropHeightData *ptr; // $v0
	/* end block 1 */
	// End offset: 0x80070F50
	// End Line: 583

	/* begin block 2 */
		// Start line: 1065
	/* end block 2 */
	// End Line: 1066
			UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ SetAnimationControllerDoneData(struct _Instance *instance /*$s0*/, long segment /*$s1*/, long type /*$s2*/, int data /*$s3*/)
int SetAnimationControllerDoneData(struct _Instance *instance, long segment, long type, int data)
{ // line 602, offset 0x80070fc0
	/* begin block 1 */
		// Start line: 603
		// Start offset: 0x80070FC0
		// Variables:
			struct evAnimationControllerDoneData *Ptr; // $v0
	/* end block 1 */
	// End offset: 0x80070FC0
	// End Line: 603

	/* begin block 2 */
		// Start line: 1105
	/* end block 2 */
	// End Line: 1106
			UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ SetAnimationInstanceSwitchData(struct _Instance *instance /*$s1*/, int anim /*$s2*/, int frame /*$s3*/, int frames /*$s4*/, int mode /*stack 16*/)
int SetAnimationInstanceSwitchData(struct _Instance *instance, int anim, int frame, int frames, int mode)
{ // line 620, offset 0x8007101c
	/* begin block 1 */
		// Start line: 621
		// Start offset: 0x8007101C
		// Variables:
			struct evAnimationInstanceSwitchData *Ptr; // $v0
	/* end block 1 */
	// End offset: 0x8007101C
	// End Line: 621

	/* begin block 2 */
		// Start line: 1141
	/* end block 2 */
	// End Line: 1142
			UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ SetFXHitData(struct _Instance *hitter /*$s2*/, int segment /*$s3*/, int amount /*$s0*/, int type /*$s1*/)
int SetFXHitData(struct _Instance *hitter, int segment, int amount, int type)
{ // line 639, offset 0x80071088
	/* begin block 1 */
		// Start line: 640
		// Start offset: 0x80071088
		// Variables:
			struct evFXHitData *Ptr; // $a1
	/* end block 1 */
	// End offset: 0x80071164
	// End Line: 656

	/* begin block 2 */
		// Start line: 1179
	/* end block 2 */
	// End Line: 1180
			UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ SetObjectThrowData(void *target /*$s2*/, struct _SVector *angularVel /*$s7*/, unsigned short type /*$s0*/, unsigned short spinType /*$s1*/, int speed /*stack 16*/, int gravity /*stack 20*/, int zVel /*stack 24*/, int initialXRot /*stack 28*/)
int SetObjectThrowData(void *target, struct _SVector *angularVel, unsigned short type, unsigned short spinType, int speed, int gravity, int zVel, int initialXRot)
{ // line 693, offset 0x80071184
	/* begin block 1 */
		// Start line: 694
		// Start offset: 0x80071184
		// Variables:
			struct evObjectThrowData *Ptr; // $a0
	/* end block 1 */
	// End offset: 0x800712B0
	// End Line: 746

	/* begin block 2 */
		// Start line: 1386
	/* end block 2 */
	// End Line: 1387
			UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ SetObjectBreakOffData(struct _Instance *force /*$s3*/, short node /*$a1*/, short distance /*$a2*/, short animation /*$a3*/, int frame /*stack 16*/, int type /*stack 20*/, int action /*stack 24*/)
int SetObjectBreakOffData(struct _Instance *force, short node, short distance, short animation, int frame, int type, int action)
{ // line 750, offset 0x800712f0
	/* begin block 1 */
		// Start line: 751
		// Start offset: 0x800712F0
		// Variables:
			struct evObjectBreakOffData *Ptr; // $v0
	/* end block 1 */
	// End offset: 0x800712F0
	// End Line: 751

	/* begin block 2 */
		// Start line: 1369
	/* end block 2 */
	// End Line: 1370
			UNIMPLEMENTED();
	return 0;
}

int SetControlInitHangData(struct _Instance* instance, long frame, long frames)
{
	struct evControlInitHangData* Ptr;
	
	Ptr = (struct evControlInitHangData*)CIRC_Alloc(sizeof(struct evControlInitHangData));

	Ptr->instance = instance;
	Ptr->frame = frame;
	Ptr->frames = frames;
	
	return (int)Ptr;
}

int SetControlInitIdleData(int mode, long frame, long frames)
{
	struct evControlInitIdleData* Ptr;

	Ptr = (struct evControlInitIdleData*)CIRC_Alloc(sizeof(struct evControlInitIdleData));
	
	Ptr->mode = mode;
	Ptr->frame = frame;
	Ptr->frames = frames;

	return (int)Ptr;
}


// autogenerated function stub: 
// int /*$ra*/ SetObjectDraftData(short force /*$a0*/, unsigned short radius /*$a1*/, unsigned short radiusCoef /*$a2*/, unsigned short height /*$a3*/, int maxVelocity /*stack 16*/)
int SetObjectDraftData(short force, unsigned short radius, unsigned short radiusCoef, unsigned short height, int maxVelocity)
{ // line 795, offset 0x80071414
	/* begin block 1 */
		// Start line: 796
		// Start offset: 0x80071414
		// Variables:
			struct evObjectDraftData *Ptr; // $v0
	/* end block 1 */
	// End offset: 0x80071414
	// End Line: 796

	/* begin block 2 */
		// Start line: 1459
	/* end block 2 */
	// End Line: 1460
			UNIMPLEMENTED();
	return 0;
}

int SetObjectAbsorbData(struct _Instance* force, unsigned short node, unsigned short steps)
{
	struct evObjectAbsorbData* Ptr;

	Ptr = (struct evObjectAbsorbData*)CIRC_Alloc(sizeof(struct evObjectAbsorbData));

	Ptr->force = force;
	Ptr->node = node;
	Ptr->steps = steps;

	return (int)Ptr;
}

int SetControlSaveDataData(long length, void* data)
{
	struct evControlSaveDataData* Ptr;
	
	Ptr = (struct evControlSaveDataData*)CIRC_Alloc(sizeof(struct evControlSaveDataData));

	Ptr->length = length;
	Ptr->data = data;

	return (int)Ptr;
}

int SetObjectIdleData(long mode, struct _Instance* instance)
{
	struct evObjectIdleData* Ptr;
	
	Ptr = (struct evObjectIdleData*)CIRC_Alloc(sizeof(struct evObjectIdleData));

	Ptr->mode = mode;
	Ptr->instance = instance;
	
	return (int)Ptr;
}


// autogenerated function stub: 
// int /*$ra*/ SetActionPlayHostAnimationData(struct _Instance *instance /*$s2*/, struct _Instance *host /*$s3*/, int newAnim /*$s4*/, int newFrame /*$s5*/, int frames /*stack 16*/, int mode /*stack 20*/)
int SetActionPlayHostAnimationData(struct _Instance *instance, struct _Instance *host, int newAnim, int newFrame, int frames, int mode)
{ // line 869, offset 0x80071544
	/* begin block 1 */
		// Start line: 870
		// Start offset: 0x80071544
		// Variables:
			struct evActionPlayHostAnimationData *Ptr; // $v0
	/* end block 1 */
	// End offset: 0x80071544
	// End Line: 870

	/* begin block 2 */
		// Start line: 1738
	/* end block 2 */
	// End Line: 1739
			UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ SetObjectBirthProjectileData(struct _Instance *instance /*$s0*/, int joint /*$s1*/, int type /*$s2*/)
int SetObjectBirthProjectileData(struct _Instance *instance, int joint, int type)
{ // line 888, offset 0x800715c0
	/* begin block 1 */
		// Start line: 889
		// Start offset: 0x800715C0
		// Variables:
			struct evObjectBirthProjectileData *Ptr; // $v0
	/* end block 1 */
	// End offset: 0x800715C0
	// End Line: 889

	/* begin block 2 */
		// Start line: 1625
	/* end block 2 */
	// End Line: 1626
			UNIMPLEMENTED();
	return 0;
}

int SetShadowSegmentData(unsigned long total)
{
	struct evShadowSegmentData* Ptr;
	
	Ptr = (struct evShadowSegmentData*)CIRC_Alloc(sizeof(struct evShadowSegmentData));

	Ptr->totalShadowSegments = total;

	return (int)Ptr;
}

void G2EmulationInit()//Matching - 98.37%
{
	G2AlphaTables[0] = NULL;

	if (G2AlphaTables[1] == NULL)
	{
		G2AlphaTables[1] = (struct _G2AnimAlphaTable_Type*)MEMPACK_Malloc(0x12, 0x19);
		G2AlphaTables[1]->size = 4;
		G2AlphaTables[1]->data[0] = 0;
		G2AlphaTables[1]->data[1] = 256;
		G2AlphaTables[1]->data[2] = 1024;
		G2AlphaTables[1]->data[3] = 4096;
	}

	if (G2AlphaTables[2] == NULL)
	{
		G2AlphaTables[2] = (struct _G2AnimAlphaTable_Type*)MEMPACK_Malloc(0x12, 0x19);
		G2AlphaTables[2]->size = 4;
		G2AlphaTables[2]->data[0] = 0;
		G2AlphaTables[2]->data[1] = 3072;
		G2AlphaTables[2]->data[2] = 3840;
		G2AlphaTables[2]->data[3] = 4096;
	}

	if (G2AlphaTables[3] == NULL)
	{
		G2AlphaTables[3] = (struct _G2AnimAlphaTable_Type*)MEMPACK_Malloc(0x6, 0x19);
		G2AlphaTables[3]->size = 1;
		G2AlphaTables[3]->data[0] = 4096;
	}

	if (G2AlphaTables[4] == NULL)
	{
		G2AlphaTables[4] = (struct _G2AnimAlphaTable_Type*)MEMPACK_Malloc(0x12, 0x19);
		G2AlphaTables[4]->size = 4;
		G2AlphaTables[4]->data[0] = 0;
		G2AlphaTables[4]->data[1] = 256;
		G2AlphaTables[4]->data[2] = 3840;
		G2AlphaTables[4]->data[3] = 4096;
	}

	if (G2AlphaTables[5] == NULL)
	{
		G2AlphaTables[5] = (struct _G2AnimAlphaTable_Type*)MEMPACK_Malloc(0x12, 0x19);
		G2AlphaTables[5]->size = 4;
		G2AlphaTables[5]->data[0] = 0;
		G2AlphaTables[5]->data[1] = 128;
		G2AlphaTables[5]->data[2] = 512;
		G2AlphaTables[5]->data[3] = 4096;
	}

	if (G2AlphaTables[6] == NULL)
	{
		G2AlphaTables[6] = (struct _G2AnimAlphaTable_Type*)MEMPACK_Malloc(0x12, 0x19);
		G2AlphaTables[6]->size = 4;
		G2AlphaTables[6]->data[0] = 0;
		G2AlphaTables[6]->data[1] = 3584;
		G2AlphaTables[6]->data[2] = 3968;
		G2AlphaTables[6]->data[3] = 4096;
	}
}

void G2EmulationInstancePlayAnimation(struct _Instance* instance)
{
	int i;
	struct _G2Anim_Type* anim;
	
	anim = &instance->anim;

	for (i = 0; i < anim->sectionCount; i++)
	{
		G2AnimSection_NextKeyframe(&anim->section[i]);
	}
}

void G2EmulatePlayAnimation(struct __CharacterState* In)
{
	G2EmulationInstancePlayAnimation(In->CharacterInstance);
}


// autogenerated function stub: 
// void /*$ra*/ G2EmulationInstanceToInstanceSwitchAnimation(struct _Instance *instance /*$a0*/, struct _Instance *host /*$a1*/, int CurrentSection /*$a2*/, int NewAnim /*$s2*/, int NewFrame /*stack 16*/, int Frames /*stack 20*/, int Mode /*stack 24*/)
void G2EmulationInstanceToInstanceSwitchAnimation(struct _Instance *instance, struct _Instance *host, int CurrentSection, int NewAnim, int NewFrame, int Frames, int Mode)
{ // line 1006, offset 0x800718b4
	/* begin block 1 */
		// Start line: 1007
		// Start offset: 0x800718B4
		// Variables:
			struct _G2AnimSection_Type *animSection; // $s4
			struct _G2AnimKeylist_Type *keylist; // $s1
	/* end block 1 */
	// End offset: 0x80071988
	// End Line: 1028

	/* begin block 2 */
		// Start line: 1880
	/* end block 2 */
	// End Line: 1881
			UNIMPLEMENTED();
}

void G2EmulationInstanceSwitchAnimation(struct _Instance* instance, int CurrentSection, int NewAnim, int NewFrame, int Frames, int Mode)//Matching - 99.43%
{
	struct _G2AnimSection_Type* animSection;
	struct _G2AnimKeylist_Type* keylist;

	animSection = &instance->anim.section[CurrentSection];

	keylist = G2Instance_GetKeylist(instance, NewAnim);

	G2AnimSection_SetAlphaTable(animSection, NULL);

	G2AnimSection_InterpToKeylistFrame(animSection, keylist, NewAnim, NewFrame, (short)(Frames * 100));

	if (Mode == 0)
	{
		G2AnimSection_SetPaused(animSection);
	}
	else
	{
		G2AnimSection_SetUnpaused(animSection);

		if (Mode == 2)
		{
			G2AnimSection_SetLooping(animSection);
		}
		else
		{
			G2AnimSection_SetNoLooping(animSection);
		}
	}
}
void G2EmulationInstanceSwitchAnimationAlpha(struct _Instance* instance, int CurrentSection, int NewAnim, int NewFrame, int Frames, int Mode, int AlphaTable)
{
#if defined(PSX_VERSION)
	struct _G2AnimSection_Type* animSection;

	animSection = &instance->anim.section[CurrentSection];

	G2EmulationInstanceSwitchAnimation(instance, CurrentSection, NewAnim, NewFrame, Frames, Mode);

	G2AnimSection_SetAlphaTable(animSection, G2AlphaTables[AlphaTable]);

#elif defined(PC_VERSION)
	struct _G2AnimSection_Type* v7; // esi
	struct _G2AnimKeylist_Type* Keylist; // ebx

	v7 = &instance->anim.section[CurrentSection];
	Keylist = G2Instance_GetKeylist(instance, NewAnim);
	G2AnimSection_SetAlphaTable(v7, 0);
	G2AnimSection_InterpToKeylistFrame(v7, Keylist, NewAnim, NewFrame, 100 * Frames);
	if (Mode)
	{
		G2AnimSection_SetUnpaused(v7);
		if (Mode == 2)
			G2AnimSection_SetLooping(v7);
		else
			G2AnimSection_SetNoLooping(v7);
	}
	else
	{
		G2AnimSection_SetPaused(v7);
	}
	G2AnimSection_SetAlphaTable(&instance->anim.section[(unsigned __int8)CurrentSection], (&table)[AlphaTable]);
#endif
}

void G2EmulationSwitchAnimation(struct __CharacterState* In, int CurrentSection, int NewAnim, int NewFrame, int Frames, int Mode)
{
	if (NewAnim < 0)
	{
		NewAnim = 0;
	}

	G2EmulationInstanceSwitchAnimation(In->CharacterInstance, CurrentSection, NewAnim, NewFrame, Frames, Mode);
}

void G2EmulationSwitchAnimationAlpha(struct __CharacterState* In, int CurrentSection, int NewAnim, int NewFrame, int Frames, int Mode, int AlphaTable)//Matching - 93.79%
{
	struct _G2AnimSection_Type* animSection;

	animSection = &In->CharacterInstance->anim.section[(char)CurrentSection];

	G2EmulationInstanceSwitchAnimation(In->CharacterInstance, CurrentSection, NewAnim, NewFrame, Frames, Mode);

	G2AnimSection_SetAlphaTable(animSection, G2AlphaTables[AlphaTable]);
}


// autogenerated function stub: 
// void /*$ra*/ G2EmulationSwitchAnimationSync(struct __CharacterState *In /*stack 0*/, int SlaveSectionID /*$fp*/, int MasterSectionID /*$a2*/, int Frames /*stack 12*/)
void G2EmulationSwitchAnimationSync(struct __CharacterState *In, int SlaveSectionID, int MasterSectionID, int Frames)
{ // line 1093, offset 0x80071bc4
	/* begin block 1 */
		// Start line: 1094
		// Start offset: 0x80071BC4
		// Variables:
			struct _Instance *instance; // $a1
			struct _G2AnimSection_Type *masterAnimSection; // $s6
			struct _G2AnimSection_Type *slaveAnimSection; // $s5
			struct _G2AnimKeylist_Type *keylist; // $s1
			int keylistID; // $s3
			struct __State *masterSection; // $s7
			struct __State *slaveSection; // $s2
	/* end block 1 */
	// End offset: 0x80071D34
	// End Line: 1130

	/* begin block 2 */
		// Start line: 2097
	/* end block 2 */
	// End Line: 2098
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ G2EmulationInstanceToInstanceSwitchAnimationCharacter(struct _Instance *instance /*$s0*/, struct _Instance *host /*$a1*/, int NewAnim /*$s2*/, int NewFrame /*$s3*/, int Frames /*stack 16*/, int Mode /*stack 20*/)
void G2EmulationInstanceToInstanceSwitchAnimationCharacter(struct _Instance *instance, struct _Instance *host, int NewAnim, int NewFrame, int Frames, int Mode)
{ // line 1137, offset 0x80071d90
	/* begin block 1 */
		// Start line: 1138
		// Start offset: 0x80071D90
		// Variables:
			struct _G2AnimKeylist_Type *keylist1; // $s0
	/* end block 1 */
	// End offset: 0x80071E58
	// End Line: 1160

	/* begin block 2 */
		// Start line: 2208
	/* end block 2 */
	// End Line: 2209
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ G2EmulationSwitchAnimationCharacter(struct __CharacterState *In /*$a0*/, int NewAnim /*$s2*/, int NewFrame /*$s5*/, int Frames /*$s3*/, int Mode /*stack 16*/)
void G2EmulationSwitchAnimationCharacter(struct __CharacterState *In, int NewAnim, int NewFrame, int Frames, int Mode)
{ // line 1164, offset 0x80071e7c
	/* begin block 1 */
		// Start line: 1165
		// Start offset: 0x80071E7C
		// Variables:
			struct _Instance *instance; // $s0
			struct _G2AnimKeylist_Type *keylist; // $s0
	/* end block 1 */
	// End offset: 0x80071F4C
	// End Line: 1192

	/* begin block 2 */
		// Start line: 2270
	/* end block 2 */
	// End Line: 2271
			UNIMPLEMENTED();
}

void G2EmulationInstanceSetAnimation(struct _Instance *instance, int CurrentSection, int NewAnim, int NewFrame, int Frames)
{
	struct _G2AnimSection_Type *animSection;
	struct _G2AnimKeylist_Type *keylist;

	animSection = &instance->anim.section[CurrentSection];
	
	keylist = G2Instance_GetKeylist(instance, NewAnim);
	
	G2AnimSection_SetAlphaTable(animSection, NULL);
	
	G2AnimSection_InterpToKeylistFrame(animSection, keylist, NewAnim, NewFrame, Frames * 100);
}

void G2EmulationSetAnimation(struct __CharacterState *In, int CurrentSection, int NewAnim, int NewFrame, int Frames)
{
#if defined(PSX_VERSION)

	if (NewAnim < 0)
	{
		NewAnim = 0;
	}
	
	G2EmulationInstanceSetAnimation(In->CharacterInstance, CurrentSection, NewAnim, NewFrame, Frames);
#endif
}

void G2EmulationInstanceSetMode(struct _Instance* instance, int CurrentSection, int Mode)
{
	struct _G2AnimSection_Type* animSection;

	animSection = &instance->anim.section[CurrentSection];

	if (Mode == 0)
	{
		G2AnimSection_SetPaused(animSection);
	}
	else
	{
		G2AnimSection_SetUnpaused(animSection);

		if (Mode == 1)
		{
			G2AnimSection_SetNoLooping(animSection);
		}
		else
		{
			G2AnimSection_SetLooping(animSection);
		}
	}
}

void G2EmulationSetMode(struct __CharacterState *In, int CurrentSection, int Mode)
{ 
	G2EmulationInstanceSetMode(In->CharacterInstance, CurrentSection, Mode);
}

void G2EmulationInstanceSetAnimSpeed(struct _Instance* instance, int CurrentSection, int speed)
{
	struct _G2AnimSection_Type* animSection;

	animSection = &instance->anim.section[CurrentSection];

	animSection->speedAdjustment = speed;
}

int G2EmulationInstanceQueryAnimation(struct _Instance* instance, int CurrentSection)
{
	struct _G2AnimSection_Type* animSection;
	
	animSection = &instance->anim.section[CurrentSection];

	return animSection->keylistID;
}

int G2EmulationQueryAnimation(struct __CharacterState* In, int CurrentSection)
{
	return G2EmulationInstanceQueryAnimation(In->CharacterInstance, CurrentSection);
}

int G2EmulationInstanceQueryFrame(struct _Instance* instance, int CurrentSection)
{
	return G2AnimSection_GetKeyframeNumber(&instance->anim.section[CurrentSection]);
}

int G2EmulationInstanceQueryLastFrame(struct _Instance* instance, int CurrentSection)
{
	return G2AnimSection_GetStoredKeyframeNumber(&instance->anim.section[CurrentSection]);
}


// autogenerated function stub: 
// int /*$ra*/ G2EmulationInstanceQueryPassedFrame(struct _Instance *instance /*$s2*/, int CurrentSection /*$a1*/, int frame /*$s1*/)
int G2EmulationInstanceQueryPassedFrame(struct _Instance *instance, int CurrentSection, int frame)
{ // line 1314, offset 0x800721bc
	/* begin block 1 */
		// Start line: 1315
		// Start offset: 0x800721BC
		// Variables:
			struct _G2AnimSection_Type *animSection; // $s0
	/* end block 1 */
	// End offset: 0x8007224C
	// End Line: 1329

	/* begin block 2 */
		// Start line: 2594
	/* end block 2 */
	// End Line: 2595
			UNIMPLEMENTED();
	return 0;
}

int G2EmulationQueryFrame(struct __CharacterState* In, int CurrentSection)
{
	return G2EmulationInstanceQueryFrame(In->CharacterInstance, CurrentSection);
}

int G2EmulationInstanceQueryMode(struct _Instance* instance, int CurrentSection)
{
	struct _G2AnimSection_Type* animSection;
	
	animSection = &instance->anim.section[CurrentSection];

	if (!(animSection->flags & 0x1) && !(animSection->flags & 0x2))
	{
		return 1;
	}
	
	return 0;
}

int G2EmulationQueryMode(struct __CharacterState* In, int CurrentSection)
{
	return G2EmulationInstanceQueryMode(In->CharacterInstance, CurrentSection);
}

void G2EmulationInstanceSetStartAndEndSegment(struct _Instance *instance, int CurrentSection, short Start, short End)
{
	struct _G2AnimSection_Type *animSection;
	
	animSection = &instance->anim.section[CurrentSection];
	animSection->firstSeg = Start;
	animSection->segCount = (End - Start) + 1;
}

void G2EmulationSetStartAndEndSegment(struct __CharacterState *In, int CurrentSection, short Start, short End)
{ 
	G2EmulationInstanceSetStartAndEndSegment(In->CharacterInstance, CurrentSection, Start, End);
}

void G2EmulationInstanceSetTotalSections(struct _Instance *instance, short Total)
{
	struct _G2Anim_Type *anim;
	
	anim = &instance->anim;
	
	while (anim->sectionCount < Total)
	{
		G2Anim_AddSection(anim, 0, 0);
	}

	G2Anim_SetCallback(anim, INSTANCE_DefaultAnimCallback, instance);
}

void G2EmulationSetTotalSections(struct __CharacterState* In, short Total)
{
	In->TotalSections = Total;
	
	G2EmulationInstanceSetTotalSections(In->CharacterInstance, In->TotalSections);
}

void G2EmulationInstanceInitSection(struct _Instance* instance, int CurrentSection, void* callback, void* data)
{
	struct _G2AnimSection_Type* animSection;

	typedef unsigned long fn(struct _G2Anim_Type*, int, enum _G2AnimCallbackMsg_Enum, long, long, struct _Instance*);

	animSection = &instance->anim.section[CurrentSection & 0xFF];

	animSection->callback = (fn*)callback;

	animSection->callbackData = data;
}


// autogenerated function stub: 
// void /*$ra*/ G2EmulationSetInterpController_Vector(struct _Instance *instance /*$a0*/, long segment /*$a1*/, long type /*$a2*/, struct _G2SVector3_Type *vec /*$a3*/, int Frames /*stack 16*/, int Data /*stack 20*/)
void G2EmulationSetInterpController_Vector(struct _Instance *instance, long segment, long type, struct _G2SVector3_Type *vec, int Frames, int Data)
{ // line 1440, offset 0x80072428
	/* begin block 1 */
		// Start line: 2880
	/* end block 1 */
	// End Line: 2881
	UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ StateSwitchStateDataDefault(struct __CharacterState *In /*$s1*/, int CurrentSection /*$s0*/, TDRFuncPtr_StateSwitchStateDataDefault2NewProcess NewProcess /*$a2*/, int Data /*$a3*/)
void StateSwitchStateDataDefault(struct __CharacterState *In, int CurrentSection, TDRFuncPtr_StateSwitchStateDataDefault2NewProcess NewProcess, int Data)
{ // line 1456, offset 0x800724b0
	/* begin block 1 */
		// Start line: 1457
		// Start offset: 0x800724B0
		// Variables:
			void (*process)(); // $s2
	/* end block 1 */
	// End offset: 0x800724B0
	// End Line: 1457

	/* begin block 2 */
		// Start line: 2907
	/* end block 2 */
	// End Line: 2908
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ StateSwitchStateCharacterDataDefault(struct __CharacterState *In /*$s1*/, TDRFuncPtr_StateSwitchStateCharacterDataDefault1NewProcess NewProcess /*$s2*/, int Data /*$s3*/)
void StateSwitchStateCharacterDataDefault(struct __CharacterState *In, TDRFuncPtr_StateSwitchStateCharacterDataDefault1NewProcess NewProcess, int Data)
{ // line 1465, offset 0x80072518
	/* begin block 1 */
		// Start line: 1466
		// Start offset: 0x80072518
		// Variables:
			int i; // $s0
	/* end block 1 */
	// End offset: 0x80072574
	// End Line: 1474

	/* begin block 2 */
		// Start line: 2928
	/* end block 2 */
	// End Line: 2929
			UNIMPLEMENTED();
}

void StateSwitchStateData(struct __CharacterState* In, int CurrentSection, void (*NewProcess)(struct __CharacterState* In, int CurrentSection, int Data), int Data)
{
	PurgeMessageQueue(&In->SectionList[CurrentSection].Event);
	EnMessageQueueData(&In->SectionList[CurrentSection].Event, 0x100001, Data);

	In->SectionList[CurrentSection].Process = NewProcess;
	In->SectionList[CurrentSection].Process(In, CurrentSection, 0);

	EnMessageQueueData(&In->SectionList[CurrentSection].Event, 0x100004, 0);
	EnMessageQueueData(&In->SectionList[CurrentSection].Event, 0x100004, 0);
}

void StateSwitchStateCharacterData(struct __CharacterState* In, void (*NewProcess)(struct __CharacterState* In, int CurrentSection, int Data), int Data)//Matching - 99.67%
{
	int i;
	typedef void (*func)(struct __CharacterState* In, int CurrentSection, int Data);
	func callbackProc;

	for (i = 0; i < In->TotalSections; i++)
	{
		PurgeMessageQueue(&In->SectionList[i].Event);

		EnMessageQueueData(&In->SectionList[i].Event, 0x100004, 0);

		callbackProc = (func)In->SectionList[i].Process;
		callbackProc(In, i, 0);

		PurgeMessageQueue(&In->SectionList[i].Event);

		EnMessageQueueData(&In->SectionList[i].Event, 0x100001, Data);

		In->SectionList[i].Process = NewProcess;

		callbackProc = (func)In->SectionList[i].Process;
		callbackProc(In, i, 0);
	}
}

void StateGovernState(struct __CharacterState* In, int Frames)//Matching - 90.26%
{
	struct __State* pSectionA;
	struct __State* pSectionB;
	struct _G2AnimSection_Type* animSectionA;
	struct _G2AnimSection_Type* animSectionB;
	struct _G2AnimKeylist_Type* keylist;
	int keylistID;
	int i;

	for (i = 1; i < 3; i++)
	{
		pSectionA = &In->SectionList[i - 1];
		pSectionB = &In->SectionList[i];

		if (pSectionA->Process == pSectionB->Process)
		{
			animSectionA = &In->CharacterInstance->anim.section[(char)(i - 1)];
			animSectionB = &In->CharacterInstance->anim.section[(char)i];

			if (animSectionA->keylistID == animSectionB->keylistID)
			{
				if (!(G2AnimSection_IsInInterpolation(animSectionA)) && !(G2AnimSection_IsInInterpolation(animSectionB)))
				{
					if (G2AnimSection_GetKeyframeNumber(animSectionA) != G2AnimSection_GetKeyframeNumber(animSectionB))
					{
						keylist = animSectionA->keylist;
						keylistID = animSectionA->keylistID;

						G2AnimSection_InterpToKeylistFrame(animSectionB, keylist, keylistID, (G2AnimSection_GetKeyframeNumber(animSectionA) + Frames) % G2AnimKeylist_GetKeyframeCount(keylist), (short)(Frames * 100));
					}
				}
			}
		}
	}
}