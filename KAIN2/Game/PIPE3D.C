#include "CORE.H"
#include "CAMERA.H"
#include "PIPE3D.H"
#include "GAMELOOP.H"
#include "MATH3D.H"
#include "STREAM.H"
#include "LIGHT3D.H"

void PIPE3D_AspectAdjustMatrix(MATRIX* matrix)
{
	matrix->m[1][0] = matrix->m[1][0];
	matrix->m[1][1] = matrix->m[1][1];
	matrix->m[1][2] = matrix->m[1][2];

	matrix->m[0][0] = (matrix->m[0][0] * 512) / 320;
	matrix->m[0][1] = (matrix->m[0][1] * 512) / 320;
	matrix->m[0][2] = (matrix->m[0][2] * 512) / 320;
}

void PIPE3D_CalculateWCTransform(struct _CameraCore_Type *cameraCore)
{
	MATRIX user_rotation;
	MATRIX first;
	MATRIX* cam_wcTrans;
	SVECTOR v0;
	VECTOR v1;

	cam_wcTrans = cameraCore->wcTransform;
	
	v0.vx = -cameraCore->position.x;
	v0.vy = -cameraCore->position.y;
	v0.vz = -cameraCore->position.z;

	if (!(gameTrackerX.debugFlags & 0x8))
	{
		MATH3D_SetUnityMatrix(&user_rotation);

		v0.vx = -cameraCore->position.x;
		v0.vy = -cameraCore->position.y;
		v0.vz = -cameraCore->position.z;
	}
	else
	{
		MATH3D_SetUnityMatrix(&user_rotation);

		v0.vx = -cameraCore->debugPos.x;
		v0.vy = -cameraCore->debugPos.y;
		v0.vz = -cameraCore->debugPos.z;

		cameraCore->nondebugPos.x = cameraCore->position.x;
		cameraCore->nondebugPos.y = cameraCore->position.y;
		cameraCore->nondebugPos.z = cameraCore->position.z;

		cameraCore->position.x = cameraCore->debugPos.x;
		cameraCore->position.y = cameraCore->debugPos.y;
		cameraCore->position.z = cameraCore->debugPos.z;
	}

	first.m[0][0] = ONE;
	first.m[0][1] = 0;
	first.m[0][2] = 0;

	first.m[1][0] = 0;
	first.m[1][1] = 0;
	first.m[1][2] = -ONE;

	first.m[2][0] = 0;
	first.m[2][1] = ONE;
	first.m[2][2] = 0;

	MulMatrix0(&first, &user_rotation, cam_wcTrans);
	MulMatrix0(&first, &user_rotation, cameraCore->wcTransform2);

	PIPE3D_AspectAdjustMatrix(cam_wcTrans);

	cam_wcTrans->m[0][0] = (cam_wcTrans->m[0][0] * cameraCore->screenScale.x) >> 12;
	cam_wcTrans->m[0][1] = (cam_wcTrans->m[0][1] * cameraCore->screenScale.x) >> 12;
	cam_wcTrans->m[0][2] = (cam_wcTrans->m[0][2] * cameraCore->screenScale.x) >> 12;

	cam_wcTrans->m[1][0] = (cam_wcTrans->m[1][0] * cameraCore->screenScale.y) >> 12;
	cam_wcTrans->m[1][1] = (cam_wcTrans->m[1][1] * cameraCore->screenScale.y) >> 12;
	cam_wcTrans->m[1][2] = (cam_wcTrans->m[1][2] * cameraCore->screenScale.y) >> 12;

	cam_wcTrans->m[2][0] = (cam_wcTrans->m[2][0] * cameraCore->screenScale.z) >> 12;
	cam_wcTrans->m[2][1] = (cam_wcTrans->m[2][1] * cameraCore->screenScale.z) >> 12;
	cam_wcTrans->m[2][2] = (cam_wcTrans->m[2][2] * cameraCore->screenScale.z) >> 12;

	gte_SetRotMatrix(cam_wcTrans);
	gte_ldv0(&v0);
	gte_mvmva(1, 0, 0, 3, 0);
	gte_stlvnl(v1);

	TransMatrix(cam_wcTrans, &v1);

	gte_SetRotMatrix(cameraCore->wcTransform2);
	gte_ldv0(&v0);
	gte_mvmva(1, 0, 0, 3, 0);
	gte_stlvnl(v1);

	TransMatrix(cameraCore->wcTransform2, &v1);
}

void PIPE3D_InvertTransform(MATRIX *target, MATRIX *source)
{
	VECTOR sourceTrans;
	MATRIX normMat;

	if (source->m[2][0] == 1)
	{
		PIPE3D_NormalizeMatrix(target, &normMat);
		TransposeMatrix(&normMat, target);
	}
	else
	{
		TransposeMatrix(source, target);
	}

	sourceTrans.vx = -source->t[0];
	sourceTrans.vy = -source->t[1];
	sourceTrans.vz = -source->t[2];

	ApplyMatrixLV(target, &sourceTrans, (VECTOR*)target->t);
}


// autogenerated function stub: 
// long /*$ra*/ PIPE3D_MatrixColumnLength(MATRIX *transform /*$a0*/, long column /*$a1*/)
long PIPE3D_MatrixColumnLength(MATRIX *transform, long column)
{ // line 174, offset 0x8003a688
	/* begin block 1 */
		// Start line: 175
		// Start offset: 0x8003A688
	/* end block 1 */
	// End offset: 0x8003A688
	// End Line: 175

	/* begin block 2 */
		// Start line: 405
	/* end block 2 */
	// End Line: 406
	UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// void /*$ra*/ PIPE3D_NormalizeMatrix(MATRIX *target /*$s1*/, MATRIX *source /*$s0*/)
void PIPE3D_NormalizeMatrix(MATRIX* target, MATRIX* source)
{
	VECTOR scalevec; // stack offset -32
	long scale; // $v1
	typedef struct {
		long m[3]; // size=12, offset=0
	} tmm;
	typedef struct {
		long m[5]; // size=20, offset=0
	} cmm;
	UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ PIPE3D_TransformVerticesToWorld(struct _Instance *instance /*stack 0*/, struct _SVector *poolVertex /*$s2*/, long *vtxSegment /*$s5*/, struct _Vector *Average /*$fp*/)
void PIPE3D_TransformVerticesToWorld(struct _Instance *instance, struct _SVector *poolVertex, long *vtxSegment, struct _Vector *Average)
{ // line 753, offset 0x8003a7b0
	/* begin block 1 */
		// Start line: 754
		// Start offset: 0x8003A7B0
		// Variables:
			MATRIX *segMatrix; // $s1
			struct _Model *model; // $s7
			struct _MVertex *vertexList; // stack offset -48
			long i; // $s3
			struct _Segment *segment; // $v1
			struct _SVector *orgPoolVertex; // stack offset -44
			struct _SVector minV; // stack offset -64
			struct _SVector maxV; // stack offset -56

		/* begin block 1.1 */
			// Start line: 773
			// Start offset: 0x8003A890
			// Variables:
				struct _MVertex *firstVertex; // $s0
				struct _MVertex *lastVertex; // $s6
				struct _MVertex *modelVertex; // $s0
		/* end block 1.1 */
		// End offset: 0x8003A9DC
		// End Line: 815
	/* end block 1 */
	// End offset: 0x8003AAAC
	// End Line: 840

	/* begin block 2 */
		// Start line: 1506
	/* end block 2 */
	// End Line: 1507
				UNIMPLEMENTED();
}

void PIPE3D_InstanceTransformAndDraw(struct _Instance* instance, struct _CameraCore_Type* cameraCore, struct _VertexPool* vertexPool, struct _PrimPool* primPool, unsigned long** ot, struct _Mirror* mirror)
{
	struct Object* object; // $v0
	struct _Model* model; // $s4
	MATRIX* matrixPool; // $s3
	MATRIX lm; // stack offset -80
	long flags; // $s1
	struct _MVertex* vertexList; // $s0
	struct _PVertex* poolVertex; // $s5
	CVECTOR* vertexColor; // $s6
	long spadOffset; // $v1
	long spadFree; // $a1
	long allocSize; // $a0
	long BackColorSave; // stack offset -44
	long BlendStartSave; // $s0
	int pval; // stack offset -48

	//s2 = instance
	//s1 = cameraCore
	//s0 = vertexPool
	UNIMPLEMENTED();
#if 0
		lw      $v0, 0x1C($s2)
		lh      $v1, 0x126($s2)
		lw      $s3, 0x40($s2)
		lw      $v0, 0xC($v0)
		sll     $v1, 2
		addu    $v1, $v0
		lw      $s4, 0($v1)
		beqz    $s3, loc_8003B384
		move    $s7, $a3
		li      $a1, 0x800
		jal     sub_80035E40
		addiu   $a2, $sp, 0x48 + var_28
		move    $s5, $s0
		addiu   $s6, $s5, 0x1080
		li      $a1, 0xE0
		lw      $a2, 0($s4)
		lw      $s0, 4($s4)
		sll     $a0, $a2, 1
		slt     $v0, $a1, $a0
		bnez    $v0, loc_8003B154
		li      $v1, 0x20  # ' '
		li      $s5, 0x1F800080
		addu    $v1, $a0, $v1
		subu    $a1, $a0

		loc_8003B154 :
	slt     $v0, $a1, $a2
		bnez    $v0, loc_8003B168
		sll     $v1, 2
		lui     $v0, 0x1F80
		addu    $s6, $v1, $v0

		loc_8003B168 :
	jal     sub_800358E4
		move    $a0, $s2
		move    $a0, $s0
		addiu   $s0, $sp, 0x48 + var_28
		sw      $s3, 0x48 + var_38($sp)
		sw      $s0, 0x48 + var_34($sp)
		sw      $s6, 0x48 + var_30($sp)
		lw      $v1, 0x298($s2)
		move    $a1, $s5
		sw      $v1, 0x48 + var_2C($sp)
		lw      $a3, 0x60($s1)
		sw      $v0, -0x6FA4($gp)
		jal     sub_80027170
		move    $a2, $s4
		move    $s1, $v0
		move    $a0, $s2
		li      $a1, 0x1000
		jal     sub_80035E40
		move    $a2, $s0
		move    $a0, $s0
		lh      $a1, 0x106($s2)
		move    $a2, $s0
		sll     $a1, 5
		jal     sub_800BDEFC
		addu    $a1, $s3, $a1
		jal     sub_800BDE7C
		move    $a0, $s0
		andi    $v0, $s1, 0x8000
		beqz    $v0, loc_8003B1E8
		lui     $v0, 0x7FFF
		li      $v0, 0x7FFF6FFF
		and $s1, $v0

		loc_8003B1E8 :
	li      $v0, 0xFFFFEFFF
		and $v0, $s1, $v0
		beqz    $v0, loc_8003B214
		nop
		lw      $v0, 0x1C($s2)
		nop
		lw      $v0, 0x2C($v0)
		nop
		andi    $v0, 0x2000
		beqz    $v0, loc_8003B384
		nop

		loc_8003B214 :
	lw      $v0, 0x10($s4)
		lw      $a0, 8($s7)
		sll     $v1, $v0, 1
		addu    $v1, $v0
		lw      $v0, 4($s7)
		sll     $v1, 4
		addu    $v0, $v1
		sltu    $v0, $a0
		beqz    $v0, loc_8003B384
		move    $s0, $zero
		lw      $v0, 0x1C($s2)
		nop
		lw      $v0, 0x2C($v0)
		nop
		andi    $v0, 0x1000
		bnez    $v0, loc_8003B288
		sw      $zero, 0x48 + var_4($sp)
		lw      $a0, -0x5310($gp)
		jal     SetRotMatrix
		nop
		lw      $a0, -0x5310($gp)
		jal     SetTransMatrix
		nop
		addiu   $v0, $s2, 0x5C  # '\'
		lwc2    $0, 0($v0)
		lwc2    $1, 4($v0)
		nop
		nop
		cop2    0x180001

		loc_8003B288:
	addiu   $v0, $sp, 0x48 + var_8
		swc2    $8, 0($v0)
		lh      $v0, 0x172($s2)
		nop
		beqz    $v0, loc_8003B308
		lui     $v0, 0x70  # 'p'
		li      $v0, 0x707070
		addiu   $a0, $sp, 0x48 + var_4
		addiu   $a1, $gp, -0x6FAC
		lw      $s0, -0x6FB8($gp)
		lw      $v1, -0x6FAC($gp)
		lw      $a2, 0x48 + var_8($sp)
		li      $a3, 0x1000
		sw      $v0, -0x6FAC($gp)
		lw      $v0, -0x6FB4($gp)
		subu    $a3, $a2
		sw      $v1, 0x48 + var_4($sp)
		sw      $v0, -0x6FB8($gp)
		jal     sub_800BCEA0
		sw      $a1, 0x48 + var_38($sp)
		lh      $v0, 0x172($s2)
		lw      $v1, 0x48 + var_8($sp)
		nop
		slt     $v0, $v1
		beqz    $v0, loc_8003B2FC
		nop
		mtc2    $v1, $8
		j       loc_8003B308
		nop

		loc_8003B2FC :
	lhu     $t0, 0x172($s2)
		nop
		mtc2    $t0, $8

		loc_8003B308 :
	lw      $v0, -0x6FA4($gp)
		nop
		slti    $v0, 0xFFE
		beqz    $v0, loc_8003B368
		nop
		lw      $v0, 0x1C($s2)
		nop
		lw      $v0, 0x2C($v0)
		nop
		andi    $v0, 0x1000
		bnez    $v0, loc_8003B34C
		move    $a0, $s4
		lw      $v0, 0x48 + var_8($sp)
		nop
		slti    $v0, 0xFFA
		beqz    $v0, loc_8003B368
		nop

		loc_8003B34C :
	move    $a1, $s5
		lw      $v0, -0x40EC($gp)
		lw      $a3, 0x48 + arg_10($sp)
		move    $a2, $s7
		jalr    $v0
		sw      $s6, 0x48 + var_38($sp)
		sw      $v0, 4($s7)

		loc_8003B368:
	lh      $v0, 0x172($s2)
		nop
		beqz    $v0, loc_8003B384
		nop
		lw      $v0, 0x48 + var_4($sp)
		sw      $s0, -0x6FB8($gp)
		sw      $v0, -0x6FAC($gp)

		loc_8003B384:
	lw      $ra, 0x48 + var_s20($sp)
		lw      $s7, 0x48 + var_s1C($sp)
		lw      $s6, 0x48 + var_s18($sp)
		lw      $s5, 0x48 + var_s14($sp)
		lw      $s4, 0x48 + var_s10($sp)
		lw      $s3, 0x48 + var_sC($sp)
		lw      $s2, 0x48 + var_s8($sp)
		lw      $s1, 0x48 + var_s4($sp)
		lw      $s0, 0x48 + var_s0($sp)
		jr      $ra
		addiu   $sp, 0x70
#endif
}

void PIPE3D_InstanceListTransformAndDrawFunc(struct _StreamUnit* unit, unsigned long** ot, struct _CameraCore_Type* cameraCore, struct _Instance* instance)
{
	struct _VertexPool* vertexPool;
	struct _PrimPool* primPool;
	VECTOR dpv[2];
	long maxRad;
	struct Level* level;
	SVECTOR bsPos;

	bsPos.vx = instance->position.x;
	bsPos.vy = instance->position.y;
	bsPos.vz = instance->position.z;

	level = unit->level;
	vertexPool = gameTrackerX.vertexPool;
	primPool = gameTrackerX.primPool;

	if (unit == NULL || !(unit->flags & 0x1) || unit->StreamUnitID == gameTrackerX.StreamUnitID || WARPGATE_IsObjectOnWarpSide(instance) != 0)
	{
		maxRad = instance->object->modelList[instance->currentModel]->maxRad;

		gte_SetRotMatrix(&cameraCore->vvNormalWorVecMat[0]);
		gte_ldv0(&bsPos);
		gte_mvmva(1, 0, 0, 3, 0);
		gte_stlvnl(dpv[0]);

		dpv[0].vx -= cameraCore->vvPlaneConsts[0];

		if (-maxRad < dpv[0].vx && dpv[0].vx < cameraCore->farPlane + maxRad &&
			-maxRad < dpv[0].vy - cameraCore->vvPlaneConsts[1] &&
			-maxRad < dpv[0].vz - cameraCore->vvPlaneConsts[2])
		{
			gte_SetRotMatrix(&cameraCore->vvNormalWorVecMat[1]);
			gte_ldv0(&bsPos);
			gte_mvmva(1, 0, 0, 3, 0);
			gte_stlvnl(dpv[1]);

			if (-maxRad < dpv[1].vx - cameraCore->vvPlaneConsts[3] &&
				-maxRad < dpv[1].vy - cameraCore->vvPlaneConsts[4])
			{
				if ((instance->flags & 0x80))
				{
					PIPE3D_AnimateTextures(instance->object->modelList[instance->currentModel]->aniTextures, instance->currentTextureAnimFrame);
				}
				else
				{
					PIPE3D_AnimateTextures(instance->object->modelList[instance->currentModel]->aniTextures, gameTrackerX.frameCount);
					instance->currentTextureAnimFrame++;
				}

				LIGHT_SetMatrixForLightGroupInstance(instance, level);

				if (!(instance->halvePlane.flags & 0xB) || (instance->flags2 & 0x800000))
				{
					PIPE3D_InstanceTransformAndDraw(instance, cameraCore, vertexPool, primPool, ot, NULL);
				}
				else
				{
					PIPE3D_HalvePlaneInstanceTransformAndDraw(instance, cameraCore->wcTransform, vertexPool, primPool, ot, NULL);
				}

				if ((instance->flags2 & 0x40))
				{
					LIGHT_DrawShadow(cameraCore->wcTransform, instance, primPool, ot);
				}

				if (instance->additionalDrawFunc != NULL)
				{
					instance->additionalDrawFunc(cameraCore->wcTransform, instance, vertexPool, primPool, ot);
				}

				gameTrackerX.visibleInstances++;

				instance->flags |= 0x200;
			}
			else
			{
				instance->flags &= 0xFFFFFDFF;
			}
		}
		else
		{
			instance->flags &= 0xFFFFFDFF;
		}
	}
	else
	{
		instance->flags &= 0xFFFFFDFF;
	}
}

void PIPE3D_InstanceListTransformAndDraw(struct _StreamUnit* unit, struct GameTracker* gameTracker, unsigned long** ot, struct _CameraCore_Type* cameraCore)
{
	struct _Instance* instance;
	int id;
	struct _Instance* player;

	player = gameTracker->playerInstance;
	id = unit->StreamUnitID;
	instance = gameTracker->instanceList->first;

	if (player->currentStreamUnitID == id)
	{
		if (!(player->flags & 0x800))
		{
			PIPE3D_InstanceListTransformAndDrawFunc(unit, ot, cameraCore, player);
		}
	}

	while (instance != NULL)
	{
		if (!(instance->flags & 0x800) && !(instance->flags2 & 0x4000000))
		{
			if (instance->currentStreamUnitID == id && instance != player)
			{
				PIPE3D_InstanceListTransformAndDrawFunc(unit, ot, cameraCore, instance);
			}
		}

		instance = instance->next;
	}
}


// autogenerated function stub: 
// void /*$ra*/ PIPE3D_TransformFromZAxis(MATRIX *transform /*$s0*/, struct _SVector *normal /*$s1*/)
void PIPE3D_TransformFromZAxis(MATRIX *transform, struct _SVector *normal)
{ // line 1606, offset 0x8003b218
	/* begin block 1 */
		// Start line: 1607
		// Start offset: 0x8003B218
		// Variables:
			struct _G2EulerAngles_Type ea1; // stack offset -40
			struct _SVector xprod; // stack offset -32
			struct _SVector yprod; // stack offset -24
	/* end block 1 */
	// End offset: 0x8003B3F4
	// End Line: 1645

	/* begin block 2 */
		// Start line: 2588
	/* end block 2 */
	// End Line: 2589
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ PIPE3D_CalcWorldToSplitPlaneTransform(MATRIX *wpTransform /*$s1*/, struct _SVector *normal /*$a1*/, struct _SVector *translation /*$s0*/)
void PIPE3D_CalcWorldToSplitPlaneTransform(MATRIX *wpTransform, struct _SVector *normal, struct _SVector *translation)
{ // line 1649, offset 0x8003b408
	/* begin block 1 */
		// Start line: 1650
		// Start offset: 0x8003B408
		// Variables:
			struct _SVector svector; // stack offset -40
			struct _Vector vector; // stack offset -32
	/* end block 1 */
	// End offset: 0x8003B408
	// End Line: 1650

	/* begin block 2 */
		// Start line: 2683
	/* end block 2 */
	// End Line: 2684
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// long /*$ra*/ PIPE3D_TransformAnimatedSplitInstanceVertices(struct _MVertex *vertexList /*stack 0*/, struct _PVertex *poolVertex /*$s4*/, struct _Model *model /*stack 8*/, MATRIX *wcTransform /*stack 12*/, MATRIX *matrixPool /*stack 16*/, struct _Mirror *mirror /*stack 20*/, MATRIX *lm /*stack 24*/, struct CVECTOR *vertexColor /*stack 28*/, struct CVECTOR *vertexSrcCol /*stack 32*/)
long PIPE3D_TransformAnimatedSplitInstanceVertices(struct _MVertex *vertexList, struct _PVertex *poolVertex, struct _Model *model, MATRIX *wcTransform, MATRIX *matrixPool, struct _Mirror *mirror, MATRIX *lm, CVECTOR *vertexColor, CVECTOR *vertexSrcCol)
{ // line 1688, offset 0x8003b4dc
	/* begin block 1 */
		// Start line: 1689
		// Start offset: 0x8003B4DC
		// Variables:
			struct TransformAnimatedInstanceVerticesWork_t *w; // $s7
			MATRIX *segMatrix; // $s2
			long i; // stack offset -64
			struct _Segment *segment; // stack offset -60
			//struct CVECTOR defaultRGBCD; // stack offset -80

		/* begin block 1.1 */
			// Start line: 1710
			// Start offset: 0x8003B56C
		/* end block 1.1 */
		// End offset: 0x8003B570
		// End Line: 1712

		/* begin block 1.2 */
			// Start line: 1719
			// Start offset: 0x8003B5A8
			// Variables:
				struct _MVertex *firstVertex; // stack offset -56
				struct _MVertex *lastVertex; // $fp
				struct _MVertex *modelVertex; // $a2
				struct _Normal *n0; // $t1
				struct _Normal *n1; // $t2
				struct _Normal *n2; // $t3
				//struct CVECTOR white; // stack offset -72
				//struct CVECTOR *c0; // $s1
				//struct CVECTOR *c1; // $s6
				//struct CVECTOR *c2; // $s5
				//long vtxcolflgs; // stack offset -52
		/* end block 1.2 */
		// End offset: 0x8003BA44
		// End Line: 1879
	/* end block 1 */
	// End offset: 0x8003BA6C
	// End Line: 1883

	/* begin block 2 */
		// Start line: 3376
	/* end block 2 */
	// End Line: 3377
				UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// void /*$ra*/ PIPE3D_TransformSplitInstanceVertices(struct _MVertex *vertexList /*stack 0*/, struct _PVertex *pvertex /*$s2*/, struct _Model *model /*stack 8*/, MATRIX *wpTransform /*stack 12*/, MATRIX *matrixPool /*stack 16*/, struct _Mirror *mirror /*stack 20*/)
void PIPE3D_TransformSplitInstanceVertices(struct _MVertex *vertexList, struct _PVertex *pvertex, struct _Model *model, MATRIX *wpTransform, MATRIX *matrixPool, struct _Mirror *mirror)
{ // line 1891, offset 0x8003baa8
	/* begin block 1 */
		// Start line: 1892
		// Start offset: 0x8003BAA8
		// Variables:
			MATRIX *spTransform; // $fp
			struct _Vector *vector; // $s1
			long i; // $s5
			struct _Segment *segment; // $v1

		/* begin block 1.1 */
			// Start line: 1904
			// Start offset: 0x8003BB30
			// Variables:
				struct _MVertex *firstVertex; // $s0
				struct _MVertex *lastVertex; // $s4
				struct _MVertex *modelVertex; // $s0
		/* end block 1.1 */
		// End offset: 0x8003BBC8
		// End Line: 1922
	/* end block 1 */
	// End offset: 0x8003BBEC
	// End Line: 1925

	/* begin block 2 */
		// Start line: 3663
	/* end block 2 */
	// End Line: 3664
				UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ PIPE3D_AnimateTextures(struct AniTex *aniTextures /*$t1*/, long req_frame /*$a1*/)
void PIPE3D_AnimateTextures(struct AniTex *aniTextures, long req_frame)
{ // line 1927, offset 0x8003bc1c
	/* begin block 1 */
		// Start line: 1928
		// Start offset: 0x8003BC1C
		// Variables:
			struct AniTexInfo *ani_tex_info; // $t0
			struct TextureMT3 *dest; // $a0
			struct TextureMT3 *src; // $v1
			long i; // $a3
	/* end block 1 */
	// End offset: 0x8003BCB4
	// End Line: 1947

	/* begin block 2 */
		// Start line: 3795
	/* end block 2 */
	// End Line: 3796
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ PIPE3D_AnimateTerrainTextures(struct DrMoveAniTex *aniTextures /*$a0*/, long req_frame /*$a1*/, struct _PrimPool *primPool /*$a2*/, unsigned long **drawot /*$a3*/)
void PIPE3D_AnimateTerrainTextures(struct DrMoveAniTex *aniTextures, long req_frame, struct _PrimPool *primPool, unsigned long **drawot)
{ // line 2020, offset 0x8003bcbc
	/* begin block 1 */
		// Start line: 2022
		// Start offset: 0x8003BCBC
		// Variables:
			unsigned long *prim; // $t3
			struct DrMoveAniTexDestInfo *dest; // $t1
			struct DrMoveAniTexSrcInfo *src; // $t2
			long i; // $t5
			unsigned long **otl; // $a3
	/* end block 1 */
	// End offset: 0x8003BE4C
	// End Line: 2076

	/* begin block 2 */
		// Start line: 3999
	/* end block 2 */
	// End Line: 4000

	/* begin block 3 */
		// Start line: 4000
	/* end block 3 */
	// End Line: 4001
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ PIPE3D_HalvePlaneInstanceTransformAndDraw(struct _Instance *instance /*$s2*/, MATRIX *wcTransform /*$s1*/, struct _VertexPool *vertexPool /*$s6*/, struct _PrimPool *primPool /*$s5*/, unsigned long **ot /*stack 16*/, struct _Mirror *mirror /*stack 20*/)
void PIPE3D_HalvePlaneInstanceTransformAndDraw(struct _Instance *instance, MATRIX *wcTransform, struct _VertexPool *vertexPool, struct _PrimPool *primPool, unsigned long **ot, struct _Mirror *mirror)
{ // line 2103, offset 0x8003be54
	/* begin block 1 */
		// Start line: 2104
		// Start offset: 0x8003BE54
		// Variables:
			struct Object *object; // $v1
			struct _Model *model; // $s3
			MATRIX *matrixPool; // $s4
			//MATRIX wpTransform; // stack offset -184
			//MATRIX pwTransform; // stack offset -152
			//MATRIX pcTransform; // stack offset -120
			//MATRIX lm; // stack offset -88
			struct _MVertex *vertexList; // $s7
			struct _SVector normalX; // stack offset -56
			struct _SVector *normal; // $a1
			struct _SVector translation; // stack offset -48
	/* end block 1 */
	// End offset: 0x8003C01C
	// End Line: 2172

	/* begin block 2 */
		// Start line: 4210
	/* end block 2 */
	// End Line: 4211
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ PIPE3D_HalvePlaneGetRingPoints(struct _Instance *instance /*$a0*/, MATRIX *wcTransform /*$fp*/, struct _VertexPool *vertexPool /*$s6*/, struct _PrimPool *primPool /*$s7*/, unsigned long **ot /*stack 16*/, struct _FXHalvePlane *ring /*stack 20*/)
void PIPE3D_HalvePlaneGetRingPoints(struct _Instance *instance, MATRIX *wcTransform, struct _VertexPool *vertexPool, struct _PrimPool *primPool, unsigned long **ot, struct _FXHalvePlane *ring)
{ // line 2220, offset 0x8003c048
	/* begin block 1 */
		// Start line: 2221
		// Start offset: 0x8003C048
		// Variables:
			struct Object *object; // $v1
			struct _Model *model; // $s1
			MATRIX *matrixPool; // $s3
			//MATRIX wpTransform; // stack offset -152
			//MATRIX pwTransform; // stack offset -120
			//MATRIX pcTransform; // stack offset -88
			struct _MVertex *vertexList; // $s4
			struct _PVertex *poolVertex; // $s5
			struct _SVector normalX; // stack offset -56
			struct _SVector *normal; // $a1
			struct _SVector translation; // stack offset -48
			struct _PlaneConstants *halvePlane; // $a0
	/* end block 1 */
	// End offset: 0x8003C1E8
	// End Line: 2278

	/* begin block 2 */
		// Start line: 4440
	/* end block 2 */
	// End Line: 4441
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ PIPE3D_DoGlow(struct _Instance *instance /*$s2*/, MATRIX *wcTransform /*$a1*/, struct _VertexPool *vertexPool /*$a2*/, struct _PrimPool *primPool /*$s3*/, unsigned long **ot /*stack 16*/, struct _FXGlowEffect *glow /*stack 20*/)
void PIPE3D_DoGlow(struct _Instance *instance, MATRIX *wcTransform, struct _VertexPool *vertexPool, struct _PrimPool *primPool, unsigned long **ot, struct _FXGlowEffect *glow)
{ // line 2294, offset 0x8003c218
	/* begin block 1 */
		// Start line: 2295
		// Start offset: 0x8003C218
		// Variables:
			long currentColorID; // $a2
			long previousColorID; // $a1
			long value; // $a0
			long fade; // $a3
			long fadeflag; // $s0

		/* begin block 1.1 */
			// Start line: 2325
			// Start offset: 0x8003C400
			// Variables:
				long color; // stack offset -32

			/* begin block 1.1.1 */
				// Start line: 2370
				// Start offset: 0x8003C578
				// Variables:
					long i; // $s0
			/* end block 1.1.1 */
			// End offset: 0x8003C5D4
			// End Line: 2380
		/* end block 1.1 */
		// End offset: 0x8003C5D4
		// End Line: 2381
	/* end block 1 */
	// End offset: 0x8003C5D4
	// End Line: 2382

	/* begin block 2 */
		// Start line: 4588
	/* end block 2 */
	// End Line: 4589
					UNIMPLEMENTED();
}


// autogenerated function stub: 
// long /*$ra*/ PIPE3D_Segment2ScreenPt(struct _Instance *instance /*$a0*/, MATRIX *wcTransform /*$a1*/, int segIndex /*$a2*/, _Position *pos /*$s0*/)
long PIPE3D_Segment2ScreenPt(struct _Instance *instance, MATRIX *wcTransform, int segIndex, _Position *pos)
{ // line 2388, offset 0x8003c5f4
	/* begin block 1 */
		// Start line: 2389
		// Start offset: 0x8003C5F4
		// Variables:
			//MATRIX scTransform; // stack offset -56
			_Position vOrigin; // stack offset -24
			long face_z; // stack offset -16
	/* end block 1 */
	// End offset: 0x8003C5F4
	// End Line: 2389

	/* begin block 2 */
		// Start line: 4816
	/* end block 2 */
	// End Line: 4817
			UNIMPLEMENTED();
	return 0;
}




