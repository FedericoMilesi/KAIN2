#include "CORE.H"
#include "MENU.H"
#include "MENUDEFS.H"
#include "MENUUTIL.H"

#include <assert.h>

int menu_data_size()
{ 
	return 904;
}

void menu_initialize(struct menu_t *menu, void *opaque)
{ 
	memset(menu, 0, sizeof(menu_t));

	menu->nmenus = -1;
	menu->opaque = opaque;
}

void menu_format(struct menu_t *menu, int center, int xpos, int ypos, int width, int lineskip, int itemskip, int border)
{
	struct menu_format_t* fmt;

	fmt = &menu->stack[menu->nmenus].format;
	
	fmt->xpos = xpos;
	fmt->ypos = ypos;
	fmt->center = center;
	fmt->lineskip = lineskip;
	fmt->itemskip = itemskip;
	fmt->width = width;
	fmt->border = border;
}

void menu_set(struct menu_t *menu, int fn(void*, int))
{ 
	menu->nmenus = 0;
	menu->drawfn = NULL;
	menu_push(menu, fn);
}

void menu_push(struct menu_t *menu, int fn(void*, int))
{ 
	struct menu_stack_t* stack;

	stack = &menu->stack[menu->nmenus++];

	(stack + 1)->fn = fn;
	(stack + 1)->index = -1;
	(stack + 1)->format.xpos = stack->format.xpos;
	(stack + 1)->format.ypos = stack->format.ypos;
	(stack + 1)->format.lineskip = stack->format.lineskip;
	(stack + 1)->format.itemskip = stack->format.itemskip;
	(stack + 1)->format.width = stack->format.width;
	(stack + 1)->format.center = stack->format.center;
	(stack + 1)->format.border = stack->format.border;
}


// autogenerated function stub: 
// void /*$ra*/ menu_pop(struct menu_t *menu /*$a0*/)
void menu_pop(struct menu_t *menu)
{ // line 134, offset 0x800b7b70
	/* begin block 1 */
		// Start line: 279
	/* end block 1 */
	// End Line: 280

	/* begin block 2 */
		// Start line: 281
	/* end block 2 */
	// End Line: 282

}


// autogenerated function stub: 
// void /*$ra*/ menu_item_flags(struct menu_t *menu /*$s2*/, TDRFuncPtr_menu_item_flags1fn fn /*$a1*/, long parameter /*$a2*/, long flags /*$a3*/, char *format /*stack 16*/)
void menu_item_flags(struct menu_t *menu, TDRFuncPtr_menu_item_flags1fn fn, long parameter, long flags, char *format)
{ // line 152, offset 0x800b7b84
	/* begin block 1 */
		// Start line: 153
		// Start offset: 0x800B7B84

		/* begin block 1.1 */
			// Start line: 153
			// Start offset: 0x800B7B84
			// Variables:
				struct menu_item_t *item; // $s1
		/* end block 1.1 */
		// End offset: 0x800B7B84
		// End Line: 153
	/* end block 1 */
	// End offset: 0x800B7B84
	// End Line: 153

	/* begin block 2 */
		// Start line: 304
	/* end block 2 */
	// End Line: 305

}

void menu_item(struct menu_t *menu, int (*fn)(void*, long, enum menu_ctrl_t), long parameter, char* format)
{ 
	struct menu_item_t* item;

	item = &menu->items[menu->nitems++];
	item->fn = fn;
	item->parameter = parameter;
	item->flags = 0;
	item->text = &menu->bytes[menu->nbytes];

	if (format != NULL)
	{
		vsprintf(menu->bytes, format, format + 1);
		menu->nbytes += strlen(item->text) + 1;
	}
	else
	{
		item->text = NULL;
	}
}

void menu_build(struct menu_t *menu)
{ 
	struct menu_stack_t *stack;
	
	menu->nitems = 0;
	menu->nbytes = 0;

	stack = &menu->stack[menu->nmenus];
	stack->fn(menu->opaque, stack->index);
}


// autogenerated function stub: 
// void /*$ra*/ DisplayHintBox(int len /*$a0*/, int y /*$a1*/)
void DisplayHintBox(int len, int y)
{ // line 221, offset 0x800b7d10
	/* begin block 1 */
		// Start line: 222
		// Start offset: 0x800B7D10
		// Variables:
			//struct Extents2d ext; // stack offset -24
			int i; // $s0

		/* begin block 1.1 */
			// Start line: 239
			// Start offset: 0x800B7D48
		/* end block 1.1 */
		// End offset: 0x800B7D48
		// End Line: 239
	/* end block 1 */
	// End offset: 0x800B7E2C
	// End Line: 255

	/* begin block 2 */
		// Start line: 458
	/* end block 2 */
	// End Line: 459

}


// autogenerated function stub: 
// void /*$ra*/ DisplayMenuBox(int x0 /*$a0*/, int x1 /*$a1*/, int y0 /*$a2*/, int y1 /*$a3*/)
void DisplayMenuBox(int x0, int x1, int y0, int y1)
{ // line 257, offset 0x800b7e3c
	/* begin block 1 */
		// Start line: 258
		// Start offset: 0x800B7E3C
		// Variables:
			//struct Extents2d ext; // stack offset -56
			static int dy[16]; // offset 0x0
			int i; // $s3
			int j; // $s6
			int k; // $s2
			int slice0; // $s7
			unsigned long **ot; // $s5
			struct _PrimPool *primPool; // $s4

		/* begin block 1.1 */
			// Start line: 276
			// Start offset: 0x800B7ED4

			/* begin block 1.1.1 */
				// Start line: 278
				// Start offset: 0x800B7EE4
			/* end block 1.1.1 */
			// End offset: 0x800B7EE4
			// End Line: 278
		/* end block 1.1 */
		// End offset: 0x800B7FDC
		// End Line: 290
	/* end block 1 */
	// End offset: 0x800B8044
	// End Line: 300

	/* begin block 2 */
		// Start line: 552
	/* end block 2 */
	// End Line: 553

}

int menu_draw_item(struct menu_t *menu, int ypos, int xadj, int yadj, char *text, int color, long flags, struct Extents2d *e)
{ 
	struct menu_format_t* fmt;
	int numColumns;
	int i;
	int texLen;
	int columnWidth;
	char* columnText;
	char tmpBuff[256];
	char* lineText;
	int columnYPos;
	int maxColumnYPos;
	int center;
	int leftEdge;
	int xpos;
	char* eol;
	char* eop;
	char* tmp;
	int wd;

	i = menu->nmenus;
	maxColumnYPos = 0;

	fmt = &menu->stack[i].format;

	if (!(flags & 0x1))
	{
		center = 0;

		if (!(flags & 0x2))
		{
			center = fmt->center;
		}
	}
	else
	{
		center = 1;
	}

	if (ypos == 0)
	{
		ypos = fmt->ypos;
	}

	ypos += yadj;
	numColumns = 1;

#if defined(PSXPC_VERSION)//Modern strlen doesn't support NULL being passed in but the old PSX version does.
	if (text == NULL)
	{
		texLen = 0;
	}
	else
	{
		texLen = strlen(text);
	}
#else
	texLen = strlen(text);
#endif


	if (texLen > 0)
	{
		for (i = 0; i < texLen; i++)
		{
			if (text[i] == 0x9)
			{
				numColumns++;
			}
		}
	}

	columnWidth = fmt->width / numColumns;

	if (fmt->center != 0)
	{
		leftEdge = (fmt->xpos + xadj) - (fmt->width >> 1);
	}
	else
	{
		leftEdge = (fmt->xpos + xadj);
	}

#if defined(PSXPC_VERSION)//Modern strtok cannot have NULL passed, PSX version can!
	if (text == NULL)
	{
		columnText = NULL;
	}
	else
	{
		columnText = strtok(text, "\x9");
	}
#else
	columnText = strtok(text, "\x9");
#endif

	while (columnText != NULL)
	{
		xpos = (leftEdge + xadj) + 0;

		if (center != 0)
		{
			xpos += columnWidth >> 1;
		}

		if (ypos < e->ymin)
		{
			e->ymin = ypos;
		}

		strcpy(tmpBuff, columnText);
		lineText = &tmpBuff[0];

		do
		{
			eol = strchr(lineText, 10);
			if (eol != NULL)
			{
				eol[0] = 0;
			}

			if (lineText != NULL)
			{
				do
				{
					eop = strchr(lineText, 32);

					if (eop != NULL)
					{
						do
						{
							tmp = strchr(eop + 1, 32);
							if (tmp != NULL)
							{
								tmp[0] = 0;
							}

							wd = menu_text_width(lineText);
							if (tmp != NULL)
							{
								tmp[0] = 32;
							}

							if (columnWidth >= wd)
							{
								eop = tmp;
								if (eop == NULL)
								{
									break;
								}
							}
							else
							{
								break;
							}

						} while (1);

						if (eop != NULL)
						{
							eop[0] = 0;
						}
					}

					if (center != 0)
					{
						int s3 = (menu_text_width(lineText) >> 1);
						wd = xpos - s3;
						menu_print(wd, ypos, lineText, color);

						if (wd < e->xmin)
						{
							e->xmin = wd;
						}

						if (e->xmax < xpos + s3)
						{
							e->xmax = xpos + s3;
						}
					}
					else
					{
						wd = menu_text_width(lineText);
						menu_print(xpos, ypos, lineText, color);

						if (xpos < e->xmin)
						{
							e->xmin = xpos;
						}

						if (e->xmax < xpos - wd)
						{
							e->xmax = xpos - wd;
						}
					}

					ypos += fmt->lineskip;

					if (eop == NULL)
					{
						break;
					}

					lineText = eop + 1;

					eop[0] = 32;

				} while (lineText != NULL);
			}

			if (eol == NULL)
			{
				break;
			}

			lineText = eol + 1;
			eol[0] = 10;

		} while (lineText != NULL);

		columnText = strtok(NULL, "\x9");

		if (maxColumnYPos < columnYPos)
		{
			maxColumnYPos = columnYPos;
		}
	}

	if (e->ymax < maxColumnYPos)
	{
		e->ymax = maxColumnYPos;
	}

	maxColumnYPos += fmt->itemskip;

	if ((flags & 0x4))
	{
		maxColumnYPos += fmt->lineskip >> 1;
	}

	return maxColumnYPos;
}

void menu_draw(struct menu_t *menu)
{
	struct Extents2d ext;
	struct menu_stack_t* stack;
	int index;
	int ypos;
	int i;
	struct menu_item_t* item;
	int color;

	ext.xmin = 2147483647;
	ext.xmax = 2147483648;
	ext.ymin = 2147483647;
	ext.ymax = 2147483648;

	stack = &menu->stack[menu->nmenus];
	index = stack->index;
	ypos = 0;
	
	if (menu->drawfn != NULL)
	{
		menu->drawfn(menu->opaque);
	}

	for (i = 0; i < menu->nitems; i++)
	{
		item = &menu->items[i];

		if (i == 0 && !(item->flags & 0x4))
		{
			color = 3;
		}
		else
		{
			color = 0 < (i ^ index);
		}

		ypos = menu_draw_item(menu, ypos, 0, 0, item->text, color, item->flags, &ext);
	}

	if (stack->format.border != 0)
	{
		DisplayMenuBox(ext.xmin, ext.xmax, ext.ymin, ext.ymax);
	}
}

void menu_run(struct menu_t *menu)
{
	enum menu_ctrl_t ctrl;
	struct menu_stack_t *stack;
	int index;
	struct menu_item_t *item;
	enum menu_sound_t sound;
	
	ctrl = menu_get_ctrl(menu->opaque);
	stack = &menu->stack[menu->nmenus];
	index = stack->index;
	item = &menu->items[index];

	if (index >= 0 && ctrl != menu_ctrl_none)
	{
		menudefs_reset_hack_attract_mode();
		sound = (menu_sound_t)item->fn(menu->opaque, item->parameter, ctrl);
		
		if (sound != menu_sound_none)
		{
			menu_sound(sound);
		}
		else
		{
			if (ctrl == menu_ctrl_down)
			{
				index = (index + 1) % menu->nitems;
				///@FIXME im sure something else is happening here!
			}
			else if (ctrl == menu_ctrl_cancel)
			{
				if (menu->nmenus >= 2)
				{
					menu_sound(menu_sound_pop);
					menu_pop(menu);
				}
			}
			else if (ctrl == menu_ctrl_up)
			{
				index = ((index + menu->nitems - 1) % menu->nitems);
				///@FIXME im sure something else is happening here!
			}

			if (stack->index != index)
			{
				menu_sound(menu_sound_select);
			}

			stack->index = index;
		}
	}
}

void menu_process(struct menu_t *menu)
{ 
	menu_build(menu);
	menu_draw(menu);
	menu_run(menu);
}




