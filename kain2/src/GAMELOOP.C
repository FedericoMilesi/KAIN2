#define _CRT_SECURE_NO_WARNINGS

#include "CORE.H"
#include "CAMERA.H"
#include "GAMELOOP.H"
#include "GAMEPAD.H"
#include "SOUND.H"
#include "EVENT.H"
#include "OBTABLE.H"
#include "MEMPACK.H"
#include "PSX/MAIN.H"
#include "TIMER.H"
#include "PSX/DRAWS.H"
#include "DRAW.H"
#include "SAVEINFO.H"
#include "PLAN/PLANAPI.H"
#include "PLAN/ENMYPLAN.H"
#include "FX.H"
#include "STRMLOAD.H"
#include "SIGNAL.H"

#if defined(PSXPC_VERSION)
#include <EMULATOR_PRIVATE.H>
#endif

char* primBase;
unsigned long(**gOt[2]); // offset 0x800D0C0C
struct LightInfo* gLightInfo; // offset 0x800D0C2C
void* enemyPlanPool; // offset 0x800D0C30
struct _ObjectTracker* GlobalObjects; // offset 0x800D0C38
void* planningPool; // offset 0x800D0C34
struct _VertexPool* gVertexPool; // offset 0x800D0C28
struct _PrimPool(*primPool[2]); // offset 0x800D0C14

struct GameTracker gameTrackerX;
struct Camera theCamera;
struct _PrimPool primPool0, primPool1;
WORD word_C54F8C;

struct _InstanceList* instanceList; // offset 0x800D0C20
struct _InstancePool* instancePool; // offset 0x800D0C24

extern void (*DRAW_AnimatedModel_S)();
extern void (*DRAW_DisplayPolytopeList_S)();

// autogenerated function stub: 
// void /*$ra*/ GAMELOOP_AllocStaticMemory()
void GAMELOOP_AllocStaticMemory()
{
	instanceList = (struct _InstanceList*)MEMPACK_Malloc(sizeof(struct _InstanceList), 6);
	instancePool = (struct _InstancePool*)MEMPACK_Malloc(sizeof(struct _InstancePool), 6);///@FIXME struct size mis-match on PSX/PSXPC!

#if defined(PSXPC_VERSION)//Increase primitive memory pools to allow 32_BIT_ADDR mode.
	primBase = MEMPACK_Malloc(216600 * 4, 6);
	gOt[1] = (unsigned long**)(primBase + 12288 * 2);
	primPool[0] = (_PrimPool*)(primBase + 24576 * 2);
	gOt[0] = (unsigned long**)(primBase);
	primPool[1] = (_PrimPool*)(primBase + 120588 * 2);
#else
	primBase = MEMPACK_Malloc(216600, 6);
	gOt[1] = (unsigned long**)(primBase + 12288);
	primPool[0] = (_PrimPool*)(primBase + 24576);
	gOt[0] = (unsigned long**)(primBase);
	primPool[1] = (_PrimPool*)(primBase + 120588);
#endif

	///@TODO disabled until header fixes implemented.
	///gLightInfo = (LightInfo*)MEMPACK_Malloc(sizeof(LightInfo), 6);
	///memset(gLightInfo, 0, sizeof(LightInfo));
	///gVertexPool = MEMPACK_Malloc(sizeof(_VertexPool), 6);
	///gPolytopeList = gVertexPool;
	///fxTracker = MEMPACK_Malloc(0x6DA8, 6);
	///gFXT = fxTracker;

	planningPool = MEMPACK_Malloc(3000, 6);
	enemyPlanPool = MEMPACK_Malloc(1000, 6);
	GlobalObjects = (struct _ObjectTracker*)MEMPACK_Malloc(1728, 6);
	///G2Anim_Install();
}


// autogenerated function stub: 
// void /*$ra*/ GAMELOOP_InitGameTracker()
void GAMELOOP_InitGameTracker()
{ 
	int i;

	primPool[0]->lastPrim = &primPool[0]->prim[23990];
	primPool[1]->lastPrim = &primPool[1]->prim[23990];
	primPool[0]->nextPrim = &primPool[0]->prim[0];
	primPool[1]->nextPrim = &primPool[1]->prim[0];

	gameTrackerX.instancePool = instancePool;
	gameTrackerX.vertexPool = gVertexPool;
	gameTrackerX.multGameTime = 10;
	gameTrackerX.material_fadeValue = 4096;
	gameTrackerX.planningPool = planningPool;
	gameTrackerX.enemyPlanPool = enemyPlanPool;
	gameTrackerX.GlobalObjects = GlobalObjects;
	gameTrackerX.instanceList = instanceList;
	gameTrackerX.lightInfo = gLightInfo;
	gameTrackerX.spectral_fadeValue = 0;
	gameTrackerX.decoupleGame = 1;
	gameTrackerX.frameRateLock = 1;
	gameTrackerX.primPool = primPool[0];
	gameTrackerX.drawOT = gOt[0];
	gameTrackerX.dispOT = gOt[1];
	gameTrackerX.frameRate24fps = 1;

	for (i = 0; i < 48; i++)
	{
		gameTrackerX.GlobalObjects[i].objectStatus = 0;
	}

	gameTrackerX.gameData.asmData.MorphTime = 1000;
	
	OBTABLE_ClearObjectReferences();
	EVENT_Init();
}


// autogenerated function stub: 
// void /*$ra*/ GAMELOOP_SystemInit(struct GameTracker *gameTracker /*$a0*/)
void GAMELOOP_SystemInit(struct GameTracker *gameTracker)
{ 
	GAMELOOP_AllocStaticMemory();
	INSTANCE_InitInstanceList(instanceList, instancePool);
	GAMELOOP_InitGameTracker();
}

void GAMELOOP_ResetGameStates()
{
	EVENT_Init();
}


// autogenerated function stub: 
// void /*$ra*/ GAMELOOP_ClearGameTracker()
void GAMELOOP_ClearGameTracker()
{ // line 304, offset 0x8002da10
	/* begin block 1 */
		// Start line: 842
	/* end block 1 */
	// End Line: 843

	/* begin block 2 */
		// Start line: 853
	/* end block 2 */
	// End Line: 854

}


// autogenerated function stub: 
// void /*$ra*/ GAMELOOP_CalcGameTime()
void GAMELOOP_CalcGameTime()
{ // line 334, offset 0x8002da58
	/* begin block 1 */
		// Start line: 336
		// Start offset: 0x8002DA58
		// Variables:
			long time; // $a1
	/* end block 1 */
	// End offset: 0x8002DA58
	// End Line: 340

	/* begin block 2 */
		// Start line: 905
	/* end block 2 */
	// End Line: 906

	/* begin block 3 */
		// Start line: 918
	/* end block 3 */
	// End Line: 919

	/* begin block 4 */
		// Start line: 919
	/* end block 4 */
	// End Line: 920

	/* begin block 5 */
		// Start line: 923
	/* end block 5 */
	// End Line: 924

}


// autogenerated function stub: 
// void /*$ra*/ GAMELOOP_SetGameTime(long timeOfDay /*$a1*/)
void GAMELOOP_SetGameTime(long timeOfDay)
{ // line 345, offset 0x8002db04
	/* begin block 1 */
		// Start line: 346
		// Start offset: 0x8002DB04
		// Variables:
			long tim; // $v1
	/* end block 1 */
	// End offset: 0x8002DB5C
	// End Line: 352

	/* begin block 2 */
		// Start line: 942
	/* end block 2 */
	// End Line: 943

}


// autogenerated function stub: 
// int /*$ra*/ GAMELOOP_GetTimeOfDay()
int GAMELOOP_GetTimeOfDay()
{ // line 362, offset 0x8002db98
	/* begin block 1 */
		// Start line: 364
		// Start offset: 0x8002DB98
		// Variables:
			int timeOfDay; // $v1
	/* end block 1 */
	// End offset: 0x8002DBDC
	// End Line: 389

	/* begin block 2 */
		// Start line: 979
	/* end block 2 */
	// End Line: 980

	/* begin block 3 */
		// Start line: 980
	/* end block 3 */
	// End Line: 981

	/* begin block 4 */
		// Start line: 982
	/* end block 4 */
	// End Line: 983

	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ GAMELOOP_GetTimeOfDayIdx(int timeOfDay /*$a0*/)
int GAMELOOP_GetTimeOfDayIdx(int timeOfDay)
{ // line 391, offset 0x8002dbe4
	/* begin block 1 */
		// Start line: 1047
	/* end block 1 */
	// End Line: 1048

	/* begin block 2 */
		// Start line: 1049
	/* end block 2 */
	// End Line: 1050

	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ GAMELOOP_WaitForLoad()
int GAMELOOP_WaitForLoad()
{ // line 819, offset 0x8002dc28
	/* begin block 1 */
		// Start line: 1505
	/* end block 1 */
	// End Line: 1506

	/* begin block 2 */
		// Start line: 1913
	/* end block 2 */
	// End Line: 1914

	return 0;
}

struct _StreamUnit * LoadLevels(char *baseAreaName, struct GameTracker *gameTracker)
{
	_SVector offset;
	struct _StreamUnit *streamUnit;
	static char oldArea[16] = { "under1" };
	int cd;
	int num;
	int waitFor;
	short _x0;
	short _y0;
	short _z0;
	short _x1;
	short _y1;
	short _z1;
	_SVector *_v;
	_Position *_v0;
	_Position *_v1;

	if (strlen(oldArea) != 0)
	{
		STREAM_AbortAreaLoad(oldArea);
	}

	strcpy(oldArea, baseAreaName);

	LOAD_ChangeDirectory(baseAreaName);

	streamUnit = STREAM_LoadLevel(baseAreaName, NULL, 0);
	
	if (streamUnit->used == 1)
	{
		DRAW_LoadingMessage();

		if (streamUnit->used == 1)
		{
			while (GAMELOOP_WaitForLoad() == 1)
			{
			}
		}

		STREAM_NextLoadFromHead();
		STREAM_LoadMainVram(gameTracker, baseAreaName, streamUnit);
		STREAM_NextLoadAsNormal();

		waitFor = GAMELOOP_WaitForLoad() - 1;
		
		do
		{
			num = GAMELOOP_WaitForLoad();

			if (num == 0)
			{
				break;
			}

		} while (num >= waitFor);
	}
	else
	{
		STREAM_DumpLoadingObjects();
		STREAM_LoadMainVram(gameTracker, baseAreaName, streamUnit);
	}

	if (streamUnit->level->startUnitMainSignal != NULL)
	{
		if (gameTracker->playerInstance != NULL)
		{
			///streamUnit->level->startUnitMainSignal->flags |= 0x1;
			///SIGNAL_HandleSignal(gameTracker->playerInstance, streamUnit->level->startUnitMainSignal->signalList, 0);
			///EVENT_AddSignalToReset(streamUnit->level->startUnitMainSignal);
		}
	}
	
	_v = &offset;
	_v1 = &streamUnit->level->terrain->BSPTreeArray->globalOffset;
	_v0 = &streamUnit->level->terrain->BSPTreeArray->bspRoot->sphere.position;

	_x1 = _v1->x;
	_y1 = _v1->y;
	_z1 = _v1->z;

	_x0 = _v0->x;
	_y0 = _v0->y;
	_z0 = _v0->z;

	_v->x = -(_x0 + _x1);
	_v->y = -(_y0 + _y1);
	_v->z = -(_z0 + _z1);

	PreloadAllConnectedUnits(streamUnit, &offset);
	
	return streamUnit;
}


// autogenerated function stub: 
// void /*$ra*/ GAMELOOP_InitStandardObjects()
void GAMELOOP_InitStandardObjects()
{ // line 937, offset 0x8002debc
	/* begin block 1 */
		// Start line: 938
		// Start offset: 0x8002DEBC
		// Variables:
			static char (*sobjects[10]); // offset 0x0
			int i; // $s1
	/* end block 1 */
	// End offset: 0x8002DEFC
	// End Line: 953

	/* begin block 2 */
		// Start line: 2169
	/* end block 2 */
	// End Line: 2170

}


// autogenerated function stub: 
// void /*$ra*/ GAMELOOP_LevelLoadAndInit(char *baseAreaName /*$s0*/, struct GameTracker *gameTracker /*$s3*/)
void GAMELOOP_LevelLoadAndInit(char *baseAreaName, struct GameTracker *gameTracker)
{
	long i; // $s1
	struct _StreamUnit *streamUnit; // $s2

	short _x1; // $v0
	short _y1; // $a0
	short _z1; // $v1
	struct _Position *_v0; // $v0
	struct _Position *_v1; // $v1

	//s0 = baseAreaName
	//s3 = gameTracker
	
	//G2Anim_ResetInternalState();
	gameTrackerX.playerInstance = NULL;

	INSTANCE_InitInstanceList(instanceList, instancePool);
	GAMELOOP_ClearGameTracker();
	CAMERA_Initialize(&theCamera);
	PLANAPI_InitPlanning(planningPool);
	ENMYPLAN_InitEnemyPlanPool(enemyPlanPool);
	//FX_Init(fxTracker);
	WARPGATE_Init();
	DRAW_InitShadow();
	GAMELOOP_InitStandardObjects();

	streamUnit = LoadLevels(baseAreaName, gameTracker);

	//loc_8002E2A8
	while (STREAM_PollLoadQueue() != 0)
	{

	}
#if 0

		loc_8002E2A8 :
		jal     sub_800601D4
		nop
		bnez    $v0, loc_8002E2A8
		lui     $v0, 0x800D
		li      $v0, off_800CA23C  # "hud_____"
		lw      $v1, (dword_800CA270 - 0x800CA23C)($v0)
		lw      $a0, (dword_800CA250 - 0x800CA23C)($v0)
		sw      $v1, 0x1CC($s3)
		lw      $a1, 8($s2)
		lhu     $v0, 0x178($s3)
		lw      $v1, 0x78($a1)
		sw      $a0, -0x6E84($gp)
		sh      $v0, -0x45B4($gp)
		blez    $v1, loc_8002E340
		move    $s1, $zero
		move    $s0, $s1

					loc_8002E2E8 :
				lw      $a0, 0x7C($a1)
					li      $a1, aRaziel     # "raziel"
					jal     sub_80074870
					addu    $a0, $s0
					bnez    $v0, loc_8002E324
					nop
					lw      $v0, 8($s2)
					nop
					lw      $a0, 0x7C($v0)
					lh      $a1, 0($s2)
					jal     sub_80032DA8
					addu    $a0, $s0
					j       loc_8002E340
					nop

					loc_8002E324 :
				lw      $a1, 8($s2)
					nop
					lw      $v0, 0x78($a1)
					addiu   $s1, 1
					slt     $v0, $s1, $v0
					bnez    $v0, loc_8002E2E8
					addiu   $s0, 0x4C  # 'L'

					loc_8002E340:
				lw      $v1, 0x2C($s3)
					nop
					lw      $v0, 0x1C($v1)
					nop
					lw      $v0, 0x1C($v0)
					nop
					sw      $v0, 0x24($v1)
					lw      $a1, 0x2C($s3)
					addiu   $a0, $gp, -0x5370
					jal     sub_800161EC
					nop
					lw      $v0, 0x2C($s3)
					nop
					addiu   $v1, $v0, 0x5C  # '\'
					lhu     $v0, 0x5C($v0)
					lhu     $a0, 2($v1)
					lhu     $v1, 4($v1)
					sh      $v0, -0x5370($gp)
					addiu   $v0, $gp, -0x5370
					sh      $a0, 2($v0)
					sh      $v1, 4($v0)
					lw      $v0, 8($s2)
					nop
					lhu     $a0, 0x46($v0)
					lhu     $a1, 0x44($v0)
					jal     SetFogNearFar
					li      $a2, 0x140
					move    $a0, $zero
					move    $a1, $a0
					jal     SetFarColor
					move    $a2, $a0
					lw      $v0, 8($s2)
					nop
					lbu     $v0, 0x3C($v0)
					addiu   $v1, $gp, -0x425C
					sb      $v0, 4($v1)
					lw      $v0, 8($s2)
					nop
					lbu     $v0, 0x3D($v0)
					nop
					sb      $v0, 5($v1)
					lw      $v0, 8($s2)
					nop
					lbu     $v0, 0x3E($v0)
					nop
					sb      $v0, 6($v1)
					lw      $v0, 8($s2)
					nop
					lbu     $v0, 0x3C($v0)
					addiu   $v1, $gp, -0x424C
					sb      $v0, 4($v1)
					lw      $v0, 8($s2)
					nop
					lbu     $v0, 0x3D($v0)
					nop
					sb      $v0, 5($v1)
					lw      $v0, 8($s2)
					nop
					lbu     $v0, 0x3E($v0)
					nop
					sb      $v0, 6($v1)
					li      $v0, 0xA
					sh      $v0, 0xD0($s3)
					li      $v0, 0x1E
					sh      $zero, 0x170($s3)
					sh      $v0, 0xCC($s3)
					sh      $v0, 0xCE($s3)
					lw      $v0, 8($s2)
					nop
					lw      $v1, 0x74($v0)
					nop
					beqz    $v1, loc_8002E4A0
					move    $a2, $zero
					lhu     $v0, 6($v1)
					nop
					ori     $v0, 1
					sh      $v0, 6($v1)
					lw      $v0, 8($s2)
					nop
					lw      $a1, 0x74($v0)
					lw      $a0, 0x2C($s3)
					jal     sub_8001E5C8
					addiu   $a1, 8
					lw      $v0, 8($s2)
					nop
					lw      $a0, 0x74($v0)
					jal     sub_80060CD0
					nop

					loc_8002E4A0 :
				sw      $zero, 0x134($s3)
					lw      $v0, 8($s2)
					nop
					lw      $v1, 0xC0($v0)
					nop
					beqz    $v1, loc_8002E508
					nop
					lw      $v0, 0x2C($s3)
					nop
					beqz    $v0, loc_8002E508
					move    $a2, $zero
					lhu     $v0, 6($v1)
					nop
					ori     $v0, 1
					sh      $v0, 6($v1)
					lw      $v0, 8($s2)
					nop
					lw      $a1, 0xC0($v0)
					lw      $a0, 0x2C($s3)
					jal     sub_8001E5C8
					addiu   $a1, 8
					lw      $v0, 8($s2)
					nop
					lw      $a0, 0xC0($v0)
					jal     sub_80060CD0
					nop

					loc_8002E508 :
				lw      $ra, 0x10 + var_s10($sp)
					lw      $s3, 0x10 + var_sC($sp)
					lw      $s2, 0x10 + var_s8($sp)
					lw      $s1, 0x10 + var_s4($sp)
					lw      $s0, 0x10 + var_s0($sp)
					jr      $ra
					addiu   $sp, 0x28
#endif

}


// autogenerated function stub: 
// void /*$ra*/ GAMELOOP_StreamLevelLoadAndInit(char *baseAreaName /*$a0*/, struct GameTracker *gameTracker /*$a1*/, int toSignalNum /*$a2*/, int fromSignalNum /*$a3*/)
void GAMELOOP_StreamLevelLoadAndInit(char *baseAreaName, struct GameTracker *gameTracker, int toSignalNum, int fromSignalNum)
{ // line 1143, offset 0x8002e220
	/* begin block 1 */
		// Start line: 1144
		// Start offset: 0x8002E220
	/* end block 1 */
	// End offset: 0x8002E220
	// End Line: 1144

	/* begin block 2 */
		// Start line: 2613
	/* end block 2 */
	// End Line: 2614

}

void GAMELOOP_SetScreenWipe(int time, int maxTime, int type)
{
	gameTrackerX.maxWipeTime = maxTime;
	gameTrackerX.wipeTime = time;
	gameTrackerX.wipeType = type;
}

void GAMELOOP_HandleScreenWipes(unsigned long **drawot)
{
	long temp;
	struct _PrimPool *primPool;
	
	primPool = gameTrackerX.primPool;

	if ((GlobalSave->flags & 0x1))
	{
		DRAW_FlatQuad(&gameTrackerX.wipeColor, 0, 0, SCREEN_WIDTH, 0, 0, 30, SCREEN_WIDTH, 30, primPool, drawot);
		DRAW_FlatQuad(&gameTrackerX.wipeColor, 0, 210, SCREEN_WIDTH, 210, 0, SCREEN_HEIGHT, SCREEN_WIDTH, 210, primPool, drawot);
	}

	if (gameTrackerX.wipeTime > 0)
	{
		if (gameTrackerX.wipeType == 10)
		{
			temp = ((gameTrackerX.wipeTime << 8) - (gameTrackerX.wipeTime)) / gameTrackerX.maxWipeTime;
			DRAW_TranslucentQuad(0, 0, SCREEN_WIDTH, 0, 0, SCREEN_HEIGHT, SCREEN_WIDTH, SCREEN_HEIGHT, temp, temp, temp, 2, primPool, drawot);
		}
		else if (gameTrackerX.wipeType == 11)
		{
			temp = ((gameTrackerX.wipeTime << 8) - (gameTrackerX.wipeTime)) / gameTrackerX.maxWipeTime;
			DRAW_TranslucentQuad(0, 0, SCREEN_WIDTH, 0, 0, 30, SCREEN_WIDTH, 30, temp, temp, temp, 2, primPool, drawot);
			DRAW_TranslucentQuad(0, 210, SCREEN_WIDTH, 210, 0, SCREEN_HEIGHT, SCREEN_WIDTH, SCREEN_HEIGHT, temp, temp, temp, 2, primPool, drawot);

			GlobalSave->flags &= 0xFFFE;
		}
		
		if (gameTrackerX.gameFramePassed != 0)
		{
			gameTrackerX.wipeTime--;
		}
	}
	else
	{
		if (gameTrackerX.wipeTime < -1)
		{
			if (gameTrackerX.wipeType == 10)
			{
				temp = ((((gameTrackerX.maxWipeTime + gameTrackerX.wipeTime) + 2) << 8) - ((gameTrackerX.maxWipeTime + gameTrackerX.wipeTime) + 2)) / gameTrackerX.maxWipeTime;
				DRAW_TranslucentQuad(0, 0, SCREEN_WIDTH, 0, 0, SCREEN_HEIGHT, SCREEN_WIDTH, SCREEN_HEIGHT, temp, temp, temp, 2, primPool, drawot);
			}
			else if (gameTrackerX.wipeType == 11)
			{
				temp = (((gameTrackerX.maxWipeTime + gameTrackerX.wipeTime) << 8) - ((gameTrackerX.maxWipeTime + gameTrackerX.wipeTime) + 2)) / gameTrackerX.maxWipeTime;
				DRAW_TranslucentQuad(0, 0, SCREEN_WIDTH, 0, 0, 30, SCREEN_WIDTH, 30, temp, temp, temp, 2, primPool, drawot);
				DRAW_TranslucentQuad(0, 210, SCREEN_WIDTH, 210, 0, SCREEN_HEIGHT, SCREEN_WIDTH, SCREEN_HEIGHT, temp, temp, temp, 2, primPool, drawot);

				if (gameTrackerX.wipeTime == -2)
				{
					GlobalSave->flags |= 0x1;
				}
			}

			if (gameTrackerX.gameFramePassed != 0)
			{
				gameTrackerX.wipeTime++;
			}
		}

		if (gameTrackerX.wipeTime == -1)
		{
			if (gameTrackerX.wipeType == 11)
			{
				GlobalSave->flags |= 0x1;
			}
			else
			{
				DRAW_FlatQuad(&gameTrackerX.wipeColor, 0, 0, SCREEN_WIDTH, 0, 0, SCREEN_HEIGHT, SCREEN_WIDTH, SCREEN_HEIGHT, primPool, drawot);
			}
		}
		else
		{
			theCamera.core.screenScale.z = 4096;
			theCamera.core.screenScale.y = 4096;
			theCamera.core.screenScale.x = 4096;
		}
	}
}


// autogenerated function stub: 
// void /*$ra*/ UpdateFogSettings(struct _StreamUnit *currentUnit /*$s2*/, struct Level *level /*$s0*/)
void UpdateFogSettings(struct _StreamUnit *currentUnit, struct Level *level)
{ // line 1662, offset 0x8002e6b4
	/* begin block 1 */
		// Start line: 1663
		// Start offset: 0x8002E6B4
		// Variables:
			int changed; // $a2
			int setflag; // $s1
			int FogFar; // $a1
			int FogNear; // $a0
	/* end block 1 */
	// End offset: 0x8002E7C4
	// End Line: 1710

	/* begin block 2 */
		// Start line: 3668
	/* end block 2 */
	// End Line: 3669

}


// autogenerated function stub: 
// int /*$ra*/ CheckForNoBlend(struct _ColorType *Color /*$a0*/)
int CheckForNoBlend(struct _ColorType *Color)
{ // line 1712, offset 0x8002e7dc
	/* begin block 1 */
		// Start line: 3779
	/* end block 1 */
	// End Line: 3780

	/* begin block 2 */
		// Start line: 3780
	/* end block 2 */
	// End Line: 3781

	return 0;
}


// autogenerated function stub: 
// void /*$ra*/ BlendToColor(struct _ColorType *target /*$s1*/, struct _ColorType *current /*$a1*/, struct _ColorType *dest /*$s0*/)
void BlendToColor(struct _ColorType *target, struct _ColorType *current, struct _ColorType *dest)
{ // line 1722, offset 0x8002e824
	/* begin block 1 */
		// Start line: 3799
	/* end block 1 */
	// End Line: 3800

}


// autogenerated function stub: 
// void /*$ra*/ MainRenderLevel(struct _StreamUnit *currentUnit /*$s7*/, unsigned long **drawot /*$fp*/)
void MainRenderLevel(struct _StreamUnit *currentUnit, unsigned long **drawot)
{ // line 1739, offset 0x8002e918
	/* begin block 1 */
		// Start line: 1740
		// Start offset: 0x8002E918
		// Variables:
			struct Level *level; // $s0
			struct GameTracker *gameTracker; // $s5
			struct _Terrain *terrain; // $s4
			int curTree; // $s1
			long BackColor; // stack offset -48
			struct _Position cam_pos_save; // stack offset -96
			//struct MATRIX cam_mat_save; // stack offset -88
			struct _Instance *saveLightInstance; // $s2

		/* begin block 1.1 */
			// Start line: 1792
			// Start offset: 0x8002E9E8
			// Variables:
				int time; // $a2
		/* end block 1.1 */
		// End offset: 0x8002EA1C
		// End Line: 1798

		/* begin block 1.2 */
			// Start line: 1806
			// Start offset: 0x8002EA68
			// Variables:
				int tod; // $v1
		/* end block 1.2 */
		// End offset: 0x8002EAE4
		// End Line: 1820

		/* begin block 1.3 */
			// Start line: 1898
			// Start offset: 0x8002EC00
			// Variables:
				struct _SVector tmp; // stack offset -56
				struct BSPTree *bsp; // $s0
		/* end block 1.3 */
		// End offset: 0x8002ECF8
		// End Line: 1955
	/* end block 1 */
	// End offset: 0x8002EDDC
	// End Line: 1975

	/* begin block 2 */
		// Start line: 3834
	/* end block 2 */
	// End Line: 3835

}


// autogenerated function stub: 
// void /*$ra*/ StreamIntroInstancesForUnit(struct _StreamUnit *currentUnit /*$a1*/)
void StreamIntroInstancesForUnit(struct _StreamUnit *currentUnit)
{ // line 1982, offset 0x8002ee18
	/* begin block 1 */
		// Start line: 1983
		// Start offset: 0x8002EE18
	/* end block 1 */
	// End offset: 0x8002EE48
	// End Line: 1995

	/* begin block 2 */
		// Start line: 4500
	/* end block 2 */
	// End Line: 4501

}


// autogenerated function stub: 
// long /*$ra*/ StreamRenderLevel(struct _StreamUnit *currentUnit /*$s7*/, struct Level *mainLevel /*$a1*/, unsigned long **drawot /*$s6*/, long portalFogColor /*$s0*/)
long StreamRenderLevel(struct _StreamUnit *currentUnit, struct Level *mainLevel, unsigned long **drawot, long portalFogColor)
{ // line 1999, offset 0x8002ee58
	/* begin block 1 */
		// Start line: 2000
		// Start offset: 0x8002EE58
		// Variables:
			struct GameTracker *gameTracker; // $s4
			struct Level *level; // $s1
			struct _Terrain *terrain; // $s2
			int curTree; // $s1
			int farplanesave; // $fp
			struct _Position cam_pos_save; // stack offset -88
			//struct MATRIX cam_mat_save; // stack offset -80

		/* begin block 1.1 */
			// Start line: 2085
			// Start offset: 0x8002EFBC
			// Variables:
				struct _SVector tmp; // stack offset -48
				struct BSPTree *bsp; // $s0
		/* end block 1.1 */
		// End offset: 0x8002F088
		// End Line: 2133

		/* begin block 1.2 */
			// Start line: 2151
			// Start offset: 0x8002F134
		/* end block 1.2 */
		// End offset: 0x8002F168
		// End Line: 2161
	/* end block 1 */
	// End offset: 0x8002F168
	// End Line: 2163

	/* begin block 2 */
		// Start line: 4534
	/* end block 2 */
	// End Line: 4535

	return 0;
}

void GAMELOOP_FlipScreenAndDraw(struct GameTracker* gameTracker, unsigned long** drawot)
{
#if defined(PSX_VERSION)
#if defined(USE_32_BIT_ADDR)
	DrawOTag((unsigned long*)drawot + 3071 * 2);
#else
	DrawOTag((unsigned long*)drawot + 3071);
#endif

#if !defined(PSXPC_VERSION)
	while (CheckVolatile(gameTracker->drawTimerReturn) != 0)
	{
	}
#endif

	ResetPrimPool();
	PutDrawEnv(&draw[gameTracker->drawPage]);

#if !defined(PSXPC_VERSION)
	while (CheckVolatile(gameTracker->reqDisp) != 0)
	{

	}
#endif
	
	gameTracker->drawTimerReturn = (long*)&gameTracker->drawTime;
	gameTracker->usecsStartDraw = (GetRCnt(0xF2000000) & 0xFFFF) | (gameTimer << 16);
	gameTracker->gameData.asmData.dispPage = 1 - gameTracker->gameData.asmData.dispPage;

#elif defined(PC_VERSION)
	unsigned int** dispOT; // ecx
	struct _PrimPool* v3; // eax

	DrawOTag((u_long*)drawot + 3071);
	dispOT = gameTrackerX.dispOT;
	gameTrackerX.dispOT = gameTrackerX.drawOT;
	gameTrackerX.drawOT = dispOT;
	gameTrackerX.drawPage = 1 - gameTrackerX.drawPage;
	ClearOTagR((u_long*)dispOT, 3072);
	if ((gameTrackerX.gameFlags & 0x8000000) != 0)
	{
		if (gameTrackerX.drawPage)
			gameTrackerX.primPool->nextPrim = &gameTrackerX.primPool->prim[16500];
		else
			gameTrackerX.primPool->nextPrim = &gameTrackerX.primPool->prim[9000];
		gameTrackerX.primPool->numPrims = 0;
	}
	else
	{
		v3 = &primPool0;
		if (gameTrackerX.primPool == &primPool0)
			v3 = &primPool1;
		gameTrackerX.primPool = v3;
		v3->nextPrim = v3->prim;
		gameTrackerX.primPool->numPrims = 0;
	}
	RenderG2_Swap();
	RenderG2_Clear(gameTracker, drawot);
#endif
}


// autogenerated function stub: 
// void /*$ra*/ GAMELOOP_AddClearPrim(unsigned long **drawot /*$a3*/, int override /*$a1*/)
void GAMELOOP_AddClearPrim(unsigned long **drawot, int override)
{ // line 2219, offset 0x8002f254
	/* begin block 1 */
		// Start line: 2220
		// Start offset: 0x8002F254

		/* begin block 1.1 */
			// Start line: 2224
			// Start offset: 0x8002F270
			// Variables:
				struct BLK_FILL *blkfill; // $a0
		/* end block 1.1 */
		// End offset: 0x8002F270
		// End Line: 2224

		/* begin block 1.2 */
			// Start line: 2240
			// Start offset: 0x8002F2DC
			// Variables:
				//struct BLK_FILL *blkfill; // $v1
		/* end block 1.2 */
		// End offset: 0x8002F2F4
		// End Line: 2242
	/* end block 1 */
	// End offset: 0x8002F2F4
	// End Line: 2243

	/* begin block 2 */
		// Start line: 5138
	/* end block 2 */
	// End Line: 5139

	/* begin block 3 */
		// Start line: 5140
	/* end block 3 */
	// End Line: 5141

}


// autogenerated function stub: 
// void /*$ra*/ GAMELOOP_SwitchTheDrawBuffer(unsigned long **drawot /*$a0*/)
void GAMELOOP_SwitchTheDrawBuffer(unsigned long **drawot)
{ // line 2245, offset 0x8002f2fc
	/* begin block 1 */
		// Start line: 5209
	/* end block 1 */
	// End Line: 5210

}


// autogenerated function stub: 
// void /*$ra*/ GAMELOOP_SetupRenderFunction(struct GameTracker *gameTracker /*$a0*/)
void GAMELOOP_SetupRenderFunction(struct GameTracker *gameTracker)
{ // line 2277, offset 0x8002f37c
#if defined(PC_VERSION)
	gameTracker->drawAnimatedModelFunc = DRAW_AnimatedModel_S;
	gameTracker->drawDisplayPolytopeListFunc = DRAW_DisplayPolytopeList_S;
#endif
}


// autogenerated function stub: 
// struct _StreamUnit * /*$ra*/ GAMELOOP_GetMainRenderUnit()
struct _StreamUnit * GAMELOOP_GetMainRenderUnit()
{ // line 2303, offset 0x8002f398
#if defined(PC_VERSION)
	struct _Instance* focusInstance; // edi
	struct _StreamUnit* StreamUnitWithID; // esi
	struct _StreamUnit* v3; // eax

	if (theCamera.mode == 5)
		return (struct _StreamUnit*)STREAM_WhichUnitPointerIsIn(theCamera.data.Cinematic.posSpline);
	focusInstance = theCamera.focusInstance;
	if (theCamera.focusInstance == gameTrackerX.playerInstance && gameTrackerX.SwitchToNewStreamUnit)
	{
		StreamUnitWithID = STREAM_GetStreamUnitWithID(gameTrackerX.moveRazielToStreamID);
		if (!StreamUnitWithID)
			return STREAM_GetStreamUnitWithID(focusInstance->currentStreamUnitID);
	}
	else
	{
		StreamUnitWithID = STREAM_GetStreamUnitWithID(theCamera.focusInstance->currentStreamUnitID);
	}
	v3 = COLLIDE_CameraWithStreamSignals(&theCamera);
	if (v3)
		return v3;
	return StreamUnitWithID;
#else
	return NULL;
#endif
}


// autogenerated function stub: 
// void /*$ra*/ GAMELOOP_DisplayFrame(struct GameTracker *gameTracker /*stack 0*/)
void GAMELOOP_DisplayFrame(struct GameTracker *gameTracker)
{ // line 2355, offset 0x8002f458
	/* begin block 1 */
		// Start line: 2356
		// Start offset: 0x8002F458
		// Variables:
			unsigned long **drawot; // stack offset -64
			struct Level *mainLevel; // stack offset -60
			struct StreamUnitPortal *streamPortal; // stack offset -56
			int numportals; // stack offset -52
			int d; // $s6
			struct _StreamUnit *mainStreamUnit; // $fp
			void *savedNextPrim; // stack offset -48

		/* begin block 1.1 */
			// Start line: 2467
			// Start offset: 0x8002F6D0
			// Variables:
				struct _StreamUnit *toStreamUnit; // $s2
				long toStreamUnitID; // stack offset -44
				struct StreamUnitPortal *streamPortal2; // $s4
				int i; // $s5
				int draw; // $s3
				//struct PSX_RECT cliprect; // stack offset -72

			/* begin block 1.1.1 */
				// Start line: 2508
				// Start offset: 0x8002F7B4
				// Variables:
					int streamID; // $s0
					struct _Instance *instance; // $v0
			/* end block 1.1.1 */
			// End offset: 0x8002F810
			// End Line: 2518
		/* end block 1.1 */
		// End offset: 0x8002F994
		// End Line: 2587
	/* end block 1 */
	// End offset: 0x8002FBF0
	// End Line: 2704

	/* begin block 2 */
		// Start line: 5433
	/* end block 2 */
	// End Line: 5434

}


// autogenerated function stub: 
// void /*$ra*/ GAMELOOP_DrawSavedOT(unsigned long **newOT /*$t3*/)
void GAMELOOP_DrawSavedOT(unsigned long **newOT)
{ // line 2710, offset 0x8002fc20
	/* begin block 1 */
		// Start line: 2711
		// Start offset: 0x8002FC20
		// Variables:
			//struct P_TAG *tag; // $a1
			int y; // $a2

		/* begin block 1.1 */
			// Start line: 2719
			// Start offset: 0x8002FC84
			// Variables:
				int tpage; // $v1
		/* end block 1.1 */
		// End offset: 0x8002FCAC
		// End Line: 2727

		/* begin block 1.2 */
			// Start line: 2732
			// Start offset: 0x8002FCC0
			// Variables:
				//int tpage; // $v1
		/* end block 1.2 */
		// End offset: 0x8002FCE8
		// End Line: 2740

		/* begin block 1.3 */
			// Start line: 2745
			// Start offset: 0x8002FCFC
		/* end block 1.3 */
		// End offset: 0x8002FD30
		// End Line: 2756
	/* end block 1 */
	// End offset: 0x8002FD54
	// End Line: 2759

	/* begin block 2 */
		// Start line: 6396
	/* end block 2 */
	// End Line: 6397

}

void ResetPrimPool()
{
#if defined(PSX_VERSION)
	ResetDrawPage();

	if (!(gameTrackerX.gameFlags & 0x8000000))
	{
		if (gameTrackerX.primPool == primPool[0])
		{
			gameTrackerX.primPool = primPool[1];
		}
		else
		{
			gameTrackerX.primPool = primPool[0];
		}

		gameTrackerX.primPool->nextPrim = &gameTrackerX.primPool->prim[0];
	}
	else
	{
		if (gameTrackerX.drawPage != 0)
		{
			gameTrackerX.primPool->nextPrim = &gameTrackerX.primPool->prim[16492];
		}
		else
		{
			gameTrackerX.primPool->nextPrim = &gameTrackerX.primPool->prim[9000];
		}
	}

	gameTrackerX.primPool->numPrims = 0;

#elif defined(PC_VERSION)
	unsigned int** dispOT; // ecx
	struct _PrimPool* v1; // eax

	dispOT = gameTrackerX.dispOT;
	gameTrackerX.dispOT = gameTrackerX.drawOT;
	gameTrackerX.drawOT = dispOT;
	gameTrackerX.drawPage = 1 - gameTrackerX.drawPage;
	ClearOTagR((u_long*)dispOT, 3072);
	if ((gameTrackerX.gameFlags & 0x8000000) != 0)
	{
		if (gameTrackerX.drawPage)
			gameTrackerX.primPool->nextPrim = &gameTrackerX.primPool->prim[16500];
		else
			gameTrackerX.primPool->nextPrim = &gameTrackerX.primPool->prim[9000];
		gameTrackerX.primPool->numPrims = 0;
	}
	else
	{
		v1 = &primPool0;
		if (gameTrackerX.primPool == &primPool0)
			v1 = &primPool1;
		gameTrackerX.primPool = v1;
		v1->nextPrim = v1->prim;
		gameTrackerX.primPool->numPrims = 0;
	}
#endif
}


// autogenerated function stub: 
// void /*$ra*/ Switch_For_Redraw()
void Switch_For_Redraw()
{ // line 2793, offset 0x8002fe44
	/* begin block 1 */
		// Start line: 2795
		// Start offset: 0x8002FE44
		// Variables:
			unsigned long **temp; // $v1
	/* end block 1 */
	// End offset: 0x8002FEA4
	// End Line: 2820

	/* begin block 2 */
		// Start line: 6612
	/* end block 2 */
	// End Line: 6613

	/* begin block 3 */
		// Start line: 6613
	/* end block 3 */
	// End Line: 6614

	/* begin block 4 */
		// Start line: 6616
	/* end block 4 */
	// End Line: 6617

}


// autogenerated function stub: 
// void /*$ra*/ GAMELOOP_Set_Pause_Redraw()
void GAMELOOP_Set_Pause_Redraw()
{ // line 2824, offset 0x8002fec0
	word_C54F8C = 1;
}


// autogenerated function stub: 
// void /*$ra*/ SaveOT()
void SaveOT()
{ // line 2829, offset 0x8002fed0
	/* begin block 1 */
		// Start line: 2830
		// Start offset: 0x8002FED0
		// Variables:
			//struct P_TAG *tag; // $a0
			//struct P_TAG *last; // $s0
			//struct P_TAG *lastlast; // $s1
	/* end block 1 */
	// End offset: 0x8003005C
	// End Line: 2880

	/* begin block 2 */
		// Start line: 6687
	/* end block 2 */
	// End Line: 6688

}

void ResetDrawPage()
{ 
	unsigned long **temp;

	temp = gameTrackerX.drawOT;
	gameTrackerX.drawOT = gameTrackerX.dispOT;
	gameTrackerX.dispOT = temp;
	gameTrackerX.drawPage = 1 - gameTrackerX.drawPage;

	ClearOTagR((unsigned long*)gameTrackerX.drawOT, 3072);
}


// autogenerated function stub: 
// void /*$ra*/ GAMELOOP_Set24FPS()
void GAMELOOP_Set24FPS()
{ // line 2914, offset 0x800300b0
	gameTrackerX.frameRate24fps = 1;
}


// autogenerated function stub: 
// void /*$ra*/ GAMELOOP_Reset24FPS()
void GAMELOOP_Reset24FPS()
{ // line 2920, offset 0x800300c0
	gameTrackerX.frameRate24fps = 0;
}


// autogenerated function stub: 
// void /*$ra*/ GAMELOOP_DoTimeProcess()
void GAMELOOP_DoTimeProcess()
{ // line 2925, offset 0x800300cc
	
#if defined(PC_VERSION)
	unsigned int TimeMS; // ebx
	int frameRateLock; // eax
	unsigned int lastLoopTime; // ecx
	unsigned int timeSinceLastGameFrame; // eax
	unsigned int fps30Count; // ecx

	TimeMS = TIMER_GetTimeMS();
	if ((gameTrackerX.gameFlags & 0x10000000) != 0)
	{
		gameTrackerX.lastLoopTime = -1;
		goto LABEL_27;
	}
	gameTrackerX.totalTime = D3D_TimeDiff(gameTrackerX.currentTicks);
	gameTrackerX.currentTicks = D3D_CurrentTime();
	frameRateLock = gameTrackerX.frameRateLock;
	if (gameTrackerX.frameRateLock < 1)
	{
		frameRateLock = 1;
		gameTrackerX.frameRateLock = 1;
	}
	if (frameRateLock > 2)
	{
		frameRateLock = 2;
		gameTrackerX.frameRateLock = 2;
	}
	if (gameTrackerX.decoupleGame && (gameTrackerX.gameFlags & 0x10000000) == 0)
	{
		lastLoopTime = 33;
		if (frameRateLock == 2)
			lastLoopTime = 50;
		if (gameTrackerX.gameData.asmData.MorphTime != 1000)
			lastLoopTime = 15;
		if (gameTrackerX.lastLoopTime != -1)
			lastLoopTime = TimeMS - gameTrackerX.currentTime;
		if (lastLoopTime > 0x42)
		{
			lastLoopTime = 66;
			gameTrackerX.lastLoopTime = 66;
			goto LABEL_22;
		}
		goto LABEL_20;
	}
	if (frameRateLock == 1)
	{
		lastLoopTime = 33;
		gameTrackerX.lastLoopTime = 33;
		goto LABEL_22;
	}
	if (frameRateLock == 2)
	{
		lastLoopTime = 50;
	LABEL_20:
		gameTrackerX.lastLoopTime = lastLoopTime;
		goto LABEL_22;
	}
	lastLoopTime = gameTrackerX.lastLoopTime;
LABEL_22:
	gameTrackerX.gameFramePassed = 0;
	gameTrackerX.timeMult = (lastLoopTime << 12) / 0x21;
	gameTrackerX.globalTimeMult = (lastLoopTime << 12) / 0x21;
	gameTrackerX.timeSinceLastGameFrame += (lastLoopTime << 12) / 0x21;
	timeSinceLastGameFrame = gameTrackerX.timeSinceLastGameFrame;
	if (gameTrackerX.timeSinceLastGameFrame <= 0x1000)
	{
	LABEL_27:
		gameTrackerX.currentTime = TimeMS;
		return;
	}
	fps30Count = gameTrackerX.fps30Count;
	do
	{
		timeSinceLastGameFrame -= 4096;
		++fps30Count;
		gameTrackerX.gameFramePassed = 1;
	} while (timeSinceLastGameFrame > 0x1000);
	gameTrackerX.fps30Count = fps30Count;
	gameTrackerX.timeSinceLastGameFrame = timeSinceLastGameFrame;
	gameTrackerX.currentTime = TimeMS;
#endif
}


// autogenerated function stub: 
// void /*$ra*/ GAMELOOP_Process(struct GameTracker *gameTracker /*$s5*/)
void GAMELOOP_Process(struct GameTracker *gameTracker)
{ // line 3021, offset 0x800302d0
	/* begin block 1 */
		// Start line: 3022
		// Start offset: 0x800302D0
		// Variables:
			int d; // $s2

		/* begin block 1.1 */
			// Start line: 3064
			// Start offset: 0x80030378
			// Variables:
				int useTime; // $s0

			/* begin block 1.1.1 */
				// Start line: 3067
				// Start offset: 0x80030388
				// Variables:
					struct Level *level; // $v0
			/* end block 1.1.1 */
			// End offset: 0x800303AC
			// End Line: 3072
		/* end block 1.1 */
		// End offset: 0x800303DC
		// End Line: 3077

		/* begin block 1.2 */
			// Start line: 3184
			// Start offset: 0x8003057C
			// Variables:
				int i; // $s0

			/* begin block 1.2.1 */
				// Start line: 3191
				// Start offset: 0x800305A8
				// Variables:
					struct _SFXMkr *sfxMkr; // $a2
			/* end block 1.2.1 */
			// End offset: 0x800305FC
			// End Line: 3203
		/* end block 1.2 */
		// End offset: 0x80030624
		// End Line: 3205
	/* end block 1 */
	// End offset: 0x800308F8
	// End Line: 3407

	/* begin block 2 */
		// Start line: 7120
	/* end block 2 */
	// End Line: 7121

	/* begin block 3 */
		// Start line: 7129
	/* end block 3 */
	// End Line: 7130

}


// autogenerated function stub: 
// void /*$ra*/ GAMELOOP_ModeStartRunning()
void GAMELOOP_ModeStartRunning()
{ // line 3411, offset 0x80030920
	/* begin block 1 */
		// Start line: 7987
	/* end block 1 */
	// End Line: 7988

}


// autogenerated function stub: 
// void /*$ra*/ GAMELOOP_ModeStartPause()
void GAMELOOP_ModeStartPause()
{ // line 3441, offset 0x800309f8
	/* begin block 1 */
		// Start line: 8050
	/* end block 1 */
	// End Line: 8051

}


// autogenerated function stub: 
// void /*$ra*/ GAMELOOP_ChangeMode()
void GAMELOOP_ChangeMode()
{ // line 3493, offset 0x80030ad0
	/* begin block 1 */
		// Start line: 3494
		// Start offset: 0x80030AD0
		// Variables:
			long *controlCommand; // $s0
	/* end block 1 */
	// End offset: 0x80030E6C
	// End Line: 3661

	/* begin block 2 */
		// Start line: 6986
	/* end block 2 */
	// End Line: 6987

}


// autogenerated function stub: 
// void /*$ra*/ GAMELOOP_RequestLevelChange(char *name /*$s2*/, short number /*$a1*/, struct GameTracker *gameTracker /*$s0*/)
void GAMELOOP_RequestLevelChange(char *name, short number, struct GameTracker *gameTracker)
{ // line 3664, offset 0x80030e7c
	if (!gameTracker->levelChange)
	{
		gameTracker->gameFlags |= 1u;
		SOUND_ResetAllSound();
		sprintf(gameTracker->baseAreaName, "%s%d", name, number);
		gameTracker->levelChange = 1;
		gameTracker->levelDone = 1;
	}
}


// autogenerated function stub: 
// void /*$ra*/ PSX_GameLoop(struct GameTracker *gameTracker /*$s0*/)
void PSX_GameLoop(struct GameTracker *gameTracker)
{ // line 3686, offset 0x80030efc
	GAMEPAD_Process(gameTracker);
	GAMELOOP_Process(gameTracker);
}


// autogenerated function stub: 
// struct MATRIX * /*$ra*/ GAMELOOP_GetMatrices(int numMatrices /*$a0*/)
MATRIX * GAMELOOP_GetMatrices(int numMatrices)
{ // line 3696, offset 0x80030f28
#if defined(PC_VERSION)
	MATRIX* result; // eax
	u_long* v2; // edx

	result = (struct MATRIX*)gameTrackerX.primPool->nextPrim;
	v2 = (u_long*)&result[numMatrices];
	if (v2 >= gameTrackerX.primPool->lastPrim)
		return 0;
	gameTrackerX.primPool->nextPrim = v2;
	return result;
#else
	return NULL;
#endif
}


// autogenerated function stub: 
// struct GameTracker * /*$ra*/ GAMELOOP_GetGT()
struct GameTracker * GAMELOOP_GetGT()
{ // line 3720, offset 0x80030f5c
	return &gameTrackerX;
}




