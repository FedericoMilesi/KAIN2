#define _CRT_SECURE_NO_WARNINGS

#include "CORE.H"
#include "CAMERA.H"
#include "GAMELOOP.H"
#include "GAMEPAD.H"
#include "SOUND.H"
#include "EVENT.H"
#include "OBTABLE.H"
#include "MEMPACK.H"
#include "PSX/MAIN.H"
#include "TIMER.H"
#include "PSX/DRAWS.H"
#include "DRAW.H"
#include "SAVEINFO.H"
#include "PLAN/PLANAPI.H"
#include "PLAN/ENMYPLAN.H"
#include "FX.H"
#include "STRMLOAD.H"
#include "SIGNAL.H"
#include "VOICEXA.H"
#include "G2/ANIMG2.H"
#include "FONT.H"
#include "DEBUG.H"
#include "G2/INSTNCG2.H"
#include "COLLIDE.H"
#include "PIPE3D.H"
#include "VM.H"
#include "LIGHT3D.H"
#include "UNDRWRLD.H"

char* primBase;
unsigned long(**gOt[2]); // offset 0x800D0C0C
struct LightInfo* gLightInfo; // offset 0x800D0C2C
void* enemyPlanPool; // offset 0x800D0C30
struct _ObjectTracker* GlobalObjects; // offset 0x800D0C38
void* planningPool; // offset 0x800D0C34
struct _VertexPool* gVertexPool; // offset 0x800D0C28
struct _PrimPool(*primPool[2]); // offset 0x800D0C14

struct GameTracker gameTrackerX;
struct Camera theCamera;
struct _PrimPool primPool0, primPool1;
WORD word_C54F8C;

struct _InstanceList* instanceList; // offset 0x800D0C20
struct _InstancePool* instancePool; // offset 0x800D0C24

extern void (*DRAW_AnimatedModel_S)();
extern void (*DRAW_DisplayPolytopeList_S)();

// autogenerated function stub: 
// void /*$ra*/ GAMELOOP_AllocStaticMemory()
void GAMELOOP_AllocStaticMemory()
{
	instanceList = (struct _InstanceList*)MEMPACK_Malloc(sizeof(struct _InstanceList), 6);
	instancePool = (struct _InstancePool*)MEMPACK_Malloc(sizeof(struct _InstancePool), 6);///@FIXME struct size mis-match on PSX/PSXPC!

#if defined(PSXPC_VERSION)//Increase primitive memory pools to allow 32_BIT_ADDR mode.
	primBase = MEMPACK_Malloc(216600 * 4, 6);
	gOt[1] = (unsigned long**)(primBase + 12288 * 2);
	primPool[0] = (_PrimPool*)(primBase + 24576 * 2);
	gOt[0] = (unsigned long**)(primBase);
	primPool[1] = (_PrimPool*)(primBase + 120588 * 2);
#else
	primBase = MEMPACK_Malloc(216600, 6);
	gOt[1] = (unsigned long**)(primBase + 12288);
	primPool[0] = (_PrimPool*)(primBase + 24576);
	gOt[0] = (unsigned long**)(primBase);
	primPool[1] = (_PrimPool*)(primBase + 120588);
#endif

	///@TODO disabled until header fixes implemented.
	///gLightInfo = (LightInfo*)MEMPACK_Malloc(sizeof(LightInfo), 6);
	///memset(gLightInfo, 0, sizeof(LightInfo));
	///gVertexPool = MEMPACK_Malloc(sizeof(_VertexPool), 6);
	///gPolytopeList = gVertexPool;
	///fxTracker = MEMPACK_Malloc(0x6DA8, 6);
	///gFXT = fxTracker;

	planningPool = MEMPACK_Malloc(3000, 6);
	enemyPlanPool = MEMPACK_Malloc(1000, 6);
	GlobalObjects = (struct _ObjectTracker*)MEMPACK_Malloc(1728, 6);
	G2Anim_Install();
}


// autogenerated function stub: 
// void /*$ra*/ GAMELOOP_InitGameTracker()
void GAMELOOP_InitGameTracker()
{ 
	int i;

	primPool[0]->lastPrim = &primPool[0]->prim[23990];
	primPool[1]->lastPrim = &primPool[1]->prim[23990];
	primPool[0]->nextPrim = &primPool[0]->prim[0];
	primPool[1]->nextPrim = &primPool[1]->prim[0];

	gameTrackerX.instancePool = instancePool;
	gameTrackerX.vertexPool = gVertexPool;
	gameTrackerX.multGameTime = 10;
	gameTrackerX.material_fadeValue = 4096;
	gameTrackerX.planningPool = planningPool;
	gameTrackerX.enemyPlanPool = enemyPlanPool;
	gameTrackerX.GlobalObjects = GlobalObjects;
	gameTrackerX.instanceList = instanceList;
	gameTrackerX.lightInfo = gLightInfo;
	gameTrackerX.spectral_fadeValue = 0;
	gameTrackerX.decoupleGame = 1;
	gameTrackerX.frameRateLock = 1;
	gameTrackerX.primPool = primPool[0];
	gameTrackerX.drawOT = gOt[0];
	gameTrackerX.dispOT = gOt[1];
	gameTrackerX.frameRate24fps = 1;

	for (i = 0; i < 48; i++)
	{
		gameTrackerX.GlobalObjects[i].objectStatus = 0;
	}

	gameTrackerX.gameData.asmData.MorphTime = 1000;
	
	OBTABLE_ClearObjectReferences();
	EVENT_Init();
}


// autogenerated function stub: 
// void /*$ra*/ GAMELOOP_SystemInit(struct GameTracker *gameTracker /*$a0*/)
void GAMELOOP_SystemInit(struct GameTracker *gameTracker)
{ 
	GAMELOOP_AllocStaticMemory();
	INSTANCE_InitInstanceList(instanceList, instancePool);
	GAMELOOP_InitGameTracker();
}

void GAMELOOP_ResetGameStates()
{
	EVENT_Init();
}

void GAMELOOP_ClearGameTracker()
{
	gameTrackerX.gameData.asmData.MorphTime = 1000;
	gameTrackerX.currentTime = 0;
	gameTrackerX.currentTicks = 0;
	gameTrackerX.gameFlags = 0;
	gameTrackerX.frameCount = 0;
	gameTrackerX.fps30Count = 0;
	gameTrackerX.currentHotSpot = 0;
	gameTrackerX.SwitchToNewStreamUnit = 0;
	gameTrackerX.gameData.asmData.drawBackFaces = 0;
	pause_redraw_flag = 0;
	pause_redraw_prim = 0;
	gameTrackerX.debugFlags |= 0x40000;
}


// autogenerated function stub: 
// void /*$ra*/ GAMELOOP_CalcGameTime()
void GAMELOOP_CalcGameTime()
{ // line 334, offset 0x8002da58
	/* begin block 1 */
		// Start line: 336
		// Start offset: 0x8002DA58
		// Variables:
			long time; // $a1
	/* end block 1 */
	// End offset: 0x8002DA58
	// End Line: 340

	/* begin block 2 */
		// Start line: 905
	/* end block 2 */
	// End Line: 906

	/* begin block 3 */
		// Start line: 918
	/* end block 3 */
	// End Line: 919

	/* begin block 4 */
		// Start line: 919
	/* end block 4 */
	// End Line: 920

	/* begin block 5 */
		// Start line: 923
	/* end block 5 */
	// End Line: 924

}


// autogenerated function stub: 
// void /*$ra*/ GAMELOOP_SetGameTime(long timeOfDay /*$a1*/)
void GAMELOOP_SetGameTime(long timeOfDay)
{ // line 345, offset 0x8002db04
	/* begin block 1 */
		// Start line: 346
		// Start offset: 0x8002DB04
		// Variables:
			long tim; // $v1
	/* end block 1 */
	// End offset: 0x8002DB5C
	// End Line: 352

	/* begin block 2 */
		// Start line: 942
	/* end block 2 */
	// End Line: 943

}


// autogenerated function stub: 
// int /*$ra*/ GAMELOOP_GetTimeOfDay()
int GAMELOOP_GetTimeOfDay()
{ // line 362, offset 0x8002db98
	/* begin block 1 */
		// Start line: 364
		// Start offset: 0x8002DB98
		// Variables:
			int timeOfDay; // $v1
	/* end block 1 */
	// End offset: 0x8002DBDC
	// End Line: 389

	/* begin block 2 */
		// Start line: 979
	/* end block 2 */
	// End Line: 980

	/* begin block 3 */
		// Start line: 980
	/* end block 3 */
	// End Line: 981

	/* begin block 4 */
		// Start line: 982
	/* end block 4 */
	// End Line: 983

	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ GAMELOOP_GetTimeOfDayIdx(int timeOfDay /*$a0*/)
int GAMELOOP_GetTimeOfDayIdx(int timeOfDay)
{ // line 391, offset 0x8002dbe4
	/* begin block 1 */
		// Start line: 1047
	/* end block 1 */
	// End Line: 1048

	/* begin block 2 */
		// Start line: 1049
	/* end block 2 */
	// End Line: 1050

	return 0;
}

int GAMELOOP_WaitForLoad()
{ 
	if ((gameTrackerX.debugFlags & 0x80000))
	{
		VOICEXA_Tick();
	}

	return STREAM_PollLoadQueue();
}

struct _StreamUnit * LoadLevels(char *baseAreaName, struct GameTracker *gameTracker)
{
	_SVector offset;
	struct _StreamUnit *streamUnit;
	static char oldArea[16] = { "under1" };
	int cd;
	int num;
	int waitFor;
	short _x0;
	short _y0;
	short _z0;
	short _x1;
	short _y1;
	short _z1;
	_SVector *_v;
	_Position *_v0;
	_Position *_v1;

	if (strlen(oldArea) != 0)
	{
		STREAM_AbortAreaLoad(oldArea);
	}

	strcpy(oldArea, baseAreaName);

	LOAD_ChangeDirectory(baseAreaName);

	streamUnit = STREAM_LoadLevel(baseAreaName, NULL, 0);
	
	if (streamUnit->used == 1)
	{
		DRAW_LoadingMessage();
		while (streamUnit->used == 1)
		{
			GAMELOOP_WaitForLoad();
		}

		STREAM_NextLoadFromHead();
		STREAM_LoadMainVram(gameTracker, baseAreaName, streamUnit);
		STREAM_NextLoadAsNormal();

		waitFor = GAMELOOP_WaitForLoad() - 1;
		
		do
		{
			num = GAMELOOP_WaitForLoad();

			if (num == 0)
			{
				break;
			}

		} while (num >= waitFor);
	}
	else
	{
		STREAM_DumpLoadingObjects();
		STREAM_LoadMainVram(gameTracker, baseAreaName, streamUnit);
	}

	if (streamUnit->level->startUnitMainSignal != NULL)
	{
		if (gameTracker->playerInstance != NULL)
		{
			streamUnit->level->startUnitMainSignal->flags |= 0x1;
			SIGNAL_HandleSignal(gameTracker->playerInstance, streamUnit->level->startUnitMainSignal->signalList, 0);
			EVENT_AddSignalToReset(streamUnit->level->startUnitMainSignal);
		}
	}
	
	_v = &offset;
	_v1 = &streamUnit->level->terrain->BSPTreeArray->globalOffset;
	_v0 = &streamUnit->level->terrain->BSPTreeArray->bspRoot->sphere.position;

	_x1 = _v1->x;
	_y1 = _v1->y;
	_z1 = _v1->z;

	_x0 = _v0->x;
	_y0 = _v0->y;
	_z0 = _v0->z;

	_v->x = -(_x0 + _x1);
	_v->y = -(_y0 + _y1);
	_v->z = -(_z0 + _z1);

	PreloadAllConnectedUnits(streamUnit, &offset);
	
	return streamUnit;
}

void GAMELOOP_InitStandardObjects()
{ 
	static char(*sobjects[10]) = {
		"raziel",
		"paths",
		"glphicon",
		"sreavr",
		"soul",
		"force",
		"particle",
		"healths",
		"eaggot",
		"eaggots"
	};
	
	int i;

	LOAD_DumpCurrentDir();

	for (i = 0; i < 10; i++)
	{
		InsertGlobalObject(sobjects[i], &gameTrackerX);
	}
}

void GAMELOOP_LevelLoadAndInit(char *baseAreaName, struct GameTracker *gameTracker)
{
	long i;
	struct _StreamUnit *streamUnit;

	short _x1;
	short _y1;
	short _z1;
	struct _Position *_v0;
	struct _Position *_v1;

	G2Anim_ResetInternalState();
	gameTrackerX.playerInstance = NULL;

	INSTANCE_InitInstanceList(instanceList, instancePool);
	GAMELOOP_ClearGameTracker();
	CAMERA_Initialize(&theCamera);
	PLANAPI_InitPlanning(planningPool);
	ENMYPLAN_InitEnemyPlanPool(enemyPlanPool);
	//FX_Init(fxTracker);
	WARPGATE_Init();
	DRAW_InitShadow();
	GAMELOOP_InitStandardObjects();

	streamUnit = LoadLevels(baseAreaName, gameTracker);

	while (STREAM_PollLoadQueue() != 0)
	{

	}
	
	gameTrackerX.introFX = (Object*)objectAccess[6].object;

	fontsObject = (Object*)objectAccess[2].object;
	RENDER_currentStreamUnitID = (unsigned short)gameTrackerX.StreamUnitID;

	if (streamUnit->level->numIntros > 0)
	{
		for (i = 0; i < streamUnit->level->numIntros; i++)
		{
#if defined(PSXPC_VERSION)
			if (_strcmpi(streamUnit->level->introList[i].name, "raziel") == 0)
#else
			if (strcmpi(streamUnit->level->introList[i].name, "raziel") == 0)
#endif
			{
				INSTANCE_IntroduceInstance(&streamUnit->level->introList[i], (short)streamUnit->StreamUnitID);
				break;
			}
		}
	}

	gameTracker->playerInstance->data = gameTracker->playerInstance->object->data;

	CAMERA_SetInstanceFocus(&theCamera, gameTracker->playerInstance);

	_v1 = &gameTracker->playerInstance->position;
	_x1 = _v1->x;
	_y1 = _v1->y;
	_z1 = _v1->z;

	_v0 = &theCamera.core.position;
	_v0->x = _x1;
	_v0->y = _y1;
	_v0->z = _z1;

	SetFogNearFar(streamUnit->level->fogNear, streamUnit->level->fogFar, 320);
	SetFarColor(0, 0, 0);

	clearRect[0].r0 = streamUnit->level->backColorR;
	clearRect[0].g0 = streamUnit->level->backColorG;
	clearRect[0].b0 = streamUnit->level->backColorB;

	clearRect[1].r0 = streamUnit->level->backColorR;
	clearRect[1].g0 = streamUnit->level->backColorG;
	clearRect[1].b0 = streamUnit->level->backColorB;

	gameTracker->wipeType = 10;
	gameTracker->hideBG = 0;
	gameTracker->wipeTime = 30;
	gameTracker->maxWipeTime = 30;

	if (streamUnit->level->startSignal != NULL)
	{
		streamUnit->level->startSignal->flags |= 0x1;
		SIGNAL_HandleSignal(gameTracker->playerInstance, streamUnit->level->startSignal->signalList, 0);
		EVENT_AddSignalToReset(streamUnit->level->startSignal);
	}

	gameTrackerX.vblFrames = 0;

	if (streamUnit->level->startUnitMainSignal != NULL && gameTracker->playerInstance != NULL)
	{
		streamUnit->level->startUnitMainSignal->flags |= 0x1;
		SIGNAL_HandleSignal(gameTracker->playerInstance, streamUnit->level->startUnitMainSignal->signalList, 0);
		EVENT_AddSignalToReset(streamUnit->level->startUnitMainSignal);
	}
}


// autogenerated function stub: 
// void /*$ra*/ GAMELOOP_StreamLevelLoadAndInit(char *baseAreaName /*$a0*/, struct GameTracker *gameTracker /*$a1*/, int toSignalNum /*$a2*/, int fromSignalNum /*$a3*/)
void GAMELOOP_StreamLevelLoadAndInit(char *baseAreaName, struct GameTracker *gameTracker, int toSignalNum, int fromSignalNum)
{ // line 1143, offset 0x8002e220
	/* begin block 1 */
		// Start line: 1144
		// Start offset: 0x8002E220
	/* end block 1 */
	// End offset: 0x8002E220
	// End Line: 1144

	/* begin block 2 */
		// Start line: 2613
	/* end block 2 */
	// End Line: 2614

}

void GAMELOOP_SetScreenWipe(int time, int maxTime, int type)
{
	gameTrackerX.maxWipeTime = maxTime;
	gameTrackerX.wipeTime = time;
	gameTrackerX.wipeType = type;
}

void GAMELOOP_HandleScreenWipes(unsigned long **drawot)
{
	long temp;
	struct _PrimPool *primPool;
	
	primPool = gameTrackerX.primPool;

	if ((GlobalSave->flags & 0x1))
	{
		DRAW_FlatQuad(&gameTrackerX.wipeColor, 0, 0, SCREEN_WIDTH, 0, 0, 30, SCREEN_WIDTH, 30, primPool, drawot);
		DRAW_FlatQuad(&gameTrackerX.wipeColor, 0, 210, SCREEN_WIDTH, 210, 0, SCREEN_HEIGHT, SCREEN_WIDTH, 210, primPool, drawot);
	}

	if (gameTrackerX.wipeTime > 0)
	{
		if (gameTrackerX.wipeType == 10)
		{
			temp = ((gameTrackerX.wipeTime << 8) - (gameTrackerX.wipeTime)) / gameTrackerX.maxWipeTime;
			DRAW_TranslucentQuad(0, 0, SCREEN_WIDTH, 0, 0, SCREEN_HEIGHT, SCREEN_WIDTH, SCREEN_HEIGHT, temp, temp, temp, 2, primPool, drawot);
		}
		else if (gameTrackerX.wipeType == 11)
		{
			temp = ((gameTrackerX.wipeTime << 8) - (gameTrackerX.wipeTime)) / gameTrackerX.maxWipeTime;
			DRAW_TranslucentQuad(0, 0, SCREEN_WIDTH, 0, 0, 30, SCREEN_WIDTH, 30, temp, temp, temp, 2, primPool, drawot);
			DRAW_TranslucentQuad(0, 210, SCREEN_WIDTH, 210, 0, SCREEN_HEIGHT, SCREEN_WIDTH, SCREEN_HEIGHT, temp, temp, temp, 2, primPool, drawot);

			GlobalSave->flags &= 0xFFFE;
		}
		
		if (gameTrackerX.gameFramePassed != 0)
		{
			gameTrackerX.wipeTime--;
		}
	}
	else
	{
		if (gameTrackerX.wipeTime < -1)
		{
			if (gameTrackerX.wipeType == 10)
			{
				temp = ((((gameTrackerX.maxWipeTime + gameTrackerX.wipeTime) + 2) << 8) - ((gameTrackerX.maxWipeTime + gameTrackerX.wipeTime) + 2)) / gameTrackerX.maxWipeTime;
				DRAW_TranslucentQuad(0, 0, SCREEN_WIDTH, 0, 0, SCREEN_HEIGHT, SCREEN_WIDTH, SCREEN_HEIGHT, temp, temp, temp, 2, primPool, drawot);
			}
			else if (gameTrackerX.wipeType == 11)
			{
				temp = (((gameTrackerX.maxWipeTime + gameTrackerX.wipeTime) << 8) - ((gameTrackerX.maxWipeTime + gameTrackerX.wipeTime) + 2)) / gameTrackerX.maxWipeTime;
				DRAW_TranslucentQuad(0, 0, SCREEN_WIDTH, 0, 0, 30, SCREEN_WIDTH, 30, temp, temp, temp, 2, primPool, drawot);
				DRAW_TranslucentQuad(0, 210, SCREEN_WIDTH, 210, 0, SCREEN_HEIGHT, SCREEN_WIDTH, SCREEN_HEIGHT, temp, temp, temp, 2, primPool, drawot);

				if (gameTrackerX.wipeTime == -2)
				{
					GlobalSave->flags |= 0x1;
				}
			}

			if (gameTrackerX.gameFramePassed != 0)
			{
				gameTrackerX.wipeTime++;
			}
		}

		if (gameTrackerX.wipeTime == -1)
		{
			if (gameTrackerX.wipeType == 11)
			{
				GlobalSave->flags |= 0x1;
			}
			else
			{
				DRAW_FlatQuad(&gameTrackerX.wipeColor, 0, 0, SCREEN_WIDTH, 0, 0, SCREEN_HEIGHT, SCREEN_WIDTH, SCREEN_HEIGHT, primPool, drawot);
			}
		}
		else
		{
			theCamera.core.screenScale.z = 4096;
			theCamera.core.screenScale.y = 4096;
			theCamera.core.screenScale.x = 4096;
		}
	}
}


// autogenerated function stub: 
// void /*$ra*/ UpdateFogSettings(struct _StreamUnit *currentUnit /*$s2*/, struct Level *level /*$s0*/)
void UpdateFogSettings(struct _StreamUnit *currentUnit, struct Level *level)
{ // line 1662, offset 0x8002e6b4
	/* begin block 1 */
		// Start line: 1663
		// Start offset: 0x8002E6B4
		// Variables:
			int changed; // $a2
			int setflag; // $s1
			int FogFar; // $a1
			int FogNear; // $a0
	/* end block 1 */
	// End offset: 0x8002E7C4
	// End Line: 1710

	/* begin block 2 */
		// Start line: 3668
	/* end block 2 */
	// End Line: 3669

}


// autogenerated function stub: 
// int /*$ra*/ CheckForNoBlend(struct _ColorType *Color /*$a0*/)
int CheckForNoBlend(struct _ColorType *Color)
{ // line 1712, offset 0x8002e7dc
	/* begin block 1 */
		// Start line: 3779
	/* end block 1 */
	// End Line: 3780

	/* begin block 2 */
		// Start line: 3780
	/* end block 2 */
	// End Line: 3781

	return 0;
}


// autogenerated function stub: 
// void /*$ra*/ BlendToColor(struct _ColorType *target /*$s1*/, struct _ColorType *current /*$a1*/, struct _ColorType *dest /*$s0*/)
void BlendToColor(struct _ColorType *target, struct _ColorType *current, struct _ColorType *dest)
{ // line 1722, offset 0x8002e824
	/* begin block 1 */
		// Start line: 3799
	/* end block 1 */
	// End Line: 3800

}


// autogenerated function stub: 
// void /*$ra*/ MainRenderLevel(struct _StreamUnit *currentUnit /*$s7*/, unsigned long **drawot /*$fp*/)
void MainRenderLevel(struct _StreamUnit *currentUnit, unsigned long **drawot)
{ // line 1739, offset 0x8002e918
	/* begin block 1 */
		// Start line: 1740
		// Start offset: 0x8002E918
		// Variables:
			struct Level *level; // $s0
			struct GameTracker *gameTracker; // $s5
			struct _Terrain *terrain; // $s4
			int curTree; // $s1
			long BackColor; // stack offset -48
			struct _Position cam_pos_save; // stack offset -96
			//struct MATRIX cam_mat_save; // stack offset -88
			struct _Instance *saveLightInstance; // $s2

		/* begin block 1.1 */
			// Start line: 1792
			// Start offset: 0x8002E9E8
			// Variables:
				int time; // $a2
		/* end block 1.1 */
		// End offset: 0x8002EA1C
		// End Line: 1798

		/* begin block 1.2 */
			// Start line: 1806
			// Start offset: 0x8002EA68
			// Variables:
				int tod; // $v1
		/* end block 1.2 */
		// End offset: 0x8002EAE4
		// End Line: 1820

		/* begin block 1.3 */
			// Start line: 1898
			// Start offset: 0x8002EC00
			// Variables:
				struct _SVector tmp; // stack offset -56
				struct BSPTree *bsp; // $s0
		/* end block 1.3 */
		// End offset: 0x8002ECF8
		// End Line: 1955
	/* end block 1 */
	// End offset: 0x8002EDDC
	// End Line: 1975

	/* begin block 2 */
		// Start line: 3834
	/* end block 2 */
	// End Line: 3835

}


// autogenerated function stub: 
// void /*$ra*/ StreamIntroInstancesForUnit(struct _StreamUnit *currentUnit /*$a1*/)
void StreamIntroInstancesForUnit(struct _StreamUnit *currentUnit)
{ // line 1982, offset 0x8002ee18
	/* begin block 1 */
		// Start line: 1983
		// Start offset: 0x8002EE18
	/* end block 1 */
	// End offset: 0x8002EE48
	// End Line: 1995

	/* begin block 2 */
		// Start line: 4500
	/* end block 2 */
	// End Line: 4501

}


// autogenerated function stub: 
// long /*$ra*/ StreamRenderLevel(struct _StreamUnit *currentUnit /*$s7*/, struct Level *mainLevel /*$a1*/, unsigned long **drawot /*$s6*/, long portalFogColor /*$s0*/)
long StreamRenderLevel(struct _StreamUnit *currentUnit, struct Level *mainLevel, unsigned long **drawot, long portalFogColor)
{ // line 1999, offset 0x8002ee58
	/* begin block 1 */
		// Start line: 2000
		// Start offset: 0x8002EE58
		// Variables:
			struct GameTracker *gameTracker; // $s4
			struct Level *level; // $s1
			struct _Terrain *terrain; // $s2
			int curTree; // $s1
			int farplanesave; // $fp
			struct _Position cam_pos_save; // stack offset -88
			//struct MATRIX cam_mat_save; // stack offset -80

		/* begin block 1.1 */
			// Start line: 2085
			// Start offset: 0x8002EFBC
			// Variables:
				struct _SVector tmp; // stack offset -48
				struct BSPTree *bsp; // $s0
		/* end block 1.1 */
		// End offset: 0x8002F088
		// End Line: 2133

		/* begin block 1.2 */
			// Start line: 2151
			// Start offset: 0x8002F134
		/* end block 1.2 */
		// End offset: 0x8002F168
		// End Line: 2161
	/* end block 1 */
	// End offset: 0x8002F168
	// End Line: 2163

	/* begin block 2 */
		// Start line: 4534
	/* end block 2 */
	// End Line: 4535

	return 0;
}

void GAMELOOP_FlipScreenAndDraw(struct GameTracker* gameTracker, unsigned long** drawot)
{
#if defined(PSX_VERSION)
#if defined(USE_32_BIT_ADDR)
	DrawOTag((unsigned long*)drawot + 3071 * 2);
#else
	DrawOTag((unsigned long*)drawot + 3071);
#endif

#if !defined(PSXPC_VERSION)
	while (CheckVolatile(gameTracker->drawTimerReturn) != 0)
	{
	}
#endif

	ResetPrimPool();
	PutDrawEnv(&draw[gameTracker->drawPage]);

#if !defined(PSXPC_VERSION)
	while (CheckVolatile(gameTracker->reqDisp) != 0)
	{

	}
#endif
	
	gameTracker->drawTimerReturn = (long*)&gameTracker->drawTime;
	gameTracker->usecsStartDraw = (GetRCnt(0xF2000000) & 0xFFFF) | (gameTimer << 16);
	gameTracker->gameData.asmData.dispPage = 1 - gameTracker->gameData.asmData.dispPage;

#elif defined(PC_VERSION)
	unsigned int** dispOT; // ecx
	struct _PrimPool* v3; // eax

	DrawOTag((u_long*)drawot + 3071);
	dispOT = gameTrackerX.dispOT;
	gameTrackerX.dispOT = gameTrackerX.drawOT;
	gameTrackerX.drawOT = dispOT;
	gameTrackerX.drawPage = 1 - gameTrackerX.drawPage;
	ClearOTagR((u_long*)dispOT, 3072);
	if ((gameTrackerX.gameFlags & 0x8000000) != 0)
	{
		if (gameTrackerX.drawPage)
			gameTrackerX.primPool->nextPrim = &gameTrackerX.primPool->prim[16500];
		else
			gameTrackerX.primPool->nextPrim = &gameTrackerX.primPool->prim[9000];
		gameTrackerX.primPool->numPrims = 0;
	}
	else
	{
		v3 = &primPool0;
		if (gameTrackerX.primPool == &primPool0)
			v3 = &primPool1;
		gameTrackerX.primPool = v3;
		v3->nextPrim = v3->prim;
		gameTrackerX.primPool->numPrims = 0;
	}
	RenderG2_Swap();
	RenderG2_Clear(gameTracker, drawot);
#endif
}


// autogenerated function stub: 
// void /*$ra*/ GAMELOOP_AddClearPrim(unsigned long **drawot /*$a3*/, int override /*$a1*/)
void GAMELOOP_AddClearPrim(unsigned long **drawot, int override)
{ // line 2219, offset 0x8002f254
	/* begin block 1 */
		// Start line: 2220
		// Start offset: 0x8002F254

		/* begin block 1.1 */
			// Start line: 2224
			// Start offset: 0x8002F270
			// Variables:
				struct BLK_FILL *blkfill; // $a0
		/* end block 1.1 */
		// End offset: 0x8002F270
		// End Line: 2224

		/* begin block 1.2 */
			// Start line: 2240
			// Start offset: 0x8002F2DC
			// Variables:
				//struct BLK_FILL *blkfill; // $v1
		/* end block 1.2 */
		// End offset: 0x8002F2F4
		// End Line: 2242
	/* end block 1 */
	// End offset: 0x8002F2F4
	// End Line: 2243

	/* begin block 2 */
		// Start line: 5138
	/* end block 2 */
	// End Line: 5139

	/* begin block 3 */
		// Start line: 5140
	/* end block 3 */
	// End Line: 5141

}


// autogenerated function stub: 
// void /*$ra*/ GAMELOOP_SwitchTheDrawBuffer(unsigned long **drawot /*$a0*/)
void GAMELOOP_SwitchTheDrawBuffer(unsigned long **drawot)
{ // line 2245, offset 0x8002f2fc
	/* begin block 1 */
		// Start line: 5209
	/* end block 1 */
	// End Line: 5210

}


// autogenerated function stub: 
// void /*$ra*/ GAMELOOP_SetupRenderFunction(struct GameTracker *gameTracker /*$a0*/)
void GAMELOOP_SetupRenderFunction(struct GameTracker *gameTracker)
{ // line 2277, offset 0x8002f37c
#if defined(PC_VERSION)
	gameTracker->drawAnimatedModelFunc = DRAW_AnimatedModel_S;
	gameTracker->drawDisplayPolytopeListFunc = DRAW_DisplayPolytopeList_S;
#endif
}


// autogenerated function stub: 
// struct _StreamUnit * /*$ra*/ GAMELOOP_GetMainRenderUnit()
struct _StreamUnit * GAMELOOP_GetMainRenderUnit()
{ // line 2303, offset 0x8002f398
#if defined(PC_VERSION)
	struct _Instance* focusInstance; // edi
	struct _StreamUnit* StreamUnitWithID; // esi
	struct _StreamUnit* v3; // eax

	if (theCamera.mode == 5)
		return (struct _StreamUnit*)STREAM_WhichUnitPointerIsIn(theCamera.data.Cinematic.posSpline);
	focusInstance = theCamera.focusInstance;
	if (theCamera.focusInstance == gameTrackerX.playerInstance && gameTrackerX.SwitchToNewStreamUnit)
	{
		StreamUnitWithID = STREAM_GetStreamUnitWithID(gameTrackerX.moveRazielToStreamID);
		if (!StreamUnitWithID)
			return STREAM_GetStreamUnitWithID(focusInstance->currentStreamUnitID);
	}
	else
	{
		StreamUnitWithID = STREAM_GetStreamUnitWithID(theCamera.focusInstance->currentStreamUnitID);
	}
	v3 = COLLIDE_CameraWithStreamSignals(&theCamera);
	if (v3)
		return v3;
	return StreamUnitWithID;
#else
	return NULL;
#endif
}

void GAMELOOP_DisplayFrame(struct GameTracker* gameTracker)
{
	unsigned long** drawot; // stack offset -64
	struct Level* mainLevel; // stack offset -60
	struct StreamUnitPortal* streamPortal; // stack offset -56
	int numportals; // stack offset -52
	int d; // $s6
	struct _StreamUnit* mainStreamUnit; // $fp
	void* savedNextPrim; // stack offset -48
	struct _StreamUnit* toStreamUnit; // $s3
	long toStreamUnitID; // stack offset -44
	struct StreamUnitPortal* streamPortal2; // $s4
	int i; // $s5
	int draw; // $s2
	PSX_RECT cliprect; // stack offset -72
	int streamID; // $s0
	struct _Instance* instance; // $v0

	if (!(gameTrackerX.gameFlags & 0x8000000) || pause_redraw_flag != 0)
	{
		//loc_8002F7B4
	}
	//loc_8002FD78
#if 0
		beqz    $v0, loc_8002F7B4
		sw      $t0, 0x38 + var_18($sp)
		lh      $v0, -0x45C4($gp)
		nop
		beqz    $v0, loc_8002FD78
		nop

		loc_8002F7B4 :
	lh      $v0, -0x45C4($gp)
		nop
		beqz    $v0, loc_8002F828
		move    $a0, $zero
		lw      $v0, -0x41F8($gp)
		nop
		lw      $v0, 4($v0)
		jal     sub_800BA43C
		sw      $v0, 0x38 + var_8($sp)
		jal     sub_8003013C
		nop
		lw      $t0, 0x38 + arg_0($sp)
		lw      $a0, -0x4064($gp)
		lw      $t0, 0x1D4($t0)
		li      $a1, 0xC00
		jal     sub_800BA768
		sw      $t0, 0x38 + var_18($sp)
		lw      $v1, -0x45C0($gp)
		nop
		beqz    $v1, loc_8002F814
		nop
		lw      $v0, -0x41F8($gp)
		j       loc_8002F83C
		sw      $v1, 4($v0)

		loc_8002F814:
	lw      $v1, -0x41F8($gp)
		nop
		addiu   $v0, $v1, 0xC
		j       loc_8002F83C
		sw      $v0, 4($v1)

		loc_8002F828 :
		lw      $v0, -0x41F8($gp)
		nop
		lw      $v0, 4($v0)
		nop
		sw      $v0, -0x45C0($gp)

		loc_8002F83C :
		lw      $v0, -0x4110($gp)
		addiu   $a0, $gp, -0x4238
		sw      $zero, -0x3FDC($gp)
		addiu   $v0, 1
		sw      $v0, -0x4110($gp)
		jal     sub_8002F680
		nop
		lw      $v0, -0x57C0($gp)
		nop
		lhu     $v0, 4($v0)
		nop
		andi    $v0, 1
		bnez    $v0, loc_8002F8C0
		li      $v0, 0xB
		lw      $t0, 0x38 + arg_0($sp)
		nop
		lh      $v1, 0xD0($t0)
		nop
		bne     $v1, $v0, loc_8002F89C
		nop
		lh      $v0, 0xCC($t0)
		nop
		bnez    $v0, loc_8002F8C0
		nop

		loc_8002F89C :
	lw      $v0, 0xC4($t0)
		nop
		andi    $v0, 0x800
		beqz    $v0, loc_8002F8C0
		nop
		lw      $a0, -0x41F8($gp)
		lw      $a1, 0x38 + var_18($sp)
		jal     sub_8004DBB4
		nop

		loc_8002F8C0 :
	lh      $v0, -0x45C4($gp)
		nop
		bnez    $v0, loc_8002F8D8
		nop
		jal     sub_8007C6F0
		nop

		loc_8002F8D8 :
	jal     sub_8002F69C
		nop
		lw      $t0, 0x38 + arg_0($sp)
		move    $fp, $v0
		lw      $v1, 0xC0($t0)
		lw      $t0, 8($fp)
		andi    $v1, 4
		beqz    $v1, loc_8002F90C
		sw      $t0, 0x38 + var_14($sp)
		lw      $a1, 0x98($t0)
		lui     $a0, 0x800D
		jal     sub_8002D70C
		li      $a0, aCameraunitS  # "Cameraunit: %s\n"

		loc_8002F90C:
	addiu   $a0, $gp, -0x5370
		lhu     $v0, 0($fp)
		li      $v1, 0x140
		sw      $v1, -0x52CC($gp)
		li      $v1, 0xF0
		sw      $zero, -0x52D0($gp)
		sw      $zero, -0x52C8($gp)
		sw      $v1, -0x52C4($gp)
		sh      $v0, -0x45B4($gp)
		jal     sub_80014F00
		nop
		lw      $a0, 0x38 + var_14($sp)
		jal     sub_800506E0
		nop
		beqz    $v0, loc_8002F994
		nop
		lw      $t0, 0x38 + var_14($sp)
		nop
		lhu     $v1, 0x44($t0)
		lw      $v0, -0x530C($gp)
		nop
		beq     $v1, $v0, loc_8002F96C
		nop
		sw      $v1, -0x530C($gp)

		loc_8002F96C:
	lw      $t0, 0x38 + arg_0($sp)
		nop
		lw      $v0, 0xC0($t0)
		nop
		andi    $v0, 0x8000
		bnez    $v0, loc_8002F994
		nop
		lw      $a1, 0x38 + var_18($sp)
		jal     sub_8002EC1C
		move    $a0, $fp

		loc_8002F994 :
	lw      $t0, 0x38 + var_14($sp)
		nop
		lw      $v0, 0($t0)
		nop
		lw      $v0, 0x30($v0)
		nop
		lw      $t0, 0($v0)
		nop
		sw      $t0, 0x38 + var_C($sp)
		addiu   $t0, $v0, 4
		sw      $t0, 0x38 + var_10($sp)
		lw      $t0, 0x38 + var_C($sp)
		nop
		blez    $t0, loc_8002FCB0
		move    $s6, $zero
		addiu   $s7, $v0, 0x22  # '"'

		loc_8002F9D4:
	lw      $t0, -0xA($s7)
		lw      $s3, 0xA($s7)
		nop
		beqz    $s3, loc_8002F9FC
		sw      $t0, 0x38 + var_4($sp)
		lw      $v1, 0x20($s3)
		lw      $v0, -0x4110($gp)
		nop
		beq     $v1, $v0, loc_8002FC8C
		nop

		loc_8002F9FC :
	addiu   $t0, $gp, -0x52D0
		li      $v0, 0x200
		sh      $v0, 0x38 + var_20($sp)
		li      $v0, 0xF0
		sh      $v0, 0x38 + var_1E($sp)
		li      $v0, 0xFFFFFE00
		sh      $v0, 0x38 + var_1C($sp)
		li      $v0, 0xFFFFFF10
		sh      $v0, 0x38 + var_1A($sp)
		li      $v0, 0x140
		sw      $v0, -0x52CC($gp)
		li      $v0, 0xF0
		sw      $zero, -0x52D0($gp)
		sw      $zero, -0x52C8($gp)
		sw      $v0, -0x52C4($gp)
		jal     sub_80014F00
		addiu   $a0, $t0, -0xA0
		lw      $t0, 0x38 + var_14($sp)
		move    $s5, $zero
		lw      $v0, 0($t0)
		move    $s2, $s5
		lw      $v0, 0x30($v0)
		lw      $t0, 0x38 + var_C($sp)
		nop
		blez    $t0, loc_8002FB24
		addiu   $s4, $v0, 4
		addiu   $s1, $v0, 0x2C  # ','

		loc_8002FA68:
	lw      $v0, -0x14($s1)
		lw      $t0, 0x38 + var_4($sp)
		nop
		bne     $v0, $t0, loc_8002FB08
		move    $a0, $s4
		jal     sub_8005E9F0
		addiu   $a1, $sp, 0x38 + var_20
		beqz    $v0, loc_8002FA94
		lui     $v1, 0x200
		j       loc_8002FB08
		li      $s2, 1

		loc_8002FA94:
	lw      $v0, -0x4ED4($gp)
		nop
		and $v0, $v1
		beqz    $v0, loc_8002FB08
		nop
		lw      $v0, 0($s1)
		lw      $a0, -0x420C($gp)
		lw      $s0, 0($v0)
		jal     sub_80034648
		li      $a1, 0x22  # '"'
		lw      $v1, -0x420C($gp)
		nop
		lw      $v1, 0x38($v1)
		nop
		beq     $s0, $v1, loc_8002FAEC
		nop
		beqz    $v0, loc_8002FB08
		nop
		lw      $v0, 0x38($v0)
		nop
		bne     $s0, $v0, loc_8002FB08
		nop

		loc_8002FAEC :
	li      $s2, 1
		li      $v0, 0x200
		sh      $v0, 0x38 + var_1C($sp)
		li      $v0, 0xF0
		sh      $zero, 0x38 + var_20($sp)
		sh      $zero, 0x38 + var_1E($sp)
		sh      $v0, 0x38 + var_1A($sp)

		loc_8002FB08:
	addiu   $s5, 1
		addiu   $s1, 0x5C  # '\'
		lw      $t0, 0x38 + var_C($sp)
		nop
		slt     $v0, $s5, $t0
		bnez    $v0, loc_8002FA68
		addiu   $s4, 0x5C  # '\'

		loc_8002FB24:
	beqz    $s2, loc_8002FC64
		nop
		lh      $a0, 0x38 + var_20($sp)
		nop
		sll     $v0, $a0, 2
		addu    $v0, $a0
		sll     $v1, $v0, 6
		bgez    $v1, loc_8002FB4C
		nop
		addiu   $v1, 0x1FF

		loc_8002FB4C:
	lh      $v0, 0x38 + var_1C($sp)
		lh      $a1, 0x38 + var_1E($sp)
		sra     $v1, 9
		sw      $v1, -0x52D0($gp)
		addu    $v0, $a0, $v0
		sll     $v1, $v0, 2
		addu    $v1, $v0
		sll     $v0, $v1, 6
		sw      $a1, -0x52C8($gp)
		bgez    $v0, loc_8002FB7C
		nop
		addiu   $v0, 0x1FF

		loc_8002FB7C:
	addiu   $t0, $gp, -0x52D0
		lh      $v1, 0x38 + var_1A($sp)
		sra     $v0, 9
		sw      $v0, -0x52CC($gp)
		addu    $v1, $a1, $v1
		sw      $v1, -0x52C4($gp)
		jal     sub_80014F00
		addiu   $a0, $t0, -0xA0
		lw      $a0, -0x5310($gp)
		jal     SetRotMatrix
		nop
		lw      $a0, -0x5310($gp)
		jal     SetTransMatrix
		nop
		lhu     $v0, 0($s7)
		nop
		andi    $v0, 1
		beqz    $v0, loc_8002FC24
		nop
		lhu     $v0, 6($fp)
		nop
		andi    $v0, 8
		beqz    $v0, loc_8002FC14
		nop
		beqz    $s3, loc_8002FBFC
		move    $a2, $fp
		lw      $v0, 0x20($s3)
		lw      $v1, -0x4110($gp)
		nop
		beq     $v0, $v1, loc_8002FC8C
		nop
		sw      $v1, 0x20($s3)

		loc_8002FBFC:
	lw      $a0, 0x38 + var_18($sp)
		lw      $a1, 0x38 + var_10($sp)
		jal     sub_8005F674
		addiu   $a3, $sp, 0x38 + var_20
		j       loc_8002FC8C
		nop

		loc_8002FC14 :
	jal     sub_8005B53C
		move    $a0, $fp
		j       loc_8002FC8C
		nop

		loc_8002FC24 :
	beqz    $s3, loc_8002FC8C
		nop
		lw      $v0, 0x20($s3)
		lw      $v1, -0x4110($gp)
		nop
		beq     $v0, $v1, loc_8002FC8C
		move    $a2, $s3
		move    $a3, $fp
		lw      $a0, 0x38 + var_18($sp)
		lw      $a1, 0x38 + var_10($sp)
		addiu   $v0, $sp, 0x38 + var_20
		sw      $v1, 0x20($a2)
		jal     sub_8005F3C8
		sw      $v0, 0x38 + var_28($sp)
		j       loc_8002FC8C
		nop

		loc_8002FC64 :
	beqz    $s3, loc_8002FC8C
		nop
		lw      $v0, 0x20($s3)
		lw      $v1, -0x4110($gp)
		nop
		beq     $v0, $v1, loc_8002FC8C
		nop
		sw      $v1, 0x20($s3)
		jal     sub_8002F11C
		move    $a0, $s3

		loc_8002FC8C :
	lw      $t0, 0x38 + var_10($sp)
		addiu   $s6, 1
		addiu   $t0, 0x5C  # '\'
		sw      $t0, 0x38 + var_10($sp)
		lw      $t0, 0x38 + var_C($sp)
		nop
		slt     $v0, $s6, $t0
		bnez    $v0, loc_8002F9D4
		addiu   $s7, 0x5C  # '\'

		loc_8002FCB0:
	move    $s6, $zero
		li      $s1, 2
		addiu   $s0, $gp, -0x38C4

		loc_8002FCBC :
		lh      $v0, 4($s0)
		nop
		bne     $v0, $s1, loc_8002FCEC
		nop
		lw      $v0, 0x20($s0)
		lw      $v1, -0x4110($gp)
		nop
		beq     $v0, $v1, loc_8002FCEC
		nop
		sw      $v1, 0x20($s0)
		jal     sub_8002F11C
		move    $a0, $s0

		loc_8002FCEC :
	addiu   $s6, 1
		slti    $v0, $s6, 0x10
		bnez    $v0, loc_8002FCBC
		addiu   $s0, 0x40  # '@'
		addiu   $a0, $gp, -0x5370
		li      $v0, 0x140
		sw      $v0, -0x52CC($gp)
		li      $v0, 0xF0
		sw      $zero, -0x52D0($gp)
		sw      $zero, -0x52C8($gp)
		sw      $v0, -0x52C4($gp)
		jal     sub_80014F00
		nop
		lh      $v0, -0x45C4($gp)
		nop
		beqz    $v0, loc_8002FD78
		nop
		lw      $a0, 0x38 + var_18($sp)
		jal     sub_8002F558
		li      $a1, 1
		jal     sub_800301C8
		nop
		lw      $a0, -0x4064($gp)
		jal     sub_800BA768
		li      $a1, 0xC00
		jal     sub_8003013C
		nop
		lw      $t0, 0x38 + arg_0($sp)
		lw      $v0, -0x41F8($gp)
		lw      $t0, 0x1D4($t0)
		nop
		sw      $t0, 0x38 + var_18($sp)
		lw      $t0, 0x38 + var_8($sp)
		sh      $zero, -0x45C4($gp)
		sw      $t0, 4($v0)

		loc_8002FD78:
	lw      $v0, -0x40F8($gp)//gameTrackerX.gameFlags
		lui     $v1, 0x800
		and $v0, $v1
		beqz    $v0, loc_8002FD94
		nop
		jal     sub_8007C6F0
		nop

		loc_8002FD94 :
	lw      $a0, 0x38 + arg_0($sp)
		lw      $a1, 0x38 + var_18($sp)
		jal     sub_800135F0
		nop
		jal     sub_8002D860
		nop
		lw      $a0, 0x38 + var_18($sp)
		jal     sub_8002F600
		nop
		jal     GetRCnt
		lui     $a0, 0xF200
		andi    $v0, 0xFFFF
		lw      $a0, -0x6FA8($gp)
		lw      $t0, 0x38 + arg_0($sp)
		sll     $a0, 16
		lw      $a1, 0x134($t0)
		lw      $v1, 0x268($t0)
		or $v0, $a0
		sltu    $v1, $a1
		bnez    $v1, loc_8002FE0C
		sw      $v0, 0x258($t0)

		loc_8002FDE8:
	lw      $t0, 0x38 + arg_0($sp)
		nop
		lw      $a0, 0x118($t0)
		jal     sub_80025210
		nop
		beqz    $v0, loc_8002FE3C
		nop
		j       loc_8002FDE8
		nop

		loc_8002FE0C :
	lw      $t0, 0x38 + arg_0($sp)
		nop
		lw      $a0, 0x118($t0)
		nop
		beqz    $a0, loc_8002FE40
		nop
		jal     sub_800BA9A0
		nop
		lw      $t0, 0x38 + arg_0($sp)
		nop
		sw      $zero, 0x118($t0)
		sw      $zero, 0x134($t0)

		loc_8002FE3C:
	lw      $t0, 0x38 + arg_0($sp)

		loc_8002FE40 :
		nop
		lw      $a0, 0x258($t0)
		jal     sub_8003DE4C
		nop
		lw      $t0, 0x38 + var_18($sp)
		nop
		addiu   $s0, $t0, 0x2FFC
		lw      $t0, 0x38 + arg_0($sp)
		nop
		lw      $v1, 4($t0)
		move    $a0, $s0
		sw      $v0, 0x258($t0)
		li      $v0, 1
		subu    $v0, $v1
		jal     nullsub_1
		sw      $v0, 4($t0)
		lw      $a0, 0x38 + var_18($sp)
		jal     sub_8002E558
		nop
		jal     GetRCnt
		lui     $a0, 0xF200
		lw      $t0, 0x38 + arg_0($sp)
		nop
		addiu   $v1, $t0, 0x228
		sw      $v1, 0x11C($t0)
		lw      $v1, -0x6FA8($gp)
		andi    $v0, 0xFFFF
		sll     $v1, 16
		or $v0, $v1
		sw      $v0, 0x120($t0)
		lw      $v0, -0x40F8($gp)//gameTrackerX.gameFlags
		lui     $v1, 0x800
		and $v0, $v1
		beqz    $v0, loc_8002FEE0
		nop
		lw      $a0, 0x38 + var_18($sp)
		jal     sub_8002FF18
		nop
		j       loc_8002FEE8
		nop

		loc_8002FEE0 :
	jal     sub_800BA870
		move    $a0, $s0

		loc_8002FEE8 :
	lw      $ra, 0x38 + var_s24($sp)
		lw      $fp, 0x38 + var_s20($sp)
		lw      $s7, 0x38 + var_s1C($sp)
		lw      $s6, 0x38 + var_s18($sp)
		lw      $s5, 0x38 + var_s14($sp)
		lw      $s4, 0x38 + var_s10($sp)
		lw      $s3, 0x38 + var_sC($sp)
		lw      $s2, 0x38 + var_s8($sp)
		lw      $s1, 0x38 + var_s4($sp)
		lw      $s0, 0x38 + var_s0($sp)
		jr      $ra
		addiu   $sp, 0x60
#endif
}


// autogenerated function stub: 
// void /*$ra*/ GAMELOOP_DrawSavedOT(unsigned long **newOT /*$t3*/)
void GAMELOOP_DrawSavedOT(unsigned long **newOT)
{ // line 2710, offset 0x8002fc20
	/* begin block 1 */
		// Start line: 2711
		// Start offset: 0x8002FC20
		// Variables:
			//struct P_TAG *tag; // $a1
			int y; // $a2

		/* begin block 1.1 */
			// Start line: 2719
			// Start offset: 0x8002FC84
			// Variables:
				int tpage; // $v1
		/* end block 1.1 */
		// End offset: 0x8002FCAC
		// End Line: 2727

		/* begin block 1.2 */
			// Start line: 2732
			// Start offset: 0x8002FCC0
			// Variables:
				//int tpage; // $v1
		/* end block 1.2 */
		// End offset: 0x8002FCE8
		// End Line: 2740

		/* begin block 1.3 */
			// Start line: 2745
			// Start offset: 0x8002FCFC
		/* end block 1.3 */
		// End offset: 0x8002FD30
		// End Line: 2756
	/* end block 1 */
	// End offset: 0x8002FD54
	// End Line: 2759

	/* begin block 2 */
		// Start line: 6396
	/* end block 2 */
	// End Line: 6397

}

void ResetPrimPool()
{
#if defined(PSX_VERSION)
	ResetDrawPage();

	if (!(gameTrackerX.gameFlags & 0x8000000))
	{
		if (gameTrackerX.primPool == primPool[0])
		{
			gameTrackerX.primPool = primPool[1];
		}
		else
		{
			gameTrackerX.primPool = primPool[0];
		}

		gameTrackerX.primPool->nextPrim = &gameTrackerX.primPool->prim[0];
	}
	else
	{
		if (gameTrackerX.drawPage != 0)
		{
			gameTrackerX.primPool->nextPrim = &gameTrackerX.primPool->prim[16492];
		}
		else
		{
			gameTrackerX.primPool->nextPrim = &gameTrackerX.primPool->prim[9000];
		}
	}

	gameTrackerX.primPool->numPrims = 0;

#elif defined(PC_VERSION)
	unsigned int** dispOT; // ecx
	struct _PrimPool* v1; // eax

	dispOT = gameTrackerX.dispOT;
	gameTrackerX.dispOT = gameTrackerX.drawOT;
	gameTrackerX.drawOT = dispOT;
	gameTrackerX.drawPage = 1 - gameTrackerX.drawPage;
	ClearOTagR((u_long*)dispOT, 3072);
	if ((gameTrackerX.gameFlags & 0x8000000) != 0)
	{
		if (gameTrackerX.drawPage)
			gameTrackerX.primPool->nextPrim = &gameTrackerX.primPool->prim[16500];
		else
			gameTrackerX.primPool->nextPrim = &gameTrackerX.primPool->prim[9000];
		gameTrackerX.primPool->numPrims = 0;
	}
	else
	{
		v1 = &primPool0;
		if (gameTrackerX.primPool == &primPool0)
			v1 = &primPool1;
		gameTrackerX.primPool = v1;
		v1->nextPrim = v1->prim;
		gameTrackerX.primPool->numPrims = 0;
	}
#endif
}


// autogenerated function stub: 
// void /*$ra*/ Switch_For_Redraw()
void Switch_For_Redraw()
{ // line 2793, offset 0x8002fe44
	/* begin block 1 */
		// Start line: 2795
		// Start offset: 0x8002FE44
		// Variables:
			unsigned long **temp; // $v1
	/* end block 1 */
	// End offset: 0x8002FEA4
	// End Line: 2820

	/* begin block 2 */
		// Start line: 6612
	/* end block 2 */
	// End Line: 6613

	/* begin block 3 */
		// Start line: 6613
	/* end block 3 */
	// End Line: 6614

	/* begin block 4 */
		// Start line: 6616
	/* end block 4 */
	// End Line: 6617

}


// autogenerated function stub: 
// void /*$ra*/ GAMELOOP_Set_Pause_Redraw()
void GAMELOOP_Set_Pause_Redraw()
{ // line 2824, offset 0x8002fec0
	word_C54F8C = 1;
}


// autogenerated function stub: 
// void /*$ra*/ SaveOT()
void SaveOT()
{ // line 2829, offset 0x8002fed0
	/* begin block 1 */
		// Start line: 2830
		// Start offset: 0x8002FED0
		// Variables:
			//struct P_TAG *tag; // $a0
			//struct P_TAG *last; // $s0
			//struct P_TAG *lastlast; // $s1
	/* end block 1 */
	// End offset: 0x8003005C
	// End Line: 2880

	/* begin block 2 */
		// Start line: 6687
	/* end block 2 */
	// End Line: 6688

}

void ResetDrawPage()
{ 
	unsigned long **temp;

	temp = gameTrackerX.drawOT;
	gameTrackerX.drawOT = gameTrackerX.dispOT;
	gameTrackerX.dispOT = temp;
	gameTrackerX.drawPage = 1 - gameTrackerX.drawPage;

	ClearOTagR((unsigned long*)gameTrackerX.drawOT, 3072);
}


// autogenerated function stub: 
// void /*$ra*/ GAMELOOP_Set24FPS()
void GAMELOOP_Set24FPS()
{ // line 2914, offset 0x800300b0
	gameTrackerX.frameRate24fps = 1;
}


// autogenerated function stub: 
// void /*$ra*/ GAMELOOP_Reset24FPS()
void GAMELOOP_Reset24FPS()
{ // line 2920, offset 0x800300c0
	gameTrackerX.frameRate24fps = 0;
}


// autogenerated function stub: 
// void /*$ra*/ GAMELOOP_DoTimeProcess()
void GAMELOOP_DoTimeProcess()
{ // line 2925, offset 0x800300cc
	
#if defined(PC_VERSION)
	unsigned int TimeMS; // ebx
	int frameRateLock; // eax
	unsigned int lastLoopTime; // ecx
	unsigned int timeSinceLastGameFrame; // eax
	unsigned int fps30Count; // ecx

	TimeMS = TIMER_GetTimeMS();
	if ((gameTrackerX.gameFlags & 0x10000000) != 0)
	{
		gameTrackerX.lastLoopTime = -1;
		goto LABEL_27;
	}
	gameTrackerX.totalTime = D3D_TimeDiff(gameTrackerX.currentTicks);
	gameTrackerX.currentTicks = D3D_CurrentTime();
	frameRateLock = gameTrackerX.frameRateLock;
	if (gameTrackerX.frameRateLock < 1)
	{
		frameRateLock = 1;
		gameTrackerX.frameRateLock = 1;
	}
	if (frameRateLock > 2)
	{
		frameRateLock = 2;
		gameTrackerX.frameRateLock = 2;
	}
	if (gameTrackerX.decoupleGame && (gameTrackerX.gameFlags & 0x10000000) == 0)
	{
		lastLoopTime = 33;
		if (frameRateLock == 2)
			lastLoopTime = 50;
		if (gameTrackerX.gameData.asmData.MorphTime != 1000)
			lastLoopTime = 15;
		if (gameTrackerX.lastLoopTime != -1)
			lastLoopTime = TimeMS - gameTrackerX.currentTime;
		if (lastLoopTime > 0x42)
		{
			lastLoopTime = 66;
			gameTrackerX.lastLoopTime = 66;
			goto LABEL_22;
		}
		goto LABEL_20;
	}
	if (frameRateLock == 1)
	{
		lastLoopTime = 33;
		gameTrackerX.lastLoopTime = 33;
		goto LABEL_22;
	}
	if (frameRateLock == 2)
	{
		lastLoopTime = 50;
	LABEL_20:
		gameTrackerX.lastLoopTime = lastLoopTime;
		goto LABEL_22;
	}
	lastLoopTime = gameTrackerX.lastLoopTime;
LABEL_22:
	gameTrackerX.gameFramePassed = 0;
	gameTrackerX.timeMult = (lastLoopTime << 12) / 0x21;
	gameTrackerX.globalTimeMult = (lastLoopTime << 12) / 0x21;
	gameTrackerX.timeSinceLastGameFrame += (lastLoopTime << 12) / 0x21;
	timeSinceLastGameFrame = gameTrackerX.timeSinceLastGameFrame;
	if (gameTrackerX.timeSinceLastGameFrame <= 0x1000)
	{
	LABEL_27:
		gameTrackerX.currentTime = TimeMS;
		return;
	}
	fps30Count = gameTrackerX.fps30Count;
	do
	{
		timeSinceLastGameFrame -= 4096;
		++fps30Count;
		gameTrackerX.gameFramePassed = 1;
	} while (timeSinceLastGameFrame > 0x1000);
	gameTrackerX.fps30Count = fps30Count;
	gameTrackerX.timeSinceLastGameFrame = timeSinceLastGameFrame;
	gameTrackerX.currentTime = TimeMS;
#endif
}

void GAMELOOP_Process(struct GameTracker* gameTracker)
{
	int d;
	int useTime;
	struct Level* level;
	int i;
	struct _SFXMkr* sfxMkr;

	if (gEndGameNow != 0)
	{
		DEBUG_ExitGame();
		gameTrackerX.levelDone = 3;
	}
	else
	{
		GAMELOOP_DoTimeProcess();
		
		if (gameTrackerX.gameMode != 6 && !(gameTrackerX.streamFlags & 0x100000))
		{
			MORPH_UpdateTimeMult();
			GAMELOOP_CalcGameTime();

			if (gameTracker->gameData.asmData.MorphType != 0)
			{
				gameTracker->currentSpectralTime += gameTracker->lastLoopTime;
			}
			else
			{
				useTime = 1;
				if (gameTrackerX.playerInstance != NULL)
				{
					level = STREAM_GetLevelWithID(gameTrackerX.playerInstance->currentStreamUnitID);
					if (level != NULL)
					{
						useTime = level->unitFlags & 0x2000 < 1;
					}
				}
				if (useTime != 0)
				{
					gameTracker->currentTimeOfDayTime += gameTracker->lastLoopTime;

				}
				gameTracker->currentMaterialTime += gameTracker->lastLoopTime;
			}
		}
		gameTracker->numGSignals = 0;
		
		GAMELOOP_ChangeMode();

		ResetPrimPool();

		memset(gameTracker->overrideData, 0, sizeof(gameTracker->overrideData));

		if (gameTrackerX.gameMode != 6)
		{
			if (!(gameTrackerX.streamFlags & 0x100000))
			{
				if (gameTrackerX.SwitchToNewStreamUnit == 1)
				{
					INSTANCE_Post(gameTrackerX.playerInstance, 0x4000006, 0);
					STREAM_MoveIntoNewStreamUnit();
				}

				if (VRAM_NeedToUpdateMorph != 0)
				{
					if (STREAM_IsCdBusy(NULL) == 0)
					{
						VRAM_UpdateMorphPalettes();
						VRAM_NeedToUpdateMorph = 0;
					}
				}

				if (gameTracker->gameData.asmData.MorphTime < 1000)
				{
					MORPH_Continue();
				}

				if ((gameTracker->streamFlags & 0x80000))
				{
					gameTracker->streamFlags &= 0xFFF7FFFF;
					UNDERWORLD_StartProcess();
				}

				EVENT_DoProcess();

				for(i = 0; i < 16; i++)
				{
					if (StreamTracker.StreamList[i].used == 2)
					{
						if (StreamTracker.StreamList[i].level->PuzzleInstances != NULL)
						{
							if ((gameTrackerX.debugFlags2 & 0x100))
							{
								FONT_Print("Processing unit %s\n", StreamTracker.StreamList[i].baseAreaName);
							}

							EVENT_ProcessEvents(StreamTracker.StreamList[i].level->PuzzleInstances, StreamTracker.StreamList[i].level);
							EVENT_BSPProcess(&StreamTracker.StreamList[i]);
						}
					}
				}
				EVENT_ResetAllOneTimeVariables();
			}
			
			EVENT_ProcessHints();

			for (d = 0; d < 16; d++)
			{
				if (StreamTracker.StreamList[d].used == 2 && StreamTracker.StreamList[d].level->NumberOfSFXMarkers > 0)
				{
					for (i = 0; i < StreamTracker.StreamList[d].level->NumberOfSFXMarkers; i++)
					{
						sfxMkr = &StreamTracker.StreamList[d].level->SFXMarkerList[i];
						if (sfxMkr != NULL && sfxMkr->soundData != NULL)
						{
							SOUND_ProcessInstanceSounds(sfxMkr->soundData, sfxMkr->sfxTbl, &sfxMkr->pos, sfxMkr->livesInOnePlace, sfxMkr->inSpectral, 0, 0, NULL);
						}
					}
				}
			}

			if (!(gameTrackerX.streamFlags & 0x100000))
			{
				INSTANCE_SpatialRelationships(instanceList);
			}
			
			INSTANCE_ProcessFunctions(gameTracker->instanceList);
			INSTANCE_CleanUpInstanceList(gameTracker->instanceList, 0);
			INSTANCE_DeactivateFarInstances(gameTracker);
			MONAPI_ProcessGenerator();

			getScratchAddr(0)[0] = ((unsigned long*)&theCamera.core.position.x)[0];
			getScratchAddr(1)[0] = ((unsigned long*)&theCamera.core.position.z)[0];
			
#if 0//Right this is either done to do this fast on the scratch pad!
			//t0 = &StackSave
			sw      $sp, 0($t0)
			li      $t4, 0x1F8003F0
			move    $sp, $t4
#endif

			G2Instance_BuildTransformsForList(gameTracker->instanceList->first);


#if 0//Right this is either done to do this fast on the scratch pad!
			//t0 = &StackSave
			lw      $sp, 0($t0)
#endif
			if (!(gameTrackerX.streamFlags & 0x100000))
			{
#if 0///@TODO macro for PSX! "PUSH_STACK"
				sw      $sp, 0($t0)
				li      $t4, 0x1F8003F0
				move    $sp, $t4
#endif
				//FX_ProcessList(fxTracker);

				
#if 0///@TODO macro for PSX! "POP_STACK"
				//t0 = &StackSave
				lw      $sp, 0($t0)
#endif
				if (!(gameTrackerX.streamFlags & 0x100000))
				{
					VM_Tick(256);

					if ((gameTracker->debugFlags2 & 0x10000))
					{
						FONT_Print("Military Time %04d\n", gameTrackerX.timeOfDay);
					}

					for (d = 0; d < 16; d++)
					{
						if (StreamTracker.StreamList[d].used == 2)
						{
							///VM_ProcessVMObjectList_S(StreamTracker.StreamList[d].level, theCamera);
						}
					}

					if (!(gameTrackerX.streamFlags & 0x100000))
					{
						PLANAPI_UpdatePlanningDatabase(gameTracker, gameTrackerX.playerInstance);
					}
				}
			}

			DEBUG_Process(gameTracker);
			COLLIDE_InstanceList(gameTracker->instanceList);
			COLLIDE_InstanceListTerrain(gameTracker->instanceList);
			INSTANCE_AdditionalCollideFunctions(instanceList);
			COLLIDE_InstanceListWithSignals(instanceList);

			if (!(gameTrackerX.streamFlags & 0x100000))
			{
				LIGHT_CalcShadowPositions(gameTracker);
				INSTANCE_CleanUpInstanceList(gameTracker->instanceList, 16);
			}
		
			CAMERA_Process(&theCamera);
			PIPE3D_CalculateWCTransform(&theCamera.core);
			theCamera.core.wcTransform->t[0] = 0;
			PIPE3D_InvertTransform(theCamera.core.cwTransform2, theCamera.core.wcTransform2);
			CAMERA_CalcVVClipInfo(&theCamera);

			if (gameTracker->levelChange != 0)
			{
				gameTracker->levelChange = 0;
			}
			
			SAVE_IntroduceBufferIntros();
		}
		else
		{
			getScratchAddr(0)[0] = ((unsigned long*)&theCamera.core.position.x)[0];
			getScratchAddr(1)[0] = ((unsigned long*)&theCamera.core.position.z)[0];
#if 0
			sw      $sp, 0($t0)
			li      $t4, 0x1F8003F0
			move    $sp, $t4
#endif

			G2Instance_BuildTransformsForList(gameTracker->instanceList->first);

#if 0
			//t0 = &StackSave
			addiu   $t0, $gp, -0x45AC
			lw      $sp, 0($t0)
#endif
			DEBUG_Process(gameTracker);
		}

		if (gameTracker->levelDone == 0)
		{
			GAMELOOP_DisplayFrame(gameTracker);
		}
		else
		{
			ResetDrawPage();
		}

		gameTracker->frameCount++;
		gameTracker->debugFlags &= 0xF7FFFFFF;
	}
}


// autogenerated function stub: 
// void /*$ra*/ GAMELOOP_ModeStartRunning()
void GAMELOOP_ModeStartRunning()
{ // line 3411, offset 0x80030920
	/* begin block 1 */
		// Start line: 7987
	/* end block 1 */
	// End Line: 7988

}


// autogenerated function stub: 
// void /*$ra*/ GAMELOOP_ModeStartPause()
void GAMELOOP_ModeStartPause()
{ // line 3441, offset 0x800309f8
	/* begin block 1 */
		// Start line: 8050
	/* end block 1 */
	// End Line: 8051

}


// autogenerated function stub: 
// void /*$ra*/ GAMELOOP_ChangeMode()
void GAMELOOP_ChangeMode()
{ // line 3493, offset 0x80030ad0
	/* begin block 1 */
		// Start line: 3494
		// Start offset: 0x80030AD0
		// Variables:
			long *controlCommand; // $s0
	/* end block 1 */
	// End offset: 0x80030E6C
	// End Line: 3661

	/* begin block 2 */
		// Start line: 6986
	/* end block 2 */
	// End Line: 6987

}


// autogenerated function stub: 
// void /*$ra*/ GAMELOOP_RequestLevelChange(char *name /*$s2*/, short number /*$a1*/, struct GameTracker *gameTracker /*$s0*/)
void GAMELOOP_RequestLevelChange(char *name, short number, struct GameTracker *gameTracker)
{ // line 3664, offset 0x80030e7c
	if (!gameTracker->levelChange)
	{
		gameTracker->gameFlags |= 1u;
		SOUND_ResetAllSound();
		sprintf(gameTracker->baseAreaName, "%s%d", name, number);
		gameTracker->levelChange = 1;
		gameTracker->levelDone = 1;
	}
}

void PSX_GameLoop(struct GameTracker *gameTracker)
{
	GAMEPAD_Process(gameTracker);
	GAMELOOP_Process(gameTracker);
}


// autogenerated function stub: 
// struct MATRIX * /*$ra*/ GAMELOOP_GetMatrices(int numMatrices /*$a0*/)
MATRIX * GAMELOOP_GetMatrices(int numMatrices)
{ // line 3696, offset 0x80030f28
#if defined(PC_VERSION)
	MATRIX* result; // eax
	u_long* v2; // edx

	result = (struct MATRIX*)gameTrackerX.primPool->nextPrim;
	v2 = (u_long*)&result[numMatrices];
	if (v2 >= gameTrackerX.primPool->lastPrim)
		return 0;
	gameTrackerX.primPool->nextPrim = v2;
	return result;
#else
	return NULL;
#endif
}


// autogenerated function stub: 
// struct GameTracker * /*$ra*/ GAMELOOP_GetGT()
struct GameTracker * GAMELOOP_GetGT()
{ // line 3720, offset 0x80030f5c
	return &gameTrackerX;
}




