#include "THISDUST.H"
#include "STRMLOAD.H"
#include "LOAD3D.H"
#include "DEBUG.H"

#include <stddef.h>

// autogenerated function stub: 
// void /*$ra*/ STREAM_NextLoadFromHead()
void STREAM_NextLoadFromHead()
{ // line 37, offset 0x8005fae8
	/* begin block 1 */
		// Start line: 74
	/* end block 1 */
	// End Line: 75

	/* begin block 2 */
		// Start line: 75
	/* end block 2 */
	// End Line: 76

}


// autogenerated function stub: 
// void /*$ra*/ STREAM_NextLoadCanFail()
void STREAM_NextLoadCanFail()
{ // line 42, offset 0x8005faf8
	/* begin block 1 */
		// Start line: 84
	/* end block 1 */
	// End Line: 85

	/* begin block 2 */
		// Start line: 85
	/* end block 2 */
	// End Line: 86

}


// autogenerated function stub: 
// void /*$ra*/ STREAM_NextLoadAsNormal()
void STREAM_NextLoadAsNormal()
{ // line 47, offset 0x8005fb08
	/* begin block 1 */
		// Start line: 94
	/* end block 1 */
	// End Line: 95

	/* begin block 2 */
		// Start line: 95
	/* end block 2 */
	// End Line: 96

}

void STREAM_InitLoader(char *bigFileName, char *voiceFileName)
{ 
	int i;

	LOAD_InitCdLoader(bigFileName, voiceFileName);
	
	loadFree = &LoadQueue[38];
	loadHead = NULL;
	loadTail = NULL;
	numLoads = 0;

	for (i = 38; i >= 0; i--)
	{
		LoadQueue[i].next = &LoadQueue[i + 1];
	}

	LoadQueue[39].next = NULL;
}


// autogenerated function stub: 
// void /*$ra*/ STREAM_RemoveQueueHead()
void STREAM_RemoveQueueHead()
{ // line 73, offset 0x8005fb6c
	/* begin block 1 */
		// Start line: 75
		// Start offset: 0x8005FB6C
		// Variables:
			struct _LoadQueueEntry *entry; // $a0
	/* end block 1 */
	// End offset: 0x8005FB8C
	// End Line: 80

	/* begin block 2 */
		// Start line: 154
	/* end block 2 */
	// End Line: 155

	/* begin block 3 */
		// Start line: 155
	/* end block 3 */
	// End Line: 156

	/* begin block 4 */
		// Start line: 156
	/* end block 4 */
	// End Line: 157

}


// autogenerated function stub: 
// void /*$ra*/ STREAM_RemoveQueueEntry(struct _LoadQueueEntry *entry /*$a0*/, struct _LoadQueueEntry *prev /*$a1*/)
void STREAM_RemoveQueueEntry(struct _LoadQueueEntry *entry, struct _LoadQueueEntry *prev)
{ // line 85, offset 0x8005fbac
	/* begin block 1 */
		// Start line: 181
	/* end block 1 */
	// End Line: 182

	/* begin block 2 */
		// Start line: 182
	/* end block 2 */
	// End Line: 183

}

struct _LoadQueueEntry * STREAM_AddQueueEntryToTail()
{ 
	struct _LoadQueueEntry *entry;
	
	entry = loadFree;
	if (entry == NULL)
	{
		DEBUG_FatalError("CD ERROR: too many queue entries\n");
	}

	loadFree = entry->next;
	entry->next = NULL;
	
	if (loadTail != NULL)
	{
		loadTail->next = entry;
	}
	else
	{
		loadHead->next = entry;
	}

	loadTail = entry;
	numLoads++;

	return entry;
}


// autogenerated function stub: 
// struct _LoadQueueEntry * /*$ra*/ STREAM_AddQueueEntryToHead()
struct _LoadQueueEntry * STREAM_AddQueueEntryToHead()
{ // line 123, offset 0x8005fc74
	/* begin block 1 */
		// Start line: 124
		// Start offset: 0x8005FC74
		// Variables:
			struct _LoadQueueEntry *entry; // $s0
	/* end block 1 */
	// End offset: 0x8005FD08
	// End Line: 148

	/* begin block 2 */
		// Start line: 268
	/* end block 2 */
	// End Line: 269

	return null;
}


// autogenerated function stub: 
// int /*$ra*/ STREAM_IsCdBusy(long *numberInQueue /*$a0*/)
int STREAM_IsCdBusy(long *numberInQueue)
{ // line 157, offset 0x8005fd28
	int IsBusy; // eax

	IsBusy = ASLD_IsBusy();
	if (numberInQueue)
		*numberInQueue = IsBusy;
	return IsBusy != 0;
}


// autogenerated function stub: 
// int /*$ra*/ STREAM_PollLoadQueue()
int STREAM_PollLoadQueue()
{ // line 174, offset 0x8005fd48
	/* begin block 1 */
		// Start line: 175
		// Start offset: 0x8005FD48

		/* begin block 1.1 */
			// Start line: 180
			// Start offset: 0x8005FD68
			// Variables:
				struct _LoadQueueEntry *queueEntry; // $s0

			/* begin block 1.1.1 */
				// Start line: 210
				// Start offset: 0x8005FE10
				// Variables:
					long size; // $v0
			/* end block 1.1.1 */
			// End offset: 0x8005FE3C
			// End Line: 216

			/* begin block 1.1.2 */
				// Start line: 254
				// Start offset: 0x8005FF14
				// Variables:
					struct _LoadQueueEntry *newQueue; // $v0
			/* end block 1.1.2 */
			// End offset: 0x8005FF14
			// End Line: 254

			/* begin block 1.1.3 */
				// Start line: 293
				// Start offset: 0x8005FFAC
				// Variables:
					struct _LoadQueueEntry *newQueue; // $v0
			/* end block 1.1.3 */
			// End offset: 0x8005FFAC
			// End Line: 293
		/* end block 1.1 */
		// End offset: 0x800600B4
		// End Line: 409
	/* end block 1 */
	// End offset: 0x800600B8
	// End Line: 412

	/* begin block 2 */
		// Start line: 377
	/* end block 2 */
	// End Line: 378

	return 0;
}


// autogenerated function stub: 
// struct _LoadQueueEntry * /*$ra*/ STREAM_SetUpQueueEntry(char *fileName /*$s2*/, void *retFunc /*$s3*/, void *retData /*$s4*/, void *retData2 /*$s5*/, void **retPointer /*stack 16*/, int fromhead /*stack 20*/)
struct _LoadQueueEntry * STREAM_SetUpQueueEntry(char *fileName, void *retFunc, void *retData, void *retData2, void **retPointer, int fromhead)
{ // line 414, offset 0x800600c8
	/* begin block 1 */
		// Start line: 415
		// Start offset: 0x800600C8
		// Variables:
			struct _LoadQueueEntry *currentEntry; // $s0
	/* end block 1 */
	// End offset: 0x8006018C
	// End Line: 448

	/* begin block 2 */
		// Start line: 865
	/* end block 2 */
	// End Line: 866

	return null;
}

void STREAM_QueueNonblockingLoads(char *fileName, unsigned char memType, void *retFunc, void *retData, void *retData2, void **retPointer, long relocateBinary)
{ 
	struct _LoadQueueEntry* currentEntry;
	int fromhead;

	fromhead = loadFromHead;
	loadFromHead = 0;
	currentEntry = STREAM_SetUpQueueEntry(fileName, retFunc, retData, retData2, retPointer, fromhead);
	currentEntry->loadEntry.loadAddr = NULL;
	currentEntry->mempackUsed = 1;
	currentEntry->loadEntry.memType = memType;
	currentEntry->relocateBinary = relocateBinary;

	if (memType == 0)
	{
		currentEntry->status = 5;
	}
	else
	{
		currentEntry->status = 1;
	}
}


// autogenerated function stub: 
// void /*$ra*/ LOAD_LoadToAddress(char *fileName /*$a0*/, void *loadAddr /*$s0*/, long relocateBinary /*$s1*/)
void LOAD_LoadToAddress(char *fileName, void *loadAddr, long relocateBinary)
{ // line 475, offset 0x80060240
	/* begin block 1 */
		// Start line: 476
		// Start offset: 0x80060240
		// Variables:
			struct _LoadQueueEntry *currentEntry; // $v0
	/* end block 1 */
	// End offset: 0x80060294
	// End Line: 485

	/* begin block 2 */
		// Start line: 1011
	/* end block 2 */
	// End Line: 1012

}


// autogenerated function stub: 
// void /*$ra*/ LOAD_NonBlockingBinaryLoad(char *fileName /*$a0*/, void *retFunc /*$t0*/, void *retData /*$t1*/, void *retData2 /*$a3*/, void **retPointer /*stack 16*/, int memType /*stack 20*/)
void LOAD_NonBlockingBinaryLoad(char *fileName, void *retFunc, void *retData, void *retData2, void **retPointer, int memType)
{ // line 498, offset 0x800602a8
	STREAM_QueueNonblockingLoads(fileName, memType, retFunc, retData, retData2, retPointer, 1);
}


// autogenerated function stub: 
// void /*$ra*/ LOAD_NonBlockingFileLoad(char *fileName /*$a0*/, void *retFunc /*$v1*/, void *retData /*$t0*/, void *retData2 /*$a3*/, void **retPointer /*stack 16*/, int memType /*stack 20*/)
void LOAD_NonBlockingFileLoad(char *fileName, void *retFunc, void *retData, void *retData2, void **retPointer, int memType)
{ // line 505, offset 0x800602ec
	STREAM_QueueNonblockingLoads(fileName, memType, retFunc, retData, retData2, retPointer, 0);
}


// autogenerated function stub: 
// void /*$ra*/ LOAD_NonBlockingBufferedLoad(char *fileName /*$a0*/, void *retFunc /*$v0*/, void *retData /*$v1*/, void *retData2 /*$a3*/)
void LOAD_NonBlockingBufferedLoad(char *fileName, void *retFunc, void *retData, void *retData2)
{ // line 511, offset 0x8006032c
}


// autogenerated function stub: 
// int /*$ra*/ LOAD_IsXAInQueue()
int LOAD_IsXAInQueue()
{ // line 516, offset 0x80060368
	return VOICEXA_IsPlaying();
}


// autogenerated function stub: 
// void /*$ra*/ LOAD_PlayXA(int number /*$s0*/)
void LOAD_PlayXA(int number)
{ // line 529, offset 0x800603b0
	VOICEXA_Play(number, 0);
}

long * LOAD_ReadFile(char *fileName, unsigned char memType)
{ 
	void *loadAddr;
	
	STREAM_QueueNonblockingLoads(fileName, 255, NULL, NULL, NULL, &loadAddr, 0);

	while (STREAM_PollLoadQueue() != 0)
	{
	}

	return (long*)loadAddr;
}

void LOAD_ChangeDirectory(char *name)
{
	struct _LoadQueueEntry* currentEntry;

	currentEntry = STREAM_AddQueueEntryToTail();
	gCurDir = LOAD_HashUnit(name);
	currentEntry->loadEntry.dirHash = gCurDir;
	currentEntry->loadEntry.fileHash = 0;
	currentEntry->status = 10;
	sprintf(&currentEntry->loadEntry.fileName[8], "dir %s", name);
}


// autogenerated function stub: 
// void /*$ra*/ LOAD_AbortDirectoryChange(char *name /*$a0*/)
void LOAD_AbortDirectoryChange(char *name)
{ // line 569, offset 0x80060478
	/* begin block 1 */
		// Start line: 570
		// Start offset: 0x80060478

		/* begin block 1.1 */
			// Start line: 574
			// Start offset: 0x80060488
			// Variables:
				struct _LoadQueueEntry *entry; // $a0
				struct _LoadQueueEntry *prev; // $a1
				long hash; // $v1
		/* end block 1.1 */
		// End offset: 0x800604F0
		// End Line: 589
	/* end block 1 */
	// End offset: 0x800604F0
	// End Line: 591

	/* begin block 2 */
		// Start line: 1216
	/* end block 2 */
	// End Line: 1217

	/* begin block 3 */
		// Start line: 1218
	/* end block 3 */
	// End Line: 1219

}


// autogenerated function stub: 
// void /*$ra*/ LOAD_AbortFileLoad(char *fileName /*$a0*/, void *retFunc /*$s3*/)
void LOAD_AbortFileLoad(char *fileName, void *retFunc)
{ // line 593, offset 0x80060500
	/* begin block 1 */
		// Start line: 594
		// Start offset: 0x80060500

		/* begin block 1.1 */
			// Start line: 597
			// Start offset: 0x80060524
			// Variables:
				struct _LoadQueueEntry *entry; // $s0
				struct _LoadQueueEntry *prev; // $s1
				long hash; // $v1
		/* end block 1.1 */
		// End offset: 0x800605B4
		// End Line: 623
	/* end block 1 */
	// End offset: 0x800605B4
	// End Line: 624

	/* begin block 2 */
		// Start line: 1276
	/* end block 2 */
	// End Line: 1277

	/* begin block 3 */
		// Start line: 1277
	/* end block 3 */
	// End Line: 1278

}




