#include "../core.H"
#include "QUATG2.H"
#include "../COLLIDE.H"

// autogenerated function stub: 
// void /*$ra*/ G2Quat_ToEuler(struct _G2Quat_Type *quat /*$a0*/, struct _G2EulerAngles_Type *euler /*$s0*/, int order /*$s1*/)
void G2Quat_ToEuler(struct _G2Quat_Type *quat, struct _G2EulerAngles_Type *euler, int order)
{ // line 74, offset 0x80095ed8
	struct _G2Matrix_Type matrix; // [esp+0h] [ebp-20h] BYREF

	G2Quat_ToMatrix((struct _G2EulerAngles_Type*)quat, &matrix);
	G2EulerAngles_FromMatrix(euler, &matrix, order);
}

BYTE byte_4F4BE0[] = { 1, 2, 0, 1, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0 };

// autogenerated function stub: 
// void /*$ra*/ G2EulerAngles_FromMatrix(struct _G2EulerAngles_Type *euler /*$s3*/, struct _G2Matrix_Type *matrix /*$s4*/, long order /*stack 8*/)
void G2EulerAngles_FromMatrix(struct _G2EulerAngles_Type *euler, struct _G2Matrix_Type *matrix, long order)
{ // line 328, offset 0x80095f1c
#if defined(PC_VERSION)
	bool v3; // ecx
	int v4; // esi
	int v5; // edi
	int v6; // ebx
	struct _G2EulerAngles_Type* v7; // ebp
	__int16 v8; // ax
	__int16 y; // dx
	__int16 v10; // cx
	__int16 x; // ax
	int v12; // [esp+10h] [ebp-14h]
	int v13; // [esp+10h] [ebp-14h]
	__int16* v14; // [esp+14h] [ebp-10h]
	__int16* v15; // [esp+14h] [ebp-10h]
	__int16* v16; // [esp+18h] [ebp-Ch]

	v3 = (order & 4) != 0;
	v4 = byte_4F4BE0[(((unsigned int)order >> 3) & 3) + 8];
	v5 = byte_4F4BE0[v3 + v4];
	v6 = byte_4F4BE0[v4 - v3 + 1];
	if ((order & 2) != 0)
	{
		v16 = &matrix->rotScale[v4][v5];
		v14 = &matrix->rotScale[v4][v6];
		v12 = MATH3D_FastSqrt((*v14 * *v14 + *v16 * *v16) >> 12);
		if (v12 > 16)
		{
			v7 = euler;
			euler->x = ratan2(*v16, *v14);
			euler->y = ratan2(v12, matrix->rotScale[0][4 * v4]);
			euler->z = ratan2(matrix->rotScale[0][2 * v5 + v4 + v5], -matrix->rotScale[0][2 * v6 + v4 + v6]);
			goto LABEL_9;
		}
		v7 = euler;
		euler->x = ratan2(-matrix->rotScale[0][2 * v5 + v6 + v5], matrix->rotScale[0][4 * v5]);
		v8 = ratan2(v12, matrix->rotScale[0][4 * v4]);
	}
	else
	{
		v15 = &matrix->rotScale[v5][v4];
		v13 = MATH3D_FastSqrt((matrix->rotScale[0][4 * v4] * matrix->rotScale[0][4 * v4] + *v15 * *v15) >> 12);
		if (v13 > 16)
		{
			v7 = euler;
			euler->x = ratan2(matrix->rotScale[v6][v5], matrix->rotScale[0][4 * v6]);
			euler->y = ratan2(-matrix->rotScale[v6][v4], v13);
			euler->z = ratan2(*v15, matrix->rotScale[0][4 * v4]);
			goto LABEL_9;
		}
		v7 = euler;
		euler->x = ratan2(-matrix->rotScale[v5][v6], matrix->rotScale[0][4 * v5]);
		v8 = ratan2(-matrix->rotScale[0][2 * v6 + v4 + v6], v13);
	}
	v7->y = v8;
	v7->z = 0;
LABEL_9:
	if ((order & 4) != 0)
	{
		y = v7->y;
		v7->x = -v7->x;
		v10 = -v7->z;
		v7->y = -y;
		v7->z = v10;
	}
	if ((order & 1) == 1)
	{
		x = v7->x;
		v7->x = v7->z;
		v7->z = x;
	}
	v7->order = order;
#endif
}




