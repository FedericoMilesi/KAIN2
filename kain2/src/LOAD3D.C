#include "THISDUST.H"
#include "LOAD3D.H"
#include "FONT.H"
#include "MEMPACK.H"
#include "TIMER.H"
#include "VOICEXA.H"

#include <stdlib.h>

void LOAD_InitCd()
{
#ifdef PSX_VERSION
	CdInit();
	ResetCallback();
	CdSetDebug(0);
#endif
}


// autogenerated function stub: 
// void /*$ra*/ LOAD_CdSeekCallback(unsigned char intr /*$a0*/, unsigned char *result /*$a1*/)
void LOAD_CdSeekCallback(unsigned char intr, unsigned char *result)
{ // line 255, offset 0x80036d74
	/* begin block 1 */
		// Start line: 327
	/* end block 1 */
	// End Line: 328

	/* begin block 2 */
		// Start line: 328
	/* end block 2 */
	// End Line: 329

}


// autogenerated function stub: 
// void /*$ra*/ LOAD_CdDataReady()
void LOAD_CdDataReady()
{ // line 267, offset 0x80036d90
	/* begin block 1 */
		// Start line: 268
		// Start offset: 0x80036D90

		/* begin block 1.1 */
			// Start line: 275
			// Start offset: 0x80036DCC
			// Variables:
				struct _ReadQueueEntry *currentQueueFile; // $s0
				long actualReadSize; // $a1

			/* begin block 1.1.1 */
				// Start line: 292
				// Start offset: 0x80036E30
				// Variables:
					int status; // $s1
			/* end block 1.1.1 */
			// End offset: 0x80036E9C
			// End Line: 324
		/* end block 1.1 */
		// End offset: 0x80036E9C
		// End Line: 325
	/* end block 1 */
	// End offset: 0x80036E9C
	// End Line: 330

	/* begin block 2 */
		// Start line: 351
	/* end block 2 */
	// End Line: 352

}


// autogenerated function stub: 
// void /*$ra*/ LOAD_CdReadReady(unsigned char intr /*$a0*/, unsigned char *result /*$a1*/)
void LOAD_CdReadReady(unsigned char intr, unsigned char *result)
{ // line 333, offset 0x80036eb0
	/* begin block 1 */
		// Start line: 334
		// Start offset: 0x80036EB0

		/* begin block 1.1 */
			// Start line: 344
			// Start offset: 0x80036EDC
			// Variables:
				long crap[3]; // stack offset -40
				int bytes; // $s0

			/* begin block 1.1.1 */
				// Start line: 367
				// Start offset: 0x80036F50
				// Variables:
					struct CdlLOC loc; // stack offset -24
			/* end block 1.1.1 */
			// End offset: 0x80036F50
			// End Line: 370
		/* end block 1.1 */
		// End offset: 0x80036F50
		// End Line: 370
	/* end block 1 */
	// End offset: 0x80036F88
	// End Line: 396

	/* begin block 2 */
		// Start line: 488
	/* end block 2 */
	// End Line: 489

}

void LOAD_UpdateCheckSum(long bytes)
{
	if (loadStatus.currentQueueFile.checksumType == 1 && bytes != 0)
	{
		do
		{
			loadStatus.checksum += *loadStatus.checkAddr++;
		} while(bytes -= sizeof(long));
	}
}

void LOAD_DoCDReading()
{
	long bytesLoaded;
	long readSoFar;
	long state;
	long lastCheck;

	state = loadStatus.state;
	readSoFar = loadStatus.currentQueueFile.readCurSize;
	lastCheck = loadStatus.lastCheckPos;
	bytesLoaded = readSoFar - lastCheck;

	loadStatus.lastCheckPos = readSoFar;

	if (bytesLoaded != 0 && loadStatus.currentQueueFile.checksumType != 0)
	{
		LOAD_UpdateCheckSum(bytesLoaded);
	}

	if (state == 5)
	{
		if (loadStatus.currentQueueFile.checksumType != 0 && loadStatus.checksum != loadStatus.currentQueueFile.checksum)
		{
			loadStatus.currentQueueFile.readStatus = 7;
		}
		else
		{
			loadStatus.currentQueueFile.readStatus = 0;

			if (loadStatus.currentDirLoading != 0)
			{
				loadStatus.currentDirLoading = 0;
				MEMPACK_SetMemoryDoneStreamed((char*)loadStatus.bigFile.currentDir);
			}
		}
	}
}

void LOAD_DoCDBufferedReading()
{ 
	if (loadStatus.state == 5)
	{
		loadStatus.currentQueueFile.readStatus = 0;
	}
}

void LOAD_SetupFileToDoCDReading()
{
#define CD_SECTOR_LENGTH 2048

	struct CdlLOC loc;

	loadStatus.currentQueueFile.readStatus = 3;
	loadStatus.checksum = 0;
	loadStatus.lastCheckPos = 0;
	loadStatus.state = 1;
	loadStatus.currentQueueFile.readCurDest = loadStatus.currentQueueFile.readStartDest;
	loadStatus.checkAddr = (long*)loadStatus.currentQueueFile.readStartDest;

	if (loadStatus.currentQueueFile.readStartPos < 0)
	{
		loadStatus.currentSector = loadStatus.bigFile.bigfileBaseOffset + ((loadStatus.currentQueueFile.readStartPos + (CD_SECTOR_LENGTH - 1)) >> 11);
	}
	else
	{
		loadStatus.currentSector = loadStatus.bigFile.bigfileBaseOffset + ((loadStatus.currentQueueFile.readStartPos >> 11) + loadStatus.bigFile.bigfileBaseOffset);
	}

	CdIntToPos(loadStatus.currentSector, &loc);
	CdControl(CdlReadN, &loc.minute, NULL);
	loadStatus.cdWaitTime = TIMER_GetTimeMS();
}


void LOAD_SetupFileToDoBufferedCDReading()
{
	struct CdlLOC loc;

	loadStatus.currentQueueFile.readStatus = 6;
	loadStatus.checksum = 0;
	loadStatus.state = 1;
	loadStatus.checkAddr = (long*)loadStatus.currentQueueFile.readStartDest;

	if (loadStatus.currentQueueFile.readStartPos < 0)
	{
		loadStatus.currentSector = loadStatus.bigFile.bigfileBaseOffset + ((loadStatus.currentQueueFile.readStartPos + (CD_SECTOR_LENGTH - 1)) >> 11);
	}
	else
	{
		loadStatus.currentSector = loadStatus.bigFile.bigfileBaseOffset + (loadStatus.currentQueueFile.readStartPos >> 11);
	}

	CdIntToPos(&loc);
	CdControl(CdlReadN, &loc.minute, NULL);
	loadStatus.cdWaitTime = TIMER_GetTimeMS();
}

void LOAD_ProcessReadQueue()
{
	long cdWaitTimeDiff;
	struct CdlLOC loc;

	if (gameTrackerX.debugFlags < 0)
	{
		FONT_Print("CD St %d LS %d sk %d tm %d rd %d cs %d\n", loadStatus.currentQueueFile.readStatus, loadStatus.state, loadStatus.seekTime, loadStatus.sectorTime, loadStatus.currentQueueFile.readCurSize);
	}

	if (loadStatus.currentQueueFile.readStatus == 3)
	{
		LOAD_DoCDReading();
	}
	else if (loadStatus.currentQueueFile.readStatus == 1)
	{
		LOAD_SetupFileToDoCDReading();
	}
	else if (loadStatus.currentQueueFile.readStatus == 5)
	{
		LOAD_SetupFileToDoBufferedCDReading();
	}
	else if (loadStatus.currentQueueFile.readStatus == 6)
	{
		LOAD_DoCDBufferedReading();
	}

	if (loadStatus.currentQueueFile.readStatus == 7)
	{
		loadStatus.currentQueueFile.readStatus = 1;
	}
	else if(loadStatus.cdWaitTime != 0)
	{
		cdWaitTimeDiff = TIMER_GetTimeMS() - loadStatus.cdWaitTime;

		if(cdWaitTimeDiff >= 8400)
		{
			if (loadStatus.currentQueueFile.readStatus == 3)
			{
				loadStatus.state = 0;
				CdReset(0);
				LOAD_InitCdStreamMode();
				loadStatus.state = 1;
				CdIntToPos(loadStatus.currentSector, &loc);
				CdControl(CdlReadN, &loc.minute, NULL);
				loadStatus.cdWaitTime = TIMER_GetTimeMS();
			}
			else if (loadStatus.currentQueueFile.readStatus == 6)
			{
				if (VOICEXA_IsPlaying() == 0)
				{
					CdControlF(CdlPause, NULL);
				}

				loadStatus.cdWaitTime = 0;
			}
		}
	}
}


// autogenerated function stub: 
// char * /*$ra*/ LOAD_ReadFileFromCD(char *filename /*$s1*/, int memType /*$s2*/)
char * LOAD_ReadFileFromCD(char *filename, int memType)
{ // line 705, offset 0x80037314
	/* begin block 1 */
		// Start line: 706
		// Start offset: 0x80037314
		// Variables:
			struct CdlFILE fp; // stack offset -40
			int i; // $s0
			char *readBuffer; // $s0
	/* end block 1 */
	// End offset: 0x800373DC
	// End Line: 750

	/* begin block 2 */
		// Start line: 1336
	/* end block 2 */
	// End Line: 1337

	return null;
}

void LOAD_CdReadFromBigFile(long fileOffset, unsigned long *loadAddr, long bytes, long chksumLevel, long checksum)
{
	loadStatus.currentQueueFile.readSize = bytes;
	loadStatus.currentQueueFile.readCurSize = 0;
	loadStatus.currentQueueFile.readStartDest = loadAddr;
	loadStatus.currentQueueFile.readStartPos = fileOffset;
	loadStatus.currentQueueFile.readStatus = 1;
	loadStatus.currentQueueFile.checksumType = chksumLevel;
	loadStatus.currentQueueFile.checksum = checksum;
}


// autogenerated function stub: 
// struct _BigFileDir * /*$ra*/ LOAD_ReadDirectory(struct _BigFileDirEntry *dirEntry /*$s0*/)
struct _BigFileDir * LOAD_ReadDirectory(struct _BigFileDirEntry *dirEntry)
{ // line 765, offset 0x80037420
	/* begin block 1 */
		// Start line: 766
		// Start offset: 0x80037420
		// Variables:
			struct _BigFileDir *dir; // $s2
			long sizeOfDir; // $s1
	/* end block 1 */
	// End offset: 0x80037420
	// End Line: 766

	/* begin block 2 */
		// Start line: 1479
	/* end block 2 */
	// End Line: 1480

	return null;
}

void LOAD_InitCdLoader(char *bigFileName, char *voiceFileName)
{
	struct CdlFILE fp;
	long i;
	char *ptr;

	loadStatus.state = 0;

	for(i = 0; i < 10; i++)
	{
		if (CdSearchFile(&fp, bigFileName) != NULL)
		{
			break;
		}

		CdReset(0);
	}

	if (i != 10)
	{
		LOAD_InitCdStreamMode();
		loadStatus.bigFile.bigfileBaseOffset = CdPosToInt(&fp.pos);
		loadStatus.cdWaitTime = 0;
		loadStatus.currentQueueFile.readStatus = 0;
		loadStatus.bigFile.currentDir = NULL;
		loadStatus.bigFile.currentDirID = 0;
		loadStatus.bigFile.cachedDir = NULL;
		loadStatus.bigFile.cachedDirID = 0;
		loadStatus.bigFile.searchDirID = 0;

		LOAD_CdReadFromBigFile(0, (unsigned long*)&loadStatus.bigFile.numSubDirs, 4, 0, 0);
		
		do
		{
			LOAD_ProcessReadQueue();
		
		} while (LOAD_IsFileLoading() != 0);
		

		CdControlF(CdlPause, NULL);
		ptr = MEMPACK_Malloc((loadStatus.bigFile.numSubDirs << 3) + 4, 8);

		CdSync(0, NULL);

		LOAD_CdReadFromBigFile(0, (unsigned long*)ptr, (loadStatus.bigFile.numSubDirs << 3) + 4, 0, 0);
		ptr += 4;
		loadStatus.bigFile.subDirList = (struct _BigFileDirEntry*)ptr;
		
		do
		{
			LOAD_ProcessReadQueue();

		} while (LOAD_IsFileLoading() != 0);

		loadStatus.bigFile.rootDir = LOAD_ReadDirectory(loadStatus.bigFile.subDirList);

		do
		{
			LOAD_ProcessReadQueue();

		} while (LOAD_IsFileLoading != 0);
	}
}


// autogenerated function stub: 
// int /*$ra*/ LOAD_SetupFileInfo(struct _NonBlockLoadEntry *loadEntry /*$s0*/)
int LOAD_SetupFileInfo(struct _NonBlockLoadEntry *loadEntry)
{ // line 934, offset 0x800375dc
	/* begin block 1 */
		// Start line: 935
		// Start offset: 0x800375DC
		// Variables:
			struct _BigFileEntry *fileInfo; // $v1
	/* end block 1 */
	// End offset: 0x80037654
	// End Line: 958

	/* begin block 2 */
		// Start line: 1869
	/* end block 2 */
	// End Line: 1870

	return 0;
}

void LOAD_CD_ReadPartOfFile(struct _NonBlockLoadEntry *loadEntry)
{ 
	struct _ReadQueueEntry *currentQueueReq;

	if (LOAD_SetupFileInfo(loadEntry) != 0)
	{
		currentQueueReq = &loadStatus.currentQueueFile;
		currentQueueReq->readCurSize = 0;
		currentQueueReq->readSize = loadEntry->loadSize;
		currentQueueReq->readStartDest = loadEntry->loadAddr;
		currentQueueReq->readCurDest = loadEntry->loadAddr;
		currentQueueReq->readStatus = 5;
		currentQueueReq->checksumType = 0;
		loadStatus.currentQueueFile.readStartPos = loadEntry->filePos;
		currentQueueReq->checksum = loadEntry->checksum;
		currentQueueReq->retFunc = loadEntry->retFunc;
		currentQueueReq->retData = loadEntry->retData;
		loadStatus.changeDir = 0;
		currentQueueReq->retData2 = loadEntry->retData2;
	}
	else
	{
		loadStatus.changeDir = 1;
	}
}

long LOAD_HashName(char *string)
{ 
	long sum;
	long xor;
	long length;
	long ext;
	char c;
	long strl;
	long endPos;
	long i;
	char* pos;

	sum = 0;
	xor = 0;
	length = 0;
	ext = 0;

	strl = strlen(string) - 1;
	pos = strchr(string, '.');
	endPos = 0;

	if (pos != 0)
	{
		pos++;
		
		for (i = 0; i < 7; i++)
		{
			if (strcmpi(pos, &HashExtensions[i][0]) == 0)
			{
				ext = i;
				break;
			}
		}

		if (i < 7)
		{
			strl -= 4;
		}

		if (strl >= endPos)
		{
			for(; strl < endPos; strl--)
			{
				c = string[strl];
				
				if (c != '\\')
				{
					if (c - 0x61 < 0x1A)
					{
						c &= 0xDF;
					}

					c -= 0x1A;
					sum += (c & 0xFF);
					length++;
					xor ^= (c & 0xFF) * length;
				}
			}
		}
	}

	return (length << 27) | (sum << 15) | (xor << 3) | ext;
}

long LOAD_HashUnit(char *name)
{
	int val;
	int last;
	int hash;
	int num;
	int flag;
	char* c;

	last = 0;
	hash = 0;
	num = 0;
	flag = 0;

	if (name[0] != 0)
	{
		for (c = name; *c != 0; c++)
		{
			val = *c;

			if (val - 0x30 < 10)
			{
				num = ((num * 10) - 0x30) + val;

			}
			else
			{
				if (val - 0x41 < 0x1A)
				{
					val -= 0x41;
				}
				else
				{
					val -= 0x61;
				}

				if (flag != 0)
				{
					hash = (hash << 2) + (val - last) * 32;
					flag ^= 1;
					last = val;
				}
				else
				{
					hash = (hash << 2) + (val - last);
					flag ^= 1;
					last = val;
				}
			}
		}
	}

	hash += num;
	return hash;
}


// autogenerated function stub: 
// struct _BigFileEntry * /*$ra*/ LOAD_GetBigFileEntryByHash(long hash /*$a0*/)
struct _BigFileEntry * LOAD_GetBigFileEntryByHash(long hash)
{ // line 1090, offset 0x800378fc
	/* begin block 1 */
		// Start line: 1092
		// Start offset: 0x800378FC
		// Variables:
			int i; // $a1
			struct _BigFileEntry *entry; // $v1
	/* end block 1 */
	// End offset: 0x8003797C
	// End Line: 1111

	/* begin block 2 */
		// Start line: 2226
	/* end block 2 */
	// End Line: 2227

	/* begin block 3 */
		// Start line: 2227
	/* end block 3 */
	// End Line: 2228

	/* begin block 4 */
		// Start line: 2230
	/* end block 4 */
	// End Line: 2231

	return null;
}


// autogenerated function stub: 
// struct _BigFileEntry * /*$ra*/ LOAD_GetBigFileEntry(char *fileName /*$a0*/)
struct _BigFileEntry * LOAD_GetBigFileEntry(char *fileName)
{ // line 1113, offset 0x80037984
	/* begin block 1 */
		// Start line: 1114
		// Start offset: 0x80037984
	/* end block 1 */
	// End offset: 0x80037984
	// End Line: 1114

	/* begin block 2 */
		// Start line: 2277
	/* end block 2 */
	// End Line: 2278

	return null;
}


// autogenerated function stub: 
// long /*$ra*/ LOAD_DoesFileExist(char *fileName /*$a0*/)
long LOAD_DoesFileExist(char *fileName)
{ // line 1169, offset 0x800379ac
	/* begin block 1 */
		// Start line: 1170
		// Start offset: 0x800379AC
		// Variables:
			struct _BigFileEntry *entry; // $v0
	/* end block 1 */
	// End offset: 0x800379D0
	// End Line: 1175

	/* begin block 2 */
		// Start line: 2338
	/* end block 2 */
	// End Line: 2339

	return 0;
}


// autogenerated function stub: 
// void /*$ra*/ LOAD_NonBlockingReadFile(struct _NonBlockLoadEntry *loadEntry /*$s0*/)
void LOAD_NonBlockingReadFile(struct _NonBlockLoadEntry *loadEntry)
{ // line 1181, offset 0x800379e0
	/* begin block 1 */
		// Start line: 2363
	/* end block 1 */
	// End Line: 2364

}

void LOAD_LoadTIM(long *addr, long x_pos, long y_pos, long clut_x, long clut_y)
{ 
	struct PSX_RECT rect;
	long *clutAddr;

	addr += 2;
	clutAddr = NULL;
	
	if (addr[-1] == 8)
	{
		clutAddr = addr + 3;
		addr += 11;
	}

	rect.x = x_pos;
	rect.y = y_pos;
	rect.w = ((unsigned short*)addr)[4];
	rect.h = ((unsigned short*)addr)[5];

	LoadImage(&rect, addr + 3);

	if (clutAddr != NULL)
	{
		rect.x = clut_x;
		rect.y = clut_y;
		rect.w = 16;
		rect.h = 1;
		DrawSync(0);
		LoadImage(&rect, clutAddr);
	}
}


// autogenerated function stub: 
// void /*$ra*/ LOAD_LoadTIM2(long *addr /*$a1*/, long x_pos /*$a1*/, long y_pos /*$a2*/, long width /*$a3*/, long height /*stack 16*/)
void LOAD_LoadTIM2(long *addr, long x_pos, long y_pos, long width, long height)
{ // line 1258, offset 0x80037b3c
	/* begin block 1 */
		// Start line: 1259
		// Start offset: 0x80037B3C
		// Variables:
			struct PSX_RECT rect; // stack offset -16
	/* end block 1 */
	// End offset: 0x80037B3C
	// End Line: 1259

	/* begin block 2 */
		// Start line: 2525
	/* end block 2 */
	// End Line: 2526

}


// autogenerated function stub: 
// long /*$ra*/ LOAD_RelocBinaryData(long *data /*$s0*/, long fileSize /*$s1*/)
long LOAD_RelocBinaryData(long *data, long fileSize)
{ // line 1296, offset 0x80037b84
	/* begin block 1 */
		// Start line: 1297
		// Start offset: 0x80037B84
		// Variables:
			long *lastMoveDest; // $v1
			long tableSize; // $s3
			struct RedirectList redirectListX; // stack offset -32
			struct RedirectList *redirectList; // $a0
	/* end block 1 */
	// End offset: 0x80037C1C
	// End Line: 1317

	/* begin block 2 */
		// Start line: 2592
	/* end block 2 */
	// End Line: 2593

	return 0;
}

void LOAD_CleanUpBuffers()
{ 
	if (loadStatus.buffer1 != NULL)
	{
		MEMPACK_Free((char*)loadStatus.buffer1);
		loadStatus.buffer1 = NULL;
	}

	if (loadStatus.buffer2 != NULL)
	{
		MEMPACK_Free((char*)loadStatus.buffer2);
		loadStatus.buffer2 = NULL;
	}
}

void * LOAD_InitBuffers()
{
	loadStatus.buffer1 = MEMPACK_Malloc(2048, 35);
	loadStatus.buffer2 = MEMPACK_Malloc(2048, 35);
	return loadStatus.buffer1;
}

void LOAD_InitCdStreamMode()
{ 
	unsigned char cdMode = 0xA0;
	CdReadyCallback(&LOAD_CdReadReady, 0xA0, NULL);
	CdSyncCallback(&LOAD_CdSeekCallback, 0, NULL);
	CdControl(CdlSetmode, &cdMode, NULL);
}


// autogenerated function stub: 
// void /*$ra*/ LOAD_DumpCurrentDir()
void LOAD_DumpCurrentDir()
{ // line 1428, offset 0x80037d1c
	/* begin block 1 */
		// Start line: 2795
	/* end block 1 */
	// End Line: 2796

	/* begin block 2 */
		// Start line: 2796
	/* end block 2 */
	// End Line: 2797

}


// autogenerated function stub: 
// int /*$ra*/ LOAD_ChangeDirectoryByID(int id /*$s1*/)
int LOAD_ChangeDirectoryByID(int id)
{ // line 1444, offset 0x80037d6c
	/* begin block 1 */
		// Start line: 1445
		// Start offset: 0x80037D6C

		/* begin block 1.1 */
			// Start line: 1449
			// Start offset: 0x80037D84
			// Variables:
				int i; // $v1

			/* begin block 1.1.1 */
				// Start line: 1456
				// Start offset: 0x80037DA4
				// Variables:
					struct _BigFileDir *dir; // $a0
			/* end block 1.1.1 */
			// End offset: 0x80037DC4
			// End Line: 1462
		/* end block 1.1 */
		// End offset: 0x80037E5C
		// End Line: 1481
	/* end block 1 */
	// End offset: 0x80037E60
	// End Line: 1484

	/* begin block 2 */
		// Start line: 2828
	/* end block 2 */
	// End Line: 2829

	return 0;
}

void LOAD_SetSearchDirectory(long id)
{ 
	loadStatus.bigFile.searchDirID = id;
}

long LOAD_GetSearchDirectory()
{
	return loadStatus.bigFile.searchDirID;
}

int LOAD_ChangeDirectoryFlag()
{
	return loadStatus.changeDir;
}


// autogenerated function stub: 
// void /*$ra*/ LOAD_UpdateBigFilePointers(struct _BigFileDir *oldDir /*$a0*/, struct _BigFileDir *newDir /*$a1*/)
void LOAD_UpdateBigFilePointers(struct _BigFileDir *oldDir, struct _BigFileDir *newDir)
{ // line 1506, offset 0x80037e98
	/* begin block 1 */
		// Start line: 2966
	/* end block 1 */
	// End Line: 2967

	/* begin block 2 */
		// Start line: 2967
	/* end block 2 */
	// End Line: 2968

}

int LOAD_IsFileLoading()
{
	return loadStatus.currentQueueFile.readStatus == 0;
}


// autogenerated function stub: 
// void /*$ra*/ LOAD_StopLoad()
void LOAD_StopLoad()
{ // line 1563, offset 0x80037ed4
	/* begin block 1 */
		// Start line: 3126
	/* end block 1 */
	// End Line: 3127

	/* begin block 2 */
		// Start line: 3048
	/* end block 2 */
	// End Line: 3049

}




