#include "THISDUST.H"
#include "FONT.H"

WORD word_C6108A;

// autogenerated function stub: 
// void /*$ra*/ FONT_MakeSpecialFogClut(int x /*$a3*/, int y /*$a1*/)
void FONT_MakeSpecialFogClut(int x, int y)
{ // line 58, offset 0x8002cb74
	RECT v2; // [esp+4h] [ebp-28h] BYREF
	static WORD v3[16] = { 0x4210, 0x4210, 0x4210, 0x4210, 0x4210, 0x4210, 0x4210, 0x4210, 
	0x4210, 0x4210, 0x4210, 0x4210, 0x4210, 0x4210, 0x4210, 0 }; // [esp+Ch] [ebp-20h] BYREF

	v2.x = x;
	v2.y = y;
	v2.w = 16;
	v2.h = 1;
	word_C6108A = ((WORD)y << 6) | (x >> 4) & 0x3F;
	DrawSync(0);
	LoadImage(&v2, v3);
	DrawSync(0);
}


// autogenerated function stub: 
// void /*$ra*/ FONT_Init()
void FONT_Init()
{ // line 91, offset 0x8002cbf8
	fontTracker.font_xpos = 10;
	fontTracker.font_ypos = 16;
	fontTracker.font_buffIndex = 0;
	fontTracker.sprite_sort_push = 0;
	fontTracker.color_global = 0;
	fontTracker.color_local = 0;
}


// autogenerated function stub: 
// void /*$ra*/ FONT_ReloadFont()
void FONT_ReloadFont()
{ // line 137, offset 0x8002cd18
}


// autogenerated function stub: 
// void /*$ra*/ FONT_DrawChar(struct FontChar *fontChar /*$a0*/)
void FONT_DrawChar(struct FontChar *fontChar)
{ // line 149, offset 0x8002cd7c
	int y; // edx
	int x; // [esp-8h] [ebp-8h]
	char c; // [esp+4h] [ebp+4h]

	y = fontChar->y;
	c = fontChar->c;
	x = fontChar->x;
	fontTracker.color_local = fontChar->color;
	FONT_DrawChar2D(c, x, y);
}


// autogenerated function stub: 
// long /*$ra*/ FONT_Get2DImageIndex(unsigned char c /*$a0*/)
long FONT_Get2DImageIndex(unsigned char c)
{ // line 471, offset 0x8002cdb0
	int v2; // eax

	if (c >= 'a' && c <= 'z')
		return c - 97;
	if (c >= '0' && c <= '9')
		return c - 22;
	if (c >= 'A' && c <= 'Z')
		return c - 13;
	switch (c)
	{
	case '!':
		return 37;
	case '/':
		return 38;
	case '-':
		return 39;
	case '"':
		return 40;
	case '%':
		return 41;
	case ':':
		return 42;
	case '(':
		return 43;
	case ')':
		return 44;
	case '+':
		return 45;
	case '=':
		return 46;
	case '*':
		return 47;
	case '?':
		return 48;
	case '~':
		return 49;
	case ',':
		return 50;
	case '\'':
		return 51;
	case ';':
		return 42;
	case '.':
		return 36;
	case '\xC8':
		return 78;
	case '\xC9':
		return 79;
	case '\xCA':
		return 80;
	case '\xCB':
		return 81;
	case '\xD0':
		return 82;
	case '\xD1':
		return 83;
	case '\xD2':
		return 84;
	case '\xD3':
		return 85;
	case '\xCC':
		return 86;
	case '\xCD':
		return 87;
	case '\xCE':
		return 88;
	case '\xCF':
		return 89;
	case '\xD4':
		return 90;
	case '\xD5':
		return 91;
	case '\xD6':
		return 96;
	case '\xD7':
		return 97;
	case '`':
		return 92;
	case '\\':
		return 93;
	case '[':
		return 94;
	}
	v2 = -(c != 93);
	v2 = v2 & 0xC5;
	return v2 + 95;
}


// autogenerated function stub: 
// void /*$ra*/ drawChar2DPoly(long fpi /*$a0*/, long x /*$s0*/, long y /*$a2*/)
void drawChar2DPoly(long fpi, long x, long y)
{ // line 558, offset 0x8002cdc8
	__int16 v3; // ax
	int v4; // ecx
	__int16 v5; // ax
	int v6; // edx
	__int16 w; // ax
	int v8; // ebp
	__int16 h; // ax
	int v10; // edi
	char v11; // cl
	char v12; // dl
	__int16 v13; // si
	__int16 v14; // ax
	__int16 v15; // si
	u_char v16; // di
	u_char v17; // cl
	POLY_FT4* nextPrim; // eax
	u_char v19; // dl
	u_char v20; // bp
	u_char v21; // di
	u_char v22; // bp
	u_char v23; // di
	u_char v24; // bp
	u_long tag; // edi
	char color_local; // bl
	char v27; // bl
	u_char v28; // [esp+10h] [ebp-20h]
	u_char v29; // [esp+14h] [ebp-1Ch]
	u_char v30; // [esp+18h] [ebp-18h]
	u_char v31; // [esp+1Ch] [ebp-14h]
	__int16 v32; // [esp+20h] [ebp-10h]
	__int16 v33; // [esp+24h] [ebp-Ch]
	__int16 v34; // [esp+28h] [ebp-8h]
	__int16 v35; // [esp+2Ch] [ebp-4h]
	u_char fpia; // [esp+34h] [ebp+4h]
	u_char ya; // [esp+3Ch] [ebp+Ch]

	v3 = fontPos[fpi].x;
	v4 = v3;
	if (v3 < 0)
		v4 = -v3;
	v5 = fontPos[fpi].y;
	v6 = v5;
	if (v5 < 0)
		v6 = -v5;
	w = fontPos[fpi].w;
	v33 = w;
	v8 = w;
	if (w < 0)
		v8 = -w;
	h = fontPos[fpi].h;
	v32 = h;
	v10 = h;
	if (h < 0)
		v10 = -h;
	v11 = fontTracker.font_vramU + v4;
	v12 = fontTracker.font_vramV + v6;
	v34 = v8 + x;
	v13 = y - v10;
	v14 = y + 12;
	ya = v12 + v10;
	v15 = v13 + 12;
	v16 = v11 + v8;
	v35 = v14;
	v17 = v11 + 1;
	fpia = v16;
	nextPrim = (POLY_FT4*)gameTrackerX.primPool->nextPrim;
	v29 = v16;
	v19 = v12 + 1;
	v30 = ya;
	v28 = v19;
	v31 = v17;
	if (v32 < 0)
	{
		v31 = v17;
		fpia = v16;
		v20 = v19;
		v19 = ya;
		ya = v20;
		v28 = v30;
		v29 = v16;
		v30 = v20;
	}
	if (v33 < 0)
	{
		v21 = v17;
		v17 = fpia;
		v22 = v19;
		v19 = v28;
		fpia = v21;
		v23 = v29;
		v28 = v22;
		v24 = v30;
		v29 = v31;
		v31 = v23;
		v30 = ya;
		ya = v24;
	}
	tag = nextPrim->tag;
	*(&nextPrim->b0 + 1) = 44;
	nextPrim->tag = tag & 0xFFFFFF | 0x9000000;
	color_local = fontTracker.color_local;
	if (fontTracker.color_local)
	{
		*(&nextPrim->b0 + 1) = 0x2C;
		nextPrim->r0 = the_font_color_table[color_local].r;
		nextPrim->g0 = the_font_color_table[color_local].g;
		nextPrim->b0 = the_font_color_table[color_local].b;
	}
	else
	{
		*(&nextPrim->b0 + 1) = 0x2D;
	}
	nextPrim->u0 = v17;
	v27 = *(&nextPrim->b0 + 1);
	nextPrim->v0 = v19;
	nextPrim->u1 = fpia;
	nextPrim->v1 = v28;
	nextPrim->u2 = v31;
	nextPrim->v2 = ya;
	nextPrim->u3 = v29;
	nextPrim->v3 = v30;
	nextPrim->x0 = x;
	nextPrim->x2 = x;
	nextPrim->y0 = v15;
	*(&nextPrim->b0 + 1) = v27 & 0xFD;
	nextPrim->x1 = v34;
	nextPrim->y1 = v15;
	nextPrim->y2 = v35;
	nextPrim->x3 = v34;
	nextPrim->y3 = v35;
	nextPrim->tpage = fontTracker.font_tpage;
	nextPrim->clut = fontTracker.font_clut;
	if (!fontTracker.color_local)
	{
		nextPrim->r0 = 0x80;
		nextPrim->g0 = 0x80;
		nextPrim->b0 = 0x80;
	}
	D3D_RenderLetter(nextPrim);
}


// autogenerated function stub: 
// void /*$ra*/ FONT_DrawChar2D(unsigned char c /*$fp*/, long x /*$s7*/, long y /*$s3*/)
void FONT_DrawChar2D(unsigned char c, long x, long y)
{ // line 660, offset 0x8002cfc8
	int v3; // eax
	int v4; // ecx
	int v5; // esi
	int v6; // ebx
	__int16 w; // ax
	int v8; // edx
	__int16 v9; // ax
	int v10; // edi
	__int16 v11; // ax
	int v12; // ebx
	int h; // eax
	int v14; // esi
	int v15; // ecx
	int v16; // [esp+10h] [ebp-10h]
	int v17; // [esp+14h] [ebp-Ch]
	int fpi; // [esp+18h] [ebp-8h]
	int v19; // [esp+1Ch] [ebp-4h]

	if (gameTrackerX.primPool->nextPrim > gameTrackerX.primPool->lastPrim - 12)
		return;
	v3 = FONT_Get2DImageIndex(c);
	v4 = charMap[v3][0];
	v5 = charMap[v3][1];
	v6 = charMap[v3][2];
	fpi = v5;
	v19 = v6;
	if (v4 < 0)
	{
		v8 = 8;
	}
	else
	{
		w = fontPos[v4].w;
		v8 = w;
		if (w < 0)
			v8 = -w;
	}
	if (v5 < 0)
	{
		v16 = v8;
	}
	else
	{
		v9 = fontPos[v5].w;
		if (v9 >= 0)
		{
			v10 = v9;
			v16 = v9;
			goto LABEL_12;
		}
		v16 = -v9;
	}
	v10 = v16;
LABEL_12:
	if (v6 < 0)
	{
		v12 = v8;
	}
	else
	{
		v11 = fontPos[v6].w;
		v12 = v11;
		if (v11 < 0)
			v12 = -v11;
	}
	if (v8 <= v10)
	{
		if (v10 > v12)
			goto LABEL_21;
	LABEL_20:
		v10 = v12;
		goto LABEL_21;
	}
	if (v8 <= v12)
		goto LABEL_20;
	v10 = v8;
LABEL_21:
	if (v4 < 0)
	{
		v17 = 12;
	}
	else
	{
		h = fontPos[v4].h;
		if ((h & 0x8000u) != 0)
			h = -(__int16)h;
		v17 = h;
	}
	v14 = y;
	if (v4 >= 0)
		drawChar2DPoly(v4, x + (v10 - v8) / 2, y);
	v15 = y + 2;
	if (c != 65)
		v15 = y;
	if (c == 39)
		v14 = y + 3;
	if (fpi >= 0)
		drawChar2DPoly(fpi, x + (v10 - v16) / 2, v15);
	if (v19 >= 0)
		drawChar2DPoly(v19, x + (v10 - v12) / 2, v14 - v17 + 1);
}


// autogenerated function stub: 
// long /*$ra*/ FONT_CharSpacing(char c /*$a0*/, long fontXSize /*$s0*/)
long FONT_CharSpacing(char c, long fontXSize)
{ // line 704, offset 0x8002d1fc
	int v2; // eax
	int v3; // eax
	char v4; // dl
	char v5; // bl
	int w; // ecx
	int v7; // esi
	int v8; // eax
	int v9; // edx
	int v10; // eax
	char fontXSizea; // [esp+10h] [ebp+8h]

	if (c == 32)
		return fontXSize;
	v2 = FONT_Get2DImageIndex(c);
	if (v2 == -1)
		return fontXSize;
	v3 = v2;
	v4 = charMap[v3][0];
	v5 = charMap[v3][1];
	fontXSizea = charMap[v3][2];
	w = fontPos[v4].w;
	if ((w & 0x8000u) != 0)
		w = -(__int16)w;
	if (fontPos[v4].x < 0)
		w = fontPos[v4].h;
	v7 = w;
	if (v4 < 0)
		v7 = 8;
	v8 = fontPos[v5].w;
	if ((v8 & 0x8000u) != 0)
		v8 = -(__int16)v8;
	v9 = v8;
	if (v5 < 0)
		v9 = v7;
	v10 = fontPos[fontXSizea].w;
	if ((v10 & 0x8000u) != 0)
		v10 = -(__int16)v10;
	if (fontXSizea < 0)
		v10 = v7;
	if (v7 <= v9)
	{
		if (v9 > v10)
			v10 = v9;
	}
	else if (v7 > v10)
	{
		return v7 + 1;
	}
	return v10 + 1;
}


// autogenerated function stub: 
// void /*$ra*/ FONT_AddCharToBuffer(char c /*$a3*/, long x /*$a1*/, long y /*$a2*/)
void FONT_AddCharToBuffer(char c, long x, long y)
{ // line 1059, offset 0x8002d340
	FontChar* v3; // eax
	__int16 v4; // dx

	v3 = &fontTracker.font_buffer[fontTracker.font_buffIndex];
	if (fontTracker.font_buffIndex < 2047)
	{
		if (c == '@')
		{
			v3->x = (unsigned __int8)x;
			v4 = (unsigned __int8)y;
		}
		else
		{
			v3->x = x;
			v4 = y;
		}
		v3->y = v4;
		v3->c = c;
		++fontTracker.font_buffIndex;
		v3->color = fontTracker.color_global;
	}
}

char byte_C549E0[512];

// autogenerated function stub: 
// void /*$ra*/ FONT_Print(char *fmt /*stack 0*/)
void FONT_Print(char *fmt, ...)
{ // line 1096, offset 0x8002d3ac
	char* v1; // ecx
	char v2; // al
	va_list ap; // [esp+8h] [ebp+8h] BYREF

	va_start(ap, fmt);
	vsprintf(&byte_C549E0, fmt, (va_list*)ap);
	v1 = &byte_C549E0;
	if (byte_C549E0)
	{
		do
		{
			v2 = *v1;
			if (*v1 >= 'A' && v2 <= 'Z')
				*v1 = v2 + ' ';
		} while (*++v1);
	}
	FONT_VaReallyPrint(&byte_C549E0, ap);
}


// autogenerated function stub: 
// void /*$ra*/ FONT_Print2(char *fmt /*stack 0*/)
void FONT_Print2(char *fmt)
{ // line 1115, offset 0x8002d43c
	va_list ap; // [esp+8h] [ebp+8h] BYREF

	va_start(ap, fmt);
	vsprintf(&byte_C549E0, fmt, (va_list*)ap);
	FONT_VaReallyPrint(&byte_C549E0, ap);
}


// autogenerated function stub: 
// int /*$ra*/ FONT_GetStringWidth(char *str /*$s3*/)
int FONT_GetStringWidth(char *str)
{ // line 1168, offset 0x8002d48c
	unsigned int v1; // kr04_4
	signed int v2; // esi
	int i; // ebx

	v1 = strlen(str) + 1;
	v2 = 0;
	for (i = 0; v2 < (int)(v1 - 1); ++v2)
		i += FONT_CharSpacing(str[v2], 8);
	return i;
}


// autogenerated function stub: 
// void /*$ra*/ FONT_Flush()
void FONT_Flush()
{ // line 1212, offset 0x8002d500
	FontChar* p_c; // esi
	__int32 font_buffIndex; // edi
	int y; // ecx
	int x; // [esp-10h] [ebp-14h]
	char c; // [esp+0h] [ebp-4h]

	fontTracker.font_xpos = 10;
	fontTracker.font_ypos = 16;
	if (fontTracker.font_buffIndex)
	{
		p_c = &fontTracker.font_buffer[0];
		font_buffIndex = fontTracker.font_buffIndex;
		do
		{
			if (p_c->c != ' ' && p_c->c != '@')
			{
				fontTracker.color_local = p_c->color;
				FONT_DrawChar2D(p_c->c, p_c->x, p_c->y);
			}
			++p_c;
			--font_buffIndex;
		} while (font_buffIndex);
		fontTracker.font_buffIndex = 0;
	}
}


// autogenerated function stub: 
// void /*$ra*/ FONT_SetCursor(short x /*$a0*/, short y /*$a1*/)
void FONT_SetCursor(short x, short y)
{ // line 1241, offset 0x8002d590
	if (x > 0)
		fontTracker.font_xpos = x;
	if (y > 0)
		fontTracker.font_ypos = y;
}


// autogenerated function stub: 
// void /*$ra*/ FONT_VaReallyPrint(char *fmt /*$a0*/, void *ap /*$a1*/)
void FONT_VaReallyPrint(char *fmt, void *ap)
{ // line 1280, offset 0x8002d5b0
	char* v2; // edi
	__int32 font_buffIndex; // esi
	char v4; // dl
	__int16 font_xpos_low; // dx
	__int32 v6; // eax
	__int16 font_ypos; // cx
	int v8; // eax
	unsigned __int8 v10; // [esp+4h] [ebp-4h]
	unsigned __int8 fmta; // [esp+Ch] [ebp+4h]

	v2 = fmt;
	if (*fmt)
	{
		font_buffIndex = fontTracker.font_buffIndex;
		do
		{
			v4 = *v2;
			if (*v2 == 10)
			{
				fontTracker.font_xpos = 10;
				fontTracker.font_ypos += 12;
			}
			else if (v4 == 64)
			{
				fmta = v2[1] - 64;
				v10 = v2[2] - 64;
				if (font_buffIndex < 2047)
				{
					font_xpos_low = LOBYTE(fontTracker.font_xpos);
					fontTracker.font_buffer[font_buffIndex].y = LOBYTE(fontTracker.font_ypos);
					fontTracker.font_buffer[font_buffIndex].x = font_xpos_low;
					fontTracker.font_buffer[font_buffIndex].c = 64;
					++fontTracker.font_buffIndex;
					fontTracker.font_buffer[font_buffIndex].color = fontTracker.color_global;
					font_buffIndex = fontTracker.font_buffIndex;
				}
				if (font_buffIndex < 2047)
				{
					fontTracker.font_buffer[font_buffIndex].x = v10;
					fontTracker.font_buffer[font_buffIndex].y = fmta;
					fontTracker.font_buffer[font_buffIndex].c = 64;
					++fontTracker.font_buffIndex;
					fontTracker.font_buffer[font_buffIndex].color = fontTracker.color_global;
					font_buffIndex = fontTracker.font_buffIndex;
				}
				v2 += 2;
			}
			else if (v4 == 36)
			{
				fontTracker.font_xpos = 10;
				fontTracker.font_ypos = 16;
			}
			else if (v4 == 13)
			{
				fontTracker.font_xpos = 10;
			}
			else
			{
				if (v4 == 9)
				{
					v6 = fontTracker.font_xpos + 32;
				}
				else
				{
					if (v4 != 32 && v4 != 95)
					{
						font_ypos = fontTracker.font_ypos;
						if (font_buffIndex < 2047)
						{
							fontTracker.font_buffer[font_buffIndex].x = fontTracker.font_xpos;
							fontTracker.font_buffer[font_buffIndex].y = font_ypos;
							fontTracker.font_buffer[font_buffIndex].c = v4;
							++fontTracker.font_buffIndex;
							fontTracker.font_buffer[font_buffIndex].color = fontTracker.color_global;
						}
						v8 = FONT_CharSpacing(*v2, 8);
						font_buffIndex = fontTracker.font_buffIndex;
						fontTracker.font_xpos += v8;
						continue;
					}
					v6 = fontTracker.font_xpos + 8;
				}
				fontTracker.font_xpos = v6;
			}
		} while (*++v2);
	}
}


// autogenerated function stub: 
// void /*$ra*/ FONT_FontPrintCentered(char *text /*$s1*/, long y /*$s0*/)
void FONT_FontPrintCentered(char *text, long y)
{ // line 1336, offset 0x8002d740
	unsigned int v2; // kr04_4
	signed int v3; // esi
	int i; // edi
	__int16 v5; // ax

	v2 = strlen(text) + 1;
	v3 = 0;
	for (i = 0; v3 < (int)(v2 - 1); ++v3)
		i += FONT_CharSpacing(text[v3], 8);
	v5 = 256 - (i >> 1);
	if (v5 > 0)
		fontTracker.font_xpos = v5;
	if ((__int16)y > 0)
		fontTracker.font_ypos = (__int16)y;
	FONT_Print2((int)text);
}


// autogenerated function stub: 
// void /*$ra*/ FONT_SetColorIndex(int color /*$a0*/)
void FONT_SetColorIndex(int color)
{ // line 1343, offset 0x8002d798
	fontTracker.color_global = color;
}


// autogenerated function stub: 
// void /*$ra*/ FONT_SetColorIndexCol(int color /*$a0*/, int r /*$a1*/, int g /*$a2*/, int b /*$a3*/)
void FONT_SetColorIndexCol(int color, int r, int g, int b)
{ // line 1349, offset 0x8002d7a4
	font_color_t* v4; // eax

	v4 = &the_font_color_table[color];
	v4->r = r;
	v4->g = g;
	v4->b = b;
}
