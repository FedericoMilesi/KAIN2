#include "CORE.H"

// autogenerated function stub: 
// void /*$ra*/ SetNoPtCollideInFamily(struct _Instance *instance /*$a0*/)
void SetNoPtCollideInFamily(struct _Instance *instance)
{ // line 57, offset 0x80074628
#if defined(PC_VERSION)
	struct _Instance* LinkChild; // esi

	LinkChild = instance->LinkChild;
	for (instance->flags |= 0x40u; LinkChild; LinkChild = LinkChild->LinkSibling)
		SetNoPtCollideInFamily(LinkChild);
#endif
}


// autogenerated function stub: 
// void /*$ra*/ ResetNoPtCollideInFamily(struct _Instance *instance /*$a0*/)
void ResetNoPtCollideInFamily(struct _Instance *instance)
{ // line 67, offset 0x80074670
#if defined(PC_VERSION)
	struct _Instance* LinkChild; // esi

	LinkChild = instance->LinkChild;
	for (instance->flags &= ~0x40u; LinkChild; LinkChild = LinkChild->LinkSibling)
		ResetNoPtCollideInFamily(LinkChild);
#endif
}


// autogenerated function stub: 
// void /*$ra*/ PHYSICS_CheckLineInWorld(struct _Instance *instance /*$a0*/, struct _PCollideInfo *pcollideInfo /*$a1*/)
void PHYSICS_CheckLineInWorld(struct _Instance *instance, struct _PCollideInfo *pcollideInfo)
{ // line 79, offset 0x800746bc
#if defined(PC_VERSION)
	struct Level* LevelWithID; // eax
	struct _Instance* LinkChild; // esi
	struct Level* v4; // ebp
	struct _Instance* v5; // esi

	pcollideInfo->collideType = 63;
	LevelWithID = STREAM_GetLevelWithID(instance->currentStreamUnitID);
	pcollideInfo->inst = 0;
	pcollideInfo->instance = instance;
	LinkChild = instance->LinkChild;
	v4 = LevelWithID;
	for (instance->flags |= 0x40u; LinkChild; LinkChild = LinkChild->LinkSibling)
		SetNoPtCollideInFamily(LinkChild);
	if (v4)
		COLLIDE_PointAndWorld(pcollideInfo, v4);
	else
		pcollideInfo->type = 0;
	v5 = instance->LinkChild;
	for (instance->flags &= ~0x40u; v5; v5 = v5->LinkSibling)
		ResetNoPtCollideInFamily(v5);
#endif
}


// autogenerated function stub: 
// void /*$ra*/ PHYSICS_CheckLineInWorldMask(struct _Instance *instance /*$s2*/, struct _PCollideInfo *pcollideInfo /*$s1*/)
void PHYSICS_CheckLineInWorldMask(struct _Instance *instance, struct _PCollideInfo *pcollideInfo)
{ // line 85, offset 0x800746e0
#if defined(PC_VERSION)
	struct Level* LevelWithID; // ebp
	struct _Instance* LinkChild; // esi
	struct _Instance* v4; // esi

	LevelWithID = STREAM_GetLevelWithID(instance->currentStreamUnitID);
	pcollideInfo->inst = 0;
	pcollideInfo->instance = instance;
	LinkChild = instance->LinkChild;
	for (instance->flags |= 0x40u; LinkChild; LinkChild = LinkChild->LinkSibling)
		SetNoPtCollideInFamily(LinkChild);
	if (LevelWithID)
		COLLIDE_PointAndWorld(pcollideInfo, LevelWithID);
	else
		pcollideInfo->type = 0;
	v4 = instance->LinkChild;
	for (instance->flags &= ~0x40u; v4; v4 = v4->LinkSibling)
		ResetNoPtCollideInFamily(v4);
#endif
}


// autogenerated function stub: 
// int /*$ra*/ PhysicsCheckLinkedMove(struct _Instance *instance /*$s2*/, int Data /*stack 4*/, short Mode /*stack -72*/)
int PhysicsCheckLinkedMove(struct _Instance *instance, int Data, short Mode)
{ // line 124, offset 0x80074754
#if defined(PC_VERSION)
	struct _Instance* v5; // eax
	MATRIX* v6; // ebx
	int x; // ebp
	struct evPhysicsLinkedMoveData* z; // edx
	int attachedID; // ecx
	__int32 v10; // ecx
	__int32 v11; // eax
	SVECTOR* p_posDelta; // ebx
	__int16 v13; // ax
	__int16 vz; // cx
	__int16 v15; // dx
	__int16 v16; // ax
	__int16 v17; // cx
	struct _Instance* v18; // eax
	int flags2; // ecx
	int v20; // ecx
	int introUniqueID; // edx
	__int16 vy; // cx
	__int16 v23; // dx
	char v24; // al
	int v25; // eax
	int v27; // [esp+4h] [ebp-68h]
	int v28; // [esp+8h] [ebp-64h]
	__int32 v29; // [esp+Ch] [ebp-60h]
	__int32 v30; // [esp+10h] [ebp-5Ch]
	__int32 v31; // [esp+14h] [ebp-58h]
	struct _Instance* v32; // [esp+18h] [ebp-54h]
	struct evPhysicsLinkedMoveData* v33; // [esp+18h] [ebp-54h]
	int v34; // [esp+1Ch] [ebp-50h]
	int y; // [esp+20h] [ebp-4Ch]
	struct _G2EulerAngles_Type euler; // [esp+24h] [ebp-48h] BYREF
	VECTOR v0; // [esp+2Ch] [ebp-40h] BYREF
	VECTOR v1; // [esp+3Ch] [ebp-30h] BYREF
	struct _G2Matrix_Type matrix; // [esp+4Ch] [ebp-20h] BYREF
	struct _Instance* instancea; // [esp+70h] [ebp+4h]
	struct evPhysicsLinkedMoveData* Dataa; // [esp+74h] [ebp+8h]

	struct evPhysicsLinkedMoveData* ptr = (struct evPhysicsLinkedMoveData*)Data;

	if (instance->matrix)
	{
		v5 = ptr->instance;
		v32 = v5;
		v6 = &ptr->instance->matrix[ptr->segment];
		x = instance->position.x;
		v29 = v6->t[0];
		v30 = v6->t[1];
		v31 = v6->t[2];
		z = (struct evPhysicsLinkedMoveData*)instance->position.z;
		instancea = (struct _Instance*)instance->position.y;
		attachedID = instance->attachedID;
		Dataa = z;
		if (v5->introUniqueID == attachedID && ptr->segment == instance->attachedSegment)
		{
			v33 = (struct evPhysicsLinkedMoveData*)instance->oldPos.z;
			v34 = instance->oldPos.x;
			y = instance->oldPos.y;
			v28 = 0;
			v27 = 0;
			if (instance->rotation.x != instance->oldRotation.x
				|| instance->rotation.y != instance->oldRotation.y
				|| instance->rotation.z != instance->oldRotation.z)
			{
				v27 = 1;
			}
			if (x != instance->oldPos.x || instancea != (struct _Instance*)instance->oldPos.y || z != v33)
				v28 = 1;
			if (v28 || v27)
			{
				TransposeMatrix(v6, (MATRIX*)&matrix);
				if (v27)
					MulMatrix0((MATRIX*)&matrix, instance->matrix, &instance->relativeMatrix);
				if (v28)
				{
					v0.vx = x - v34;
					v0.vy = (__int32)instancea - y;
					v0.vz = (char*)Dataa - (char*)v33;
					ApplyMatrixLV((MATRIX*)&matrix, &v0, &v0);
					v10 = instance->relativeMatrix.t[1];
					instance->relativeMatrix.t[0] += v0.vx;
					v11 = instance->relativeMatrix.t[2];
					instance->relativeMatrix.t[1] = v0.vy + v10;
					instance->relativeMatrix.t[2] = v0.vz + v11;
				}
			}
			ApplyMatrixLV(v6, (VECTOR*)instance->relativeMatrix.t, &v1);
			MulMatrix0(v6, &instance->relativeMatrix, (MATRIX*)&matrix);
			G2EulerAngles_FromMatrix(&euler, &matrix, 21);
			p_posDelta = (struct SVECTOR*)&ptr->posDelta;
			v13 = LOWORD(v1.vy) - (WORD)instancea;
			vz = v1.vz;
			ptr->posDelta.x = v29 + LOWORD(v1.vx) - x;
			v15 = euler.x;
			ptr->posDelta.y = v30 + v13;
			v16 = euler.y;
			ptr->posDelta.z = v31 + vz - (WORD)Dataa;
			v17 = euler.z;
			ptr->rotDelta.x = v15 - instance->oldRotation.x;
			ptr->rotDelta.y = v16 - instance->oldRotation.y;
			ptr->rotDelta.z = v17 - instance->oldRotation.z;
		}
		else
		{
			if (attachedID != v5->introUniqueID)
			{
				v18 = INSTANCE_Find(attachedID);
				if (v18)
				{
					flags2 = v18->flags2;
					flags2 = flags2 & 0x7F;
					v18->flags2 = flags2;
				}
				v5 = v32;
			}
			v20 = v5->flags2;
			introUniqueID = v5->introUniqueID;
			v20 = v20 | 0x80;
			v5->flags2 = v20;
			instance->attachedID = introUniqueID;
			instance->attachedSegment = ptr->segment;
			instance->zAccl = 0;
			instance->zVel = 0;
			TransposeMatrix(v6, (MATRIX*)&matrix);
			v0.vx = x - v29;
			v0.vy = (__int32)instancea - v30;
			v0.vz = (__int32)Dataa - v31;
			ApplyMatrixLV((MATRIX*)&matrix, &v0, (VECTOR*)instance->relativeMatrix.t);
			MulMatrix0((MATRIX*)&matrix, instance->matrix, &instance->relativeMatrix);
			ApplyMatrixLV(v6, (VECTOR*)instance->relativeMatrix.t, &v0);
			vy = v0.vy;
			ptr->rotDelta.z = 0;
			ptr->rotDelta.y = 0;
			ptr->rotDelta.x = 0;
			p_posDelta = (struct SVECTOR*)&ptr->posDelta;
			v23 = v0.vz;
			ptr->posDelta.x = x - LOWORD(v0.vx) - v29;
			ptr->posDelta.y = (WORD)instancea - vy - v30;
			ptr->posDelta.z = (WORD)Dataa - v23 - v31;
		}
		v24 = Mode;
		if ((Mode & 4) != 0)
		{
			instance->position.x += p_posDelta->vx;
			instance->position.y += ptr->posDelta.y;
			instance->position.z += ptr->posDelta.z;
			if ((~(BYTE)Mode & 8) != 0)
			{
				COLLIDE_UpdateAllTransforms(instance, p_posDelta);
				v24 = Mode;
			}
			instance->rotation.z += ptr->rotDelta.z;
		}
		if ((v24 & 2) != 0)
			INSTANCE_Post(instance, 0x4010008, (int)ptr);
		if (p_posDelta->vx || ptr->posDelta.y || ptr->posDelta.z || ptr->rotDelta.x || ptr->rotDelta.y || ptr->rotDelta.z)
		{
			v25 = instance->flags2;
			v25 = v25 | 8;
			instance->flags2 = v25;
		}
		return 0x10000;
	}
	else
	{
		instance->attachedID = 0;
		return 0;
	}
#else
	return 0;
#endif
}


// autogenerated function stub: 
// void /*$ra*/ PhysicsDefaultLinkedMoveResponse(struct _Instance *instance /*$s0*/, struct evPhysicsLinkedMoveData *Data /*$s1*/, int updateTransforms /*$a2*/)
void PhysicsDefaultLinkedMoveResponse(struct _Instance *instance, struct evPhysicsLinkedMoveData *Data, int updateTransforms)
{ // line 272, offset 0x80074bb0
#if defined(PC_VERSION)
	instance->position.x += Data->posDelta.x;
	instance->position.y += Data->posDelta.y;
	instance->position.z += Data->posDelta.z;
	if (updateTransforms)
		COLLIDE_UpdateAllTransforms(instance, (SVECTOR*)&Data->posDelta);
	instance->rotation.z += Data->rotDelta.z;
#endif
}


// autogenerated function stub: 
// int /*$ra*/ PhysicsCheckGravity(struct _Instance *instance /*$s0*/, int Data /*stack 4*/, short Mode /*$s7*/)
int PhysicsCheckGravity(struct _Instance *instance, int Data, short Mode)
{ // line 296, offset 0x80074c38
	/* begin block 1 */
		// Start line: 297
		// Start offset: 0x80074C38
		// Variables:
			struct evPhysicsGravityData *Ptr; // $s3
			SVECTOR D; // stack offset -120
			SVECTOR N; // stack offset -112
			short Dot; // $v0
			int rc; // $s4
			//struct _PCollideInfo CInfo; // stack offset -104
			SVECTOR Old; // stack offset -56
			SVECTOR New; // stack offset -48
			int slide; // $fp

		/* begin block 1.1 */
			// Start line: 326
			// Start offset: 0x80074D30
			// Variables:
				int stillOnOldTFace; // $v0
				struct Level *level; // $s2
				struct _TFace *tface; // $s1
		/* end block 1.1 */
		// End offset: 0x80074DF0
		// End Line: 361

		/* begin block 1.2 */
			// Start line: 504
			// Start offset: 0x8007528C
			// Variables:
				struct _Instance *oldOn; // $a0
		/* end block 1.2 */
		// End offset: 0x800752B0
		// End Line: 511
	/* end block 1 */
	// End offset: 0x800753BC
	// End Line: 564

	/* begin block 2 */
		// Start line: 644
	/* end block 2 */
	// End Line: 645

	return 0;
}


// autogenerated function stub: 
// void /*$ra*/ PhysicsDefaultGravityResponse(struct _Instance *instance /*$a0*/, struct evPhysicsGravityData *Data /*$a1*/)
void PhysicsDefaultGravityResponse(struct _Instance *instance, struct evPhysicsGravityData *Data)
{ // line 570, offset 0x800753f0
#if defined(PC_VERSION)
	instance->position.x += Data->x;
	instance->position.y += Data->y;
	if (instance == gameTrackerX.playerInstance && Data->z > 128)
		instance->position.z += 128;
	else
		instance->position.z += Data->z;
#endif
}


// autogenerated function stub: 
// int /*$ra*/ PhysicsCheckEdgeGrabbing(struct _Instance *instance /*$s2*/, struct GameTracker *gameTracker /*$a1*/, int Data /*stack 8*/, short Mode /*$s7*/)
int PhysicsCheckEdgeGrabbing(struct _Instance *instance, struct GameTracker *gameTracker, int Data, short Mode)
{ // line 589, offset 0x80075468
	/* begin block 1 */
		// Start line: 590
		// Start offset: 0x80075468
		// Variables:
			struct evPhysicsEdgeData *Ptr; // $s1
			int rc; // $s6
			VECTOR OutTrans; // stack offset -120
			SVECTOR *ExtraRot; // $v0
			//struct _PCollideInfo CInfo; // stack offset -104
			SVECTOR Old; // stack offset -56
			SVECTOR New; // stack offset -48
			static MATRIX TempMat; // offset 0x0
			static MATRIX *pTempMat; // offset 0x20
			int wallCrawl; // $fp
			int freeSpot; // $s3
	/* end block 1 */
	// End offset: 0x80075AEC
	// End Line: 873

	/* begin block 2 */
		// Start line: 1345
	/* end block 2 */
	// End Line: 1346

	return 0;
}


// autogenerated function stub: 
// void /*$ra*/ PhysicsDefaultEdgeGrabResponse(struct _Instance *instance /*$s2*/, struct evPhysicsEdgeData *Data /*$s1*/, int blockFlag /*$a2*/)
void PhysicsDefaultEdgeGrabResponse(struct _Instance *instance, struct evPhysicsEdgeData *Data, int blockFlag)
{ // line 886, offset 0x80075b20
	/* begin block 1 */
		// Start line: 887
		// Start offset: 0x80075B20
		// Variables:
			struct _SVector normal; // stack offset -88
			struct _G2EulerAngles_Type ea1; // stack offset -80
			VECTOR OutTrans; // stack offset -72
			MATRIX TempMat; // stack offset -56
			SVECTOR New; // stack offset -24

		/* begin block 1.1 */
			// Start line: 936
			// Start offset: 0x80075C3C
			// Variables:
				long dp; // $v0
		/* end block 1.1 */
		// End offset: 0x80075C3C
		// End Line: 936
	/* end block 1 */
	// End offset: 0x80075C3C
	// End Line: 936

	/* begin block 2 */
		// Start line: 2031
	/* end block 2 */
	// End Line: 2032

}


// autogenerated function stub: 
// int /*$ra*/ PhysicsCheckSliding(struct _Instance *instance /*$s3*/, int Data /*$a1*/, short Mode /*$s6*/)
int PhysicsCheckSliding(struct _Instance *instance, int Data, short Mode)
{ // line 983, offset 0x80075dc4
	/* begin block 1 */
		// Start line: 984
		// Start offset: 0x80075DC4
		// Variables:
			struct evPhysicsSlideData *Ptr; // $s0
			int rc; // $s1
			VECTOR OutTrans; // stack offset -120
			struct _SVector normal; // stack offset -104
			//struct _PCollideInfo CInfo; // stack offset -96
			SVECTOR Old; // stack offset -48
			SVECTOR New; // stack offset -40
			static MATRIX *pTempMat; // offset 0x24

		/* begin block 1.1 */
			// Start line: 1015
			// Start offset: 0x80075E4C
		/* end block 1.1 */
		// End offset: 0x80075E4C
		// End Line: 1017

		/* begin block 1.2 */
			// Start line: 1024
			// Start offset: 0x80075E88
			// Variables:
				int Temp; // $a3
		/* end block 1.2 */
		// End offset: 0x80075F5C
		// End Line: 1032
	/* end block 1 */
	// End offset: 0x80076244
	// End Line: 1166

	/* begin block 2 */
		// Start line: 2245
	/* end block 2 */
	// End Line: 2246

	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ PhysicsUpdateTface(struct _Instance *instance /*$s0*/, int Data /*$a1*/)
int PhysicsUpdateTface(struct _Instance *instance, int Data)
{ // line 1177, offset 0x80076270
	/* begin block 1 */
		// Start line: 1178
		// Start offset: 0x80076270
		// Variables:
			//struct _PCollideInfo CInfo; // stack offset -72
			SVECTOR Old; // stack offset -24
			SVECTOR New; // stack offset -16
	/* end block 1 */
	// End offset: 0x8007635C
	// End Line: 1219

	/* begin block 2 */
		// Start line: 2786
	/* end block 2 */
	// End Line: 2787

	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ PhysicsCheckBlockers(struct _Instance *instance /*$s3*/, struct GameTracker *gameTracker /*$a1*/, int Data /*$s4*/, short Mode /*$s2*/)
int PhysicsCheckBlockers(struct _Instance *instance, struct GameTracker *gameTracker, int Data, short Mode)
{ // line 1232, offset 0x8007636c
	/* begin block 1 */
		// Start line: 1233
		// Start offset: 0x8007636C
		// Variables:
			struct evPhysicsEdgeData *Ptr; // $s1
			VECTOR OutTrans; // stack offset -120
			//struct _PCollideInfo CInfo; // stack offset -104
			SVECTOR Old; // stack offset -56
			SVECTOR New; // stack offset -48
			static MATRIX *pTempMat; // offset 0x28

		/* begin block 1.1 */
			// Start line: 1276
			// Start offset: 0x80076418
			// Variables:
				struct _TFace *tface; // $s0

			/* begin block 1.1.1 */
				// Start line: 1278
				// Start offset: 0x80076418
				// Variables:
					int Dot; // $a0
					SVECTOR Force; // stack offset -40
			/* end block 1.1.1 */
			// End offset: 0x800764FC
			// End Line: 1323

			/* begin block 1.1.2 */
				// Start line: 1351
				// Start offset: 0x800765D0
				// Variables:
					struct _HFace *hface; // stack offset -32
			/* end block 1.1.2 */
			// End offset: 0x800765D0
			// End Line: 1357
		/* end block 1.1 */
		// End offset: 0x800766E8
		// End Line: 1401
	/* end block 1 */
	// End offset: 0x800766EC
	// End Line: 1404

	/* begin block 2 */
		// Start line: 2909
	/* end block 2 */
	// End Line: 2910

	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ PhysicsCheckSwim(struct _Instance *instance /*$s1*/, int Data /*$s3*/, short Mode /*$s5*/)
int PhysicsCheckSwim(struct _Instance *instance, int Data, short Mode)
{ // line 1486, offset 0x8007670c
	/* begin block 1 */
		// Start line: 1487
		// Start offset: 0x8007670C
		// Variables:
			struct evPhysicsSwimData *Ptr; // $s4
			int rc; // $s0
			int Depth; // $s0
			int WaterDepth; // $v1
			//struct _PCollideInfo CInfo; // stack offset -96
			SVECTOR Old; // stack offset -48
			SVECTOR New; // stack offset -40
			long waterZLevel; // $s2
	/* end block 1 */
	// End offset: 0x800768CC
	// End Line: 1576

	/* begin block 2 */
		// Start line: 3530
	/* end block 2 */
	// End Line: 3531

	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ PhysicsDefaultCheckSwimResponse(struct _Instance *instance /*$s2*/, struct evPhysicsSwimData *Data /*$s3*/)
int PhysicsDefaultCheckSwimResponse(struct _Instance *instance, struct evPhysicsSwimData *Data)
{ // line 1584, offset 0x800768fc
#if defined(PC_VERSION)
	int v2; // ebp
	int WaterLevel; // ebx
	__int16 Depth; // ax
	MATRIX* matrix; // ecx
	MATRIX* oldMatrix; // eax
	MATRIX* v7; // ecx
	MATRIX* v8; // esi
	int v9; // eax

	v2 = 0;
	STREAM_GetLevelWithID(instance->currentStreamUnitID);
	WaterLevel = Data->WaterLevel;
	if (Data->WaterDepth > -Data->WadeDepth)
		v2 = 128;
	Depth = Data->Depth;
	if (Depth > -Data->TreadDepth && Depth < 0)
		v2 |= 0x40u;
	if (Depth < -Data->SwimDepth)
		v2 |= 0x10u;
	if (Depth > 0)
		v2 |= 0x20u;
	if (WaterLevel > instance->position.z && WaterLevel < instance->oldPos.z && Data->iVelocity->z < 0)
	{
		SIGNAL_InWater(instance);
		v2 |= 0x100u;
	}
	matrix = instance->matrix;
	if (matrix)
	{
		oldMatrix = instance->oldMatrix;
		if (oldMatrix)
		{
			if (WaterLevel < matrix[1].t[2] && WaterLevel > oldMatrix[1].t[2])
			{
				SIGNAL_OutOfWater(instance);
				v2 |= 0x200u;
			}
		}
	}
	if (WaterLevel < instance->position.z && WaterLevel > instance->oldPos.z && Data->iVelocity->z > 0)
		v2 |= 0x400u;
	v7 = instance->matrix;
	if (v7)
	{
		v8 = instance->oldMatrix;
		if (v8)
		{
			v9 = WaterLevel - Data->SwimDepth;
			if (v9 > v7[1].t[2] && v9 < v8[1].t[2] && Data->iVelocity->z < 0)
				return v2 | 0x800;
		}
	}
	return v2;
#else
	return 0;
#endif
}


// autogenerated function stub: 
// void /*$ra*/ PhysicsForceSetWater(struct _Instance *instance /*$s1*/, int *Time /*$t0*/, int Depth /*$a2*/, int rate /*$a3*/, int maxAmplitude /*stack 16*/)
void PhysicsForceSetWater(struct _Instance *instance, int *Time, int Depth, int rate, int maxAmplitude)
{ // line 1856, offset 0x80076af4
#if defined(PC_VERSION)
	int v5; // eax
	int v6; // edx

	v5 = Depth;
	if (Depth < -3072)
		v5 = -3072;
	if (v5 > 0)
		v5 = 0;
	v6 = (rate << 12) / gameTrackerX.timeMult + *Time;
	*Time = v6;
	if (v6 > 4096)
		*Time = v6 - 4096;
	if (Depth < 0)
		instance->position.z += maxAmplitude * v5 / -3072 * rcos(*Time) / 4096;
#endif
}


// autogenerated function stub: 
// int /*$ra*/ PhysicsCheckLOS(struct _Instance *instance /*$a0*/, int Data /*$a1*/, int Mode /*$a2*/)
int PhysicsCheckLOS(struct _Instance *instance, int Data, int Mode)
{ // line 1887, offset 0x80076bcc
#if defined(PC_VERSION)
	int v3; // ebp
	int currentStreamUnitID; // edx
	struct Level* LevelWithID; // eax
	struct _Instance* LinkChild; // esi
	int v7; // ecx
	struct Level* v8; // ebx
	struct _Instance* v9; // esi
	struct _PCollideInfo v11; // [esp+10h] [ebp-2Ch] BYREF

	v3 = 0;
	currentStreamUnitID = instance->currentStreamUnitID;
	v11.oldPoint = (SVECTOR*)(Data + 8);
	v11.newPoint = (SVECTOR*)Data;
	v11.collideType = 63;
	LevelWithID = STREAM_GetLevelWithID(currentStreamUnitID);
	LinkChild = instance->LinkChild;
	v7 = instance->flags | 0x40;
	v8 = LevelWithID;
	v11.inst = 0;
	v11.instance = instance;
	for (instance->flags = v7; LinkChild; LinkChild = LinkChild->LinkSibling)
		SetNoPtCollideInFamily(LinkChild);
	if (v8)
		COLLIDE_PointAndWorld(&v11, v8);
	else
		v11.type = 0;
	v9 = instance->LinkChild;
	for (instance->flags &= ~0x40u; v9; v9 = v9->LinkSibling)
		ResetNoPtCollideInFamily(v9);
	if (!v11.type)
		return 1;
	return v3;
#else
	return 0;
#endif
}


// autogenerated function stub: 
// int /*$ra*/ PhysicsCheckDropHeight(struct _Instance *instance /*$s2*/, int Data /*$a1*/, int Mode /*$s3*/)
int PhysicsCheckDropHeight(struct _Instance *instance, int Data, int Mode)
{ // line 1915, offset 0x80076bfc
	/* begin block 1 */
		// Start line: 1916
		// Start offset: 0x80076BFC
		// Variables:
			struct evPhysicsDropHeightData *data; // $s0
			struct Level *level; // $v0
			SVECTOR newPos; // stack offset -104
			SVECTOR oldPos; // stack offset -96
			int rc; // $s1
			int lowZ; // $v1
			//struct _PCollideInfo CInfo; // stack offset -88
			static MATRIX TempMat; // offset 0x30
			static MATRIX *pTempMat; // offset 0x50

		/* begin block 1.1 */
			// Start line: 1929
			// Start offset: 0x80076C30
			// Variables:
				VECTOR outTrans; // stack offset -40
				SVECTOR *ExtraRot; // $v0
		/* end block 1.1 */
		// End offset: 0x80076C74
		// End Line: 1958

		/* begin block 1.2 */
			// Start line: 1982
			// Start offset: 0x80076D40
			// Variables:
				long waterZLevel; // $a0
		/* end block 1.2 */
		// End offset: 0x80076D7C
		// End Line: 2000
	/* end block 1 */
	// End offset: 0x80076E6C
	// End Line: 2048

	/* begin block 2 */
		// Start line: 4438
	/* end block 2 */
	// End Line: 4439

	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ PhysicsCheckDropOff(struct _Instance *instance /*$s0*/, int Data /*$a1*/, short Mode /*$s3*/)
int PhysicsCheckDropOff(struct _Instance *instance, int Data, short Mode)
{ // line 2060, offset 0x80076e8c
	/* begin block 1 */
		// Start line: 2061
		// Start offset: 0x80076E8C
		// Variables:
			struct evPhysicsDropOffData *Ptr; // $s1
			int rc; // $s2
			VECTOR OutTrans; // stack offset -104
			SVECTOR *ExtraRot; // $v0
			//struct _PCollideInfo CInfo; // stack offset -88
			SVECTOR New; // stack offset -40
			SVECTOR Old; // stack offset -32
			static MATRIX TempMat; // offset 0x60
			static MATRIX *pTempMat; // offset 0x80
	/* end block 1 */
	// End offset: 0x80077090
	// End Line: 2155

	/* begin block 2 */
		// Start line: 4753
	/* end block 2 */
	// End Line: 4754

	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ PhysicsFollowWall(struct _Instance *instance /*$s2*/, struct GameTracker *gameTracker /*$a1*/, int Data /*$s7*/, short Mode /*$s5*/)
int PhysicsFollowWall(struct _Instance *instance, struct GameTracker *gameTracker, int Data, short Mode)
{ // line 2209, offset 0x800770ac
	/* begin block 1 */
		// Start line: 2210
		// Start offset: 0x800770AC
		// Variables:
			VECTOR OutTrans; // stack offset -168
			struct evPhysicsWallCrawlData *Ptr; // $s1
			//struct _PCollideInfo CInfo; // stack offset -152
			SVECTOR New; // stack offset -104
			SVECTOR Old; // stack offset -96
			static MATRIX *pTempMat; // offset 0x84

		/* begin block 1.1 */
			// Start line: 2281
			// Start offset: 0x800771E8
			// Variables:
				struct _Position A; // stack offset -88
				struct _Position B; // stack offset -80
				MATRIX mat; // stack offset -72
		/* end block 1.1 */
		// End offset: 0x800772E4
		// End Line: 2341
	/* end block 1 */
	// End offset: 0x8007758C
	// End Line: 2488

	/* begin block 2 */
		// Start line: 4418
	/* end block 2 */
	// End Line: 4419

	return 0;
}


// autogenerated function stub: 
// void /*$ra*/ PhysicsMoveLocalZClamp(struct _Instance *instance /*$s3*/, long segment /*$s0*/, long time /*$s1*/, long clamp /*$s2*/)
void PhysicsMoveLocalZClamp(struct _Instance *instance, long segment, long time, long clamp)
{ // line 2636, offset 0x800775bc
#if defined(PC_VERSION)
	MATRIX* matrix; // edx
	__int16 vy; // cx
	struct _Position position; // [esp+4h] [ebp-18h] BYREF
	SVECTOR v0; // [esp+Ch] [ebp-10h] BYREF
	SVECTOR v1; // [esp+14h] [ebp-8h] BYREF

	position.x = 0;
	position.y = 0;
	position.z = 0;
	PhysicsMove(instance, &position, time);
	v0.vx = position.x;
	v0.vz = position.z;
	matrix = instance->matrix;
	v0.vy = -position.y;
	ApplyMatrixSV(&matrix[segment], &v0, &v1);
	vy = v1.vy;
	instance->position.x += v1.vx;
	instance->position.y += vy;
	if (!clamp)
		instance->position.z += v1.vz;
#endif
}


// autogenerated function stub: 
// void /*$ra*/ PhysicsMove(struct _Instance *instance /*$a0*/, struct _Position *position /*$a1*/, long time /*$a2*/)
void PhysicsMove(struct _Instance *instance, struct _Position *position, long time)
{ // line 2662, offset 0x80077694
#if defined(PC_VERSION)
	int zVel; // ecx
	int v6; // kr18_4
	int v7; // ebx
	int v8; // ecx
	int v9; // eax
	int maxXVel; // edx
	int v11; // ebp
	int maxYVel; // edx
	int maxZVel; // edx
	int v14; // [esp+14h] [ebp-Ch]
	int xVel; // [esp+18h] [ebp-8h]
	int instancea; // [esp+24h] [ebp+4h]
	int timea; // [esp+2Ch] [ebp+Ch]

	zVel = instance->zVel;
	instancea = instance->yVel;
	v14 = zVel;
	xVel = instance->xVel;
	v6 = time * instance->yAccl;
	v7 = time * instance->xAccl / 4096;
	timea = time * instance->zAccl / 4096;
	position->x += time * xVel / 4096 + time * v7 / 0x2000;
	position->y += time * instancea / 4096 + time * (v6 / 4096) / 0x2000;
	position->z += time * v14 / 4096 + time * timea / 0x2000;
	v8 = v7 + xVel;
	v9 = v6 / 4096 + instancea;
	maxXVel = instance->maxXVel;
	v11 = timea + v14;
	if (v7 + xVel > maxXVel || (maxXVel = -maxXVel, v8 < maxXVel))
		v8 = maxXVel;
	maxYVel = instance->maxYVel;
	if (v9 > maxYVel || (maxYVel = -maxYVel, v9 < maxYVel))
		v9 = maxYVel;
	maxZVel = instance->maxZVel;
	if (v11 > maxZVel || (maxZVel = -maxZVel, v11 < maxZVel))
		v11 = maxZVel;
	instance->xVel = v8;
	instance->yVel = v9;
	instance->zVel = v11;
#endif
}


// autogenerated function stub: 
// void /*$ra*/ PhysicsSetVelFromZRot(struct _Instance *instance /*$s2*/, short angle /*$a1*/, long magnitude /*$s1*/)
void PhysicsSetVelFromZRot(struct _Instance *instance, short angle, long magnitude)
{ // line 2734, offset 0x80077830
#if defined(PC_VERSION)
	instance->xVel = (magnitude * rcos(angle - 1024)) >> 12;
	instance->yVel = (magnitude * rsin(angle - 1024)) >> 12;
#endif
}


// autogenerated function stub: 
// void /*$ra*/ PhysicsSetVelFromRot(struct _Instance *instance /*$s0*/, struct _Rotation *rot /*$a1*/, long magnitude /*$a2*/)
void PhysicsSetVelFromRot(struct _Instance *instance, struct _Rotation *rot, long magnitude)
{ // line 2745, offset 0x800778a0
#if defined(PC_VERSION)
	int vy; // edx
	int vz; // eax
	SVECTOR v0; // [esp+4h] [ebp-30h] BYREF
	SVECTOR v1; // [esp+Ch] [ebp-28h] BYREF
	MATRIX m; // [esp+14h] [ebp-20h] BYREF

	v0.vx = 0;
	v0.vz = 0;
	v0.vy = -(__int16)magnitude;
	RotMatrix((SVECTOR*)&instance->rotation, &m);
	ApplyMatrixSV(&m, &v0, &v1);
	vy = v1.vy;
	vz = v1.vz;
	instance->xVel = v1.vx;
	instance->yVel = vy;
	instance->zVel = vz;
#endif
}


// autogenerated function stub: 
// void /*$ra*/ PHYSICS_SetVAndAFromRot(struct _Instance *instance /*$s0*/, struct _Rotation *rot /*$a1*/, long v /*$s1*/, long a /*$s2*/)
void PHYSICS_SetVAndAFromRot(struct _Instance *instance, struct _Rotation *rot, long v, long a)
{ // line 2765, offset 0x80077910
#if defined(PC_VERSION)
	int vy; // eax
	int vz; // ecx
	int v6; // eax
	int v7; // ecx
	SVECTOR v0; // [esp+10h] [ebp-30h] BYREF
	SVECTOR v1; // [esp+18h] [ebp-28h] BYREF
	MATRIX m; // [esp+20h] [ebp-20h] BYREF

	if (v || a)
	{
		RotMatrix((SVECTOR*)&instance->rotation, &m);
		v0.vx = 0;
		v0.vz = 0;
	}
	if (v)
	{
		v0.vy = -(__int16)v;
		ApplyMatrixSV(&m, &v0, &v1);
		vy = v1.vy;
		vz = v1.vz;
		instance->xVel = v1.vx;
		instance->yVel = vy;
		instance->zVel = vz;
	}
	else
	{
		instance->xVel = 0;
		instance->yVel = 0;
		instance->zVel = 0;
	}
	if (a)
	{
		v0.vy = -(__int16)a;
		ApplyMatrixSV(&m, &v0, &v1);
		v6 = v1.vy;
		v7 = v1.vz;
		instance->xAccl = v1.vx;
		instance->yAccl = v6;
		instance->zAccl = v7;
	}
	else
	{
		instance->xAccl = 0;
		instance->yAccl = 0;
		instance->zAccl = 0;
	}
#endif
}


// autogenerated function stub: 
// long /*$ra*/ PHYSICS_FindAFromDAndT(long d /*$a0*/, long t /*$a1*/)
long PHYSICS_FindAFromDAndT(long d, long t)
{ // line 2822, offset 0x80077a00
#if defined(PC_VERSION)
	if (t)
		return (d << 13) / (t * t) / 4096;
	else
		return 0;
#else
	return 0;
#endif
}


// autogenerated function stub: 
// long /*$ra*/ PHYSICS_FindVFromAAndD(long a /*$a0*/, long d /*$a1*/)
long PHYSICS_FindVFromAAndD(long a, long d)
{ // line 2835, offset 0x80077a3c
#if defined(PC_VERSION)
	if (2 * a * d)
		return MATH3D_FastSqrt0(2 * a * d);
	else
		return 0;
#else
	return 0;
#endif
}


// autogenerated function stub: 
// void /*$ra*/ PHYSICS_StopIfCloseToTarget(struct _Instance *instance /*$a0*/, int x /*$a1*/, int y /*$a2*/, int z /*$a3*/)
void PHYSICS_StopIfCloseToTarget(struct _Instance *instance, int x, int y, int z)
{ // line 2876, offset 0x80077a74
#if defined(PC_VERSION)
	int xAccl; // ecx
	int yAccl; // ecx
	int zAccl; // ecx

	xAccl = instance->xAccl;
	if (xAccl < 0 && instance->xVel <= x || xAccl > 0 && instance->xVel >= x)
	{
		instance->xAccl = 0;
		instance->xVel = x;
	}
	yAccl = instance->yAccl;
	if (yAccl < 0 && instance->yVel <= y || yAccl > 0 && instance->yVel >= y)
	{
		instance->yAccl = 0;
		instance->yVel = y;
	}
	zAccl = instance->zAccl;
	if (zAccl < 0 && instance->zVel <= z || zAccl > 0 && instance->zVel >= z)
	{
		instance->zAccl = 0;
		instance->zVel = z;
	}
#endif
}


// autogenerated function stub: 
// int /*$ra*/ PHYSICS_CheckForTerrainCollide(struct _Instance *instance /*$a0*/, SVECTOR *startVec /*$a1*/, SVECTOR *endVec /*$a2*/, int segment /*$a3*/)
int PHYSICS_CheckForTerrainCollide(struct _Instance *instance, SVECTOR *startVec, SVECTOR *endVec, int segment)
{ // line 2898, offset 0x80077b54
#if defined(PC_VERSION)
	MATRIX* matrix; // eax
	struct _PCollideInfo v6; // [esp+0h] [ebp-2Ch] BYREF

	v6.newPoint = endVec;
	v6.oldPoint = startVec;
	matrix = instance->matrix;
	v6.collideType = 1;
	PHYSICS_GenericLineCheckMask(instance, &matrix[segment], &matrix[segment], &v6);
	return v6.type == 3;
#else
	return 0;
#endif
}


// autogenerated function stub: 
// int /*$ra*/ PHYSICS_CheckForObjectCollide(struct _Instance *instance /*$a0*/, SVECTOR *startVec /*$a1*/, SVECTOR *endVec /*$a2*/, int segment /*$a3*/)
int PHYSICS_CheckForObjectCollide(struct _Instance *instance, SVECTOR *startVec, SVECTOR *endVec, int segment)
{ // line 2917, offset 0x80077b9c
#if defined(PC_VERSION)
	MATRIX* matrix; // eax
	struct _PCollideInfo v6; // [esp+0h] [ebp-2Ch] BYREF

	v6.newPoint = endVec;
	v6.oldPoint = startVec;
	matrix = instance->matrix;
	v6.collideType = 62;
	PHYSICS_GenericLineCheckMask(instance, &matrix[segment], &matrix[segment], &v6);
	return v6.type != 0;
#else
	return 0;
#endif
}


// autogenerated function stub: 
// int /*$ra*/ PHYSICS_CheckForValidMove(struct _Instance *instance /*$a0*/, SVECTOR *startVec /*$a1*/, SVECTOR *endVec /*$a2*/, int segment /*$a3*/)
int PHYSICS_CheckForValidMove(struct _Instance *instance, SVECTOR *startVec, SVECTOR *endVec, int segment)
{ // line 2938, offset 0x80077be0
#if defined(PC_VERSION)
	int v4; // edi
	int v5; // edx
	int v6 = 0; // ecx
	MATRIX* v8; // [esp-Ch] [ebp-44h]
	struct _PCollideInfo v9; // [esp+Ch] [ebp-2Ch] BYREF

	v9.newPoint = endVec;
	v9.oldPoint = startVec;
	v8 = &instance->matrix[segment];
	v4 = 0;
	v9.collideType = 63;
	PHYSICS_GenericLineCheckMask(instance, v8, v8, &v9);
	v5 = 0;
	if (v9.type == 3)
	{
		if (*((WORD*)v9.prim + 5) == 0xFFFF)
			v6 &= 0xff00;
		else
			v6 = *(unsigned __int16*)((char*)&v9.inst->node.prev[6].next[1].prev + *((unsigned __int16*)v9.prim + 5) + 2);
		if ((v6 & 0x200) != 0)
			v5 = 1;
	}
	if (v5)
		v4 = 1;
	if (v9.type == 3 || v9.type == 2 || v9.type == 5)
		v4 += 2;
	return v4;
#else
	return 0;
#endif
}


// autogenerated function stub: 
// int /*$ra*/ PHYSICS_CheckFaceStick(struct _PCollideInfo *CInfo /*$a0*/)
int PHYSICS_CheckFaceStick(struct _PCollideInfo *CInfo)
{ // line 2966, offset 0x80077c4c
	/* begin block 1 */
		// Start line: 2967
		// Start offset: 0x80077C4C
		// Variables:
			int rc; // $a1

		/* begin block 1.1 */
			// Start line: 2973
			// Start offset: 0x80077C60
			// Variables:
				struct _TFace *tface; // $a2
		/* end block 1.1 */
		// End offset: 0x80077C78
		// End Line: 2975

		/* begin block 1.2 */
			// Start line: 2979
			// Start offset: 0x80077CA4
			// Variables:
				struct _HFace *hface; // stack offset -8
		/* end block 1.2 */
		// End offset: 0x80077CA4
		// End Line: 2987
	/* end block 1 */
	// End offset: 0x80077CA4
	// End Line: 2988

	/* begin block 2 */
		// Start line: 6640
	/* end block 2 */
	// End Line: 6641

	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ PHYSICS_CheckDontGrabEdge(struct _PCollideInfo *CInfo /*$s0*/)
int PHYSICS_CheckDontGrabEdge(struct _PCollideInfo *CInfo)
{ // line 2992, offset 0x80077cb0
#if defined(PC_VERSION)
	int v1; // edi
	__int16 type; // ax
	int v3; // ecx

	v1 = 0;
	type = CInfo->type;
	if (CInfo->type == 3)
	{
		if (*((WORD*)CInfo->prim + 5) == 0xFFFF)
			v3 = 0;
		else
			v3 = *(unsigned __int16*)((char*)&CInfo->inst->node.prev[6].next[1].prev
				+ *((unsigned __int16*)CInfo->prim + 5)
				+ 2);
		if ((v3 & 0x80u) != 0)
			v1 = 1;
		if (*((char*)&CInfo->inst->node.prev[9].prev[2].prev + 36 * CInfo->segment + 3) < 0)
			return 1;
	}
	else if (type == 2)
	{
		if (*((char*)CInfo->prim + 6) < 0)
			return 1;
	}
	else if (type == 5 && (INSTANCE_Query(CInfo->inst, 1) & 0x20) != 0 && (INSTANCE_Query(CInfo->inst, 3) & 1) == 0)
	{
		return 1;
	}
	return v1;
#else
	return 0;
#endif
}


// autogenerated function stub: 
// void /*$ra*/ PHYSICS_GenericLineCheckSetup(short x /*$a0*/, short y /*$a1*/, short z /*$a2*/, SVECTOR *inVec /*$a3*/)
void PHYSICS_GenericLineCheckSetup(short x, short y, short z, SVECTOR *inVec)
{ // line 3035, offset 0x80077dd8
#if defined(PC_VERSION)
	inVec->vx = x;
	inVec->vy = y;
	inVec->vz = z;
#endif
}


// autogenerated function stub: 
// void /*$ra*/ PHYSICS_GenericLineCheck(struct _Instance *instance /*$a0*/, MATRIX *transMat /*$a1*/, MATRIX *rotMat /*$a2*/, struct _PCollideInfo *cInfo /*$a3*/)
void PHYSICS_GenericLineCheck(struct _Instance *instance, MATRIX *transMat, MATRIX *rotMat, struct _PCollideInfo *cInfo)
{ // line 3053, offset 0x80077de8
#if defined(PC_VERSION)
	cInfo->collideType = 63;
	PHYSICS_GenericLineCheckMask(instance, transMat, rotMat, cInfo);
#endif
}


// autogenerated function stub: 
// void /*$ra*/ PHYSICS_GenericLineCheckMask(struct _Instance *instance /*$a0*/, MATRIX *transMat /*$a1*/, MATRIX *rotMat /*$a2*/, struct _PCollideInfo *cInfo /*$a3*/)
void PHYSICS_GenericLineCheckMask(struct _Instance *instance, MATRIX *transMat, MATRIX *rotMat, struct _PCollideInfo *cInfo)
{ // line 3057, offset 0x80077e0c
#if defined(PC_VERSION)
	SVECTOR* oldPoint; // edi
	SVECTOR* newPoint; // ebx
	struct Level* LevelWithID; // eax
	struct _Instance* LinkChild; // esi
	struct Level* v8; // ebx
	struct _Instance* i; // edi
	VECTOR v10; // [esp+10h] [ebp-10h] BYREF

	oldPoint = cInfo->oldPoint;
	newPoint = cInfo->newPoint;
	TRANS_ApplyMatrix(rotMat, oldPoint, &v10);
	oldPoint->vx = transMat->t[0] + v10.vx;
	oldPoint->vy = transMat->t[1] + v10.vy;
	oldPoint->vz = transMat->t[2] + v10.vz;
	TRANS_ApplyMatrix(rotMat, newPoint, &v10);
	newPoint->vx = transMat->t[0] + v10.vx;
	newPoint->vy = transMat->t[1] + v10.vy;
	newPoint->vz = transMat->t[2] + v10.vz;
	LevelWithID = STREAM_GetLevelWithID(instance->currentStreamUnitID);
	cInfo->inst = 0;
	cInfo->instance = instance;
	LinkChild = instance->LinkChild;
	v8 = LevelWithID;
	for (instance->flags |= 0x40u; LinkChild; LinkChild = LinkChild->LinkSibling)
		SetNoPtCollideInFamily(LinkChild);
	if (v8)
		COLLIDE_PointAndWorld(cInfo, v8);
	else
		cInfo->type = 0;
	instance->flags &= ~0x40u;
	for (i = instance->LinkChild; i; i = i->LinkSibling)
		ResetNoPtCollideInFamily(i);
#endif
}




