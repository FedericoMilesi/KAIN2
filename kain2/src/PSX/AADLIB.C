#include "../CORE.H"
#include "AADLIB.H"

struct AadMemoryStruct* aadMem; // offset 0x800CECD8

#include <stddef.h>

unsigned long aadGetMemorySize(struct AadInitAttr *attributes)
{
#if defined(PC_VERSION)
	return 1488 * attributes->numSlots + 23720;
#elif defined(PSX_VERSION)
	return 1488 * attributes->numSlots + 7304;
#endif
}


// autogenerated function stub: 
// int /*$ra*/ aadInit(struct AadInitAttr *attributes /*$s1*/, unsigned char *memoryPtr /*$s0*/)
int aadInit(struct AadInitAttr *attributes, unsigned char *memoryPtr)
{ // line 46, offset 0x800514f8
	/* begin block 1 */
		// Start line: 47
		// Start offset: 0x800514F8
		// Variables:
			struct _AadSequenceSlot *slot; // $v1
			unsigned long size; // $v0
			int slotNumber; // $a2
			int i; // $a1
	/* end block 1 */
	// End offset: 0x8005178C
	// End Line: 183

	/* begin block 2 */
		// Start line: 92
	/* end block 2 */
	// End Line: 93

	return 0;
}


// autogenerated function stub: 
// void /*$ra*/ aadInstallUpdateFunc(TDRFuncPtr_aadInstallUpdateFunc0updateFuncPtr updateFuncPtr /*$s0*/, int hblanksPerUpdate /*$s1*/)
void aadInstallUpdateFunc(TDRFuncPtr_aadInstallUpdateFunc0updateFuncPtr updateFuncPtr, int hblanksPerUpdate)
{ // line 186, offset 0x800517a0
	/* begin block 1 */
		// Start line: 495
	/* end block 1 */
	// End Line: 496

}

void aadInitVolume()
{ 
	aadMem->masterVolume = 0;
	SpuSetCommonCDMix(0);
	SpuSetCommonMasterVolume(0, 0);
}


// autogenerated function stub: 
// void /*$ra*/ aadSetMasterVolume(int voll /*$a0*/)
void aadSetMasterVolume(int volume)
{ // line 210, offset 0x80051850
	/* begin block 1 */
		// Start line: 547
	/* end block 1 */
	// End Line: 548

}


// autogenerated function stub: 
// void /*$ra*/ aadStartMasterVolumeFade(int targetVolume /*$a0*/, int volumeStep /*$a1*/, TDRFuncPtr_aadStartMasterVolumeFade2fadeCompleteCallback fadeCompleteCallback /*$a2*/)
void aadStartMasterVolumeFade(int targetVolume, int volumeStep, TDRFuncPtr_aadStartMasterVolumeFade2fadeCompleteCallback fadeCompleteCallback)
{ // line 219, offset 0x80051880
	aadMem->masterVolFader.volumeStep = volumeStep;
	aadMem->masterVolFader.targetVolume = targetVolume;
	aadMem->masterVolFader.fadeCompleteCallback = fadeCompleteCallback;
}


// autogenerated function stub: 
// void /*$ra*/ aadSetSfxMasterVolume(int voll /*$a0*/)
void aadSetSfxMasterVolume(int volume)
{ // line 229, offset 0x80051898
	aadMem->sfxMasterVol = volume;
}


// autogenerated function stub: 
// void /*$ra*/ aadSetMusicMasterVolume(int voll /*$a0*/)
void aadSetMusicMasterVolume(int volume)
{ // line 237, offset 0x800518a8
	/* begin block 1 */
		// Start line: 238
		// Start offset: 0x800518A8
		// Variables:
			int slotNumber; // $s0
	/* end block 1 */
	// End offset: 0x800518FC
	// End Line: 247

	/* begin block 2 */
		// Start line: 604
	/* end block 2 */
	// End Line: 605

	/* begin block 3 */
		// Start line: 608
	/* end block 3 */
	// End Line: 609

}

void aadStartMusicMasterVolFade(int targetVolume, int volumeStep, TDRFuncPtr_aadStartMusicMasterVolFade2fadeCompleteCallback fadeCompleteCallback)
{
	aadMem->musicMasterVolFader.volumeStep = volumeStep;
	aadMem->musicMasterVolFader.targetVolume = targetVolume;
	aadMem->musicMasterVolFader.fadeCompleteCallback = fadeCompleteCallback;
}

// autogenerated function stub: 
// void /*$ra*/ aadShutdown()
void aadShutdown()
{ // line 285, offset 0x80051924
	/* begin block 1 */
		// Start line: 570
	/* end block 1 */
	// End Line: 571

}


// autogenerated function stub: 
// long /*$ra*/ aadSlotUpdateWrapper()
long aadSlotUpdateWrapper()
{ // line 321, offset 0x800519ac
	/* begin block 1 */
		// Start line: 322
		// Start offset: 0x800519AC
		// Variables:
			unsigned long curGp; // $s0
	/* end block 1 */
	// End offset: 0x800519AC
	// End Line: 322

	/* begin block 2 */
		// Start line: 745
	/* end block 2 */
	// End Line: 746

	return 0;
}


// autogenerated function stub: 
// void /*$ra*/ aadSlotUpdate()
void aadSlotUpdate()
{ // line 338, offset 0x800519f0
	/* begin block 1 */
		// Start line: 339
		// Start offset: 0x800519F0
		// Variables:
			struct _AadSequenceSlot *slot; // $s2
			struct AadSeqEvent *seqEventPtr; // $a0
			int slotNumber; // $fp
			int i; // $a3
			int fadeComplete; // $v1
			int track; // $s3
			int newVol; // $s0
			int slotDone; // $a2

		/* begin block 1.1 */
			// Start line: 354
			// Start offset: 0x80051A38
			// Variables:
				unsigned long vmask; // $a2
		/* end block 1.1 */
		// End offset: 0x80051AB0
		// End Line: 369
	/* end block 1 */
	// End offset: 0x80051F08
	// End Line: 592

	/* begin block 2 */
		// Start line: 780
	/* end block 2 */
	// End Line: 781

	/* begin block 3 */
		// Start line: 789
	/* end block 3 */
	// End Line: 790

}


// autogenerated function stub: 
// unsigned long /*$ra*/ aadCreateFourCharID(char a /*$a0*/, char b /*$a1*/, char c /*$a2*/, char d /*$a3*/)
unsigned long aadCreateFourCharID(char a, char b, char c, char d)
{ // line 636, offset 0x80051f38
	/* begin block 1 */
		// Start line: 1512
	/* end block 1 */
	// End Line: 1513

	/* begin block 2 */
		// Start line: 1513
	/* end block 2 */
	// End Line: 1514

	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ aadLoadDynamicSoundBank(char *sndFileName /*$s3*/, char *smpFileName /*$s4*/, int dynamicBankIndex /*$s2*/, int loadOption /*$s5*/, TDRFuncPtr_aadLoadDynamicSoundBank4retProc retProc /*stack 16*/)
int aadLoadDynamicSoundBank(char *sndFileName, char *smpFileName, int dynamicBankIndex, int loadOption, TDRFuncPtr_aadLoadDynamicSoundBank4retProc retProc)
{ // line 644, offset 0x80051f60
	/* begin block 1 */
		// Start line: 645
		// Start offset: 0x80051F60
		// Variables:
			int i; // $a0
			struct AadDynamicBankLoadInfo *info; // $s1
	/* end block 1 */
	// End offset: 0x80052094
	// End Line: 699

	/* begin block 2 */
		// Start line: 1528
	/* end block 2 */
	// End Line: 1529

	return 0;
}


// autogenerated function stub: 
// void /*$ra*/ aadLoadDynamicSoundBankReturn(void *loadedDataPtr /*$a0*/, void *data /*$s3*/, void *data2 /*$a2*/)
void aadLoadDynamicSoundBankReturn(void *loadedDataPtr, void *data, void *data2)
{ // line 704, offset 0x800520b8
	/* begin block 1 */
		// Start line: 705
		// Start offset: 0x800520B8
		// Variables:
			int dynamicBankIndex; // $s1
			int error; // $s0
	/* end block 1 */
	// End offset: 0x8005216C
	// End Line: 772

	/* begin block 2 */
		// Start line: 1693
	/* end block 2 */
	// End Line: 1694

}


// autogenerated function stub: 
// void /*$ra*/ aadLoadDynamicSoundBankReturn2(void *loadedDataPtr /*$a0*/, long loadedDataSize /*$s2*/, short status /*$s5*/, void *data1 /*$a3*/, void *data2 /*stack 16*/)
void aadLoadDynamicSoundBankReturn2(void *loadedDataPtr, long loadedDataSize, short status, void *data1, void *data2)
{ // line 782, offset 0x80052188
	/* begin block 1 */
		// Start line: 783
		// Start offset: 0x80052188
		// Variables:
			unsigned char *dataPtr; // $s1
			struct AadDynamicBankLoadInfo *info; // $s0
			int dynamicBankIndex; // $s3
			int error; // $v0

		/* begin block 1.1 */
			// Start line: 866
			// Start offset: 0x800522FC
			// Variables:
				int i; // $a2
		/* end block 1.1 */
		// End offset: 0x80052390
		// End Line: 880
	/* end block 1 */
	// End offset: 0x80052390
	// End Line: 882

	/* begin block 2 */
		// Start line: 1851
	/* end block 2 */
	// End Line: 1852

}

int aadFreeDynamicSoundBank(int dynamicBankIndex)
{ 
	if (dynamicBankIndex < 2)
	{
		return 0x1005;
	}
	
	if (aadMem->dynamicBankStatus[dynamicBankIndex] != 2)
	{
		return 0x1007;
	}

	if (aadMem->dynamicSoundBankData[dynamicBankIndex] == NULL)
	{
		return 0x1007;
	}

	aadMem->dynamicBankStatus[dynamicBankIndex] = 0;
	aadMem->memoryFreeProc(aadMem->dynamicSoundBankData[dynamicBankIndex]);
	aadMem->dynamicSoundBankData[dynamicBankIndex] = NULL;

	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ aadOpenDynamicSoundBank(unsigned char *soundBank /*$a0*/, int dynamicBankIndex /*$s1*/)
int aadOpenDynamicSoundBank(unsigned char *soundBank, int dynamicBankIndex)
{ // line 930, offset 0x80052430
	/* begin block 1 */
		// Start line: 931
		// Start offset: 0x80052430
		// Variables:
			struct AadSoundBankHdr *soundBankHdr; // $s0
			struct AadProgramAtr *programAtr; // $v0
			struct AadToneAtr *toneAtr; // $v0
			unsigned long *waveAddr; // $v0
			unsigned long *sequenceOffsetTbl; // $a0
			unsigned long *sequenceLabelOffsetTbl; // $a1
			unsigned char *sequenceBase; // $a3
			int i; // $t2
	/* end block 1 */
	// End offset: 0x8005253C
	// End Line: 979

	/* begin block 2 */
		// Start line: 2186
	/* end block 2 */
	// End Line: 2187

	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ aadLoadDynamicSfx(char *fileName /*$a3*/, long directoryID /*$a1*/, long flags /*$a2*/)
int aadLoadDynamicSfx(char *fileName, long directoryID, long flags)
{ // line 996, offset 0x80052550
	/* begin block 1 */
		// Start line: 997
		// Start offset: 0x80052550
		// Variables:
			struct AadDynamicLoadRequest *loadReq; // $s0
	/* end block 1 */
	// End offset: 0x800525F4
	// End Line: 1020

	/* begin block 2 */
		// Start line: 2390
	/* end block 2 */
	// End Line: 2391

	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ aadFreeDynamicSfx(int handle /*$a0*/)
int aadFreeDynamicSfx(int handle)
{ // line 1046, offset 0x80052604
	/* begin block 1 */
		// Start line: 1048
		// Start offset: 0x80052604
		// Variables:
			struct AadDynamicLoadRequest *loadReq; // $a1
			int i; // $a2
	/* end block 1 */
	// End offset: 0x800526D8
	// End Line: 1079

	/* begin block 2 */
		// Start line: 2516
	/* end block 2 */
	// End Line: 2517

	/* begin block 3 */
		// Start line: 2517
	/* end block 3 */
	// End Line: 2518

	/* begin block 4 */
		// Start line: 2524
	/* end block 4 */
	// End Line: 2525

	return 0;
}

void aadRelocateMusicMemoryBegin()
{ 
	aadMem->flags |= 0x2;
}


// autogenerated function stub: 
// void /*$ra*/ aadRelocateMusicMemoryEnd(struct MemHeader *newAddress /*$t9*/, long offset /*$a1*/, void *oldAddress /*$a2*/)
void aadRelocateMusicMemoryEnd(struct MemHeader *newAddress, long offset, void *oldAddress)
{ // line 1132, offset 0x800526fc
	/* begin block 1 */
		// Start line: 1133
		// Start offset: 0x800526FC
		// Variables:
			int bank; // $t7

		/* begin block 1.1 */
			// Start line: 1141
			// Start offset: 0x8005271C
			// Variables:
				int slotNumber; // $t5
				int i; // $a3
				struct AadSoundBankHdr *bankHdr; // $a0

			/* begin block 1.1.1 */
				// Start line: 1160
				// Start offset: 0x800527C4
				// Variables:
					struct _AadSequenceSlot *slot; // $t3

				/* begin block 1.1.1.1 */
					// Start line: 1163
					// Start offset: 0x800527EC
					// Variables:
						int track; // $t1
				/* end block 1.1.1.1 */
				// End offset: 0x80052860
				// End Line: 1179
			/* end block 1.1.1 */
			// End offset: 0x80052860
			// End Line: 1180
		/* end block 1.1 */
		// End offset: 0x8005287C
		// End Line: 1183

		/* begin block 1.2 */
			// Start line: 1186
			// Start offset: 0x8005288C
			// Variables:
				struct AadSynthVoice *voice; // $a0
				//int i; // $t0
				long dataSize; // $v0
		/* end block 1.2 */
		// End offset: 0x80052908
		// End Line: 1205
	/* end block 1 */
	// End offset: 0x80052908
	// End Line: 1207

	/* begin block 2 */
		// Start line: 2710
	/* end block 2 */
	// End Line: 2711

}

void aadRelocateSfxMemory(void *oldAddress, int offset)
{
	struct _AadDynSfxFileHdr *snfFile;
	
	snfFile = aadMem->firstDynSfxFile;

	if (oldAddress == snfFile)
	{
		snfFile = (struct _AadDynSfxFileHdr*)snfFile + offset;
		aadMem->firstDynSfxFile = snfFile;
	}

	if (snfFile != NULL)
	{
		do
		{
			if (oldAddress == snfFile->prevDynSfxFile)
			{
				snfFile->prevDynSfxFile = (struct _AadDynSfxFileHdr*)oldAddress + offset;
			}
			if (oldAddress == snfFile->nextDynSfxFile)
			{
				snfFile->nextDynSfxFile = (struct _AadDynSfxFileHdr*)oldAddress + offset;
			}

			snfFile = snfFile->nextDynSfxFile;

		} while (snfFile != NULL);
	}
}

int aadGetNumLoadsQueued()
{
	return aadMem->numLoadReqsQueued;
}


// autogenerated function stub: 
// void /*$ra*/ aadPurgeLoadQueue()
void aadPurgeLoadQueue()
{ // line 1265, offset 0x800529a0
	/* begin block 1 */
		// Start line: 3078
	/* end block 1 */
	// End Line: 3079

	/* begin block 2 */
		// Start line: 3080
	/* end block 2 */
	// End Line: 3081

}


// autogenerated function stub: 
// void /*$ra*/ aadProcessLoadQueue()
void aadProcessLoadQueue()
{ // line 1277, offset 0x800529b8
	/* begin block 1 */
		// Start line: 1278
		// Start offset: 0x800529B8
		// Variables:
			struct AadDynamicSfxLoadInfo *info; // $s0
			int i; // $a0
			char *p; // $v0

		/* begin block 1.1 */
			// Start line: 1303
			// Start offset: 0x80052A40
			// Variables:
				struct AadDynamicLoadRequest *loadReq; // $s2

			/* begin block 1.1.1 */
				// Start line: 1314
				// Start offset: 0x80052A90
				// Variables:
					char areaName[12]; // stack offset -32

				/* begin block 1.1.1.1 */
					// Start line: 1335
					// Start offset: 0x80052ACC
				/* end block 1.1.1.1 */
				// End offset: 0x80052ACC
				// End Line: 1335

				/* begin block 1.1.1.2 */
					// Start line: 1340
					// Start offset: 0x80052AF8
				/* end block 1.1.1.2 */
				// End offset: 0x80052B28
				// End Line: 1342
			/* end block 1.1.1 */
			// End offset: 0x80052BB0
			// End Line: 1361

			/* begin block 1.1.2 */
				// Start line: 1366
				// Start offset: 0x80052BC0
				// Variables:
					//int i; // $s2
					struct _AadDynSfxFileHdr *snfFile; // $s1
					unsigned short *sfxIDListPtr; // $v1
			/* end block 1.1.2 */
			// End offset: 0x80052C98
			// End Line: 1398
		/* end block 1.1 */
		// End offset: 0x80052CAC
		// End Line: 1406
	/* end block 1 */
	// End offset: 0x80052CE0
	// End Line: 1414

	/* begin block 2 */
		// Start line: 3102
	/* end block 2 */
	// End Line: 3103

	/* begin block 3 */
		// Start line: 3114
	/* end block 3 */
	// End Line: 3115

}


// autogenerated function stub: 
// void /*$ra*/ aadLoadDynamicSfxAbort(struct AadDynamicSfxLoadInfo *info /*$s0*/, int error /*$a1*/)
void aadLoadDynamicSfxAbort(struct AadDynamicSfxLoadInfo *info, int error)
{ // line 1417, offset 0x80052cf8
	/* begin block 1 */
		// Start line: 3422
	/* end block 1 */
	// End Line: 3423

}


// autogenerated function stub: 
// void /*$ra*/ aadLoadDynamicSfxDone(struct AadDynamicSfxLoadInfo *info /*$a0*/)
void aadLoadDynamicSfxDone(struct AadDynamicSfxLoadInfo *info)
{ // line 1443, offset 0x80052d7c
	/* begin block 1 */
		// Start line: 3474
	/* end block 1 */
	// End Line: 3475

	/* begin block 2 */
		// Start line: 3476
	/* end block 2 */
	// End Line: 3477

}


// autogenerated function stub: 
// void /*$ra*/ aadLoadDynamicSfxReturn(void *loadedDataPtr /*$a0*/, void *data /*$a1*/, void *data2 /*$a2*/)
void aadLoadDynamicSfxReturn(void *loadedDataPtr, void *data, void *data2)
{ // line 1458, offset 0x80052d84
	/* begin block 1 */
		// Start line: 1459
		// Start offset: 0x80052D84
		// Variables:
			struct _AadDynSfxFileHdr *p; // $v1
			struct AadDynamicSfxLoadInfo *info; // $s0
	/* end block 1 */
	// End offset: 0x80052EE8
	// End Line: 1546

	/* begin block 2 */
		// Start line: 3504
	/* end block 2 */
	// End Line: 3505

}


// autogenerated function stub: 
// int /*$ra*/ aadWaveMalloc(unsigned short waveID /*$t6*/, unsigned long waveSize /*$a1*/)
int aadWaveMalloc(unsigned short waveID, unsigned long waveSize)
{ // line 1561, offset 0x80052efc
	/* begin block 1 */
		// Start line: 1562
		// Start offset: 0x80052EFC
		// Variables:
			struct AadNewSramBlockDesc *sramDesc; // $a2
			struct AadNewSramBlockDesc *bestFit; // $t1
			struct AadNewSramBlockDesc *next; // $a2
			struct AadNewSramBlockDesc *sramDescTbl; // $t2
			unsigned long safeWaveSize; // $t4
			int i; // $a3
			int sramDescIndex; // $t0
			int bestFitIndex; // $t3
	/* end block 1 */
	// End offset: 0x8005313C
	// End Line: 1665

	/* begin block 2 */
		// Start line: 3724
	/* end block 2 */
	// End Line: 3725

	/* begin block 3 */
		// Start line: 3734
	/* end block 3 */
	// End Line: 3735

	return 0;
}


// autogenerated function stub: 
// unsigned long /*$ra*/ aadGetSramBlockAddr(int handle /*$a0*/)
unsigned long aadGetSramBlockAddr(int handle)
{ // line 1669, offset 0x80053144
	/* begin block 1 */
		// Start line: 1671
		// Start offset: 0x80053144
		// Variables:
			struct AadNewSramBlockDesc *sramDesc; // $v1
	/* end block 1 */
	// End offset: 0x80053168
	// End Line: 1681

	/* begin block 2 */
		// Start line: 3969
	/* end block 2 */
	// End Line: 3970

	/* begin block 3 */
		// Start line: 3970
	/* end block 3 */
	// End Line: 3971

	/* begin block 4 */
		// Start line: 3972
	/* end block 4 */
	// End Line: 3973

	return 0;
}


// autogenerated function stub: 
// void /*$ra*/ aadWaveFree(int handle /*$a0*/)
void aadWaveFree(int handle)
{ // line 1702, offset 0x80053170
	/* begin block 1 */
		// Start line: 1704
		// Start offset: 0x80053170
		// Variables:
			struct AadNewSramBlockDesc *sramDesc; // $a1
			struct AadNewSramBlockDesc *sramDescTbl; // $a3

		/* begin block 1.1 */
			// Start line: 1715
			// Start offset: 0x800531A0
			// Variables:
				struct AadNewSramBlockDesc *next; // $a2
		/* end block 1.1 */
		// End offset: 0x80053204
		// End Line: 1724

		/* begin block 1.2 */
			// Start line: 1728
			// Start offset: 0x80053214
			// Variables:
				struct AadNewSramBlockDesc *prev; // $a0
		/* end block 1.2 */
		// End offset: 0x80053278
		// End Line: 1737
	/* end block 1 */
	// End offset: 0x80053278
	// End Line: 1740

	/* begin block 2 */
		// Start line: 3404
	/* end block 2 */
	// End Line: 3405

	/* begin block 3 */
		// Start line: 4019
	/* end block 3 */
	// End Line: 4020

	/* begin block 4 */
		// Start line: 4022
	/* end block 4 */
	// End Line: 4023

}


// autogenerated function stub: 
// void /*$ra*/ aadFreeSingleDynSfx(int sfxID /*$a0*/)
void aadFreeSingleDynSfx(int sfxID)
{ // line 1744, offset 0x80053280
	/* begin block 1 */
		// Start line: 1745
		// Start offset: 0x80053280
		// Variables:
			int ti; // $v1
			int wi; // $v1
			struct AadLoadedSfxToneAttr *toneAttr; // $a1
			struct AadLoadedSfxWaveAttr *waveAttr; // $v1
	/* end block 1 */
	// End offset: 0x80053338
	// End Line: 1770

	/* begin block 2 */
		// Start line: 4106
	/* end block 2 */
	// End Line: 4107

	/* begin block 3 */
		// Start line: 4111
	/* end block 3 */
	// End Line: 4112

}


// autogenerated function stub: 
// void /*$ra*/ setSramFullAlarm()
void setSramFullAlarm()
{ // line 1773, offset 0x80053348
	/* begin block 1 */
		// Start line: 1775
		// Start offset: 0x80053348
		// Variables:
			struct AadNewSramBlockDesc *sramDescTbl; // $v1
			struct AadNewSramBlockDesc *sramDesc; // $a1
			long totalUsed; // $t0
			long totalFree; // $t1
			long largestFree; // $t2
			long numFreeBlocks; // $t3
			long numUsedBlocks; // $a3
			int i; // $a2
	/* end block 1 */
	// End offset: 0x800533F4
	// End Line: 1812

	/* begin block 2 */
		// Start line: 4169
	/* end block 2 */
	// End Line: 4170

	/* begin block 3 */
		// Start line: 4170
	/* end block 3 */
	// End Line: 4171

	/* begin block 4 */
		// Start line: 4184
	/* end block 4 */
	// End Line: 4185

}


// autogenerated function stub: 
// void /*$ra*/ aadLoadSingleDynSfx(struct AadDynamicSfxLoadInfo *info /*$s2*/)
void aadLoadSingleDynSfx(struct AadDynamicSfxLoadInfo *info)
{ // line 1829, offset 0x80053424
	/* begin block 1 */
		// Start line: 1830
		// Start offset: 0x80053424
		// Variables:
			int i; // $a0
			struct AadLoadedSfxToneAttr *toneAttr; // $a1
			struct AadLoadedSfxWaveAttr *waveAttr; // $s0
			struct AadDynSfxAttr *attr; // $s1
	/* end block 1 */
	// End offset: 0x800536DC
	// End Line: 1943

	/* begin block 2 */
		// Start line: 4288
	/* end block 2 */
	// End Line: 4289

	/* begin block 3 */
		// Start line: 4297
	/* end block 3 */
	// End Line: 4298

}


// autogenerated function stub: 
// void /*$ra*/ HackCallback()
void HackCallback()
{ // line 1958, offset 0x800536f4
	/* begin block 1 */
		// Start line: 4622
	/* end block 1 */
	// End Line: 4623

}


// autogenerated function stub: 
// void /*$ra*/ aadLoadDynamicSfxReturn2(void *loadedDataPtr /*$a0*/, long loadedDataSize /*$a1*/, short status /*$a2*/, void *data1 /*$a3*/, void *data2 /*stack 16*/)
void aadLoadDynamicSfxReturn2(void *loadedDataPtr, long loadedDataSize, short status, void *data1, void *data2)
{ // line 1967, offset 0x8005372c
	/* begin block 1 */
		// Start line: 1968
		// Start offset: 0x8005372C
		// Variables:
			unsigned char *dataPtr; // $s4
			unsigned long dataOffset; // $s3
			unsigned long bytesRemaining; // $s2
			struct AadDynamicSfxLoadInfo *info; // $s1
			unsigned long n; // $s0
	/* end block 1 */
	// End offset: 0x800539CC
	// End Line: 2120

	/* begin block 2 */
		// Start line: 4640
	/* end block 2 */
	// End Line: 4641

}


// autogenerated function stub: 
// int /*$ra*/ aadCheckSramFragmented()
int aadCheckSramFragmented()
{ // line 2172, offset 0x800539f4
	/* begin block 1 */
		// Start line: 2174
		// Start offset: 0x800539F4
		// Variables:
			struct AadNewSramBlockDesc *sramDescTbl; // $v1
			struct AadNewSramBlockDesc *sramDesc; // $a1
			long totalFree; // $t0
			long smallestFree; // $t1
			long numFreeBlocks; // $a3
			int i; // $a2
			int defragNeeded; // $v1
	/* end block 1 */
	// End offset: 0x80053AA0
	// End Line: 2216

	/* begin block 2 */
		// Start line: 5103
	/* end block 2 */
	// End Line: 5104

	/* begin block 3 */
		// Start line: 5104
	/* end block 3 */
	// End Line: 5105

	/* begin block 4 */
		// Start line: 5114
	/* end block 4 */
	// End Line: 5115

	return 0;
}


// autogenerated function stub: 
// void /*$ra*/ aadProcessSramDefrag()
void aadProcessSramDefrag()
{ // line 2235, offset 0x80053aa8
	/* begin block 1 */
		// Start line: 2236
		// Start offset: 0x80053AA8
		// Variables:
			struct AadSramDefragInfo *info; // $s3
			struct AadNewSramBlockDesc *sramDescTbl; // $s5
			struct AadNewSramBlockDesc *firstBlock; // $s1
			struct AadNewSramBlockDesc *secondBlock; // $s2
			int n; // $s0
			int waveID; // $a0
			int firstBlockIndex; // $s4
			int secondBlockIndex; // $s6

		/* begin block 1.1 */
			// Start line: 2338
			// Start offset: 0x80053C70
			// Variables:
				struct AadNewSramBlockDesc *next; // $a0
		/* end block 1.1 */
		// End offset: 0x80053CD4
		// End Line: 2350
	/* end block 1 */
	// End offset: 0x80053DE4
	// End Line: 2428

	/* begin block 2 */
		// Start line: 5234
	/* end block 2 */
	// End Line: 5235

}


// autogenerated function stub: 
// int /*$ra*/ aadIsSfxLoaded(unsigned int toneID /*$a0*/)
int aadIsSfxLoaded(unsigned int toneID)
{ // line 2437, offset 0x80053e0c
	/* begin block 1 */
		// Start line: 4874
	/* end block 1 */
	// End Line: 4875

	/* begin block 2 */
		// Start line: 5664
	/* end block 2 */
	// End Line: 5665

	return 0;
}

void aadInitSequenceSlot(struct _AadSequenceSlot *slot)
{
	struct AadSequenceHdr* seqHdr;
	unsigned long trackOffset;
	int i;
	int bank;

	bank = slot->sequenceAssignedDynamicBank;
	i = 0;
	slot->status = 0;
	slot->selectedDynamicBank = bank;
	slot->slotFlags &= 0x1;

	seqHdr = (struct AadSequenceHdr*)aadMem->dynamicSequenceAddressTbl[bank][slot->sequenceNumberAssigned];

	for (i = 0; i < 16; i++, seqHdr++)
	{
		if (i < seqHdr->numTracks)
		{
			slot->sequencePosition[i] = (unsigned char*)(char*)seqHdr + ((int*)seqHdr)[4];
		}
		else
		{
			slot->sequencePosition[i] = NULL;
		}

		slot->trackFlags[i] = 0;
		slot->loopCurrentNestLevel[i] = 0;
		slot->eventsInQueue[i] = 0;
		slot->eventIn[i] = 0;
		slot->eventOut[i] = 0;
		slot->trackFlags[i] |= 0x20;
	}

	for (i = 0; i < 16; i++)
	{
		slot->currentProgram[i] = 255;
		slot->volume[i] = 127;
		slot->panPosition[i] = 63;
		slot->currentDynamicBank[i] = slot->sequenceAssignedDynamicBank;
		slot->pitchWheel[i] = 8192;
	}

	slot->selectedSlotPtr = slot;
	slot->delayedMuteMode = 0;
	slot->delayedMuteCmds = 0;
	slot->delayedUnMuteCmds = 0;
	slot->selectedSlotNum = slot->thisSlotNumber;
}


// autogenerated function stub: 
// int /*$ra*/ aadWaitForSramTransferComplete()
int aadWaitForSramTransferComplete()
{ // line 2779, offset 0x80053f54
	/* begin block 1 */
		// Start line: 2780
		// Start offset: 0x80053F54
		// Variables:
			int n; // $s0
	/* end block 1 */
	// End offset: 0x80053F84
	// End Line: 2787

	/* begin block 2 */
		// Start line: 6438
	/* end block 2 */
	// End Line: 6439

	return 0;
}


// autogenerated function stub: 
// void /*$ra*/ aadInitReverb()
void aadInitReverb()
{ // line 2790, offset 0x80053f94
	/* begin block 1 */
		// Start line: 6461
	/* end block 1 */
	// End Line: 6462

}


// autogenerated function stub: 
// void /*$ra*/ aadShutdownReverb()
void aadShutdownReverb()
{ // line 2806, offset 0x80054018
	/* begin block 1 */
		// Start line: 6493
	/* end block 1 */
	// End Line: 6494

}


// autogenerated function stub: 
// int /*$ra*/ aadGetReverbMode()
int aadGetReverbMode()
{ // line 2820, offset 0x80054050
	/* begin block 1 */
		// Start line: 6521
	/* end block 1 */
	// End Line: 6522

	/* begin block 2 */
		// Start line: 6522
	/* end block 2 */
	// End Line: 6523

	return 0;
}


// autogenerated function stub: 
// unsigned long /*$ra*/ aadGetReverbSize()
unsigned long aadGetReverbSize()
{ // line 2842, offset 0x80054058
	/* begin block 1 */
		// Start line: 6565
	/* end block 1 */
	// End Line: 6566

	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ aadGetReverbDepth()
int aadGetReverbDepth()
{ // line 2847, offset 0x80054088
	/* begin block 1 */
		// Start line: 6575
	/* end block 1 */
	// End Line: 6576

	/* begin block 2 */
		// Start line: 6576
	/* end block 2 */
	// End Line: 6577

	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ aadGetNumDynamicSequences(int bank /*$a0*/)
int aadGetNumDynamicSequences(int bank)
{ // line 2860, offset 0x80054090
	/* begin block 1 */
		// Start line: 5720
	/* end block 1 */
	// End Line: 5721

	/* begin block 2 */
		// Start line: 6592
	/* end block 2 */
	// End Line: 6593

	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ aadAssignDynamicSequence(int bank /*$s1*/, int sequenceNumber /*$s3*/, int slotNumber /*$s2*/)
int aadAssignDynamicSequence(int bank, int sequenceNumber, int slotNumber)
{ // line 2877, offset 0x800540c0
	/* begin block 1 */
		// Start line: 2878
		// Start offset: 0x800540C0
		// Variables:
			//struct AadTempo tempo; // stack offset -32
			//struct _AadSequenceSlot *slot; // $s0
			//int i; // $v1
	/* end block 1 */
	// End offset: 0x80054180
	// End Line: 2924

	/* begin block 2 */
		// Start line: 6623
	/* end block 2 */
	// End Line: 6624

	return 0;
}


// autogenerated function stub: 
// struct AadTempo * /*$ra*/ aadGetTempoFromDynamicSequence(int bank /*$a0*/, int sequenceNumber /*$a1*/, struct AadTempo *tempo /*$a2*/)
struct AadTempo * aadGetTempoFromDynamicSequence(int bank, int sequenceNumber, struct AadTempo *tempo)
{ // line 2927, offset 0x8005419c
	/* begin block 1 */
		// Start line: 2929
		// Start offset: 0x8005419C
		// Variables:
			struct AadSequenceHdr *seqHdr; // $v1
	/* end block 1 */
	// End offset: 0x800541E4
	// End Line: 2942

	/* begin block 2 */
		// Start line: 6753
	/* end block 2 */
	// End Line: 6754

	/* begin block 3 */
		// Start line: 6754
	/* end block 3 */
	// End Line: 6755

	/* begin block 4 */
		// Start line: 6761
	/* end block 4 */
	// End Line: 6762

	return null;
}


// autogenerated function stub: 
// void /*$ra*/ aadSetSlotTempo(int slotNumber /*$a0*/, struct AadTempo *tempo /*$a1*/)
void aadSetSlotTempo(int slotNumber, struct AadTempo *tempo)
{ // line 3061, offset 0x800541ec
	/* begin block 1 */
		// Start line: 3063
		// Start offset: 0x800541EC
		// Variables:
			struct _AadSequenceSlot *slot; // $a0
			unsigned long tickTime; // $v1
			unsigned long tickTimeRemainder; // $a2
	/* end block 1 */
	// End offset: 0x800541EC
	// End Line: 3069

	/* begin block 2 */
		// Start line: 7021
	/* end block 2 */
	// End Line: 7022

	/* begin block 3 */
		// Start line: 7022
	/* end block 3 */
	// End Line: 7023

	/* begin block 4 */
		// Start line: 7028
	/* end block 4 */
	// End Line: 7029

}


// autogenerated function stub: 
// void /*$ra*/ aadStartSlot(int slotNumber /*$a0*/)
void aadStartSlot(int slotNumber)
{ // line 3082, offset 0x800542a0
	/* begin block 1 */
		// Start line: 3083
		// Start offset: 0x800542A0
		// Variables:
			struct _AadSequenceSlot *slot; // $s0
	/* end block 1 */
	// End offset: 0x8005430C
	// End Line: 3096

	/* begin block 2 */
		// Start line: 7068
	/* end block 2 */
	// End Line: 7069

	/* begin block 3 */
		// Start line: 7071
	/* end block 3 */
	// End Line: 7072

}

void aadStopSlot(int slotNumber)
{
	struct _AadSequenceSlot *slot;

	if (slotNumber < aadMem->numSlots)
	{
		slot = aadMem->sequenceSlots[slotNumber];

		if (slot->sequenceNumberAssigned != 255)
		{
			slot->status &= -2;
			aadInitSequenceSlot(slot);
			aadAllNotesOff(slotNumber);
		}
	}
}


// autogenerated function stub: 
// void /*$ra*/ aadStopAllSlots()
void aadStopAllSlots()
{ 
#ifdef PSX_VERSION
	struct _AadSequenceSlot* slot;
	int slotNumber;

	slotNumber = 0;
	
	if (aadMem->numSlots > 0)
	{
		do
		{
			slot = aadMem->sequenceSlots[slotNumber];

			if ((slot->status & 0x1))
			{
				aadStopSlot(slotNumber);
			}

			slot->sequenceNumberAssigned = 255;

		} while (++slotNumber < aadMem->numSlots);
	}
#else
	AadMemoryStruct* v0; // ecx
	int v1; // edx
	int numSlots; // eax
	int v3; // edi
	int v4; // esi
	AadMemoryStruct* v5; // ebp
	int v6; // ecx
	int v7; // edx
	int i; // edi
	char* v9; // eax
	int v10; // ebp
	int v11; // [esp+0h] [ebp-8h]
	int v12; // [esp+4h] [ebp-4h]

	v0 = aadMem;
	v1 = 0;
	v11 = 0;
	numSlots = aadMem->numSlots;
	if (numSlots > 0)
	{
		v3 = 52;
		v12 = 52;
		do
		{
			v4 = *(unsigned int*)((char*)&v0->updateCounter + v3);
			if ((*(BYTE*)(v4 + 1344) & 1) != 0 && v1 < numSlots && *(BYTE*)(v4 + 1342) != 0xFF)
			{
				*(WORD*)(v4 + 1344) &= ~1u;
				aadInitSequenceSlot(v4);
				v5 = aadMem;
				v6 = 0;
				v7 = *(unsigned int*)((char*)&aadMem->updateCounter + v3);
				for (i = 476; i < 1148; i += 28)
				{
					v9 = (char*)v5 + i;
					if ((*((BYTE*)&v5->updateMode + i) & 0xF0) == *(BYTE*)(v7 + 1361))
					{
						v10 = *(DWORD*)v9;
						v9[8] = -1;
						v6 |= v10;
						v9[18] |= 2u;
						v5 = aadMem;
					}
				}
				if (v6)
				{
					v5->voiceKeyOffRequest |= v6;
					aadMem->voiceKeyOnRequest &= ~v6;
				}
			}
			v1 = v11 + 1;
			*(BYTE*)(v4 + 1342) = -1;
			v0 = aadMem;
			v3 = v12 + 4;
			v11 = v1;
			numSlots = aadMem->numSlots;
			v12 += 4;
		} while (v1 < numSlots);
	}
#endif
}


// autogenerated function stub: 
// void /*$ra*/ aadDisableSlot(int slotNumber /*$a0*/)
void aadDisableSlot(int slotNumber)
{ // line 3135, offset 0x80054418
	int v1; // esi
	AadMemoryStruct* v2; // edi
	int v3; // ecx
	struct _AadSequenceSlot* v4; // ebp
	char* v5; // eax
	int v6; // ebx

	if (slotNumber < aadMem->numSlots)
	{
		v1 = 476;
		aadMem->sequenceSlots[slotNumber]->slotFlags |= 1u;
		v2 = aadMem;
		v3 = 0;
		v4 = aadMem->sequenceSlots[slotNumber];
		do
		{
			v5 = (char*)v2 + v1;
			if ((*((BYTE*)&v2->updateMode + v1) & 0xF0) == v4->slotID)
			{
				v6 = *(DWORD*)v5;
				v5[8] = -1;
				v3 |= v6;
				*((WORD*)v5 + 9) |= 2u;
				v2 = aadMem;
			}
			v1 += 28;
		} while (v1 < 1148);
		if (v3)
		{
			v2->voiceKeyOffRequest |= v3;
			aadMem->voiceKeyOnRequest &= ~v3;
		}
	}
}


// autogenerated function stub: 
// void /*$ra*/ aadEnableSlot(int slotNumber /*$a0*/)
void aadEnableSlot(int slotNumber)
{ // line 3146, offset 0x80054468
	if (slotNumber < aadMem->numSlots)
		aadMem->sequenceSlots[slotNumber]->slotFlags &= ~1u;
}


// autogenerated function stub: 
// void /*$ra*/ aadPauseSlot(int slotNumber /*$a0*/)
void aadPauseSlot(int slotNumber)
{ // line 3154, offset 0x800544a8
	int v1; // esi
	AadMemoryStruct* v2; // edi
	int v3; // ecx
	struct _AadSequenceSlot* v4; // ebp
	char* v5; // eax
	int v6; // ebx

	if (slotNumber < aadMem->numSlots)
	{
		v1 = 476;
		aadMem->sequenceSlots[slotNumber]->status &= ~1u;
		v2 = aadMem;
		v3 = 0;
		v4 = aadMem->sequenceSlots[slotNumber];
		do
		{
			v5 = (char*)v2 + v1;
			if ((*((BYTE*)&v2->updateMode + v1) & 0xF0) == v4->slotID)
			{
				v6 = *(DWORD*)v5;
				v5[8] = -1;
				v3 |= v6;
				*((WORD*)v5 + 9) |= 2u;
				v2 = aadMem;
			}
			v1 += 28;
		} while (v1 < 1148);
		if (v3)
		{
			v2->voiceKeyOffRequest |= v3;
			aadMem->voiceKeyOnRequest &= ~v3;
		}
	}
}


// autogenerated function stub: 
// void /*$ra*/ aadResumeSlot(int slotNumber /*$a0*/)
void aadResumeSlot(int slotNumber)
{ // line 3165, offset 0x800544f8
	/* begin block 1 */
		// Start line: 3167
		// Start offset: 0x800544F8
		// Variables:
	struct _AadSequenceSlot *slot; // $a1
	int track; // $a0

	unsigned __int8* trackFlags; // eax

	if (slotNumber < aadMem->numSlots)
	{
		slot = aadMem->sequenceSlots[slotNumber];
		if (slot->sequenceNumberAssigned != 0xFF)
		{
			trackFlags = slot->trackFlags;
			do
				*trackFlags++ |= 0x20u;
			while ((int)&trackFlags[-984 - (DWORD)slot] < 16);
			slot->status |= 1u;
		}
	}
}


// autogenerated function stub: 
// int /*$ra*/ aadGetSlotStatus(int slotNumber /*$a0*/)
int aadGetSlotStatus(int slotNumber)
{ // line 3184, offset 0x80054568
	return aadMem->sequenceSlots[slotNumber]->status;
}

void aadAllNotesOff(int slotNumber)
{ 
#ifdef PSX_VERSION
	struct AadSynthVoice* voice;
	unsigned long vmask;
	int i;
	struct _AadSequenceSlot* slot;

	vmask = 0;
	slot = aadMem->sequenceSlots[slotNumber];

	for (i = 0; i < 24; i++)
	{
		voice = &aadMem->synthVoice[i];

		if ((voice->voiceID & 0xF0) == slot->slotID)
		{
			voice->voiceID = 255;
			vmask |= voice->voiceMask;
			voice->flags |= 0x2;
		}
	}

	if (vmask != 0)
	{
		aadMem->voiceKeyOffRequest |= vmask;
		aadMem->voiceKeyOnRequest &= ~vmask;
	}
#else
	AadMemoryStruct* v1; // edi
	int v2; // ecx
	int v3; // esi
	struct _AadSequenceSlot* v4; // ebp
	char* v5; // eax
	int v6; // ebx

	v1 = aadMem;
	v2 = 0;
	v3 = 476;
	v4 = aadMem->sequenceSlots[slotNumber];
	do
	{
		v5 = (char*)v1 + v3;
		if ((*((BYTE*)&v1->updateMode + v3) & 0xF0) == v4->slotID)
		{
			v6 = *(DWORD*)v5;
			v5[8] = -1;
			v2 |= v6;
			*((WORD*)v5 + 9) |= 2u;
			v1 = aadMem;
		}
		v3 += 28;
	} while (v3 < 1148);
	if (v2)
	{
		v1->voiceKeyOffRequest |= v2;
		aadMem->voiceKeyOnRequest &= ~v2;
	}
#endif
}


// autogenerated function stub: 
// void /*$ra*/ aadMuteChannels(struct _AadSequenceSlot *slot /*$a0*/, unsigned long channelList /*$a1*/)
void aadMuteChannels(struct _AadSequenceSlot *slot, unsigned long channelList)
{ 
#if defined(PC_VERSION)
	// line 3252, offset 0x80054628
	/* begin block 1 */
		// Start line: 3254
		// Start offset: 0x80054628
		// Variables:
			struct AadSynthVoice *voice; // $a2
			unsigned long vmask; // $t2
			unsigned long delayedMute; // $a2
			int channel; // $t1
			//int i; // $t0
	unsigned int v2; // edx
	unsigned int v3; // eax
	AadMemoryStruct* v4; // esi
	int v5; // edi
	int i; // ebp
	int j; // eax
	BYTE* v8; // edx
	int v9; // ecx

	v2 = channelList;
	v3 = channelList & slot->delayedMuteMode;
	if (((unsigned __int16)channelList & slot->delayedMuteMode) != 0)
	{
		slot->delayedMuteCmds |= v3;
		v2 = ~v3 & channelList;
		channelList = v2;
	}
	slot->channelMute |= v2;
	v4 = aadMem;
	v5 = 0;
	for (i = 0; i < 16; ++i)
	{
		if (((1 << i) & v2) != 0)
		{
			for (j = 476; j < 1148; j += 28)
			{
				v8 = (char*)&v4->updateMode + j;
				if ((unsigned __int8)*v8 == (slot->slotID | i))
				{
					v9 = *(unsigned int*)((char*)&v4->updateCounter + j);
					*v8 = -1;
					v4 = aadMem;
					v5 |= v9;
				}
			}
			v2 = channelList;
		}
	}
	if (v5)
	{
		v4->voiceKeyOffRequest |= v5;
		aadMem->voiceKeyOnRequest &= ~v5;
	}
#endif
}


// autogenerated function stub: 
// void /*$ra*/ aadUnMuteChannels(struct _AadSequenceSlot *slot /*$a0*/, unsigned long channelList /*$a1*/)
void aadUnMuteChannels(struct _AadSequenceSlot *slot, unsigned long channelList)
{
	__int16 v2; // dx
	__int16 v3; // ax

	v2 = channelList;
	v3 = channelList & slot->delayedMuteMode;
	if (v3)
	{
		slot->delayedUnMuteCmds |= v3;
		v2 = ~v3 & channelList;
	}
	slot->channelMute &= ~v2;
}


// autogenerated function stub: 
// TDRFuncPtr_aadInstallEndSequenceCallback /*$ra*/ aadInstallEndSequenceCallback(TDRFuncPtr_aadInstallEndSequenceCallback0callbackProc callbackProc /*$a0*/, long data /*$a1*/)
TDRFuncPtr_aadInstallEndSequenceCallback aadInstallEndSequenceCallback(TDRFuncPtr_aadInstallEndSequenceCallback0callbackProc callbackProc, long data)
{ // line 3405, offset 0x8005473c
	TDRFuncPtr_aadInstallEndSequenceCallback result; // eax

	result = (TDRFuncPtr_aadInstallEndSequenceCallback)aadMem[3].loadRequestQueue[13].type;
	aadMem[3].loadRequestQueue[13].type = (int)callbackProc;
	aadMem[3].loadRequestQueue[13].directoryID = data;
	return result;
}


// autogenerated function stub: 
// void /*$ra*/ aadSetUserVariable(int variableNumber /*$a0*/, int value /*$a1*/)
void aadSetUserVariable(int variableNumber, int value)
{ // line 3416, offset 0x80054754
	*((BYTE*)&aadMem[3].loadRequestQueue[13].flags + variableNumber) = value;
}


void aadSetNoUpdateMode(int noUpdate)
{ 
#ifdef PSX_VERSION
	if (noUpdate != 0)
	{
		aadMem->flags |= 2;
	}
	else
	{
		aadMem->flags &= -3;
	}
#else
	int flags; // ecx

	flags = aadMem->flags;
	if (noUpdate)
		aadMem->flags = flags | 2;
	else
		aadMem->flags = flags & ~2u;
#endif
}


// autogenerated function stub: 
// void /*$ra*/ aadPauseSound()
void aadPauseSound()
{ // line 3467, offset 0x800547a8
	int flags; // eax
	int v1; // esi
	int v2; // ebx
	int i; // edi

	flags = aadMem->flags;
	if ((flags & 8) == 0)
	{
		v1 = 0;
		aadMem->flags |= 0xC;
		v2 = 0;
		for (i = 1172; i < 1220; i += 2)
		{
			aadMem->synthVoice[v2].flags &= ~2u;
			SpuGetVoicePitch(v1, (unsigned __int16*)((char*)aadMem + i));
			SpuSetVoicePitch(v1++, 0);
			++v2;
		}
	}
}


// autogenerated function stub: 
// void /*$ra*/ aadCancelPauseSound()
void aadCancelPauseSound()
{ // line 3486, offset 0x80054840
	aadMem->flags &= ~0xCu;
}


// autogenerated function stub: 
// void /*$ra*/ aadResumeSound()
void aadResumeSound()
{ // line 3493, offset 0x8005485c
	int flags; // eax
	AadMemoryStruct* v1; // eax
	int v2; // edi
	int v3; // ebp
	int i; // esi

	flags = aadMem->flags;
	if ((flags & 8) != 0)
	{
		aadMem->flags &= ~0xC;
		v1 = aadMem;
		v2 = 0;
		v3 = 0;
		for (i = 1172; i < 1220; i += 2)
		{
			if ((v1->synthVoice[v3].flags & 2) == 0)
			{
				SpuSetVoicePitch(v2, *(WORD*)((char*)&v1->updateCounter + i));
				v1 = aadMem;
			}
			++v2;
			++v3;
		}
	}
}




