#include "CORE.H"
#include "AADLIB.H"
#include "SOUND.H"
#include "LOAD3D.H"
#include "AADSEQEV.H"
#include "AADSFX.H"

unsigned short aadHblanksPerUpdate[4] = { 0x0106, 0x0083, 0x0138, 0x009C };
struct AadMemoryStruct* aadMem; // offset 0x800CECD8
unsigned long aadGp;
int gDefragRequest;
unsigned char* smfDataPtr;
unsigned long smfBytesLeft;
struct AadDynamicSfxLoadInfo* smfInfo;
unsigned long __hblankEvent;

#include <stddef.h>

unsigned long aadGetMemorySize(struct AadInitAttr *attributes)
{
#if defined(PC_VERSION)
	return 1488 * attributes->numSlots + 23720;
#elif defined(PSX_VERSION)
	return 1488 * attributes->numSlots + 7304;
#endif
}


// autogenerated function stub: 
// int /*$ra*/ aadInit(struct AadInitAttr *attributes /*$s1*/, unsigned char *memoryPtr /*$s0*/)
int aadInit(struct AadInitAttr *attributes, unsigned char *memoryPtr)
{
	struct _AadSequenceSlot* slot;
	unsigned long size;
	int slotNumber;
	int i;

#ifndef PC_VERSION
	aadGp = GetGp();
#endif
	
	PSX_EnterCriticalSection();
	size = aadGetMemorySize(attributes);
	aadMem = (AadMemoryStruct*)memoryPtr;

	if (aadMem == NULL)
	{
		return 0x1009;
	}
	else
	{
		memset(memoryPtr, 0, size);

		if (attributes->nonBlockLoadProc == NULL ||
			attributes->nonBlockBufferedLoadProc == NULL ||
			attributes->memoryMallocProc == NULL)
		{
			return 0x1008;
		}

		aadMem->nonBlockLoadProc = attributes->nonBlockLoadProc;
		aadMem->nonBlockBufferedLoadProc = attributes->nonBlockBufferedLoadProc;
		aadMem->memoryMallocProc = attributes->memoryMallocProc;
		aadMem->memoryFreeProc = attributes->memoryFreeProc;
		
		memset(aadMem->sfxToneMasterList, 255, sizeof(aadMem->sfxToneMasterList));
		memset(aadMem->sfxWaveMasterList, 255, sizeof(aadMem->sfxWaveMasterList));
		
		aadMem->sramDescriptorTbl[0].prevIndex = 255;
		aadMem->nextSramDescIndex = 1;
		aadMem->sramDescriptorTbl[0].waveID = 32768;
		aadMem->sramDescriptorTbl[0].address = 514;
		aadMem->firstSramBlockDescIndex = 0;
		aadMem->sramDescriptorTbl[0].size = 37336;
		aadMem->sramDescriptorTbl[0].nextIndex = 255;

		aadPurgeLoadQueue();

		SpuInit();
		SpuSetCommonMasterVolume(0, 0);

		if (attributes->numSlots > 0)
		{
			for (slotNumber = 0; slotNumber < attributes->numSlots; slotNumber++)
			{
				slot = (struct _AadSequenceSlot*)(aadMem + 1) + slotNumber;

				aadMem->sequenceSlots[slotNumber] = slot;
				aadMem->sequenceSlots[slotNumber]->thisSlotNumber = slotNumber;
				aadMem->sequenceSlots[slotNumber]->sequenceNumberAssigned = 255;
				aadMem->sequenceSlots[slotNumber]->slotID = slotNumber << 4;
				aadMem->sequenceSlots[slotNumber]->slotVolume = 127;
				aadMem->sequenceSlots[slotNumber]->slotPan = 63;
				aadMem->sequenceSlots[slotNumber]->masterVolPtr = &aadMem->musicMasterVol;
				
				for (i = 0; i < 16; i++)
				{
					slot->currentProgram[i] = 255;
					slot->volume[i] = 127;
					slot->panPosition[i] = 63;
					aadMem->sequenceSlots[slotNumber]->pitchWheel[i] = 8192;
				}
				
				slot->selectedSlotPtr = slot;
				slot->selectedSlotNum = slotNumber;
			}
		}

		aadMem->sfxSlot.handleCounter = 12345;
		aadMem->sfxSlot.sfxVolume = 127;
		aadMem->numSlots = attributes->numSlots & 0xFF;//maybe union used.
		aadMem->sfxMasterVol = 127;
		aadMem->musicMasterVol = 127;
		aadMem->endSequenceCallback = NULL;
		aadMem->controller11Callback = NULL;
		aadMem->updateMode = attributes->updateMode & 0xFF;//maybe union used.

		for (slotNumber = 0; slotNumber < 24; slotNumber++)
		{
			aadMem->synthVoice[slotNumber].voiceID = 255;
			aadMem->synthVoice[slotNumber].voiceMask = 1 << slotNumber;
			aadMem->synthVoice[slotNumber].voiceNum = slotNumber;
		}

		//v0 = aadMem
		//v1 = aadMem->updateMode
		aadMem->voiceKeyOffRequest = 0;
		aadMem->voiceKeyOnRequest = 0;
		aadMem->voiceReverbRequest = 0;

		if (aadMem->updateMode < 4)
		{
			//v0 = aadMem->updateMode << 1
			//a1 = aadHblanksPerUpdate[aadMem->updateMode]
			aadInstallUpdateFunc(aadSlotUpdateWrapper, aadHblanksPerUpdate[aadMem->updateMode]);
		}
		//loc_80051D38
		aadMem->flags = 0;
		PSX_ExitCriticalSection();
	}

	return 0;
}

void aadInstallUpdateFunc(TDRFuncPtr_aadInstallUpdateFunc0updateFuncPtr updateFuncPtr, int hblanksPerUpdate)
{ 
	EnterCriticalSection();
	
	__hblankEvent = OpenEvent(0xF2000001, 2, 0x1000, updateFuncPtr);
	
	EnableEvent(__hblankEvent);
	
	SetRCnt(0xF2000001, hblanksPerUpdate, 0x1000);
	
	StartRCnt(0xF2000001);
	
	ExitCriticalSection();
}

void aadInitVolume()
{ 
	aadMem->masterVolume = 0;
	SpuSetCommonCDMix(0);
	SpuSetCommonMasterVolume(0, 0);
}


// autogenerated function stub: 
// void /*$ra*/ aadSetMasterVolume(int voll /*$a0*/)
void aadSetMasterVolume(int volume)
{ // line 210, offset 0x80051850
	/* begin block 1 */
		// Start line: 547
	/* end block 1 */
	// End Line: 548

}


// autogenerated function stub: 
// void /*$ra*/ aadStartMasterVolumeFade(int targetVolume /*$a0*/, int volumeStep /*$a1*/, TDRFuncPtr_aadStartMasterVolumeFade2fadeCompleteCallback fadeCompleteCallback /*$a2*/)
void aadStartMasterVolumeFade(int targetVolume, int volumeStep, TDRFuncPtr_aadStartMasterVolumeFade2fadeCompleteCallback fadeCompleteCallback)
{ // line 219, offset 0x80051880
	aadMem->masterVolFader.volumeStep = volumeStep;
	aadMem->masterVolFader.targetVolume = targetVolume;
	aadMem->masterVolFader.fadeCompleteCallback = fadeCompleteCallback;
}

void aadSetSfxMasterVolume(int volume)
{
	aadMem->sfxMasterVol = volume;
}

void aadSetMusicMasterVolume(int volume)
{
	int slotNumber;
	
	aadMem->musicMasterVol = volume;

	if (aadMem->numSlots > 0)
	{
		for (slotNumber = 0; slotNumber < aadMem->numSlots; slotNumber++)
		{
			aadUpdateSlotVolPan(aadMem->sequenceSlots[slotNumber]);
		}
	}
}

void aadStartMusicMasterVolFade(int targetVolume, int volumeStep, TDRFuncPtr_aadStartMusicMasterVolFade2fadeCompleteCallback fadeCompleteCallback)
{
	aadMem->musicMasterVolFader.volumeStep = volumeStep;
	aadMem->musicMasterVolFader.targetVolume = targetVolume;
	aadMem->musicMasterVolFader.fadeCompleteCallback = fadeCompleteCallback;
}

// autogenerated function stub: 
// void /*$ra*/ aadShutdown()
void aadShutdown()
{ // line 285, offset 0x80051924
	/* begin block 1 */
		// Start line: 570
	/* end block 1 */
	// End Line: 571

}

long aadSlotUpdateWrapper()
{ 
	unsigned long curGp; // $s0

	curGp = GetGp();
	
#if !defined(PSXPC_VERSION) && defined(PSX_VERSION)
	int forceCompilerErrorUntilThisIsUncommented.
#endif
	//SetGp(aadGp);

	aadSlotUpdate();

	//SetGp(curGp);

	return 0;
}

void aadSlotUpdate()
{
	struct _AadSequenceSlot* slot;
	struct AadSeqEvent* seqEventPtr;
	int slotNumber;
	int i;
	int fadeComplete;
	int track;
	int newVol;
	int slotDone;
	unsigned long vmask;

	if (aadMem != NULL)
	{
		if (!(aadMem->flags & 0x2))
		{
			SpuGetAllKeysStatus(aadMem->voiceStatus);

			vmask = 1;

			for (i = 0; i < 24; i++, vmask <<= 1)
			{
				if (aadMem->voiceStatus[i] == 3)
				{
					aadMem->voiceKeyOffRequest |= vmask;
				}
				else if ((aadMem->voiceKeyOffRequest & vmask))
				{
					if (aadMem->voiceStatus[i] == 0 || aadMem->voiceStatus[i] == 2)
					{
						aadMem->voiceKeyOffRequest = aadMem->voiceKeyOffRequest & ~vmask;
					}
				}
			}

			if (!(aadMem->flags & 0x4) && aadMem->numSlots > 0)
			{
				slotNumber = 0;

				do
				{
					slot = aadMem->sequenceSlots[slotNumber];

					if ((slot->status & 0x1) && (slot->slotFlags & 0x1))
					{
						slot->tempo.currentTick += slot->tempo.ticksPerUpdate;
						slot->tempo.currentError += slot->tempo.errorPerUpdate;

						if (slot->tempo.currentError >= slot->tempo.tickTimeFixed)
						{
							slot->tempo.currentError -= slot->tempo.tickTimeFixed;
							slot->tempo.currentTick += 1;
						}

						do
						{

							for (track = 0; track < 16; track++)
							{
								if (slot->sequencePosition[track] != NULL)
								{
									while (slot->eventsInQueue[track] < 3)
									{
										if (aadQueueNextEvent(slot, track) == 1)
										{
											break;
										}
									}
								}
							}

							slotDone = 1;

							for (track = 0; track < 16; track++)
							{
								if (slot->sequencePosition[track] != 0)
								{
									if (slot->eventsInQueue[track] != 0)
									{
										do
										{
											if (slot->tempo.currentTick >= slot->eventQueue[slot->eventOut[track]][track].deltaTime + slot->lastEventExecutedTime[track])
											{
												slot->lastEventExecutedTime[track] = slot->eventQueue[slot->eventOut[track]][track].deltaTime + slot->lastEventExecutedTime[track];
												slot->eventOut[track]++;
												slot->eventsInQueue[track]--;

												if (slot->eventOut[track] == 4)
												{
													slot->eventOut[track] = 0;
												}

												seqEventPtr = &slot->eventQueue[slot->eventOut[track]][track];
												aadExecuteEvent(seqEventPtr, slot);
											}

											slotDone = 0;
										} while (slot->eventsInQueue[track] != 0);
									}
								}
							}
						} while (slotDone == 0);
					}
			
				} while (++slotNumber < aadMem->numSlots);
			}
			
			while (aadMem->sfxSlot.commandsInQueue != 0)
			{
				aadExecuteSfxCommand(&aadMem->sfxSlot.commandQueue[aadMem->sfxSlot.commandOut]);

				aadMem->sfxSlot.commandOut++;
				aadMem->sfxSlot.commandsInQueue--;

				if (aadMem->sfxSlot.commandOut == 32)
				{
					aadMem->sfxSlot.commandOut = 0;
				}
			}
			
			aadMem->voiceKeyOffRequest = aadMem->voiceKeyOffRequest & ~aadMem->voiceKeyOnRequest;

			if (aadMem->voiceKeyOffRequest != 0)
			{
				SpuSetKey(0, aadMem->voiceKeyOffRequest);
			}

			SpuSetReverbVoice(1, aadMem->voiceReverbRequest);

			SpuSetReverbVoice(0, ~aadMem->voiceReverbRequest);

			if (aadMem->voiceKeyOnRequest != 0)
			{
				SpuSetKey(1, aadMem->voiceKeyOnRequest);

				aadMem->voiceKeyOnRequest = 0;
			}
		}

		fadeComplete = 0;
		
		if (aadMem->masterVolFader.volumeStep != 0)
		{
			newVol = aadMem->masterVolume + aadMem->masterVolFader.volumeStep;

			if (aadMem->masterVolFader.volumeStep < 0)
			{
				fadeComplete = newVol < aadMem->masterVolFader.targetVolume;
			}
			else
			{
				if (aadMem->masterVolFader.targetVolume < newVol)
				{
					fadeComplete = 1;
				}
			}
			
			if (fadeComplete != 0)
			{
				newVol = aadMem->masterVolFader.targetVolume;
				aadMem->masterVolFader.volumeStep = 0;
				if (aadMem->masterVolFader.fadeCompleteCallback != NULL)
				{
					aadMem->masterVolFader.fadeCompleteCallback();
				}

				aadSetMasterVolume(newVol);
			}
		}

		if (aadMem->musicMasterVolFader.volumeStep != 0)
		{
			fadeComplete = 0;

			if (!(aadMem->updateCounter & 0x1))
			{
				newVol = aadMem->musicMasterVol;
				newVol += aadMem->musicMasterVolFader.volumeStep;

				if (aadMem->musicMasterVolFader.volumeStep < 0)
				{
					fadeComplete = (aadMem->musicMasterVolFader.targetVolume < newVol) ^ 1;
				}
				else
				{
					if (newVol >= aadMem->musicMasterVolFader.targetVolume)
					{
						fadeComplete = 1;
					}
				}

				if (fadeComplete != 0)
				{
					newVol = aadMem->musicMasterVolFader.targetVolume;
					aadMem->musicMasterVolFader.volumeStep = 0;

					if (aadMem->musicMasterVolFader.fadeCompleteCallback != NULL)
					{
						aadMem->musicMasterVolFader.fadeCompleteCallback();
					}
				}

				aadSetMusicMasterVolume(newVol);
			}
		}
		aadMem->updateCounter++;
	}
}

unsigned long aadCreateFourCharID(char a, char b, char c, char d)
{ 
	return  d | (c << 8) | (b << 16) | (a << 24);
}


// autogenerated function stub: 
// int /*$ra*/ aadLoadDynamicSoundBank(char *sndFileName /*$s3*/, char *smpFileName /*$s4*/, int dynamicBankIndex /*$s2*/, int loadOption /*$s5*/, TDRFuncPtr_aadLoadDynamicSoundBank4retProc retProc /*stack 16*/)
int aadLoadDynamicSoundBank(char *sndFileName, char *smpFileName, int dynamicBankIndex, int loadOption, TDRFuncPtr_aadLoadDynamicSoundBank4retProc retProc)
{ // line 644, offset 0x80051f60
	/* begin block 1 */
		// Start line: 645
		// Start offset: 0x80051F60
		// Variables:
			int i; // $a0
			struct AadDynamicBankLoadInfo *info; // $s1
	/* end block 1 */
	// End offset: 0x80052094
	// End Line: 699

	/* begin block 2 */
		// Start line: 1528
	/* end block 2 */
	// End Line: 1529

	return 0;
}


// autogenerated function stub: 
// void /*$ra*/ aadLoadDynamicSoundBankReturn(void *loadedDataPtr /*$a0*/, void *data /*$s3*/, void *data2 /*$a2*/)
void aadLoadDynamicSoundBankReturn(void *loadedDataPtr, void *data, void *data2)
{ // line 704, offset 0x800520b8
	/* begin block 1 */
		// Start line: 705
		// Start offset: 0x800520B8
		// Variables:
			int dynamicBankIndex; // $s1
			int error; // $s0
	/* end block 1 */
	// End offset: 0x8005216C
	// End Line: 772

	/* begin block 2 */
		// Start line: 1693
	/* end block 2 */
	// End Line: 1694

}


// autogenerated function stub: 
// void /*$ra*/ aadLoadDynamicSoundBankReturn2(void *loadedDataPtr /*$a0*/, long loadedDataSize /*$s2*/, short status /*$s5*/, void *data1 /*$a3*/, void *data2 /*stack 16*/)
void aadLoadDynamicSoundBankReturn2(void *loadedDataPtr, long loadedDataSize, short status, void *data1, void *data2)
{ // line 782, offset 0x80052188
	/* begin block 1 */
		// Start line: 783
		// Start offset: 0x80052188
		// Variables:
			unsigned char *dataPtr; // $s1
			struct AadDynamicBankLoadInfo *info; // $s0
			int dynamicBankIndex; // $s3
			int error; // $v0

		/* begin block 1.1 */
			// Start line: 866
			// Start offset: 0x800522FC
			// Variables:
				int i; // $a2
		/* end block 1.1 */
		// End offset: 0x80052390
		// End Line: 880
	/* end block 1 */
	// End offset: 0x80052390
	// End Line: 882

	/* begin block 2 */
		// Start line: 1851
	/* end block 2 */
	// End Line: 1852

}

int aadFreeDynamicSoundBank(int dynamicBankIndex)
{ 
	if (dynamicBankIndex < 2)
	{
		return 0x1005;
	}
	
	if (aadMem->dynamicBankStatus[dynamicBankIndex] != 2)
	{
		return 0x1007;
	}

	if (aadMem->dynamicSoundBankData[dynamicBankIndex] == NULL)
	{
		return 0x1007;
	}

	aadMem->dynamicBankStatus[dynamicBankIndex] = 0;
	aadMem->memoryFreeProc((char*)aadMem->dynamicSoundBankData[dynamicBankIndex]);
	aadMem->dynamicSoundBankData[dynamicBankIndex] = NULL;

	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ aadOpenDynamicSoundBank(unsigned char *soundBank /*$a0*/, int dynamicBankIndex /*$s1*/)
int aadOpenDynamicSoundBank(unsigned char *soundBank, int dynamicBankIndex)
{ // line 930, offset 0x80052430
	/* begin block 1 */
		// Start line: 931
		// Start offset: 0x80052430
		// Variables:
			struct AadSoundBankHdr *soundBankHdr; // $s0
			struct AadProgramAtr *programAtr; // $v0
			struct AadToneAtr *toneAtr; // $v0
			unsigned long *waveAddr; // $v0
			unsigned long *sequenceOffsetTbl; // $a0
			unsigned long *sequenceLabelOffsetTbl; // $a1
			unsigned char *sequenceBase; // $a3
			int i; // $t2
	/* end block 1 */
	// End offset: 0x8005253C
	// End Line: 979

	/* begin block 2 */
		// Start line: 2186
	/* end block 2 */
	// End Line: 2187

	return 0;
}

int aadLoadDynamicSfx(char *fileName, long directoryID, long flags)
{ 
	struct AadDynamicLoadRequest *loadReq;

	if (aadMem->numLoadReqsQueued < 16)
	{
		loadReq = &aadMem->loadRequestQueue[aadMem->nextLoadReqIn];
		loadReq->type = 0;
		loadReq->handle = (aadMem->nextFileHandle++ & 0x3FFF) | 0x4000;
		loadReq->directoryID = directoryID;
		loadReq->flags = flags;

		strncpy(loadReq->fileName, fileName, sizeof(loadReq->fileName) - 1);

		aadMem->nextLoadReqIn = (aadMem->nextLoadReqIn++) & 0xF;
		aadMem->numLoadReqsQueued++;

		return loadReq->handle;
	}

	return 0;
}

int aadFreeDynamicSfx(int handle)
{
	struct AadDynamicLoadRequest* loadReq;
	int i;

	i = aadMem->nextLoadReqOut;

	if (i != aadMem->nextLoadReqIn)
	{
		do
		{
			loadReq = &aadMem->loadRequestQueue[i];
			
			if (loadReq->type == 0 && loadReq->handle == handle)
			{
				loadReq->type = 2;
				return 0;
			}

		} while ((++i & 0xF) != aadMem->nextLoadReqIn);
	}

	if (aadMem->numLoadReqsQueued < 16)
	{
		loadReq = &aadMem->loadRequestQueue[(aadMem->nextLoadReqOut - 1) & 0xF];
		
		aadMem->nextLoadReqOut = (aadMem->nextLoadReqOut - 1) & 0xF;
		
		loadReq->type = 1;
		loadReq->handle = handle;
		
		aadMem->numLoadReqsQueued++;
		
		return 0;
	}
	
	return 0x100F;
}

void aadRelocateMusicMemoryBegin()
{ 
	aadMem->flags |= 0x2;
}


// autogenerated function stub: 
// void /*$ra*/ aadRelocateMusicMemoryEnd(struct MemHeader *newAddress /*$t9*/, long offset /*$a1*/, void *oldAddress /*$a2*/)
void aadRelocateMusicMemoryEnd(struct MemHeader *newAddress, long offset, void *oldAddress)
{ // line 1132, offset 0x800526fc
	/* begin block 1 */
		// Start line: 1133
		// Start offset: 0x800526FC
		// Variables:
			int bank; // $t7

		/* begin block 1.1 */
			// Start line: 1141
			// Start offset: 0x8005271C
			// Variables:
				int slotNumber; // $t5
				int i; // $a3
				struct AadSoundBankHdr *bankHdr; // $a0

			/* begin block 1.1.1 */
				// Start line: 1160
				// Start offset: 0x800527C4
				// Variables:
					struct _AadSequenceSlot *slot; // $t3

				/* begin block 1.1.1.1 */
					// Start line: 1163
					// Start offset: 0x800527EC
					// Variables:
						int track; // $t1
				/* end block 1.1.1.1 */
				// End offset: 0x80052860
				// End Line: 1179
			/* end block 1.1.1 */
			// End offset: 0x80052860
			// End Line: 1180
		/* end block 1.1 */
		// End offset: 0x8005287C
		// End Line: 1183

		/* begin block 1.2 */
			// Start line: 1186
			// Start offset: 0x8005288C
			// Variables:
				struct AadSynthVoice *voice; // $a0
				//int i; // $t0
				long dataSize; // $v0
		/* end block 1.2 */
		// End offset: 0x80052908
		// End Line: 1205
	/* end block 1 */
	// End offset: 0x80052908
	// End Line: 1207

	/* begin block 2 */
		// Start line: 2710
	/* end block 2 */
	// End Line: 2711

}

void aadRelocateSfxMemory(void *oldAddress, int offset)
{
	struct _AadDynSfxFileHdr *snfFile;
	
	snfFile = aadMem->firstDynSfxFile;

	if (oldAddress == snfFile)
	{
		snfFile = (struct _AadDynSfxFileHdr*)snfFile + offset;
		aadMem->firstDynSfxFile = snfFile;
	}

	if (snfFile != NULL)
	{
		do
		{
			if (oldAddress == snfFile->prevDynSfxFile)
			{
				snfFile->prevDynSfxFile = (struct _AadDynSfxFileHdr*)((char*)oldAddress + offset);
			}
			if (oldAddress == snfFile->nextDynSfxFile)
			{
				snfFile->nextDynSfxFile = (struct _AadDynSfxFileHdr*)((char*)oldAddress + offset);
			}

			snfFile = snfFile->nextDynSfxFile;

		} while (snfFile != NULL);
	}
}

int aadGetNumLoadsQueued()
{
	return aadMem->numLoadReqsQueued;
}


// autogenerated function stub: 
// void /*$ra*/ aadPurgeLoadQueue()
void aadPurgeLoadQueue()
{ // line 1265, offset 0x800529a0
	/* begin block 1 */
		// Start line: 3078
	/* end block 1 */
	// End Line: 3079

	/* begin block 2 */
		// Start line: 3080
	/* end block 2 */
	// End Line: 3081

}

void aadProcessLoadQueue()
{
	struct AadDynamicSfxLoadInfo* info;
	int i;
	char* p;
	struct AadDynamicLoadRequest* loadReq;
	char areaName[12];
	struct _AadDynSfxFileHdr* snfFile;
	unsigned short* sfxIDListPtr;

	info = &aadMem->dynamicSfxLoadInfo;

	if (!(info->flags & 0x1))
	{
		for(i = 0; i < 2; i++)
		{
			if (aadMem->dynamicBankStatus[i] == 1)
			{
				return;
			}
		}

		if (aadMem->numLoadReqsQueued != 0 && aadMem->sramDefragInfo.status == 0 && gDefragRequest == 0)
		{
			loadReq = &aadMem->loadRequestQueue[aadMem->nextLoadReqOut];

			aadMem->nextLoadReqOut = (aadMem->nextLoadReqOut + 1) & 0xF;

			aadMem->numLoadReqsQueued--;

			if (loadReq->type == 1)
			{
				snfFile = aadMem->firstDynSfxFile;

				while (snfFile != NULL)
				{
					if (snfFile->handle == loadReq->handle)
					{
						sfxIDListPtr = (unsigned short*)(snfFile + 1);

						for (i = 0; i < snfFile->numSfxInFile; i++)
						{
							aadFreeSingleDynSfx(*sfxIDListPtr++);
						}

						if (snfFile->prevDynSfxFile != NULL)
						{
							snfFile->prevDynSfxFile->nextDynSfxFile = snfFile->nextDynSfxFile;
						}
						else
						{
							aadMem->firstDynSfxFile = snfFile->nextDynSfxFile;
						}

						if (snfFile->nextDynSfxFile != NULL)
						{
							snfFile->nextDynSfxFile->prevDynSfxFile = snfFile->prevDynSfxFile;
						}

						aadMem->memoryFreeProc((char*)snfFile);

						gSramFullAlarm = 0;

						break;
					}

					snfFile = snfFile->nextDynSfxFile;
				}
				
				if (aadCheckSramFragmented() != 0)
				{
					gDefragRequest = 1;
				}
			}
			else if (loadReq->type == 0)
			{
				strcpy(areaName, loadReq->fileName);
				
				p = strpbrk(areaName, "0123456789");
				
				if (p != NULL)
				{
					p[0] = 0;
				}

				if ((loadReq->flags & 0x1))
				{
					sprintf(info->snfFileName, "\\kain2\\area\\%s\\bin\\%s.snf", areaName, loadReq->fileName);
					sprintf(info->smfFileName, "\\kain2\\area\\%s\\bin\\%s.smf", areaName, loadReq->fileName);
				}
				else
				{
					sprintf(info->snfFileName, "\\kain2\\sfx\\object\\%s\\%s.snf", loadReq->fileName, loadReq->fileName);
					sprintf(info->smfFileName, "\\kain2\\sfx\\object\\%s\\%s.smf", loadReq->fileName, loadReq->fileName);
				}
				
				info->fileHandle = loadReq->handle;
				
				gSramFullAlarm = 0;
				
				info->directoryID = loadReq->directoryID;
				info->flags = 1;
				info->snfFile = NULL;
				info->error = 0;
				info->totalSramUsed = 0;
				info->loadFlags = loadReq->flags;

				if (loadReq->directoryID != 0)
				{
					LOAD_SetSearchDirectory(loadReq->directoryID);
				}

				aadMem->nonBlockLoadProc(info->snfFileName, (void*)aadLoadDynamicSfxReturn, info, NULL, (void**)&info->snfFile, 0x2F);

				if (info->directoryID != 0)
				{
					LOAD_SetSearchDirectory(0);
				}
			}
		}
		
		if (gDefragRequest != 0 && SOUND_IsMusicLoading() == 0)
		{
			aadMem->numSlots = 0;
			aadMem->sramDefragInfo.status = 1;
		}
	}

	aadProcessSramDefrag();
}

void aadLoadDynamicSfxAbort(struct AadDynamicSfxLoadInfo *info, int error)
{ 
	info->flags = 0;
}

void aadLoadDynamicSfxDone(struct AadDynamicSfxLoadInfo *info)
{ 
	info->flags = 0;
}

void aadLoadDynamicSfxReturn(void* loadedDataPtr, void* data, void* data2)
{
	struct _AadDynSfxFileHdr* p;
	struct AadDynamicSfxLoadInfo* info;

	info = (struct AadDynamicSfxLoadInfo*)data;

	if (info->snfFile == NULL || info->snfFile != loadedDataPtr)
	{
		aadLoadDynamicSfxAbort(info, 0x100E);
	}
	else
	{
		if (info->snfFile->snfID == aadCreateFourCharID('a', 'S', 'N', 'F'))
		{
			if (info->snfFile->snfVersion != 256)
			{
				aadLoadDynamicSfxAbort(info, 0x100B);
			}
			else
			{
				info->snfFile->handle = info->fileHandle;
				
				p = aadMem->firstDynSfxFile;
				
				if (p != NULL)
				{
					if (aadMem->firstDynSfxFile->nextDynSfxFile != NULL)
					{
						do
						{
							p = p->nextDynSfxFile;

						} while (p != NULL);
					}

					p->nextDynSfxFile = info->snfFile;
					info->snfFile->prevDynSfxFile = p;
				}
				else
				{
					aadMem->firstDynSfxFile = info->snfFile;
					info->snfFile->prevDynSfxFile = NULL;
				}

				info->snfFile->nextDynSfxFile = NULL;
				info->smfLoadingState = 0;
				info->flags |= 0x2;

				if (info->directoryID != 0)
				{
					LOAD_SetSearchDirectory(info->directoryID);
				}

				aadMem->nonBlockBufferedLoadProc(info->smfFileName, (void*)aadLoadDynamicSfxReturn2, info, NULL);

				if (info->directoryID != 0)
				{
					LOAD_SetSearchDirectory(0);
				}
			}
		}
	}
}

int aadWaveMalloc(unsigned short waveID, unsigned long waveSize)
{ 
	struct AadNewSramBlockDesc *sramDesc;
	struct AadNewSramBlockDesc *bestFit;
	struct AadNewSramBlockDesc *next;
	struct AadNewSramBlockDesc *sramDescTbl;
	unsigned long safeWaveSize;
	int i;
	int sramDescIndex;
	int bestFitIndex;
	
	waveSize >>= 3;
	safeWaveSize = (waveSize & 0xFFFFFFF8);
	
	if ((waveSize & 0x7))
	{
		safeWaveSize += 8;
	}

	bestFit = NULL;
	sramDescIndex = aadMem->firstSramBlockDescIndex;
	sramDescTbl = &aadMem->sramDescriptorTbl[0];
	next = sramDescTbl + sramDescIndex;

	i = 128;
	for(i = 128; next != NULL; i--)
	{
		if (--i == -1)
		{
			break;
		}

		if (!(next->waveID & 0x4000) && next->size >= safeWaveSize)
		{
			if (bestFit == NULL || next->size < bestFit->size)
			{
				bestFitIndex = sramDescIndex;
				bestFit = next;
			}
		}

		if ((char)next->nextIndex >= 0)
		{
			if (next->nextIndex != sramDescIndex)
			{
				sramDescIndex = next->nextIndex;
				next = NULL;
				next = sramDescTbl + sramDescIndex;
			}
		}
		else
		{
			next = NULL;
		}
	}

	i++;

	if (bestFit != NULL)
	{
		bestFit->waveID = waveID | 0xC000;

		if (waveSize < bestFit->size)
		{
			if ((char)bestFit->nextIndex >= 0)
			{
				next = sramDescTbl + bestFit->nextIndex;

				if (!(next->waveID & 0x4000))
				{
					next->address -= bestFit->size;
					next->size += (bestFit->size - waveSize);
					
					bestFit->size = waveSize;
				
					return 255;
				}
			}

			sramDescIndex = aadMem->nextSramDescIndex;

			next = sramDescTbl + sramDescIndex;

			i = sramDescIndex;
			if ((next->waveID & 0x8000))
			{
				do
				{
					sramDescIndex = i;
					
					if (((i + 1) & 0x7F) != i)
					{
						next = sramDescTbl + sramDescIndex;
					}

				} while ((next->waveID & 0x8000) != 0);

				return 255;
			}
			else
			{
				aadMem->nextSramDescIndex = (aadMem->nextSramDescIndex + 8) & 0x7F;
				
				next->waveID = 0x8000;
				next->address = bestFit->address + waveSize;
				next->prevIndex = bestFitIndex;
				next->size = bestFit->size - waveSize;
				next->nextIndex = bestFit->nextIndex;

				if ((char)next->nextIndex >= 0)
				{
					(sramDescTbl + next->nextIndex)->prevIndex = sramDescIndex;
				}
				
				bestFit->size = waveSize;
				bestFit->nextIndex = sramDescIndex;
			}
		}
		return bestFitIndex;
	}

	return 255;
}

unsigned long aadGetSramBlockAddr(int handle)
{
	struct AadNewSramBlockDesc* sramDesc;

	if (handle < 0x80)
	{
		return aadMem->sramDescriptorTbl[handle].address << 3;
	}

	return 0;
}


// autogenerated function stub: 
// void /*$ra*/ aadWaveFree(int handle /*$a0*/)
void aadWaveFree(int handle)
{ // line 1702, offset 0x80053170
	/* begin block 1 */
		// Start line: 1704
		// Start offset: 0x80053170
		// Variables:
			struct AadNewSramBlockDesc *sramDesc; // $a1
			struct AadNewSramBlockDesc *sramDescTbl; // $a3

		/* begin block 1.1 */
			// Start line: 1715
			// Start offset: 0x800531A0
			// Variables:
				struct AadNewSramBlockDesc *next; // $a2
		/* end block 1.1 */
		// End offset: 0x80053204
		// End Line: 1724

		/* begin block 1.2 */
			// Start line: 1728
			// Start offset: 0x80053214
			// Variables:
				struct AadNewSramBlockDesc *prev; // $a0
		/* end block 1.2 */
		// End offset: 0x80053278
		// End Line: 1737
	/* end block 1 */
	// End offset: 0x80053278
	// End Line: 1740

	/* begin block 2 */
		// Start line: 3404
	/* end block 2 */
	// End Line: 3405

	/* begin block 3 */
		// Start line: 4019
	/* end block 3 */
	// End Line: 4020

	/* begin block 4 */
		// Start line: 4022
	/* end block 4 */
	// End Line: 4023

}

void aadFreeSingleDynSfx(int sfxID)
{ 
	int ti;
	int wi;
	struct AadLoadedSfxToneAttr *toneAttr;
	struct AadLoadedSfxWaveAttr *waveAttr;
	
	ti = aadMem->sfxToneMasterList[sfxID];

	if (ti < 0xFE)
	{
		toneAttr = &aadMem->sfxToneAttrTbl[ti];

		if (--toneAttr->referenceCount == 0)
		{
			aadMem->sfxToneMasterList[sfxID] = 255;

			wi = aadMem->sfxWaveMasterList[toneAttr->waveID];

			if (wi < 0xFE)
			{
				waveAttr = &aadMem->sfxWaveAttrTbl[wi];
				if (--waveAttr->referenceCount == 0)
				{
					aadMem->sfxWaveMasterList[toneAttr->waveID] = 255;
					aadWaveFree(waveAttr->sramHandle);
				}
			}
		}
	}
}


// autogenerated function stub: 
// void /*$ra*/ setSramFullAlarm()
void setSramFullAlarm()
{ // line 1773, offset 0x80053348
	/* begin block 1 */
		// Start line: 1775
		// Start offset: 0x80053348
		// Variables:
			struct AadNewSramBlockDesc *sramDescTbl; // $v1
			struct AadNewSramBlockDesc *sramDesc; // $a1
			long totalUsed; // $t0
			long totalFree; // $t1
			long largestFree; // $t2
			long numFreeBlocks; // $t3
			long numUsedBlocks; // $a3
			int i; // $a2
	/* end block 1 */
	// End offset: 0x800533F4
	// End Line: 1812

	/* begin block 2 */
		// Start line: 4169
	/* end block 2 */
	// End Line: 4170

	/* begin block 3 */
		// Start line: 4170
	/* end block 3 */
	// End Line: 4171

	/* begin block 4 */
		// Start line: 4184
	/* end block 4 */
	// End Line: 4185

}

void aadLoadSingleDynSfx(struct AadDynamicSfxLoadInfo *info)
{ 
	int i;
	struct AadLoadedSfxToneAttr* toneAttr;
	struct AadLoadedSfxWaveAttr* waveAttr;
	struct AadDynSfxAttr* attr;

	info->waveTransferAddr = NULL;

	attr = &info->attr;

	if (aadMem->sfxToneMasterList[info->attr.sfxID] == 254)
	{
		aadMem->sfxToneMasterList[info->attr.sfxID] = 255;
	}

	i = aadMem->sfxToneMasterList[info->attr.sfxID];
	
	if (i != 255)
	{
		toneAttr = &aadMem->sfxToneAttrTbl[info->attr.sfxID];
		toneAttr->referenceCount++;

		info->smfLoadingState = 2;
		return;
	}
	else
	{
		i = aadMem->nextToneIndex;
		
		toneAttr = &aadMem->sfxToneAttrTbl[i];
		
		while ((toneAttr->referenceCount & 0x7F) != 0)
		{
			if (((i + 1) & 0x7F) != i)
			{
				toneAttr = &aadMem->sfxToneAttrTbl[((i + 1) & 0x7F)];
			}
			else
			{
				info->smfLoadingState = 2;

				aadFreeSingleDynSfx(attr->sfxID);

				aadMem->sfxToneMasterList[attr->sfxID] = 0xFE;

				setSramFullAlarm();
			}
		}

		aadMem->nextToneIndex = ((aadMem->nextToneIndex + 8) & 0x7F);

		toneAttr->referenceCount = 1;
		toneAttr->waveID = attr->waveID;
		toneAttr->toneAttr = attr->toneAttr;

		aadMem->sfxToneMasterList[attr->waveID] = i;

		i = aadMem->sfxWaveMasterList[attr->sfxID];

		if (i != 255)
		{
			waveAttr = &aadMem->sfxWaveAttrTbl[i];
			waveAttr->referenceCount++;

			info->smfLoadingState = 2;
			return;
		}
		else
		{
			i = aadMem->nextWaveIndex;

			waveAttr = &aadMem->sfxWaveAttrTbl[i];

			goto check;

			while (waveAttr->referenceCount != 0)
			{
				if (i >= 120)
				{
					i = 0;
				}

				if (i == aadMem->nextWaveIndex)
				{
					aadFreeSingleDynSfx(attr->sfxID);
					
					info->smfLoadingState = 2;
					
					aadMem->sfxToneMasterList[attr->sfxID] = 0xFE;
					
					setSramFullAlarm();
					return;
				}

			check:
				waveAttr = &aadMem->sfxWaveAttrTbl[i++];
			}

			i--;

			aadMem->nextWaveIndex = (aadMem->nextWaveIndex + 8);

			if (aadMem->nextWaveIndex >= 120)
			{
				aadMem->nextWaveIndex = aadMem->nextWaveIndex - 120;
			}			

			aadMem->sfxWaveMasterList[attr->waveID] = i;

			waveAttr->referenceCount = 1;

			waveAttr->sramHandle = aadWaveMalloc(attr->waveID, attr->waveSize);

			if (waveAttr->sramHandle >= 0)
			{
				info->waveTransferAddr = aadGetSramBlockAddr(waveAttr->sramHandle);
				info->smfLoadingState = 3;
			}
			else
			{
				aadFreeSingleDynSfx(attr->sfxID);

				info->smfLoadingState = 2;

				aadMem->sfxToneMasterList[attr->sfxID] = 0xFE;

				setSramFullAlarm();
			}
		}
	}
}

void HackCallback()
{ 
	SpuSetTransferCallback(NULL);

	aadLoadDynamicSfxReturn2(smfDataPtr, smfBytesLeft, NULL, smfInfo, NULL);
}

void aadLoadDynamicSfxReturn2(void *loadedDataPtr, long loadedDataSize, short status, void *data1, void *data2)
{ 
	unsigned char *dataPtr;
	unsigned long dataOffset;
	unsigned long bytesRemaining;
	struct AadDynamicSfxLoadInfo *info;
	unsigned long n;

	info = (struct AadDynamicSfxLoadInfo*)data1;
	dataOffset = 0;
	bytesRemaining = loadedDataSize;
	dataPtr = (unsigned char*)loadedDataPtr;

	while (bytesRemaining != 0)
	{
		if (info->smfLoadingState == 1)
		{
			n = info->bytesToLoad;
			
			if (bytesRemaining < n)
			{
				n = bytesRemaining;
			}
		
			memcpy(((char*)info - (unsigned)(info->bytesToLoad - 148)), &dataPtr[dataOffset], n);
			
			dataOffset += n;
			bytesRemaining -= n;

			if (info->bytesToLoad - n == 0)
			{
				aadLoadSingleDynSfx(info);
				info->bytesToLoad = info->attr.waveSize;
			}
			else
			{
				info->bytesToLoad = info->bytesToLoad - n;
			}
		}
		else if (info->smfLoadingState == 2)
		{
			n = info->bytesToLoad;
			
			if (bytesRemaining < n)
			{
				n = bytesRemaining;
			}

			dataOffset += n;
			bytesRemaining -= n;

			if (info->bytesToLoad - n == 0)
			{
				if (--info->numSfxToLoad != 0)
				{
					info->smfLoadingState = 1;
					info->bytesToLoad = 24;
				}
			}
			else
			{
				info->bytesToLoad = info->bytesToLoad - n;
			}
		}
		else if (info->smfLoadingState == 3)
		{
			n = info->bytesToLoad;

			if (bytesRemaining < n)
			{
				bytesRemaining = n;
			}

			aadWaitForSramTransferComplete();

			bytesRemaining -= n;

			SpuSetTransferCallback(HackCallback);
			SpuSetTransferStartAddr(info->waveTransferAddr);
			SpuWrite(&dataPtr[dataOffset], n);

			dataOffset += n;

			info->waveTransferAddr += n;
			info->bytesToLoad -= n;

			if (info->bytesToLoad == 0)
			{
				info->totalSramUsed += info->attr.waveSize;

				if (--info->numSfxToLoad == 0)
				{
					SpuSetTransferCallback(NULL);
					aadLoadDynamicSfxDone(info);
				}
				else
				{
					info->smfLoadingState = 1;
					info->bytesToLoad = 24;

					if (bytesRemaining != NULL)
					{
						smfDataPtr = &dataPtr[dataOffset];
						smfBytesLeft = bytesRemaining;
						smfInfo = info;
					}
					else
					{
						SpuSetTransferCallback(NULL);
					}
				}
			}
		}
		else if (info->smfLoadingState == 0)
		{
			if (((_AadDynSfxFileHdr*)dataPtr)->snfID != aadCreateFourCharID('a', 'S', 'M', 'F'))
			{
				aadLoadDynamicSfxAbort(info, 0x100B);
			}
			else
			{
				if (((_AadDynSfxFileHdr*)dataPtr)->snfVersion != 0x100)
				{
					aadLoadDynamicSfxAbort(info, 0x100C);
				}
				else
				{
					if (((_AadDynSfxFileHdr*)dataPtr)->uniqueID != info->snfFile->uniqueID)
					{
						aadLoadDynamicSfxAbort(info, 0x100D);
					}
					else
					{
						dataOffset += 16;

						if (((_AadDynSfxFileHdr*)dataPtr)->handle != info->snfFile->numSfxInFile)
						{

							aadLoadDynamicSfxAbort(info, 0x100D);
						}

						bytesRemaining -= 16;
						info->smfLoadingState = 1;
						info->bytesToLoad = 24;
						info->numSfxToLoad = info->snfFile->numSfxInFile;
					}
				}
			}
		}
	}
}


// autogenerated function stub: 
// int /*$ra*/ aadCheckSramFragmented()
int aadCheckSramFragmented()
{ // line 2172, offset 0x800539f4
	/* begin block 1 */
		// Start line: 2174
		// Start offset: 0x800539F4
		// Variables:
			struct AadNewSramBlockDesc *sramDescTbl; // $v1
			struct AadNewSramBlockDesc *sramDesc; // $a1
			long totalFree; // $t0
			long smallestFree; // $t1
			long numFreeBlocks; // $a3
			int i; // $a2
			int defragNeeded; // $v1
	/* end block 1 */
	// End offset: 0x80053AA0
	// End Line: 2216

	/* begin block 2 */
		// Start line: 5103
	/* end block 2 */
	// End Line: 5104

	/* begin block 3 */
		// Start line: 5104
	/* end block 3 */
	// End Line: 5105

	/* begin block 4 */
		// Start line: 5114
	/* end block 4 */
	// End Line: 5115

	return 0;
}


// autogenerated function stub: 
// void /*$ra*/ aadProcessSramDefrag()
void aadProcessSramDefrag()
{ // line 2235, offset 0x80053aa8
	/* begin block 1 */
		// Start line: 2236
		// Start offset: 0x80053AA8
		// Variables:
			struct AadSramDefragInfo *info; // $s3
			struct AadNewSramBlockDesc *sramDescTbl; // $s5
			struct AadNewSramBlockDesc *firstBlock; // $s1
			struct AadNewSramBlockDesc *secondBlock; // $s2
			int n; // $s0
			int waveID; // $a0
			int firstBlockIndex; // $s4
			int secondBlockIndex; // $s6

		/* begin block 1.1 */
			// Start line: 2338
			// Start offset: 0x80053C70
			// Variables:
				struct AadNewSramBlockDesc *next; // $a0
		/* end block 1.1 */
		// End offset: 0x80053CD4
		// End Line: 2350
	/* end block 1 */
	// End offset: 0x80053DE4
	// End Line: 2428

	/* begin block 2 */
		// Start line: 5234
	/* end block 2 */
	// End Line: 5235

}


// autogenerated function stub: 
// int /*$ra*/ aadIsSfxLoaded(unsigned int toneID /*$a0*/)
int aadIsSfxLoaded(unsigned int toneID)
{ // line 2437, offset 0x80053e0c
	/* begin block 1 */
		// Start line: 4874
	/* end block 1 */
	// End Line: 4875

	/* begin block 2 */
		// Start line: 5664
	/* end block 2 */
	// End Line: 5665

	return 0;
}

void aadInitSequenceSlot(struct _AadSequenceSlot *slot)
{
	struct AadSequenceHdr* seqHdr;
	unsigned long trackOffset;
	int i;
	int bank;

	bank = slot->sequenceAssignedDynamicBank;
	i = 0;
	slot->status = 0;
	slot->selectedDynamicBank = bank;
	slot->slotFlags &= 0x1;

	seqHdr = (struct AadSequenceHdr*)aadMem->dynamicSequenceAddressTbl[bank][slot->sequenceNumberAssigned];

	for (i = 0; i < 16; i++, seqHdr++)
	{
		if (i < seqHdr->numTracks)
		{
			slot->sequencePosition[i] = (unsigned char*)(char*)seqHdr + ((int*)seqHdr)[4];
		}
		else
		{
			slot->sequencePosition[i] = NULL;
		}

		slot->trackFlags[i] = 0;
		slot->loopCurrentNestLevel[i] = 0;
		slot->eventsInQueue[i] = 0;
		slot->eventIn[i] = 0;
		slot->eventOut[i] = 0;
		slot->trackFlags[i] |= 0x20;
	}

	for (i = 0; i < 16; i++)
	{
		slot->currentProgram[i] = 255;
		slot->volume[i] = 127;
		slot->panPosition[i] = 63;
		slot->currentDynamicBank[i] = slot->sequenceAssignedDynamicBank;
		slot->pitchWheel[i] = 8192;
	}

	slot->selectedSlotPtr = slot;
	slot->delayedMuteMode = 0;
	slot->delayedMuteCmds = 0;
	slot->delayedUnMuteCmds = 0;
	slot->selectedSlotNum = slot->thisSlotNumber;
}

int aadWaitForSramTransferComplete()
{ 
	int n;
	
	for (n = 100000; n != 0; n--)
	{
		if (SpuIsTransferCompleted(0) != 0)
		{
			return 1;
		}
	}

	return 0;
}


// autogenerated function stub: 
// void /*$ra*/ aadInitReverb()
void aadInitReverb()
{ // line 2790, offset 0x80053f94
	/* begin block 1 */
		// Start line: 6461
	/* end block 1 */
	// End Line: 6462

}


// autogenerated function stub: 
// void /*$ra*/ aadShutdownReverb()
void aadShutdownReverb()
{ // line 2806, offset 0x80054018
	/* begin block 1 */
		// Start line: 6493
	/* end block 1 */
	// End Line: 6494

}


// autogenerated function stub: 
// int /*$ra*/ aadGetReverbMode()
int aadGetReverbMode()
{ // line 2820, offset 0x80054050
	/* begin block 1 */
		// Start line: 6521
	/* end block 1 */
	// End Line: 6522

	/* begin block 2 */
		// Start line: 6522
	/* end block 2 */
	// End Line: 6523

	return 0;
}


// autogenerated function stub: 
// unsigned long /*$ra*/ aadGetReverbSize()
unsigned long aadGetReverbSize()
{ // line 2842, offset 0x80054058
	/* begin block 1 */
		// Start line: 6565
	/* end block 1 */
	// End Line: 6566

	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ aadGetReverbDepth()
int aadGetReverbDepth()
{ // line 2847, offset 0x80054088
	/* begin block 1 */
		// Start line: 6575
	/* end block 1 */
	// End Line: 6576

	/* begin block 2 */
		// Start line: 6576
	/* end block 2 */
	// End Line: 6577

	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ aadGetNumDynamicSequences(int bank /*$a0*/)
int aadGetNumDynamicSequences(int bank)
{ // line 2860, offset 0x80054090
	/* begin block 1 */
		// Start line: 5720
	/* end block 1 */
	// End Line: 5721

	/* begin block 2 */
		// Start line: 6592
	/* end block 2 */
	// End Line: 6593

	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ aadAssignDynamicSequence(int bank /*$s1*/, int sequenceNumber /*$s3*/, int slotNumber /*$s2*/)
int aadAssignDynamicSequence(int bank, int sequenceNumber, int slotNumber)
{ // line 2877, offset 0x800540c0
	/* begin block 1 */
		// Start line: 2878
		// Start offset: 0x800540C0
		// Variables:
			//struct AadTempo tempo; // stack offset -32
			//struct _AadSequenceSlot *slot; // $s0
			//int i; // $v1
	/* end block 1 */
	// End offset: 0x80054180
	// End Line: 2924

	/* begin block 2 */
		// Start line: 6623
	/* end block 2 */
	// End Line: 6624

	return 0;
}


// autogenerated function stub: 
// struct AadTempo * /*$ra*/ aadGetTempoFromDynamicSequence(int bank /*$a0*/, int sequenceNumber /*$a1*/, struct AadTempo *tempo /*$a2*/)
struct AadTempo * aadGetTempoFromDynamicSequence(int bank, int sequenceNumber, struct AadTempo *tempo)
{ // line 2927, offset 0x8005419c
	/* begin block 1 */
		// Start line: 2929
		// Start offset: 0x8005419C
		// Variables:
			struct AadSequenceHdr *seqHdr; // $v1
	/* end block 1 */
	// End offset: 0x800541E4
	// End Line: 2942

	/* begin block 2 */
		// Start line: 6753
	/* end block 2 */
	// End Line: 6754

	/* begin block 3 */
		// Start line: 6754
	/* end block 3 */
	// End Line: 6755

	/* begin block 4 */
		// Start line: 6761
	/* end block 4 */
	// End Line: 6762

	return null;
}


// autogenerated function stub: 
// void /*$ra*/ aadSetSlotTempo(int slotNumber /*$a0*/, struct AadTempo *tempo /*$a1*/)
void aadSetSlotTempo(int slotNumber, struct AadTempo *tempo)
{ // line 3061, offset 0x800541ec
	/* begin block 1 */
		// Start line: 3063
		// Start offset: 0x800541EC
		// Variables:
			struct _AadSequenceSlot *slot; // $a0
			unsigned long tickTime; // $v1
			unsigned long tickTimeRemainder; // $a2
	/* end block 1 */
	// End offset: 0x800541EC
	// End Line: 3069

	/* begin block 2 */
		// Start line: 7021
	/* end block 2 */
	// End Line: 7022

	/* begin block 3 */
		// Start line: 7022
	/* end block 3 */
	// End Line: 7023

	/* begin block 4 */
		// Start line: 7028
	/* end block 4 */
	// End Line: 7029

}


// autogenerated function stub: 
// void /*$ra*/ aadStartSlot(int slotNumber /*$a0*/)
void aadStartSlot(int slotNumber)
{ // line 3082, offset 0x800542a0
	/* begin block 1 */
		// Start line: 3083
		// Start offset: 0x800542A0
		// Variables:
			struct _AadSequenceSlot *slot; // $s0
	/* end block 1 */
	// End offset: 0x8005430C
	// End Line: 3096

	/* begin block 2 */
		// Start line: 7068
	/* end block 2 */
	// End Line: 7069

	/* begin block 3 */
		// Start line: 7071
	/* end block 3 */
	// End Line: 7072

}

void aadStopSlot(int slotNumber)
{
	struct _AadSequenceSlot *slot;

	if (slotNumber < aadMem->numSlots)
	{
		slot = aadMem->sequenceSlots[slotNumber];

		if (slot->sequenceNumberAssigned != 255)
		{
			slot->status &= -2;
			aadInitSequenceSlot(slot);
			aadAllNotesOff(slotNumber);
		}
	}
}


// autogenerated function stub: 
// void /*$ra*/ aadStopAllSlots()
void aadStopAllSlots()
{ 
#ifdef PSX_VERSION
	struct _AadSequenceSlot* slot;
	int slotNumber;

	slotNumber = 0;
	
	if (aadMem->numSlots > 0)
	{
		do
		{
			slot = aadMem->sequenceSlots[slotNumber];

			if ((slot->status & 0x1))
			{
				aadStopSlot(slotNumber);
			}

			slot->sequenceNumberAssigned = 255;

		} while (++slotNumber < aadMem->numSlots);
	}
#else
	AadMemoryStruct* v0; // ecx
	int v1; // edx
	int numSlots; // eax
	int v3; // edi
	int v4; // esi
	AadMemoryStruct* v5; // ebp
	int v6; // ecx
	int v7; // edx
	int i; // edi
	char* v9; // eax
	int v10; // ebp
	int v11; // [esp+0h] [ebp-8h]
	int v12; // [esp+4h] [ebp-4h]

	v0 = aadMem;
	v1 = 0;
	v11 = 0;
	numSlots = aadMem->numSlots;
	if (numSlots > 0)
	{
		v3 = 52;
		v12 = 52;
		do
		{
			v4 = *(unsigned int*)((char*)&v0->updateCounter + v3);
			if ((*(BYTE*)(v4 + 1344) & 1) != 0 && v1 < numSlots && *(BYTE*)(v4 + 1342) != 0xFF)
			{
				*(WORD*)(v4 + 1344) &= ~1u;
				aadInitSequenceSlot((struct _AadSequenceSlot* )v4);
				v5 = aadMem;
				v6 = 0;
				v7 = *(unsigned int*)((char*)&aadMem->updateCounter + v3);
				for (i = 476; i < 1148; i += 28)
				{
					v9 = (char*)v5 + i;
					if ((*((BYTE*)&v5->updateMode + i) & 0xF0) == *(BYTE*)(v7 + 1361))
					{
						v10 = *(DWORD*)v9;
						v9[8] = -1;
						v6 |= v10;
						v9[18] |= 2u;
						v5 = aadMem;
					}
				}
				if (v6)
				{
					v5->voiceKeyOffRequest |= v6;
					aadMem->voiceKeyOnRequest &= ~v6;
				}
			}
			v1 = v11 + 1;
			*(BYTE*)(v4 + 1342) = -1;
			v0 = aadMem;
			v3 = v12 + 4;
			v11 = v1;
			numSlots = aadMem->numSlots;
			v12 += 4;
		} while (v1 < numSlots);
	}
#endif
}


// autogenerated function stub: 
// void /*$ra*/ aadDisableSlot(int slotNumber /*$a0*/)
void aadDisableSlot(int slotNumber)
{ // line 3135, offset 0x80054418
	int v1; // esi
	AadMemoryStruct* v2; // edi
	int v3; // ecx
	struct _AadSequenceSlot* v4; // ebp
	char* v5; // eax
	int v6; // ebx

	if (slotNumber < aadMem->numSlots)
	{
		v1 = 476;
		aadMem->sequenceSlots[slotNumber]->slotFlags |= 1u;
		v2 = aadMem;
		v3 = 0;
		v4 = aadMem->sequenceSlots[slotNumber];
		do
		{
			v5 = (char*)v2 + v1;
			if ((*((BYTE*)&v2->updateMode + v1) & 0xF0) == v4->slotID)
			{
				v6 = *(DWORD*)v5;
				v5[8] = -1;
				v3 |= v6;
				*((WORD*)v5 + 9) |= 2u;
				v2 = aadMem;
			}
			v1 += 28;
		} while (v1 < 1148);
		if (v3)
		{
			v2->voiceKeyOffRequest |= v3;
			aadMem->voiceKeyOnRequest &= ~v3;
		}
	}
}


// autogenerated function stub: 
// void /*$ra*/ aadEnableSlot(int slotNumber /*$a0*/)
void aadEnableSlot(int slotNumber)
{ // line 3146, offset 0x80054468
	if (slotNumber < aadMem->numSlots)
		aadMem->sequenceSlots[slotNumber]->slotFlags &= ~1u;
}


// autogenerated function stub: 
// void /*$ra*/ aadPauseSlot(int slotNumber /*$a0*/)
void aadPauseSlot(int slotNumber)
{ // line 3154, offset 0x800544a8
	int v1; // esi
	AadMemoryStruct* v2; // edi
	int v3; // ecx
	struct _AadSequenceSlot* v4; // ebp
	char* v5; // eax
	int v6; // ebx

	if (slotNumber < aadMem->numSlots)
	{
		v1 = 476;
		aadMem->sequenceSlots[slotNumber]->status &= ~1u;
		v2 = aadMem;
		v3 = 0;
		v4 = aadMem->sequenceSlots[slotNumber];
		do
		{
			v5 = (char*)v2 + v1;
			if ((*((BYTE*)&v2->updateMode + v1) & 0xF0) == v4->slotID)
			{
				v6 = *(DWORD*)v5;
				v5[8] = -1;
				v3 |= v6;
				*((WORD*)v5 + 9) |= 2u;
				v2 = aadMem;
			}
			v1 += 28;
		} while (v1 < 1148);
		if (v3)
		{
			v2->voiceKeyOffRequest |= v3;
			aadMem->voiceKeyOnRequest &= ~v3;
		}
	}
}


// autogenerated function stub: 
// void /*$ra*/ aadResumeSlot(int slotNumber /*$a0*/)
void aadResumeSlot(int slotNumber)
{
#if defined(PC_VERSION)
	// line 3165, offset 0x800544f8
	/* begin block 1 */
		// Start line: 3167
		// Start offset: 0x800544F8
		// Variables:
	struct _AadSequenceSlot *slot; // $a1
	int track; // $a0

	unsigned __int8* trackFlags; // eax

	if (slotNumber < aadMem->numSlots)
	{
		slot = aadMem->sequenceSlots[slotNumber];
		if (slot->sequenceNumberAssigned != 0xFF)
		{
			trackFlags = slot->trackFlags;
			do
				*trackFlags++ |= 0x20u;
			while ((int)&trackFlags[-984 - (DWORD)slot] < 16);
			slot->status |= 1u;
		}
	}
#endif
}


// autogenerated function stub: 
// int /*$ra*/ aadGetSlotStatus(int slotNumber /*$a0*/)
int aadGetSlotStatus(int slotNumber)
{ // line 3184, offset 0x80054568
	return aadMem->sequenceSlots[slotNumber]->status;
}

void aadAllNotesOff(int slotNumber)
{ 
#ifdef PSX_VERSION
	struct AadSynthVoice* voice;
	unsigned long vmask;
	int i;
	struct _AadSequenceSlot* slot;

	vmask = 0;
	slot = aadMem->sequenceSlots[slotNumber];

	for (i = 0; i < 24; i++)
	{
		voice = &aadMem->synthVoice[i];

		if ((voice->voiceID & 0xF0) == slot->slotID)
		{
			voice->voiceID = 255;
			vmask |= voice->voiceMask;
			voice->flags |= 0x2;
		}
	}

	if (vmask != 0)
	{
		aadMem->voiceKeyOffRequest |= vmask;
		aadMem->voiceKeyOnRequest &= ~vmask;
	}
#else
	AadMemoryStruct* v1; // edi
	int v2; // ecx
	int v3; // esi
	struct _AadSequenceSlot* v4; // ebp
	char* v5; // eax
	int v6; // ebx

	v1 = aadMem;
	v2 = 0;
	v3 = 476;
	v4 = aadMem->sequenceSlots[slotNumber];
	do
	{
		v5 = (char*)v1 + v3;
		if ((*((BYTE*)&v1->updateMode + v3) & 0xF0) == v4->slotID)
		{
			v6 = *(DWORD*)v5;
			v5[8] = -1;
			v2 |= v6;
			*((WORD*)v5 + 9) |= 2u;
			v1 = aadMem;
		}
		v3 += 28;
	} while (v3 < 1148);
	if (v2)
	{
		v1->voiceKeyOffRequest |= v2;
		aadMem->voiceKeyOnRequest &= ~v2;
	}
#endif
}


// autogenerated function stub: 
// void /*$ra*/ aadMuteChannels(struct _AadSequenceSlot *slot /*$a0*/, unsigned long channelList /*$a1*/)
void aadMuteChannels(struct _AadSequenceSlot *slot, unsigned long channelList)
{ 
#if defined(PC_VERSION)
	// line 3252, offset 0x80054628
	/* begin block 1 */
		// Start line: 3254
		// Start offset: 0x80054628
		// Variables:
			struct AadSynthVoice *voice; // $a2
			unsigned long vmask; // $t2
			unsigned long delayedMute; // $a2
			int channel; // $t1
			//int i; // $t0
	unsigned int v2; // edx
	unsigned int v3; // eax
	AadMemoryStruct* v4; // esi
	int v5; // edi
	int i; // ebp
	int j; // eax
	BYTE* v8; // edx
	int v9; // ecx

	v2 = channelList;
	v3 = channelList & slot->delayedMuteMode;
	if (((unsigned __int16)channelList & slot->delayedMuteMode) != 0)
	{
		slot->delayedMuteCmds |= v3;
		v2 = ~v3 & channelList;
		channelList = v2;
	}
	slot->channelMute |= v2;
	v4 = aadMem;
	v5 = 0;
	for (i = 0; i < 16; ++i)
	{
		if (((1 << i) & v2) != 0)
		{
			for (j = 476; j < 1148; j += 28)
			{
				v8 = (BYTE*)&v4->updateMode + j;
				if ((unsigned __int8)*v8 == (slot->slotID | i))
				{
					v9 = *(unsigned int*)((char*)&v4->updateCounter + j);
					*v8 = -1;
					v4 = aadMem;
					v5 |= v9;
				}
			}
			v2 = channelList;
		}
	}
	if (v5)
	{
		v4->voiceKeyOffRequest |= v5;
		aadMem->voiceKeyOnRequest &= ~v5;
	}
#endif
}


// autogenerated function stub: 
// void /*$ra*/ aadUnMuteChannels(struct _AadSequenceSlot *slot /*$a0*/, unsigned long channelList /*$a1*/)
void aadUnMuteChannels(struct _AadSequenceSlot *slot, unsigned long channelList)
{
#if defined(PC_VERSION)
	__int16 v2; // dx
	__int16 v3; // ax

	v2 = channelList;
	v3 = channelList & slot->delayedMuteMode;
	if (v3)
	{
		slot->delayedUnMuteCmds |= v3;
		v2 = ~v3 & channelList;
	}
	slot->channelMute &= ~v2;
#endif
}


// autogenerated function stub: 
// TDRFuncPtr_aadInstallEndSequenceCallback /*$ra*/ aadInstallEndSequenceCallback(TDRFuncPtr_aadInstallEndSequenceCallback0callbackProc callbackProc /*$a0*/, long data /*$a1*/)
TDRFuncPtr_aadInstallEndSequenceCallback aadInstallEndSequenceCallback(TDRFuncPtr_aadInstallEndSequenceCallback0callbackProc callbackProc, long data)
{ // line 3405, offset 0x8005473c
	TDRFuncPtr_aadInstallEndSequenceCallback result; // eax

	result = (TDRFuncPtr_aadInstallEndSequenceCallback)aadMem[3].loadRequestQueue[13].type;
	aadMem[3].loadRequestQueue[13].type = (int)callbackProc;
	aadMem[3].loadRequestQueue[13].directoryID = data;
	return result;
}


// autogenerated function stub: 
// void /*$ra*/ aadSetUserVariable(int variableNumber /*$a0*/, int value /*$a1*/)
void aadSetUserVariable(int variableNumber, int value)
{ // line 3416, offset 0x80054754
	*((BYTE*)&aadMem[3].loadRequestQueue[13].flags + variableNumber) = value;
}


void aadSetNoUpdateMode(int noUpdate)
{ 
#ifdef PSX_VERSION
	if (noUpdate != 0)
	{
		aadMem->flags |= 2;
	}
	else
	{
		aadMem->flags &= -3;
	}
#else
	int flags; // ecx

	flags = aadMem->flags;
	if (noUpdate)
		aadMem->flags = flags | 2;
	else
		aadMem->flags = flags & ~2u;
#endif
}


// autogenerated function stub: 
// void /*$ra*/ aadPauseSound()
void aadPauseSound()
{ // line 3467, offset 0x800547a8
#if defined(PC_VERSION)
	int flags; // eax
	int v1; // esi
	int v2; // ebx
	int i; // edi

	flags = aadMem->flags;
	if ((flags & 8) == 0)
	{
		v1 = 0;
		aadMem->flags |= 0xC;
		v2 = 0;
		for (i = 1172; i < 1220; i += 2)
		{
			aadMem->synthVoice[v2].flags &= ~2u;
			SpuGetVoicePitch(v1, (unsigned __int16*)((char*)aadMem + i));
			SpuSetVoicePitch(v1++, 0);
			++v2;
		}
	}
#endif
}


// autogenerated function stub: 
// void /*$ra*/ aadCancelPauseSound()
void aadCancelPauseSound()
{ // line 3486, offset 0x80054840
	aadMem->flags &= ~0xCu;
}


// autogenerated function stub: 
// void /*$ra*/ aadResumeSound()
void aadResumeSound()
{ // line 3493, offset 0x8005485c
	int flags; // eax
	AadMemoryStruct* v1; // eax
	int v2; // edi
	int v3; // ebp
	int i; // esi

	flags = aadMem->flags;
	if ((flags & 8) != 0)
	{
		aadMem->flags &= ~0xC;
		v1 = aadMem;
		v2 = 0;
		v3 = 0;
		for (i = 1172; i < 1220; i += 2)
		{
			if ((v1->synthVoice[v3].flags & 2) == 0)
			{
				SpuSetVoicePitch(v2, *(WORD*)((char*)&v1->updateCounter + i));
				v1 = aadMem;
			}
			++v2;
			++v3;
		}
	}
}




