#include "THISDUST.H"
#include "MEMPACK.H"
#include "PSX/DRAWS.H"
#include "STREAM.H"
#include "DEBUG.H"

#include <stddef.h>

void MEMPACK_Init()
{ 
	newMemTracker.totalMemory = (BASE_ADDRESS + TWO_MB - (ONE_MB / 256)) - (unsigned int)overlayAddress;
	newMemTracker.rootNode = (MemHeader*)overlayAddress;
	newMemTracker.rootNode->magicNumber = DEFAULT_MEM_MAGIC;
	newMemTracker.rootNode->memStatus = 2;
	newMemTracker.rootNode->memType = 0;
	newMemTracker.rootNode->memSize = newMemTracker.totalMemory;
	newMemTracker.currentMemoryUsed = 0;
	newMemTracker.doingGarbageCollection = 0;
	newMemTracker.lastMemoryAddress = (char*)overlayAddress + (char*)newMemTracker.rootNode;
}

struct MemHeader * MEMPACK_GetSmallestBlockTopBottom(long allocSize)
{ 
	struct MemHeader *address;
	struct MemHeader *bestAddress;
	
	address = newMemTracker.rootNode;

	bestAddress = NULL;
	if ((char*)address != newMemTracker.lastMemoryAddress)
	{
		do
		{
			if (address->memStatus == 0 && address->memSize >= allocSize && bestAddress == NULL)
			{
				bestAddress = address;
				break;
			}

			address = (struct MemHeader*)(char*)address + address->memSize;

		} while ((char*)address != newMemTracker.lastMemoryAddress);
	}

	return bestAddress;
}


// autogenerated function stub: 
// struct MemHeader * /*$ra*/ MEMPACK_GetSmallestBlockBottomTop(long allocSize /*$a0*/)
struct MemHeader * MEMPACK_GetSmallestBlockBottomTop(long allocSize)
{ // line 279, offset 0x8004fb74
	/* begin block 1 */
		// Start line: 281
		// Start offset: 0x8004FB74
		// Variables:
			struct MemHeader *address; // $v1
			struct MemHeader *bestAddress; // $a1
	/* end block 1 */
	// End offset: 0x8004FBD8
	// End Line: 309

	/* begin block 2 */
		// Start line: 590
	/* end block 2 */
	// End Line: 591

	/* begin block 3 */
		// Start line: 591
	/* end block 3 */
	// End Line: 592

	/* begin block 4 */
		// Start line: 593
	/* end block 4 */
	// End Line: 594

	return null;
}

long MEMPACK_RelocatableType(long memType)
{
	if (memType - 1 < 2 || memType == 0x2C || memType == 0x2F || memType == 0x4)
	{
		return 1;
	}

	return 0;
}

char * MEMPACK_Malloc(unsigned long allocSize, unsigned char memType)
{
#ifdef PSX_VERSION
	struct MemHeader* bestAddress; // $s1
	long relocatableMemory; // $s3
	int curMem; // $s0
	struct MemHeader* address; // $a1
	long topOffset; // $a0

	//s2 = allocSize
	//s4 = memType

	relocatableMemory = MEMPACK_RelocatableType(memType);
	//s2 = ((allocSize + 11) >> 2) << 2
	//loc_80050240
	if (newMemTracker.doingGarbageCollection == 0 && relocatableMemory != 0)
	{
		MEMPACK_DoGarbageCollection();
	}
	//loc_80050260

#if 0

		loc_80050240:
	lw      $v0, -0x3900($gp)
		nop
		bnez    $v0, loc_80050260
		nop
		beqz    $s3, loc_80050278
		nop
		jal     sub_80050960
		nop

		loc_80050260 :
	beqz    $s3, loc_80050278
		nop
		jal     sub_800500F8
		move    $a0, $s2
		j       loc_80050284
		move    $s1, $v0

		loc_80050278 :
	jal     sub_80050160
		move    $a0, $s2
		move    $s1, $v0

		loc_80050284 :
	bnez    $s1, loc_800502E4
		nop
		lw      $s0, -0x3908($gp)
		jal     sub_80058F84
		nop
		lw      $v0, -0x3908($gp)
		nop
		bne     $s0, $v0, loc_80050240
		andi    $s0, $s4, 0xFF
		li      $v0, 0x10
		beq     $s0, $v0, loc_800503AC
		move    $v0, $zero
		jal     sub_800505FC
		nop
		li      $a0, aTryingToFitMem  # "Trying to fit memory size %d Type = %d"...
		move    $a1, $s2
		lw      $v0, -0x390C($gp)
		lw      $v1, -0x3908($gp)
		move    $a2, $s0
		subu    $v0, $v1
		move    $a3, $v1
		jal     sub_800148AC
		sw      $v0, 0x18 + var_8($sp)

		loc_800502E4:
	lw      $a0, 4($s1)
		nop
		subu    $v0, $a0, $s2
		sltiu   $v0, 8
		beqz    $v0, loc_80050300
		nop
		move    $s2, $a0

		loc_80050300 :
	beq     $s2, $a0, loc_80050384
		li      $v0, 0xBADE
		beqz    $s3, loc_8005033C
		addu    $a1, $s1, $s2
		li      $v1, 0xBADE
		sh      $v1, 0($a1)
		sb      $zero, 2($a1)
		sb      $zero, 3($a1)
		lw      $v0, 4($s1)
		nop
		subu    $v0, $s2
		sw      $v0, 4($a1)
		li      $v0, 1
		j       loc_8005038C
		sh      $v1, 0($s1)

		loc_8005033C:
	subu    $a0, $s2
		addu    $a1, $s1, $a0
		li      $v1, 0xBADE
		li      $v0, 1
		sh      $v1, 0($a1)
		sb      $v0, 2($a1)
		sb      $s4, 3($a1)
		sw      $s2, 4($a1)
		lw      $v0, -0x3908($gp)
		nop
		addu    $v0, $s2
		sw      $v0, -0x3908($gp)
		sh      $v1, 0($s1)
		sb      $zero, 2($s1)
		sb      $zero, 3($s1)
		sw      $a0, 4($s1)
		j       loc_800503A8
		move    $s1, $a1

		loc_80050384 :
	sh      $v0, 0($s1)
		li      $v0, 1

		loc_8005038C :
		sb      $v0, 2($s1)
		sb      $s4, 3($s1)
		sw      $s2, 4($s1)
		lw      $v0, -0x3908($gp)
		nop
		addu    $v0, $s2
		sw      $v0, -0x3908($gp)

		loc_800503A8:
	addiu   $v0, $s1, 8

		loc_800503AC :
		lw      $ra, 0x18 + var_s14($sp)
		lw      $s4, 0x18 + var_s10($sp)
		lw      $s3, 0x18 + var_sC($sp)
		lw      $s2, 0x18 + var_s8($sp)
		lw      $s1, 0x18 + var_s4($sp)
		lw      $s0, 0x18 + var_s0($sp)
		jr      $ra
		addiu   $sp, 0x30
		# End of function sub_80050204
#endif

#else
	char* result; // eax

	result = (char*)MEMPACK_MallocFailOk(allocSize, memType);
	if (!result)
	{
		GXFilePrint("---------------------\n");
		MEMPACK_ReportMemory2();
		DEBUG_FatalError(
			"Trying to fit memory size %d Type = %d\nAvailable memory : used = %d, free = %d\n",
			allocSize,
			memType,
			mem_used,
			mem_total - mem_used);
	}
	return result;
#endif
}


// autogenerated function stub: 
// char * /*$ra*/ MEMPACK_MallocFailOk(unsigned long allocSize /*$s1*/, unsigned char memType /*$s3*/)
char * MEMPACK_MallocFailOk(unsigned long allocSize, unsigned char memType)
{ // line 349, offset 0x8004fc94
	/* begin block 1 */
		// Start line: 350
		// Start offset: 0x8004FC94
		// Variables:
			struct MemHeader *bestAddress; // $a1
			long relocatableMemory; // $s2

		/* begin block 1.1 */
			// Start line: 378
			// Start offset: 0x8004FD18
			// Variables:
				int curMem; // $s0
		/* end block 1.1 */
		// End offset: 0x8004FD34
		// End Line: 390

		/* begin block 1.2 */
			// Start line: 404
			// Start offset: 0x8004FD60
			// Variables:
				struct MemHeader *address; // $a2

			/* begin block 1.2.1 */
				// Start line: 424
				// Start offset: 0x8004FD94
				// Variables:
					long topOffset; // $a0
			/* end block 1.2.1 */
			// End offset: 0x8004FD94
			// End Line: 426
		/* end block 1.2 */
		// End offset: 0x8004FD94
		// End Line: 426
	/* end block 1 */
	// End offset: 0x8004FE04
	// End Line: 457

	/* begin block 2 */
		// Start line: 733
	/* end block 2 */
	// End Line: 734

	return null;
}

void MEMORY_MergeAddresses(struct MemHeader *firstAddress, struct MemHeader *secondAddress)
{
	if (firstAddress->memStatus == 0 && secondAddress->memType == 0)
	{
		firstAddress->memSize += secondAddress->memSize;
		secondAddress->magicNumber = 0;
		secondAddress->memStatus = 1;
	}
}


// autogenerated function stub: 
// void /*$ra*/ MEMPACK_Return(char *address /*$a0*/, long takeBackSize /*$a1*/)
void MEMPACK_Return(char *address, long takeBackSize)
{ // line 480, offset 0x8004fe68
	/* begin block 1 */
		// Start line: 481
		// Start offset: 0x8004FE68
		// Variables:
			struct MemHeader *memAddress; // $a0
			struct MemHeader *nextAddress; // $a1
	/* end block 1 */
	// End offset: 0x8004FEDC
	// End Line: 508

	/* begin block 2 */
		// Start line: 1002
	/* end block 2 */
	// End Line: 1003

}


// autogenerated function stub: 
// void /*$ra*/ MEMPACK_Free(char *address /*$a0*/)
void MEMPACK_Free(char *address)
{ // line 539, offset 0x8004feec
	/* begin block 1 */
		// Start line: 540
		// Start offset: 0x8004FEEC
		// Variables:
			struct MemHeader *memAddress; // $s0
			struct MemHeader *secondAddress; // $v1
	/* end block 1 */
	// End offset: 0x8004FF8C
	// End Line: 584

	/* begin block 2 */
		// Start line: 1078
	/* end block 2 */
	// End Line: 1079

}


// autogenerated function stub: 
// void /*$ra*/ MEMPACK_FreeByType(unsigned char memType /*$a0*/)
void MEMPACK_FreeByType(unsigned char memType)
{ // line 586, offset 0x8004ff9c
	/* begin block 1 */
		// Start line: 587
		// Start offset: 0x8004FF9C
		// Variables:
			struct MemHeader *address; // $a0
			int freed; // $s0
	/* end block 1 */
	// End offset: 0x8005001C
	// End Line: 608

	/* begin block 2 */
		// Start line: 1187
	/* end block 2 */
	// End Line: 1188

}


// autogenerated function stub: 
// unsigned long /*$ra*/ MEMPACK_Size(char *address /*$a0*/)
unsigned long MEMPACK_Size(char *address)
{ // line 611, offset 0x80050034
	return *((DWORD*)address - 1) - 8;
}


// autogenerated function stub: 
// unsigned long /*$ra*/ MEMPACK_ReportFreeMemory()
unsigned long MEMPACK_ReportFreeMemory()
{ // line 621, offset 0x80050040
	return mem_total - mem_used;
}


// autogenerated function stub: 
// void /*$ra*/ MEMPACK_ReportMemory2()
void MEMPACK_ReportMemory2()
{ // line 689, offset 0x80050050
	GXFilePrint("----- Memory Map -----\n");
	for (i = dword_C550A8; i != dword_C550B4; i += *(DWORD*)(i + 4))
	{
		if (*(BYTE*)(i + 2))
		{
			if (*(BYTE*)(i + 3) == 1)
			{
				GXFilePrint("CLOSED) addr %x size=%d type=OBJECT : %s\n", i, *(_DWORD*)(i + 4), *(_DWORD*)(i + 44));
			}
			else if (*(BYTE*)(i + 3) == 2)
			{
				GXFilePrint("CLOSED) addr %x size=%d type=AREA : %s\n", i, *(_DWORD*)(i + 4), *(_DWORD*)(i + 160));
			}
			else
			{
				GXFilePrint("CLOSED) addr %x size=%d type=%d\n", i, *(_DWORD*)(i + 4), *(unsigned __int8*)(i + 3));
			}
		}
		else
		{
			GXFilePrint("OPEN) addr %x size=%d\n", i, *(DWORD*)(i + 4));
		}
	}
	GXFilePrint("Total Memory Used = %d, Total Memory Free = %d\n", mem_used, mem_total - mem_used);
}


// autogenerated function stub: 
// void /*$ra*/ MEMPACK_ReportMemory()
void MEMPACK_ReportMemory()
{ // line 727, offset 0x80050080
	/* begin block 1 */
		// Start line: 729
		// Start offset: 0x80050080
		// Variables:
			struct MemHeader *address; // $v1
			long i; // $a1
			long firstTime; // $a0
	/* end block 1 */
	// End offset: 0x80050114
	// End Line: 799

	/* begin block 2 */
		// Start line: 1413
	/* end block 2 */
	// End Line: 1414

	/* begin block 3 */
		// Start line: 1414
	/* end block 3 */
	// End Line: 1415

	/* begin block 4 */
		// Start line: 1421
	/* end block 4 */
	// End Line: 1422

}


// autogenerated function stub: 
// void /*$ra*/ MEMPACK_SetMemoryBeingStreamed(char *address /*$a0*/)
void MEMPACK_SetMemoryBeingStreamed(char *address)
{ // line 801, offset 0x8005011c
	/* begin block 1 */
		// Start line: 803
		// Start offset: 0x8005011C
	/* end block 1 */
	// End offset: 0x8005011C
	// End Line: 808

	/* begin block 2 */
		// Start line: 1597
	/* end block 2 */
	// End Line: 1598

	/* begin block 3 */
		// Start line: 1598
	/* end block 3 */
	// End Line: 1599

	/* begin block 4 */
		// Start line: 1603
	/* end block 4 */
	// End Line: 1604

}

void MEMPACK_SetMemoryDoneStreamed(char *address)
{ 
	address[-6] = 1;
}


// autogenerated function stub: 
// long /*$ra*/ MEMPACK_MemoryValidFunc(char *address /*$a0*/)
long MEMPACK_MemoryValidFunc(char *address)
{ // line 826, offset 0x80050134
	return address != (char*)0xFAFBFCFD && address && *(address - 6) == 1;
}


char * MEMPACK_GarbageCollectMalloc(unsigned long *allocSize, unsigned char memType, unsigned long *freeSize)
{
	struct MemHeader* bestAddress;

	allocSize[0] = ((allocSize[0] + 11) >> 2) << 2;
	bestAddress = MEMPACK_GetSmallestBlockTopBottom(allocSize[0]);
	
	if (bestAddress == NULL)
	{
		STREAM_DumpNonResidentObjects();
		bestAddress = MEMPACK_GetSmallestBlockTopBottom(allocSize[0]);

		if (bestAddress == NULL)
		{
			if (memType == 16)
			{
				return NULL;
			}

			MEMPACK_ReportMemory();
			DEBUG_FatalError("Trying to fit memory size %d Type = %d\nAvailable memory : used = %d, free = %d", allocSize[0], memType, newMemTracker.currentMemoryUsed, newMemTracker.totalMemory - newMemTracker.currentMemoryUsed);
		}
	}

	if (allocSize[0] - bestAddress->memSize < 8)
	{
		allocSize[0] = bestAddress->memSize;
	}

	if (allocSize[0] != bestAddress->memSize)
	{
		freeSize[0] = bestAddress->memSize - allocSize[0];
		bestAddress->magicNumber = DEFAULT_MEM_MAGIC;
		bestAddress->memStatus = 1;
		bestAddress->memType = memType;
		bestAddress->memSize = allocSize[0];
		newMemTracker.currentMemoryUsed += allocSize[0];
	}
	else
	{
		bestAddress->magicNumber = DEFAULT_MEM_MAGIC;
		bestAddress->memStatus = 1;
		bestAddress->memType = memType;
		bestAddress->memSize = allocSize[0];
		newMemTracker.currentMemoryUsed += allocSize[0];
		freeSize[0] = 0;
	}

	return (char*)bestAddress + 1;
}


// autogenerated function stub: 
// void /*$ra*/ MEMPACK_GarbageSplitMemoryNow(unsigned long allocSize /*$a0*/, struct MemHeader *bestAddress /*$a1*/, long memType /*$a2*/, unsigned long freeSize /*$a3*/)
void MEMPACK_GarbageSplitMemoryNow(unsigned long allocSize, struct MemHeader *bestAddress, long memType, unsigned long freeSize)
{ // line 921, offset 0x800502cc
	if (freeSize)
	{
		*(unsigned __int16*)((char*)&bestAddress->magicNumber + allocSize) = 0xBADE;
		*(&bestAddress->memStatus + allocSize) = 0;
		*(&bestAddress->memType + allocSize) = 0;
		*(unsigned int*)((char*)&bestAddress->memSize + allocSize) = freeSize;
	}
}

void MEMPACK_GarbageCollectFree(struct MemHeader *memAddress)
{
	struct MemHeader* secondAddress;

	memAddress->memStatus = 0;
	memAddress->memType = 0;

	newMemTracker.currentMemoryUsed -= memAddress->memSize;
	secondAddress = (struct MemHeader*)(char*)memAddress + memAddress->memSize;

	if ((char*)secondAddress != newMemTracker.lastMemoryAddress)
	{
		MEMORY_MergeAddresses(memAddress, secondAddress);
	}

	if ((char*)newMemTracker.rootNode != newMemTracker.lastMemoryAddress)
	{
		do
		{
			if ((char*)newMemTracker.rootNode + newMemTracker.rootNode->memSize == (char*)memAddress)
			{
				MEMORY_MergeAddresses(newMemTracker.rootNode, (struct MemHeader*)(char*)newMemTracker.rootNode + newMemTracker.rootNode->memSize);
			}

		} while ((char*)newMemTracker != (char*)newMemTracker.rootNode + newMemTracker.rootNode->memSize);
	}
}

void MEMPACK_DoGarbageCollection()
{ 
	struct MemHeader* relocateAddress; // $s0
	long foundOpening; // $s1
	long done; // $s5
	long addressSize; // $s3
	long addressMemType; // $s2
	long holdSize; // stack offset -40
	long freeSize; // stack offset -36
	char* oldAddress; // $s0
	char* newAddress; // $s1

	done = 0;
	//s6 = 1
	//s4 = 2
	//v0 = 1
	//sw      $zero, 0x18 + var_4($sp)
	newMemTracker.doingGarbageCollection = 1;

	//loc_8005099C
	relocateAddress = newMemTracker.rootNode;

	foundOpening = 0;
	if ((char*)relocateAddress != newMemTracker.lastMemoryAddress)
	{
		do
		{
			if (relocateAddress->memStatus != 0)
			{
				if (MEMPACK_RelocatableType(relocateAddress->memType) != 0 && foundOpening == 1 &&
					relocateAddress->memStatus != 2)
				{
					foundOpening = 2;
					break;
				}
			}
			else
			{
				foundOpening = 1;
			}

			relocateAddress = (MemHeader*)(char*)relocateAddress + relocateAddress->memSize;
		} while ((char*)relocateAddress != newMemTracker.lastMemoryAddress);
	}

	//loc_80050A0C
	if (foundOpening == 2)
	{
		addressMemType = relocateAddress->memType;
		addressSize = relocateAddress->memSize - 8;
		MEMPACK_GarbageCollectFree(relocateAddress);
		MEMPACK_GarbageCollectMalloc();
	}
	//loc_80050B40
#if 0

		addiu   $a0, $sp, 0x18 + var_8
		move    $a1, $s2
		addiu   $a2, $sp, 0x18 + var_4
		jal     sub_80050714
		sw      $s3, 0x18 + var_8($sp)
		move    $s1, $v0
		beqz    $s1, loc_80050B44
		addiu   $s0, 8
		bne     $s2, $s4, loc_80050A5C
		li      $v0, 4
		jal     sub_8005ACC0
		move    $a0, $s0
		j       loc_80050A70
		move    $a0, $s1

		loc_80050A5C :
	bne     $s2, $v0, loc_80050A70
		move    $a0, $s1
		jal     sub_80052C8C
		nop
		move    $a0, $s1

		loc_80050A70 :
	move    $a1, $s0
		jal     sub_80079408
		move    $a2, $s3
		bne     $s2, $s4, loc_80050A98
		addiu   $a0, $s1, -8
		subu    $a1, $s1, $s0
		jal     sub_80050B78
		move    $a2, $s0
		j       loc_80050B28
		addiu   $a1, $s1, -8

		loc_80050A98:
	bne     $s2, $s6, loc_80050AB8
		li      $v0, 0xE
		addiu   $a0, $s1, -8
		subu    $a1, $s1, $s0
		jal     sub_800514FC
		move    $a2, $s0
		j       loc_80050B28
		addiu   $a1, $s1, -8

		loc_80050AB8:
	bne     $s2, $v0, loc_80050AD4
		li      $v0, 0x2C  # ','
		move    $a0, $s0
		jal     sub_8005A91C
		move    $a1, $s1
		j       loc_80050B28
		addiu   $a1, $s1, -8

		loc_80050AD4:
	bne     $s2, $v0, loc_80050AF4
		li      $v0, 4
		addiu   $a0, $s1, -8
		subu    $a1, $s1, $s0
		jal     sub_80051A6C
		move    $a2, $s0
		j       loc_80050B28
		addiu   $a1, $s1, -8

		loc_80050AF4:
	bne     $s2, $v0, loc_80050B10
		li      $v0, 0x2F  # '/'
		move    $a0, $s0
		jal     sub_80052CA8
		subu    $a1, $s1, $a0
		j       loc_80050B28
		addiu   $a1, $s1, -8

		loc_80050B10:
	bne     $s2, $v0, loc_80050B28
		addiu   $a1, $s1, -8
		move    $a0, $s0
		jal     sub_80052E54
		subu    $a1, $s1, $a0
		addiu   $a1, $s1, -8

		loc_80050B28:
	lw      $a0, 0x18 + var_8($sp)
		lw      $a3, 0x18 + var_4($sp)
		jal     sub_8005088C
		move    $a2, $s2
		j       loc_80050B44
		nop

		loc_80050B40 :
	li      $s5, 1

		loc_80050B44 :
		beqz    $s5, loc_8005099C
		nop
		lw      $ra, 0x18 + var_s1C($sp)
		lw      $s6, 0x18 + var_s18($sp)
		lw      $s5, 0x18 + var_s14($sp)
		lw      $s4, 0x18 + var_s10($sp)
		lw      $s3, 0x18 + var_sC($sp)
		lw      $s2, 0x18 + var_s8($sp)
		lw      $s1, 0x18 + var_s4($sp)
		lw      $s0, 0x18 + var_s0($sp)
		sw      $zero, -0x3900($gp)//newMemTracker.doingGarbageCollection
		jr      $ra
		addiu   $sp, 0x38
		# End of function sub_80050960
#endif
}


// autogenerated function stub: 
// void /*$ra*/ MEMPACK_RelocateAreaType(struct MemHeader *newAddress /*$a0*/, long offset /*$s1*/, struct Level *oldLevel /*$s3*/)
void MEMPACK_RelocateAreaType(struct MemHeader *newAddress, long offset, struct Level *oldLevel)
{ // line 1163, offset 0x800505bc
	/* begin block 1 */
		// Start line: 1164
		// Start offset: 0x800505BC
		// Variables:
			struct Level *level; // $s0
			struct _MultiSignal *msignal; // $a0
			long sizeOfLevel; // $s2
			long i; // $t0
			long d; // $a3

		/* begin block 1.1 */
			// Start line: 1229
			// Start offset: 0x800508DC
			// Variables:
				struct _Terrain *terrain; // $t1

			/* begin block 1.1.1 */
				// Start line: 1257
				// Start offset: 0x800509F8
				// Variables:
					struct Intro *intro; // $v0

				/* begin block 1.1.1.1 */
					// Start line: 1267
					// Start offset: 0x80050A34
					// Variables:
						struct MultiSpline *multiSpline; // $a2
				/* end block 1.1.1.1 */
				// End offset: 0x80050B28
				// End Line: 1290
			/* end block 1.1.1 */
			// End offset: 0x80050B3C
			// End Line: 1292

			/* begin block 1.1.2 */
				// Start line: 1310
				// Start offset: 0x80050B64
				// Variables:
					struct DrMoveAniTexDestInfo **dest; // $v0
			/* end block 1.1.2 */
			// End offset: 0x80050BB8
			// End Line: 1320

			/* begin block 1.1.3 */
				// Start line: 1363
				// Start offset: 0x80050C1C
				// Variables:
					struct _VMObject *vmo; // $a1
			/* end block 1.1.3 */
			// End offset: 0x80050CF4
			// End Line: 1374

			/* begin block 1.1.4 */
				// Start line: 1361
				// Start offset: 0x80050D0C
				// Variables:
					struct BSPTree *bsp; // $t2
					struct _BSPNode *node; // $a2
					struct _BSPLeaf *leaf; // $a1
			/* end block 1.1.4 */
			// End offset: 0x80050E24
			// End Line: 1401
		/* end block 1.1 */
		// End offset: 0x80050E24
		// End Line: 1403
	/* end block 1 */
	// End offset: 0x80050E58
	// End Line: 1421

	/* begin block 2 */
		// Start line: 2348
	/* end block 2 */
	// End Line: 2349

}


// autogenerated function stub: 
// void /*$ra*/ MEMPACK_RelocateG2AnimKeylistType(struct _G2AnimKeylist_Type **pKeylist /*$a0*/, int offset /*$a1*/, char *start /*$a2*/, char *end /*$a3*/)
void MEMPACK_RelocateG2AnimKeylistType(struct _G2AnimKeylist_Type **pKeylist, int offset, char *start, char *end)
{ // line 1432, offset 0x80050ea0
	struct _G2AnimKeylist_Type* v4; // eax
	struct _G2AnimKeylist_Type* v5; // esi
	struct _G2AnimFxHeader_Type* fxList; // eax
	int v7; // edx
	unsigned __int16** sectionData; // eax
	unsigned __int16* v9; // ecx

	v4 = *pKeylist;
	if (*pKeylist >= (struct _G2AnimKeylist_Type*)start && v4 < (struct _G2AnimKeylist_Type*)end)
	{
		v5 = v4 ? (struct _G2AnimKeylist_Type*)((char*)v4 + offset) : 0;
		*pKeylist = v5;
		if (*(DWORD*)&v5->sectionCount != 0xFACE0FF)
		{
			fxList = v5->fxList;
			if (fxList)
				fxList = (struct _G2AnimFxHeader_Type*)((char*)fxList + offset);
			v5->fxList = fxList;
			v7 = 0;
			if (v5->sectionCount)
			{
				sectionData = v5->sectionData;
				do
				{
					v9 = *sectionData;
					if (*sectionData)
						v9 = (unsigned __int16*)((char*)v9 + offset);
					*sectionData = v9;
					++v7;
					++sectionData;
				} while (v7 < v5->sectionCount);
			}
		}
	}
}


// autogenerated function stub: 
// void /*$ra*/ MEMPACK_RelocateObjectType(struct MemHeader *newAddress /*$a0*/, long offset /*$s0*/, struct Object *oldObject /*$s3*/)
void MEMPACK_RelocateObjectType(struct MemHeader *newAddress, long offset, struct Object *oldObject)
{ // line 1455, offset 0x80050f40
	/* begin block 1 */
		// Start line: 1456
		// Start offset: 0x80050F40
		// Variables:
			struct _Instance *instance; // $a1
			struct Object *object; // $s1
			int i; // $s2
			int j; // $a2
			int d; // $a3
			int sizeOfObject; // $s4
			struct _Model *model; // $t0

		/* begin block 1.1 */
			// Start line: 1502
			// Start offset: 0x80051140
			// Variables:
				struct _MFace *mface; // $a0
		/* end block 1.1 */
		// End offset: 0x80051178
		// End Line: 1507

		/* begin block 1.2 */
			// Start line: 1511
			// Start offset: 0x800511A0
			// Variables:
				struct _Segment *segment; // $v0

			/* begin block 1.2.1 */
				// Start line: 1515
				// Start offset: 0x800511C8
				// Variables:
					struct _HInfo *hInfo; // $v1
			/* end block 1.2.1 */
			// End offset: 0x8005120C
			// End Line: 1519
		/* end block 1.2 */
		// End offset: 0x8005120C
		// End Line: 1520

		/* begin block 1.3 */
			// Start line: 1522
			// Start offset: 0x80051230
			// Variables:
				struct AniTexInfo *aniTexInfo; // $a0
		/* end block 1.3 */
		// End offset: 0x80051278
		// End Line: 1531

		/* begin block 1.4 */
			// Start line: 1535
			// Start offset: 0x80051288
			// Variables:
				struct MultiSpline *multiSpline; // $v0
		/* end block 1.4 */
		// End offset: 0x80051378
		// End Line: 1557
	/* end block 1 */
	// End offset: 0x80051480
	// End Line: 1607

	/* begin block 2 */
		// Start line: 3084
	/* end block 2 */
	// End Line: 3085

}


// autogenerated function stub: 
// void /*$ra*/ MEMPACK_RelocateCDMemory(struct MemHeader *newAddress /*$a0*/, long offset /*$a1*/, struct _BigFileDir *oldDir /*$a2*/)
void MEMPACK_RelocateCDMemory(struct MemHeader *newAddress, long offset, struct _BigFileDir *oldDir)
{ // line 1617, offset 0x800514b0
	/* begin block 1 */
		// Start line: 1618
		// Start offset: 0x800514B0
		// Variables:
			struct _BigFileDir *newDir; // $a1
	/* end block 1 */
	// End offset: 0x800514B0
	// End Line: 1618

	/* begin block 2 */
		// Start line: 3234
	/* end block 2 */
	// End Line: 3235

}




