#include "THISDUST.H"
#include "MEMPACK.H"
#include "PSX/DRAWS.H"

void MEMPACK_Init()
{ 
#define ONE_MB 1048576
#define TWO_MB ONE_MB * 2
#define BASE_ADDRESS 0x80000000
#define PACK_MAGIC_USHORT(A, B, C, D) A << 12 | B << 8 | C << 4 | D << 0
#define DEFAULT_MEM_MAGIC PACK_MAGIC_USHORT(0xB, 0xA, 0xD, 0xE)

	newMemTracker.totalMemory = (BASE_ADDRESS + TWO_MB - (ONE_MB / 256)) - (unsigned int)overlayAddress;
	newMemTracker.rootNode = (MemHeader*)overlayAddress;
	newMemTracker.rootNode->magicNumber = DEFAULT_MEM_MAGIC;
	newMemTracker.rootNode->memStatus = 2;
	newMemTracker.rootNode->memType = 0;
	newMemTracker.rootNode->memSize = newMemTracker.totalMemory;
	newMemTracker.currentMemoryUsed = 0;
	newMemTracker.doingGarbageCollection = 0;
	newMemTracker.lastMemoryAddress = (char*)overlayAddress + (char*)newMemTracker.rootNode;
}


// autogenerated function stub: 
// struct MemHeader * /*$ra*/ MEMPACK_GetSmallestBlockTopBottom(long allocSize /*$a0*/)
struct MemHeader * MEMPACK_GetSmallestBlockTopBottom(long allocSize)
{ // line 250, offset 0x8004fb0c
	/* begin block 1 */
		// Start line: 252
		// Start offset: 0x8004FB0C
		// Variables:
			struct MemHeader *address; // $v1
			struct MemHeader *bestAddress; // $a1
	/* end block 1 */
	// End offset: 0x8004FB6C
	// End Line: 273

	/* begin block 2 */
		// Start line: 516
	/* end block 2 */
	// End Line: 517

	/* begin block 3 */
		// Start line: 532
	/* end block 3 */
	// End Line: 533

	/* begin block 4 */
		// Start line: 533
	/* end block 4 */
	// End Line: 534

	/* begin block 5 */
		// Start line: 535
	/* end block 5 */
	// End Line: 536

	return null;
}


// autogenerated function stub: 
// struct MemHeader * /*$ra*/ MEMPACK_GetSmallestBlockBottomTop(long allocSize /*$a0*/)
struct MemHeader * MEMPACK_GetSmallestBlockBottomTop(long allocSize)
{ // line 279, offset 0x8004fb74
	/* begin block 1 */
		// Start line: 281
		// Start offset: 0x8004FB74
		// Variables:
			struct MemHeader *address; // $v1
			struct MemHeader *bestAddress; // $a1
	/* end block 1 */
	// End offset: 0x8004FBD8
	// End Line: 309

	/* begin block 2 */
		// Start line: 590
	/* end block 2 */
	// End Line: 591

	/* begin block 3 */
		// Start line: 591
	/* end block 3 */
	// End Line: 592

	/* begin block 4 */
		// Start line: 593
	/* end block 4 */
	// End Line: 594

	return null;
}


// autogenerated function stub: 
// long /*$ra*/ MEMPACK_RelocatableType(long memType /*$a0*/)
long MEMPACK_RelocatableType(long memType)
{ // line 312, offset 0x8004fbe0
	/* begin block 1 */
		// Start line: 656
	/* end block 1 */
	// End Line: 657

	/* begin block 2 */
		// Start line: 657
	/* end block 2 */
	// End Line: 658

	return 0;
}


// autogenerated function stub: 
// char * /*$ra*/ MEMPACK_Malloc(unsigned long allocSize /*$s2*/, unsigned char memType /*$a1*/)
char * MEMPACK_Malloc(unsigned long allocSize, unsigned char memType)
{ // line 331, offset 0x8004fc18
	char* result; // eax

	result = (char*)MEMPACK_MallocFailOk(allocSize, memType);
	if (!result)
	{
		GXFilePrint("---------------------\n");
		MEMPACK_ReportMemory2();
		DEBUG_FatalError(
			"Trying to fit memory size %d Type = %d\nAvailable memory : used = %d, free = %d\n",
			allocSize,
			memType,
			mem_used,
			mem_total - mem_used);
	}
	return result;
}


// autogenerated function stub: 
// char * /*$ra*/ MEMPACK_MallocFailOk(unsigned long allocSize /*$s1*/, unsigned char memType /*$s3*/)
char * MEMPACK_MallocFailOk(unsigned long allocSize, unsigned char memType)
{ // line 349, offset 0x8004fc94
	/* begin block 1 */
		// Start line: 350
		// Start offset: 0x8004FC94
		// Variables:
			struct MemHeader *bestAddress; // $a1
			long relocatableMemory; // $s2

		/* begin block 1.1 */
			// Start line: 378
			// Start offset: 0x8004FD18
			// Variables:
				int curMem; // $s0
		/* end block 1.1 */
		// End offset: 0x8004FD34
		// End Line: 390

		/* begin block 1.2 */
			// Start line: 404
			// Start offset: 0x8004FD60
			// Variables:
				struct MemHeader *address; // $a2

			/* begin block 1.2.1 */
				// Start line: 424
				// Start offset: 0x8004FD94
				// Variables:
					long topOffset; // $a0
			/* end block 1.2.1 */
			// End offset: 0x8004FD94
			// End Line: 426
		/* end block 1.2 */
		// End offset: 0x8004FD94
		// End Line: 426
	/* end block 1 */
	// End offset: 0x8004FE04
	// End Line: 457

	/* begin block 2 */
		// Start line: 733
	/* end block 2 */
	// End Line: 734

	return null;
}


// autogenerated function stub: 
// void /*$ra*/ MEMORY_MergeAddresses(struct MemHeader *firstAddress /*$a0*/, struct MemHeader *secondAddress /*$a1*/)
void MEMORY_MergeAddresses(struct MemHeader *firstAddress, struct MemHeader *secondAddress)
{ // line 461, offset 0x8004fe20
	/* begin block 1 */
		// Start line: 963
	/* end block 1 */
	// End Line: 964

	/* begin block 2 */
		// Start line: 969
	/* end block 2 */
	// End Line: 970

}


// autogenerated function stub: 
// void /*$ra*/ MEMPACK_Return(char *address /*$a0*/, long takeBackSize /*$a1*/)
void MEMPACK_Return(char *address, long takeBackSize)
{ // line 480, offset 0x8004fe68
	/* begin block 1 */
		// Start line: 481
		// Start offset: 0x8004FE68
		// Variables:
			struct MemHeader *memAddress; // $a0
			struct MemHeader *nextAddress; // $a1
	/* end block 1 */
	// End offset: 0x8004FEDC
	// End Line: 508

	/* begin block 2 */
		// Start line: 1002
	/* end block 2 */
	// End Line: 1003

}


// autogenerated function stub: 
// void /*$ra*/ MEMPACK_Free(char *address /*$a0*/)
void MEMPACK_Free(char *address)
{ // line 539, offset 0x8004feec
	/* begin block 1 */
		// Start line: 540
		// Start offset: 0x8004FEEC
		// Variables:
			struct MemHeader *memAddress; // $s0
			struct MemHeader *secondAddress; // $v1
	/* end block 1 */
	// End offset: 0x8004FF8C
	// End Line: 584

	/* begin block 2 */
		// Start line: 1078
	/* end block 2 */
	// End Line: 1079

}


// autogenerated function stub: 
// void /*$ra*/ MEMPACK_FreeByType(unsigned char memType /*$a0*/)
void MEMPACK_FreeByType(unsigned char memType)
{ // line 586, offset 0x8004ff9c
	/* begin block 1 */
		// Start line: 587
		// Start offset: 0x8004FF9C
		// Variables:
			struct MemHeader *address; // $a0
			int freed; // $s0
	/* end block 1 */
	// End offset: 0x8005001C
	// End Line: 608

	/* begin block 2 */
		// Start line: 1187
	/* end block 2 */
	// End Line: 1188

}


// autogenerated function stub: 
// unsigned long /*$ra*/ MEMPACK_Size(char *address /*$a0*/)
unsigned long MEMPACK_Size(char *address)
{ // line 611, offset 0x80050034
	return *((DWORD*)address - 1) - 8;
}


// autogenerated function stub: 
// unsigned long /*$ra*/ MEMPACK_ReportFreeMemory()
unsigned long MEMPACK_ReportFreeMemory()
{ // line 621, offset 0x80050040
	return mem_total - mem_used;
}


// autogenerated function stub: 
// void /*$ra*/ MEMPACK_ReportMemory2()
void MEMPACK_ReportMemory2()
{ // line 689, offset 0x80050050
	GXFilePrint("----- Memory Map -----\n");
	for (i = dword_C550A8; i != dword_C550B4; i += *(DWORD*)(i + 4))
	{
		if (*(BYTE*)(i + 2))
		{
			if (*(BYTE*)(i + 3) == 1)
			{
				GXFilePrint("CLOSED) addr %x size=%d type=OBJECT : %s\n", i, *(_DWORD*)(i + 4), *(_DWORD*)(i + 44));
			}
			else if (*(BYTE*)(i + 3) == 2)
			{
				GXFilePrint("CLOSED) addr %x size=%d type=AREA : %s\n", i, *(_DWORD*)(i + 4), *(_DWORD*)(i + 160));
			}
			else
			{
				GXFilePrint("CLOSED) addr %x size=%d type=%d\n", i, *(_DWORD*)(i + 4), *(unsigned __int8*)(i + 3));
			}
		}
		else
		{
			GXFilePrint("OPEN) addr %x size=%d\n", i, *(DWORD*)(i + 4));
		}
	}
	GXFilePrint("Total Memory Used = %d, Total Memory Free = %d\n", mem_used, mem_total - mem_used);
}


// autogenerated function stub: 
// void /*$ra*/ MEMPACK_ReportMemory()
void MEMPACK_ReportMemory()
{ // line 727, offset 0x80050080
	/* begin block 1 */
		// Start line: 729
		// Start offset: 0x80050080
		// Variables:
			struct MemHeader *address; // $v1
			long i; // $a1
			long firstTime; // $a0
	/* end block 1 */
	// End offset: 0x80050114
	// End Line: 799

	/* begin block 2 */
		// Start line: 1413
	/* end block 2 */
	// End Line: 1414

	/* begin block 3 */
		// Start line: 1414
	/* end block 3 */
	// End Line: 1415

	/* begin block 4 */
		// Start line: 1421
	/* end block 4 */
	// End Line: 1422

}


// autogenerated function stub: 
// void /*$ra*/ MEMPACK_SetMemoryBeingStreamed(char *address /*$a0*/)
void MEMPACK_SetMemoryBeingStreamed(char *address)
{ // line 801, offset 0x8005011c
	/* begin block 1 */
		// Start line: 803
		// Start offset: 0x8005011C
	/* end block 1 */
	// End offset: 0x8005011C
	// End Line: 808

	/* begin block 2 */
		// Start line: 1597
	/* end block 2 */
	// End Line: 1598

	/* begin block 3 */
		// Start line: 1598
	/* end block 3 */
	// End Line: 1599

	/* begin block 4 */
		// Start line: 1603
	/* end block 4 */
	// End Line: 1604

}

void MEMPACK_SetMemoryDoneStreamed(char *address)
{ 
	address[-6] = 1;
}


// autogenerated function stub: 
// long /*$ra*/ MEMPACK_MemoryValidFunc(char *address /*$a0*/)
long MEMPACK_MemoryValidFunc(char *address)
{ // line 826, offset 0x80050134
	return address != (char*)0xFAFBFCFD && address && *(address - 6) == 1;
}


// autogenerated function stub: 
// char * /*$ra*/ MEMPACK_GarbageCollectMalloc(unsigned long *allocSize /*$s1*/, unsigned char memType /*$s2*/, unsigned long *freeSize /*$s3*/)
char * MEMPACK_GarbageCollectMalloc(unsigned long *allocSize, unsigned char memType, unsigned long *freeSize)
{ // line 855, offset 0x80050168
	/* begin block 1 */
		// Start line: 856
		// Start offset: 0x80050168
		// Variables:
			struct MemHeader *bestAddress; // $s0
	/* end block 1 */
	// End offset: 0x800502AC
	// End Line: 918

	/* begin block 2 */
		// Start line: 1705
	/* end block 2 */
	// End Line: 1706

	return null;
}


// autogenerated function stub: 
// void /*$ra*/ MEMPACK_GarbageSplitMemoryNow(unsigned long allocSize /*$a0*/, struct MemHeader *bestAddress /*$a1*/, long memType /*$a2*/, unsigned long freeSize /*$a3*/)
void MEMPACK_GarbageSplitMemoryNow(unsigned long allocSize, struct MemHeader *bestAddress, long memType, unsigned long freeSize)
{ // line 921, offset 0x800502cc
	if (freeSize)
	{
		*(unsigned __int16*)((char*)&bestAddress->magicNumber + allocSize) = 0xBADE;
		*(&bestAddress->memStatus + allocSize) = 0;
		*(&bestAddress->memType + allocSize) = 0;
		*(unsigned int*)((char*)&bestAddress->memSize + allocSize) = freeSize;
	}
}


// autogenerated function stub: 
// void /*$ra*/ MEMPACK_GarbageCollectFree(struct MemHeader *memAddress /*$s0*/)
void MEMPACK_GarbageCollectFree(struct MemHeader *memAddress)
{ // line 940, offset 0x800502f0
	/* begin block 1 */
		// Start line: 941
		// Start offset: 0x800502F0
		// Variables:
			struct MemHeader *secondAddress; // $v1
	/* end block 1 */
	// End offset: 0x80050390
	// End Line: 977

	/* begin block 2 */
		// Start line: 1880
	/* end block 2 */
	// End Line: 1881

}


// autogenerated function stub: 
// void /*$ra*/ MEMPACK_DoGarbageCollection()
void MEMPACK_DoGarbageCollection()
{ // line 998, offset 0x800503a0
	/* begin block 1 */
		// Start line: 999
		// Start offset: 0x800503A0
		// Variables:
			struct MemHeader *relocateAddress; // $s0
			long foundOpening; // $s1
			long done; // $s5
			long addressSize; // $s3
			long addressMemType; // $s2
			long holdSize; // stack offset -40
			long freeSize; // stack offset -36
			char *oldAddress; // $s0
			char *newAddress; // $s1
	/* end block 1 */
	// End offset: 0x80050590
	// End Line: 1131

	/* begin block 2 */
		// Start line: 1996
	/* end block 2 */
	// End Line: 1997

}


// autogenerated function stub: 
// void /*$ra*/ MEMPACK_RelocateAreaType(struct MemHeader *newAddress /*$a0*/, long offset /*$s1*/, struct Level *oldLevel /*$s3*/)
void MEMPACK_RelocateAreaType(struct MemHeader *newAddress, long offset, struct Level *oldLevel)
{ // line 1163, offset 0x800505bc
	/* begin block 1 */
		// Start line: 1164
		// Start offset: 0x800505BC
		// Variables:
			struct Level *level; // $s0
			struct _MultiSignal *msignal; // $a0
			long sizeOfLevel; // $s2
			long i; // $t0
			long d; // $a3

		/* begin block 1.1 */
			// Start line: 1229
			// Start offset: 0x800508DC
			// Variables:
				struct _Terrain *terrain; // $t1

			/* begin block 1.1.1 */
				// Start line: 1257
				// Start offset: 0x800509F8
				// Variables:
					struct Intro *intro; // $v0

				/* begin block 1.1.1.1 */
					// Start line: 1267
					// Start offset: 0x80050A34
					// Variables:
						struct MultiSpline *multiSpline; // $a2
				/* end block 1.1.1.1 */
				// End offset: 0x80050B28
				// End Line: 1290
			/* end block 1.1.1 */
			// End offset: 0x80050B3C
			// End Line: 1292

			/* begin block 1.1.2 */
				// Start line: 1310
				// Start offset: 0x80050B64
				// Variables:
					struct DrMoveAniTexDestInfo **dest; // $v0
			/* end block 1.1.2 */
			// End offset: 0x80050BB8
			// End Line: 1320

			/* begin block 1.1.3 */
				// Start line: 1363
				// Start offset: 0x80050C1C
				// Variables:
					struct _VMObject *vmo; // $a1
			/* end block 1.1.3 */
			// End offset: 0x80050CF4
			// End Line: 1374

			/* begin block 1.1.4 */
				// Start line: 1361
				// Start offset: 0x80050D0C
				// Variables:
					struct BSPTree *bsp; // $t2
					struct _BSPNode *node; // $a2
					struct _BSPLeaf *leaf; // $a1
			/* end block 1.1.4 */
			// End offset: 0x80050E24
			// End Line: 1401
		/* end block 1.1 */
		// End offset: 0x80050E24
		// End Line: 1403
	/* end block 1 */
	// End offset: 0x80050E58
	// End Line: 1421

	/* begin block 2 */
		// Start line: 2348
	/* end block 2 */
	// End Line: 2349

}


// autogenerated function stub: 
// void /*$ra*/ MEMPACK_RelocateG2AnimKeylistType(struct _G2AnimKeylist_Type **pKeylist /*$a0*/, int offset /*$a1*/, char *start /*$a2*/, char *end /*$a3*/)
void MEMPACK_RelocateG2AnimKeylistType(struct _G2AnimKeylist_Type **pKeylist, int offset, char *start, char *end)
{ // line 1432, offset 0x80050ea0
	struct _G2AnimKeylist_Type* v4; // eax
	struct _G2AnimKeylist_Type* v5; // esi
	struct _G2AnimFxHeader_Type* fxList; // eax
	int v7; // edx
	unsigned __int16** sectionData; // eax
	unsigned __int16* v9; // ecx

	v4 = *pKeylist;
	if (*pKeylist >= (struct _G2AnimKeylist_Type*)start && v4 < (struct _G2AnimKeylist_Type*)end)
	{
		v5 = v4 ? (struct _G2AnimKeylist_Type*)((char*)v4 + offset) : 0;
		*pKeylist = v5;
		if (*(DWORD*)&v5->sectionCount != 0xFACE0FF)
		{
			fxList = v5->fxList;
			if (fxList)
				fxList = (struct _G2AnimFxHeader_Type*)((char*)fxList + offset);
			v5->fxList = fxList;
			v7 = 0;
			if (v5->sectionCount)
			{
				sectionData = v5->sectionData;
				do
				{
					v9 = *sectionData;
					if (*sectionData)
						v9 = (unsigned __int16*)((char*)v9 + offset);
					*sectionData = v9;
					++v7;
					++sectionData;
				} while (v7 < v5->sectionCount);
			}
		}
	}
}


// autogenerated function stub: 
// void /*$ra*/ MEMPACK_RelocateObjectType(struct MemHeader *newAddress /*$a0*/, long offset /*$s0*/, struct Object *oldObject /*$s3*/)
void MEMPACK_RelocateObjectType(struct MemHeader *newAddress, long offset, struct Object *oldObject)
{ // line 1455, offset 0x80050f40
	/* begin block 1 */
		// Start line: 1456
		// Start offset: 0x80050F40
		// Variables:
			struct _Instance *instance; // $a1
			struct Object *object; // $s1
			int i; // $s2
			int j; // $a2
			int d; // $a3
			int sizeOfObject; // $s4
			struct _Model *model; // $t0

		/* begin block 1.1 */
			// Start line: 1502
			// Start offset: 0x80051140
			// Variables:
				struct _MFace *mface; // $a0
		/* end block 1.1 */
		// End offset: 0x80051178
		// End Line: 1507

		/* begin block 1.2 */
			// Start line: 1511
			// Start offset: 0x800511A0
			// Variables:
				struct _Segment *segment; // $v0

			/* begin block 1.2.1 */
				// Start line: 1515
				// Start offset: 0x800511C8
				// Variables:
					struct _HInfo *hInfo; // $v1
			/* end block 1.2.1 */
			// End offset: 0x8005120C
			// End Line: 1519
		/* end block 1.2 */
		// End offset: 0x8005120C
		// End Line: 1520

		/* begin block 1.3 */
			// Start line: 1522
			// Start offset: 0x80051230
			// Variables:
				struct AniTexInfo *aniTexInfo; // $a0
		/* end block 1.3 */
		// End offset: 0x80051278
		// End Line: 1531

		/* begin block 1.4 */
			// Start line: 1535
			// Start offset: 0x80051288
			// Variables:
				struct MultiSpline *multiSpline; // $v0
		/* end block 1.4 */
		// End offset: 0x80051378
		// End Line: 1557
	/* end block 1 */
	// End offset: 0x80051480
	// End Line: 1607

	/* begin block 2 */
		// Start line: 3084
	/* end block 2 */
	// End Line: 3085

}


// autogenerated function stub: 
// void /*$ra*/ MEMPACK_RelocateCDMemory(struct MemHeader *newAddress /*$a0*/, long offset /*$a1*/, struct _BigFileDir *oldDir /*$a2*/)
void MEMPACK_RelocateCDMemory(struct MemHeader *newAddress, long offset, struct _BigFileDir *oldDir)
{ // line 1617, offset 0x800514b0
	/* begin block 1 */
		// Start line: 1618
		// Start offset: 0x800514B0
		// Variables:
			struct _BigFileDir *newDir; // $a1
	/* end block 1 */
	// End offset: 0x800514B0
	// End Line: 1618

	/* begin block 2 */
		// Start line: 3234
	/* end block 2 */
	// End Line: 3235

}




