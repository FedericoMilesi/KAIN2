#include "CORE.H"
#include "MONSENSE.H"


// autogenerated function stub: 
// struct _MonsterIR * /*$ra*/ MONSENSE_FindIR(struct _MonsterVars *mv /*$a0*/, struct _Instance *instance /*$a1*/)
struct _MonsterIR * MONSENSE_FindIR(struct _MonsterVars *mv, struct _Instance *instance)
{ // line 64, offset 0x80085aa4
#if defined(PC_VERSION)
	struct _MonsterIR* mir; // eax

	for (mir = mv->monsterIRList; mir; mir = mir->next)
	{
		if (mir->instance == instance)
			break;
	}
	return mir;
#else
	return NULL;
#endif
}


// autogenerated function stub: 
// int /*$ra*/ MONSENSE_See(struct _Instance *instance /*$s2*/, struct evCollideInstanceStatsData *data /*$s1*/)
int MONSENSE_See(struct _Instance *instance, struct evCollideInstanceStatsData *data)
{ // line 97, offset 0x80085adc
	/* begin block 1 */
		// Start line: 98
		// Start offset: 0x80085ADC
		// Variables:
			struct _MonsterVars *mv; // $v0
			struct _MonsterSenses *senses; // $s0

		/* begin block 1.1 */
			// Start line: 104
			// Start offset: 0x80085B20
			// Variables:
				int arc; // $a1
				int elevation; // $a2

			/* begin block 1.1.1 */
				// Start line: 114
				// Start offset: 0x80085B70
				// Variables:
					struct _Instance *target; // $s0

				/* begin block 1.1.1.1 */
					// Start line: 118
					// Start offset: 0x80085B88
					// Variables:
						//struct evPhysicsLOSData losData; // stack offset -40

					/* begin block 1.1.1.1.1 */
						// Start line: 122
						// Start offset: 0x80085B98
						// Variables:
							MATRIX *mat; // $v0
					/* end block 1.1.1.1.1 */
					// End offset: 0x80085B98
					// End Line: 122

					/* begin block 1.1.1.1.2 */
						// Start line: 128
						// Start offset: 0x80085BD4
						// Variables:
							//short _x1; // $v1
							//short _y1; // $a0
							//short _z1; // $a1
							//_Position *_v0; // $v0
							//_Position *_v1; // $v0
					/* end block 1.1.1.1.2 */
					// End offset: 0x80085BF0
					// End Line: 128

					/* begin block 1.1.1.1.3 */
						// Start line: 132
						// Start offset: 0x80085C00
						// Variables:
							//MATRIX *mat; // $v1
					/* end block 1.1.1.1.3 */
					// End offset: 0x80085C00
					// End Line: 132

					/* begin block 1.1.1.1.4 */
						// Start line: 138
						// Start offset: 0x80085C24
						// Variables:
							//short _x1; // $v1
							//short _y1; // $a0
							//short _z1; // $a1
							//_Position *_v0; // $v0
							//_Position *_v1; // $v0
					/* end block 1.1.1.1.4 */
					// End offset: 0x80085C44
					// End Line: 138
				/* end block 1.1.1.1 */
				// End offset: 0x80085C5C
				// End Line: 141
			/* end block 1.1.1 */
			// End offset: 0x80085C5C
			// End Line: 144
		/* end block 1.1 */
		// End offset: 0x80085C5C
		// End Line: 145
	/* end block 1 */
	// End offset: 0x80085C60
	// End Line: 148

	/* begin block 2 */
		// Start line: 194
	/* end block 2 */
	// End Line: 195

	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ MONSENSE_Hear(struct _Instance *instance /*$a0*/, struct evCollideInstanceStatsData *data /*$s1*/)
int MONSENSE_Hear(struct _Instance *instance, struct evCollideInstanceStatsData *data)
{ // line 153, offset 0x80085c78
	/* begin block 1 */
		// Start line: 154
		// Start offset: 0x80085C78
		// Variables:
			struct _MonsterVars *mv; // $v0
			struct _MonsterSenses *senses; // $s0
			long mode; // $a0
	/* end block 1 */
	// End offset: 0x80085CF4
	// End Line: 171

	/* begin block 2 */
		// Start line: 270
	/* end block 2 */
	// End Line: 271

	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ MONSENSE_Smell(struct _Instance *instance /*$a0*/, struct evCollideInstanceStatsData *data /*$a1*/)
int MONSENSE_Smell(struct _Instance *instance, struct evCollideInstanceStatsData *data)
{ // line 176, offset 0x80085d08
	/* begin block 1 */
		// Start line: 178
		// Start offset: 0x80085D08
		// Variables:
			struct _MonsterVars *mv; // $v0
	/* end block 1 */
	// End offset: 0x80085D08
	// End Line: 178

	/* begin block 2 */
		// Start line: 319
	/* end block 2 */
	// End Line: 320

	/* begin block 3 */
		// Start line: 320
	/* end block 3 */
	// End Line: 321

	return 0;
}


// autogenerated function stub: 
// struct _MonsterIR * /*$ra*/ MONSENSE_FirstSense(struct _Instance *instance /*$s2*/, struct _Instance *sensed /*$s4*/)
struct _MonsterIR * MONSENSE_FirstSense(struct _Instance *instance, struct _Instance *sensed)
{ // line 186, offset 0x80085d30
#if defined(PC_VERSION)
	struct _MonsterVars* mv; // edi
	struct _MonsterIR* mir; // esi
	unsigned int v5; // ebx
	struct _Instance* allegiances; // eax MAPDST
	unsigned __int16 mirFlags; // ax

	mv = (struct _MonsterVars*)instance->extraData;
	mir = mv->freeIRs;
	if (mir)
		mv->freeIRs = mir->next;
	else
		mir = 0;
	if (mir)
	{
		v5 = INSTANCE_Query(sensed, 1);
		allegiances = (struct _Instance*)mv->subAttr->allegiances;
		mir->mirFlags = 256;
		mir->instance = sensed;
		mir->handle = sensed->instanceID;
		mir->forgetTimer = MON_GetTime(instance) + 1000 * mv->subAttr->forgetTime;
		mir->next = mv->monsterIRList;
		mv->monsterIRList = mir;
		mir->mirConditions = 0;
		if ((v5 & (unsigned int)allegiances->node.prev) != 0 && (INSTANCE_Query(sensed, 0) & 0x44000000) == 0)
			mir->mirFlags |= 1u;
		if ((v5 & (unsigned int)allegiances->node.next) != 0)
		{
			mir->mirFlags |= 2u;
			mirFlags = mir->mirFlags;
			if ((v5 & 0xA) != 0 && (*(DWORD*)sensed->extraData & 0x100000) != 0)
			{
				mirFlags = mirFlags | 0x10;
				mir->mirFlags = mirFlags;
			}
		}
		if ((v5 & (unsigned int)allegiances->next) != 0)
			mir->mirFlags |= 9u;
		if ((v5 & (unsigned int)allegiances->prev) != 0)
			mir->mirFlags |= 4u;
	}
	return mir;
#else
	return NULL;
#endif
}


// autogenerated function stub: 
// void /*$ra*/ MONSENSE_SetupMIR(struct _Instance *instance /*$s3*/, struct evCollideInstanceStatsData *data /*$s1*/, int flags /*$s2*/)
void MONSENSE_SetupMIR(struct _Instance *instance, struct evCollideInstanceStatsData *data, int flags)
{ // line 233, offset 0x80085ed4
#if defined(PC_VERSION)
	struct _Instance* v3; // ecx
	struct _MonsterVars* mv; // ebp MAPDST
	struct _MonsterIR* mir; // esi
	struct _MonsterCombatAttributes* combatAttributes; // eax
	_Position* p_position; // edi
	unsigned int v8; // ebp
	unsigned __int16 mirFlags; // ax
	unsigned __int16 mirConditions; // ax
	struct _MonsterCombatAttributes* v11; // eax
	int v12; // eax
	unsigned __int16 v13; // ax

	v3 = instance;
	mv = (struct _MonsterVars*)instance->extraData;
	for (mir = mv->monsterIRList; mir; mir = mir->next)
	{
		if (mir->instance == data->instance)
			break;
	}
	if (mir)
	{
		if (!flags)
			goto LABEL_10;
		mir->forgetTimer = MON_GetTime(instance) + 1000 * mv->subAttr->forgetTime;
	}
	else
	{
		if (!flags)
			goto LABEL_10;
		mir = MONSENSE_FirstSense(instance, data->instance);
	}
	v3 = instance;
LABEL_10:
	if (mir)
	{
		mir->mirFlags |= flags;
		mir->distance = data->distance;
		mir->relativePosition.x = data->relativePosition.x;
		mir->relativePosition.y = data->relativePosition.y;
		mir->relativePosition.z = data->relativePosition.z;
		combatAttributes = mv->subAttr->combatAttributes;
		if (combatAttributes && combatAttributes->combatRange > mir->distance)
			mir->mirConditions |= 8u;
		else
			mir->mirConditions &= ~8u;
		p_position = &v3->position;
		if (((1024 - mir->instance->rotation.z + MATH3D_AngleFromPosToPos(&mir->instance->position, &v3->position)) & 0xFFFu) <= 0x800)
			mir->mirConditions &= ~2u;
		else
			mir->mirConditions |= 2u;
		v8 = INSTANCE_Query(mir->instance, 10);
		if ((v8 & 0x208000) == 0x208000)
			v8 &= ~0x200000u;
		if ((v8 & 4) != 0)
			mir->mirConditions |= 1u;
		else
			mir->mirConditions &= ~1u;
		if ((mir->mirFlags & 0x400) != 0)
		{
			if ((v8 & 0x200000) == 0)
			{
				mir->mirFlags &= ~0x400u;
				mirFlags = mir->mirFlags;
				mir->mirConditions &= 0xF7DFu;
				if ((mirFlags & 1) != 0)
				{
					mirConditions = mir->mirConditions;
					if ((mirConditions & 0x400) == 0)
					{
						mirConditions = mirConditions | 4;
						mir->mirConditions = mirConditions;
					}
				}
			}
		}
		else if ((v8 & 0x200000) != 0)
		{
			v11 = mv->subAttr->combatAttributes;
			if (v11)
			{
				v12 = (v8 & 4) != 0 ? v11->enemyRunAttackRange : v11->enemyAttackRange;
				mir->mirFlags |= 0x400u;
				mir->mirConditions &= 0xFF1Bu;
				if (mir->distance < v12
					&& ((512 - mir->instance->rotation.z + MATH3D_AngleFromPosToPos(&mir->instance->position, p_position)) & 0xFFFu) < 0x800)
				{
					if ((v8 & 4) != 0)
						mir->mirConditions |= 0x20u;
					mir->mirConditions |= 0x800u;
				}
			}
		}
		if ((mir->mirFlags & 0x800) != 0)
		{
			if (v8 == 1)
			{
				if ((mir->mirConditions & 0x10) == 0 && mir->idleTime < MON_GetTime(instance))
					mir->mirConditions |= 0x10u;
			}
			else
			{
				mir->mirConditions &= ~0x10u;
				mir->mirFlags &= ~0x800u;
			}
		}
		else if (v8 == 1)
		{
			mir->mirFlags |= 0x800u;
			mir->idleTime = MON_GetTime(instance) + 4950;
		}
		v13 = mir->mirFlags;
		if ((v13 & 0x200) != 0)
		{
			if (mir->distance > mv->subAttr->combatAttributes->allyRange + 300
				|| (INSTANCE_Query(mir->instance, 0) & 0x44000000) != 0)
			{
				mir->mirFlags &= ~0x200u;
			}
		}
		else if ((v13 & 2) != 0 && mir->distance < mv->subAttr->combatAttributes->allyRange)
		{
			v13 |= 0x200u;
			mir->mirFlags = v13;
		}
	}
#endif
}


// autogenerated function stub: 
// void /*$ra*/ MONSENSE_SenseInstance(struct _Instance *instance /*$s3*/, struct evCollideInstanceStatsData *data /*$s2*/)
void MONSENSE_SenseInstance(struct _Instance *instance, struct evCollideInstanceStatsData *data)
{ // line 374, offset 0x80086300
	/* begin block 1 */
		// Start line: 375
		// Start offset: 0x80086300
		// Variables:
			struct _MonsterVars *mv; // $s1
			long flags; // $s0
			unsigned long whatAmI; // $s4

		/* begin block 1.1 */
			// Start line: 387
			// Start offset: 0x80086358
			// Variables:
				struct PhysObProperties *prop; // $s0

			/* begin block 1.1.1 */
				// Start line: 390
				// Start offset: 0x80086378
			/* end block 1.1.1 */
			// End offset: 0x80086418
			// End Line: 401
		/* end block 1.1 */
		// End offset: 0x80086418
		// End Line: 401
	/* end block 1 */
	// End offset: 0x800864D4
	// End Line: 419

	/* begin block 2 */
		// Start line: 735
	/* end block 2 */
	// End Line: 736

}


// autogenerated function stub: 
// void /*$ra*/ MONSENSE_StartMonsterIRList(struct _Instance *instance /*$s5*/)
void MONSENSE_StartMonsterIRList(struct _Instance *instance)
{ // line 424, offset 0x800864f4
	/* begin block 1 */
		// Start line: 425
		// Start offset: 0x800864F4
		// Variables:
			struct _MonsterVars *mv; // $s1
			struct _MonsterIR *mir; // $s0
			struct _MonsterIR *newlist; // $s2
			int enemyOnList; // $s4

		/* begin block 1.1 */
			// Start line: 435
			// Start offset: 0x80086540
			// Variables:
				struct _MonsterIR *next; // $s3
		/* end block 1.1 */
		// End offset: 0x800865C8
		// End Line: 463
	/* end block 1 */
	// End offset: 0x800865E4
	// End Line: 471

	/* begin block 2 */
		// Start line: 839
	/* end block 2 */
	// End Line: 840

}


// autogenerated function stub: 
// struct _MonsterIR * /*$ra*/ MONSENSE_GetMonsterIR(struct _MonsterVars *mv /*$a0*/)
struct _MonsterIR * MONSENSE_GetMonsterIR(struct _MonsterVars *mv)
{ // line 476, offset 0x80086608
	/* begin block 1 */
		// Start line: 478
		// Start offset: 0x80086608
		// Variables:
			struct _MonsterIR *mir; // $v1
	/* end block 1 */
	// End offset: 0x80086628
	// End Line: 488

	/* begin block 2 */
		// Start line: 975
	/* end block 2 */
	// End Line: 976

	/* begin block 3 */
		// Start line: 976
	/* end block 3 */
	// End Line: 977

	/* begin block 4 */
		// Start line: 978
	/* end block 4 */
	// End Line: 979

	return null;
}


// autogenerated function stub: 
// void /*$ra*/ MONSENSE_InitIRList(struct _MonsterVars *mv /*$a0*/, struct _MonsterIR *list /*$a1*/, int num /*$a2*/)
void MONSENSE_InitIRList(struct _MonsterVars *mv, struct _MonsterIR *list, int num)
{ // line 494, offset 0x80086630
	/* begin block 1 */
		// Start line: 496
		// Start offset: 0x80086630
		// Variables:
			int i; // $a2
	/* end block 1 */
	// End offset: 0x80086650
	// End Line: 505

	/* begin block 2 */
		// Start line: 1011
	/* end block 2 */
	// End Line: 1012

	/* begin block 3 */
		// Start line: 1012
	/* end block 3 */
	// End Line: 1013

	/* begin block 4 */
		// Start line: 1016
	/* end block 4 */
	// End Line: 1017

}


// autogenerated function stub: 
// struct _MonsterIR * /*$ra*/ MONSENSE_SetEnemy(struct _Instance *instance /*$s1*/, struct _Instance *newenemy /*$s2*/)
struct _MonsterIR * MONSENSE_SetEnemy(struct _Instance *instance, struct _Instance *newenemy)
{ // line 512, offset 0x8008665c
	/* begin block 1 */
		// Start line: 513
		// Start offset: 0x8008665C
		// Variables:
			struct _MonsterVars *mv; // $s0
			struct _MonsterIR *mir; // $a2

		/* begin block 1.1 */
			// Start line: 532
			// Start offset: 0x800866D0
			// Variables:
				long angle; // $v0
		/* end block 1.1 */
		// End offset: 0x8008672C
		// End Line: 538
	/* end block 1 */
	// End offset: 0x80086760
	// End Line: 548

	/* begin block 2 */
		// Start line: 1049
	/* end block 2 */
	// End Line: 1050

	return null;
}


// autogenerated function stub: 
// void /*$ra*/ MONSENSE_ProcessIRList(struct _Instance *instance /*$s7*/)
void MONSENSE_ProcessIRList(struct _Instance *instance)
{ // line 554, offset 0x8008677c
	/* begin block 1 */
		// Start line: 555
		// Start offset: 0x8008677C
		// Variables:
			struct _MonsterVars *mv; // $s4
			struct _MonsterIR *mir; // $s0
			struct _MonsterIR *closestEnemy; // $s1
			struct _MonsterIR *closestLeader; // $s2
			struct _MonsterIR *closestAlly; // $s3
			struct _MonsterIR *player; // $s6
			struct _MonsterCombatAttributes *combatAttr; // $s5
	/* end block 1 */
	// End offset: 0x80086968
	// End Line: 612

	/* begin block 2 */
		// Start line: 1138
	/* end block 2 */
	// End Line: 1139

}


// autogenerated function stub: 
// void /*$ra*/ MONSENSE_SetupSenses(struct _Instance *instance /*$s2*/)
void MONSENSE_SetupSenses(struct _Instance *instance)
{ // line 630, offset 0x8008699c
	/* begin block 1 */
		// Start line: 631
		// Start offset: 0x8008699C
		// Variables:
			struct _MonsterVars *mv; // $s1
			struct _MonsterAllegiances *allegiances; // $s0
			int num; // $v0
	/* end block 1 */
	// End offset: 0x80086AF0
	// End Line: 697

	/* begin block 2 */
		// Start line: 1260
	/* end block 2 */
	// End Line: 1261

}


// autogenerated function stub: 
// void /*$ra*/ MONSENSE_RemoveSenses(struct _Instance *instance /*$a0*/)
void MONSENSE_RemoveSenses(struct _Instance *instance)
{ // line 702, offset 0x80086b08
	/* begin block 1 */
		// Start line: 704
		// Start offset: 0x80086B08
		// Variables:
			struct _MonsterVars *mv; // $a0
			int i; // $a1
	/* end block 1 */
	// End offset: 0x80086BA0
	// End Line: 723

	/* begin block 2 */
		// Start line: 1541
	/* end block 2 */
	// End Line: 1542

	/* begin block 3 */
		// Start line: 1542
	/* end block 3 */
	// End Line: 1543

	/* begin block 4 */
		// Start line: 1547
	/* end block 4 */
	// End Line: 1548

}


// autogenerated function stub: 
// void /*$ra*/ MONSENSE_Radar(struct _Instance *instance /*$s0*/)
void MONSENSE_Radar(struct _Instance *instance)
{ // line 847, offset 0x80086ba8
	/* begin block 1 */
		// Start line: 848
		// Start offset: 0x80086BA8
		// Variables:
			struct _MonsterVars *mv; // $s1
			SVECTOR newPos; // stack offset -96
			SVECTOR oldPos; // stack offset -88
			//struct _PCollideInfo pCollideInfo; // stack offset -80
			int index; // $s3
	/* end block 1 */
	// End offset: 0x80086DC0
	// End Line: 919

	/* begin block 2 */
		// Start line: 1840
	/* end block 2 */
	// End Line: 1841

}


// autogenerated function stub: 
// short /*$ra*/ MONSENSE_GetClosestFreeDirection(struct _Instance *instance /*$a0*/, short angle /*$t1*/, long range /*$a2*/)
short MONSENSE_GetClosestFreeDirection(struct _Instance *instance, short angle, long range)
{ // line 924, offset 0x80086de4
	/* begin block 1 */
		// Start line: 925
		// Start offset: 0x80086DE4
		// Variables:
			struct _MonsterVars *mv; // $t0
			int bit; // $a1
			int search; // $a0
	/* end block 1 */
	// End offset: 0x80086EE0
	// End Line: 958

	/* begin block 2 */
		// Start line: 2013
	/* end block 2 */
	// End Line: 2014

	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ MONSENSE_GetDistanceInDirection(struct _Instance *instance /*$a0*/, short angle /*$a1*/)
int MONSENSE_GetDistanceInDirection(struct _Instance *instance, short angle)
{ // line 963, offset 0x80086ee8
	/* begin block 1 */
		// Start line: 965
		// Start offset: 0x80086EE8
		// Variables:
			struct _MonsterVars *mv; // $v1
			int bit; // $v0
	/* end block 1 */
	// End offset: 0x80086F08
	// End Line: 966

	/* begin block 2 */
		// Start line: 2096
	/* end block 2 */
	// End Line: 2097

	/* begin block 3 */
		// Start line: 2097
	/* end block 3 */
	// End Line: 2098

	/* begin block 4 */
		// Start line: 2098
	/* end block 4 */
	// End Line: 2099

	return 0;
}


// autogenerated function stub: 
// void /*$ra*/ MONSENSE_DoSenses(struct _Instance *instance /*$s1*/)
void MONSENSE_DoSenses(struct _Instance *instance)
{ // line 974, offset 0x80086f20
	/* begin block 1 */
		// Start line: 975
		// Start offset: 0x80086F20
		// Variables:
			struct _MonsterVars *mv; // $s0
			static int doneThisFrame; // offset 0x44
	/* end block 1 */
	// End offset: 0x80087004
	// End Line: 1005

	/* begin block 2 */
		// Start line: 2119
	/* end block 2 */
	// End Line: 2120

}


// autogenerated function stub: 
// void /*$ra*/ MONSENSE_AdjustRadarFromObjects(struct _Instance *instance /*$s3*/)
void MONSENSE_AdjustRadarFromObjects(struct _Instance *instance)
{ // line 1010, offset 0x80087018
	/* begin block 1 */
		// Start line: 1011
		// Start offset: 0x80087018
		// Variables:
			struct _MonsterVars *mv; // $s4
			struct _Instance *physob; // $s2

		/* begin block 1.1 */
			// Start line: 1019
			// Start offset: 0x80087068
			// Variables:
				struct PhysObProperties *prop; // $s1

			/* begin block 1.1.1 */
				// Start line: 1022
				// Start offset: 0x80087080

				/* begin block 1.1.1.1 */
					// Start line: 1028
					// Start offset: 0x800870BC
					// Variables:
						long dist; // $s0

					/* begin block 1.1.1.1.1 */
						// Start line: 1033
						// Start offset: 0x800870F0
						// Variables:
							int i; // $v1
							int min; // $a1
							int max; // $a2
							int ang; // $s0
					/* end block 1.1.1.1.1 */
					// End offset: 0x800871CC
					// End Line: 1060
				/* end block 1.1.1.1 */
				// End offset: 0x800871CC
				// End Line: 1061
			/* end block 1.1.1 */
			// End offset: 0x800871CC
			// End Line: 1063
		/* end block 1.1 */
		// End offset: 0x800871CC
		// End Line: 1064
	/* end block 1 */
	// End offset: 0x800871DC
	// End Line: 1066

	/* begin block 2 */
		// Start line: 2191
	/* end block 2 */
	// End Line: 2192

	/* begin block 3 */
		// Start line: 2195
	/* end block 3 */
	// End Line: 2196

}




